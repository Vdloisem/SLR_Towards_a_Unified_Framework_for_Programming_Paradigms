Sub-question 1.2 (Contribution),,,,,,,,,,,,,,,,,,,,,,,,,,
"How can we define a set of conceptual primitives that enable programming paradigms to be reconstructed in a minimal and orthogonal manner, and how can we formally guarantee these properties within a unified mathematical framework?",,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
Title,Authors,DOI,DOI link,Venue,Citation count,Year,Conceptual Primitives Defined,Mathematical Framework Characteristics,Programming Paradigm Integration Approach,Genericity and Abstraction Mechanisms,Novelty and Theoretical Contribution,Evidence for Primitives (Quotes),Evidence for Primitives (Tables),Primitives Analysis & Rationale,Evidence for Framework (Quotes),Evidence for Framework (Tables),Framework Analysis & Rationale,Evidence for Integration (Quotes),Evidence for Integration (Tables),Integration Analysis & Rationale,Evidence for Abstraction (Quotes),Evidence for Abstraction (Tables),Abstraction Analysis & Rationale,Evidence for Contribution (Quotes),Evidence for Contribution (Tables),Contribution Analysis & Rationale
TopHat,-,10.1145/3354166.3354182,https://doi.org/10.1145/3354166.3354182,Proceedings of the 21st International Symposium on Principles and Practice of Programming Languages 2019,4,2019,"1. Primitive Name: Tasks
  Definition: Specify the work a user or system has to perform with a high level of abstraction.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Composition of Tasks
  Definition: Through combinators, allowing the creation of arbitrarily large tasks.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Data
  Definition: Passed between tasks sequentially and globally.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Interactive and Input-Driven Tasks
  Definition: Tasks are reevaluated and result in a new task upon receiving input.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Shared Information
  Definition: Tasks can share information through shared data stores or continuations.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Formal verification of TopHat programs
 - Proof techniques used: Symbolic execution
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: TopHat provides formal semantics for task-oriented programming, allowing for formal reasoning and verification.
 - Theoretical advancements: TopHat's simple datatype and combinators enable formal verification; symbolic execution semantics for formal verification.
 - Potential implications: Simplified implementation of TOP frameworks; potential for broader adoption; future work on multi-user support and richer datatypes.","- ""TOP is centered around the concept of tasks, which specify the work a user or system has to perform with a high level of abstraction.""
  - ""Tasks that describe the work that has to be performed, providing an abstraction that separates the what from the how""
  - ""Composition of tasks through combinators, allowing the creation of arbitrarily large tasks.""
  - ""Data that is being passed between tasks sequentially and globally.""
  - ""Tasks are interactive and input-driven. When a task receives input it is reevaluated and results in a new task.""
  - ""Tasks can share information with each other, either directly through shared data stores, or by passing task values to continuations.""",,"- The paper discusses Task-Oriented Programming (TOP) as a paradigm that focuses on tasks as the primary conceptual primitive. Tasks are defined as specifying the work to be performed with a high level of abstraction.
 - The composition of tasks through combinators is another key primitive, allowing for the creation of complex applications from simpler tasks.
 - Data passing between tasks is also highlighted as a fundamental aspect, indicating that data is a conceptual primitive in TOP.
 - The paper emphasizes the interactive and input-driven nature of tasks, suggesting that these are intrinsic properties of the task primitive.
 - The ability of tasks to share information through shared data stores or continuations further defines the task primitive in terms of its communicative capabilities.","- ""Idris is a programming language that features dependent types and a totality checker, which is used to prove properties of TopHat programs.""
  - ""Symbolic execution has also been used to provide end-users of tasks with additional feedback [16].""
  - ""To demonstrate the formal reasoning capabilities of TopHat, a symbolic execution semantics has been developed [17].""
  - ""By employing symbolic execution it is possible to formally verify TopHat programs [17].""
  - ""The formal TopHat semantics fits on a single page, and is largely straightforward.""
  - ""TopHat is a Domain-Specific Language (DSL) that paves the way to formally reason about task-oriented programs [26], by defining a formal TOP semantics.""",,"- The paper mentions that TopHat is a DSL that allows for formal reasoning about task-oriented programs, indicating a focus on formal verification.
 - The use of Idris, a language with dependent types and a totality checker, suggests that type theory is a part of the mathematical framework, as dependent types are a feature of type theory.
 - The mention of symbolic execution semantics indicates that this is a proof technique used to formally verify TopHat programs.
 - The paper does not explicitly mention category theory or other mathematical frameworks, so it seems that type theory is the primary framework discussed.
 - The paper does not specify any limitations or constraints of the framework, but it does highlight the simplicity and straightforwardness of the formal semantics.","- ""Task-oriented programming (TOP) is a programming paradigm that aims to provide the desired level of abstraction while still being expressive enough to describe real world collaboration.""
  - ""TOP is centered around the concept of tasks, which specify the work a user or system has to perform with a high level of abstraction.""
  - ""TOP aims to facilitate collaborating with multiple people towards a shared goal, over the internet.""
  - ""TOP itself focuses on the domain logic, with tasks providing merely a description of the work that has to be performed.""
  - ""The TOP paradigm provides an abstraction over workflow software.""
  - ""Functional Reactive programming (FRP) is another approach to UI development using functional programming.""
  - ""FRP is a paradigm for reactive programming, whereas TOP is a way to model collaboration between users.""
  - ""We have selected PureScript and Halogen because it is a powerful functional programming language that fits our problem domain.""",,"- The paper discusses Task-Oriented Programming (TOP) as a paradigm that focuses on collaboration and workflow abstraction.
 - It mentions Functional Reactive Programming (FRP) as another paradigm used for UI development, indicating a comparison between paradigms.
 - The paper does not explicitly describe a specific integration mechanism or interaction model between TOP and FRP.
 - There is no mention of novel translation or embedding techniques for integrating different paradigms.
 - The paper does not discuss constraints or challenges in integrating these paradigms.","- ""TOP is centered around the concept of tasks, which specify the work a user or system has to perform with a high level of abstraction.""
  - ""Tasks can be combined using combinators: they can be executed sequentially, in parallel, or conditionally.""
  - ""tasks are first-class citizens: they can be used as input of functions, they can be returned from them, and tasks can contain other tasks as value.""
  - ""The TOP paradigm provides an abstraction over workflow software.""
  - ""iTasks defines tasks as a ""state transforming function that reacts to an event, rewrites itself to a reduct and accumulates responses to users""""
  - ""TopHat on the other hand defines tasks as a simple datatype, with three base cases and a small number of simple combinators""
  - ""The formal TopHat semantics fits on a single page, and is largely straightforward.""
  - ""Our framework implements all basic requirements for a TOP framework, by supporting tasks, shared data stores, combinators and generics.""",,"- The paper discusses the concept of tasks as a central abstraction mechanism in Task-Oriented Programming (TOP). Tasks are defined with a high level of abstraction, allowing for generic programming.
 - The use of combinators to combine tasks sequentially, in parallel, or conditionally is a mechanism for representing generic abstractions. This allows for flexible and reusable task structures.
 - Tasks being first-class citizens indicates a high level of abstraction, as they can be used as inputs, outputs, or contained within other tasks, which is a characteristic of generic programming.
 - The TOP paradigm provides an abstraction over workflow software, suggesting a focus on conceptual abstraction rather than specific implementation details.
 - The paper does not explicitly discuss minimal type requirements or static checking strategies in detail, but the mention of generics and the formal semantics of TopHat implies some level of type system discussion.
 - The paper does not extensively address generic programming methodologies or type system discussions beyond the abstraction mechanisms provided by tasks and combinators.","- ""TopHat is a Domain-Specific Language (DSL) that paves the way to formally reason about task-oriented programs [26], by defining a formal TOP semantics.""
  - ""TopHat on the other hand defines tasks as a simple datatype, with three base cases and a small number of simple combinators [26]. The TopHat framework takes care of handling events, rewriting and task rendering.""
  - ""To demonstrate the formal reasoning capabilities of TopHat, a symbolic execution semantics has been developed [17].""
  - ""Our work is based on TopHat's Haskell implementation.""
  - ""The prototype UI framework completely relies on the TopHat semantics for handling input and rewriting tasks.""
  - ""We have demonstrated TopHat UI, a proof-of-concept framework that implements a GUI for Tophat programs. None of the advanced Clean features used by iTasks were required to do so, as expected.""
  - ""Our framework implements all basic requirements for a TOP framework, by supporting tasks, shared data stores, combinators and generics.""
  - ""As mentioned in Section 3, TOP features such as multi-user support and richer datatypes are considered future work.""",,"- The paper introduces TopHat as a DSL that provides formal semantics for task-oriented programming (TOP), which is a novel contribution as it allows for formal reasoning about these programs.
 - TopHat's design as a simple datatype with straightforward combinators is highlighted as a theoretical advancement, making it more suitable for formal verification compared to existing frameworks like iTasks.
 - The development of symbolic execution semantics for TopHat is a significant theoretical contribution, enabling formal verification of task-oriented programs.
 - The paper demonstrates that TopHat can be implemented without relying on advanced features from other languages, showing its independence and potential for broader adoption.
 - The framework's ability to support basic TOP requirements without needing advanced features from other languages is a theoretical contribution, as it simplifies the implementation of TOP frameworks.
 - The potential for future work on multi-user support and richer datatypes suggests ongoing theoretical development and implications for programming language design."
Imperative Compositional Programming: Type Sound Distributive Intersection Subtyping with References via Bidirectional Typing,"Wenjia Ye, Yaozhu Sun, Bruno C. d. S. Oliveira",10.1145/3689782,https://doi.org/10.1145/3689782,Proc. ACM Program. Lang.,0,2024,"1. Primitive Name: Compositional Programming
  Definition: A programming paradigm emphasizing modularity, implemented in the CP programming language.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Fi+
  Definition: A purely functional variant of System F with intersection types and distributivity rules for subtyping.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Bidirectional Typing
  Definition: A method used to restrict the typing rule for references, ensuring type soundness.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Mutable References
  Definition: An extension to compositional programming enabling a modular, imperative style.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory (System F with intersection types)
 - Specific mathematical properties guaranteed: Type soundness
 - Proof techniques used: Bidirectional typing
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Use of bidirectional typing to restrict the typing rule for references.
 - Interaction models between paradigms: Addressing type soundness issues when combining distributive intersection subtyping with mutable references.
 - Constraints or challenges in paradigm integration: Potential for type unsoundness when distributive subtyping rules are combined with references.
 - Novel translation or embedding techniques: Adopting bidirectional typing to achieve type soundness without dropping distributivity rules.",Generic programming not extensively addressed,"- Key novel insights: Extension of compositional programming with mutable references using bidirectional typing to achieve type soundness.
 - Theoretical advancements: Retaining distributivity and an unrestricted intersection introduction rule by restricting the typing rule for references, addressing a long-standing issue in the field.
 - Potential implications: Enabling modular, imperative compositional programming, influencing future language design by balancing modularity with type soundness.","- ""Compositional programming is a programming paradigm that emphasizes modularity and is implemented in the CP programming language.""
  - ""The foundations for compositional programming are based on a purely functional variant of System F with intersection types, called Fi+, which includes distributivity rules for subtyping.""
  - ""This paper shows how to extend compositional programming and CP with mutable references, enabling a modular, imperative compositional programming style.""
  - ""A technical obstacle solved in our work is the interaction between distributive intersection subtyping and mutable references.""
  - ""Therefore, we revisit the problem and show that, by adopting bidirectional typing, a more lightweight and type sound restriction is possible: we can simply restrict the typing rule for references.""
  - ""We present a first calculus, based on Davies and Pfenning's work, which illustrates the generality of our solution.""
  - ""Then we present an extension of Fi+ with references, which adopts our restriction and enables imperative compositional programming.""",,"- The abstract discusses the extension of compositional programming with mutable references, which is a key conceptual primitive in this context.
 - The foundation of compositional programming is based on Fi+, a variant of System F with intersection types and distributivity rules, which are conceptual primitives.
 - The interaction between distributive intersection subtyping and mutable references is a critical aspect, indicating that these are conceptual primitives being manipulated.
 - The use of bidirectional typing to restrict the typing rule for references is another conceptual primitive, as it provides a solution to maintain type soundness.
 - The abstract mentions the presentation of a calculus based on Davies and Pfenning's work and an extension of Fi+ with references, which suggests these are part of the conceptual framework.","- ""The foundations for compositional programming are based on a purely functional variant of System F with intersection types, called Fi+,""
  - ""Therefore, we revisit the problem and show that, by adopting bidirectional typing, a more lightweight and type sound restriction is possible:""
  - ""A technical obstacle solved in our work is the interaction between distributive intersection subtyping and mutable references.""
  - ""Both calculi and their proofs are formalized in the Coq proof assistant.""",,"- The abstract mentions that the foundations of compositional programming are based on a ""purely functional variant of System F with intersection types, called Fi+."" This indicates that the mathematical framework is rooted in type theory, specifically using System F with intersection types.
 - The mention of ""distributive intersection subtyping"" suggests that the framework involves subtyping rules, which are a part of type theory.
 - The use of ""bidirectional typing"" as a solution to ensure type soundness with mutable references implies a specific proof technique within the type theory framework.
 - The abstract states that ""both calculi and their proofs are formalized in the Coq proof assistant,"" which indicates that formal verification is conducted using Coq, a tool for formal proof development.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or limitations of the framework, but it does highlight the use of bidirectional typing as a solution to ensure type soundness.","- ""Compositional programming is a programming paradigm that emphasizes modularity and is implemented in the CP programming language.""
  - ""The foundations for compositional programming are based on a purely functional variant of System F with intersection types, called Fi+, which includes distributivity rules for subtyping.""
  - ""This paper shows how to extend compositional programming and CP with mutable references, enabling a modular, imperative compositional programming style.""
  - ""A technical obstacle solved in our work is the interaction between distributive intersection subtyping and mutable references.""
  - ""Davies and Pfenning [2000] studied this problem in standard formulations of intersection type systems and argued that, when combined with references, distributive subtyping rules lead to type unsoundness.""
  - ""To recover type soundness, they proposed dropping distributivity rules in subtyping.""
  - ""CP cannot adopt this solution, since it fundamentally relies on distributivity for modularity.""
  - ""Therefore, we revisit the problem and show that, by adopting bidirectional typing, a more lightweight and type sound restriction is possible: we can simply restrict the typing rule for references.""
  - ""This solution retains distributivity and an unrestricted intersection introduction rule.""
  - ""We present a first calculus, based on Davies and Pfenning's work, which illustrates the generality of our solution.""
  - ""Then we present an extension of Fi+ with references, which adopts our restriction and enables imperative compositional programming.""",,"- The abstract discusses the integration of compositional programming with mutable references, which is a key aspect of imperative programming. This integration is aimed at enabling a modular, imperative compositional programming style.
 - The specific integration mechanism proposed is the use of bidirectional typing to restrict the typing rule for references, which allows for the retention of distributivity and an unrestricted intersection introduction rule.
 - The interaction model between paradigms involves addressing the technical obstacle of ensuring type soundness when combining distributive intersection subtyping with mutable references.
 - A constraint or challenge in paradigm integration is the potential for type unsoundness when distributive subtyping rules are combined with references, as noted by Davies and Pfenning.
 - The novel translation or embedding technique involves adopting bidirectional typing to achieve a type sound restriction without dropping distributivity rules.","- ""Compositional programming is a programming paradigm that emphasizes modularity and is implemented in the CP programming language.""
  - ""The foundations for compositional programming are based on a purely functional variant of System F with intersection types, called Fi+, which includes distributivity rules for subtyping.""
  - ""This paper shows how to extend compositional programming and CP with mutable references, enabling a modular, imperative compositional programming style.""
  - ""A technical obstacle solved in our work is the interaction between distributive intersection subtyping and mutable references.""
  - ""Therefore, we revisit the problem and show that, by adopting bidirectional typing, a more lightweight and type sound restriction is possible: we can simply restrict the typing rule for references.""
  - ""We present a first calculus, based on Davies and Pfenning's work, which illustrates the generality of our solution.""
  - ""Then we present an extension of Fi+ with references, which adopts our restriction and enables imperative compositional programming.""",,"- The abstract discusses compositional programming and its extension with mutable references, which implies a focus on modularity and imperative programming rather than generic programming.
 - The mention of ""Fi+ with intersection types"" and ""distributivity rules for subtyping"" suggests a focus on type systems rather than generic programming mechanisms.
 - The abstract does not explicitly mention generic programming or abstraction mechanisms related to genericity.
 - The focus is on solving a technical obstacle related to type soundness with mutable references, which does not directly relate to generic programming.
 - The abstract does not provide any information on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies related to generic programming.","- ""This paper shows how to extend compositional programming and CP with mutable references, enabling a modular, imperative compositional programming style.""
  - ""A technical obstacle solved in our work is the interaction between distributive intersection subtyping and mutable references.""
  - ""Davies and Pfenning [2000] studied this problem in standard formulations of intersection type systems and argued that, when combined with references, distributive subtyping rules lead to type unsoundness.""
  - ""To recover type soundness, they proposed dropping distributivity rules in subtyping.""
  - ""CP cannot adopt this solution, since it fundamentally relies on distributivity for modularity.""
  - ""Therefore, we revisit the problem and show that, by adopting bidirectional typing, a more lightweight and type sound restriction is possible: we can simply restrict the typing rule for references.""
  - ""This solution retains distributivity and an unrestricted intersection introduction rule.""
  - ""We present a first calculus, based on Davies and Pfenning's work, which illustrates the generality of our solution.""
  - ""Then we present an extension of Fi+ with references, which adopts our restriction and enables imperative compositional programming.""",,"- The abstract discusses the extension of compositional programming with mutable references, which is a novel contribution as it enables a modular, imperative compositional programming style.
 - The interaction between distributive intersection subtyping and mutable references is identified as a technical obstacle, which has been previously studied by Davies and Pfenning. However, their solution involved dropping distributivity rules, which is not feasible for CP due to its reliance on distributivity for modularity.
 - The novel insight is the use of bidirectional typing to achieve type soundness without dropping distributivity rules. This is a theoretical advancement as it provides a more lightweight and type sound restriction by simply restricting the typing rule for references.
 - The solution retains distributivity and an unrestricted intersection introduction rule, which is a significant theoretical contribution as it addresses a long-standing issue in the field.
 - The presentation of a new calculus based on Davies and Pfenning's work and an extension of Fi+ with references further illustrates the generality and applicability of the solution.
 - The potential implications for programming language design include enabling modular, imperative compositional programming, which could influence future language design by providing a framework that balances modularity with type soundness."
Unifying theories of healthiness condition,"J. He, C. Hoare",10.1109/APSEC.2000.896685,https://doi.org/10.1109/APSEC.2000.896685,Proceedings Seventh Asia-Pacific Software Engeering Conference. APSEC 2000,2,2000,"1. Primitive Name: Complete Boolean Algebra of Specifications
  Definition: Forms the basis of the programming theory
  Orthogonality Score: Not discussed
 2. Primitive Name: Healthiness Conditions
  Definition: Exclude infeasibility of implementation
  Orthogonality Score: Not discussed
 3. Primitive Name: Algebraic Laws
  Definition: Useful for transformation and optimization of designs
  Orthogonality Score: Not discussed
 4. Primitive Name: Constructions due to Karoubi and Kleisli
  Definition: Formalize the healthiness condition
  Orthogonality Score: Not discussed","- Type of mathematical framework: Boolean algebra, category theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described (the abstract implies a theoretical integration strategy through a single healthiness condition but does not provide specific mechanisms or models),Generic programming not extensively addressed,"- Key novel insights: The development of a theory of programming based on a complete Boolean algebra of specifications and the expression of healthiness conditions as algebraic laws.
 - Theoretical advancements: Unification of healthiness conditions across different programming paradigms (nondeterministic, sequential, parallel, logical, and probabilistic) using constructions due to Karoubi and Kleisli.
 - Potential implications: Ensuring a single notion of correctness throughout the design process, which can lead to more consistent and reliable programming language design.","- ""A theory of programming starts with a complete Boolean algebra of specifications, and defines healthiness conditions which exclude infeasibility of implementation.""
  - ""These are expressed as algebraic laws useful for transformation and optimisation of designs.""
  - ""The uniformity maintains for all paradigms a single notion of correctness throughout the chain that leads from specification through designs to programs that are proved to meet the original specification.""
  - ""We have explored a wide range of programming paradigms, including nondeterministic, sequential, parallel, logical and probabilistic.""
  - ""In all cases, we have found a single healthiness condition, formalised by constructions due to Karoubi and to Kleisli.""",,"- The abstract mentions a ""complete Boolean algebra of specifications"" and ""healthiness conditions"" as foundational elements of the theory. These are likely conceptual primitives as they form the basis of the programming theory.
 - The ""healthiness conditions"" are defined as excluding infeasibility of implementation, which suggests they are about ensuring practicality and feasibility in programming.
 - The abstract refers to ""algebraic laws"" as part of these healthiness conditions, indicating that these laws are also conceptual primitives used for transformation and optimization.
 - The mention of ""constructions due to Karoubi and to Kleisli"" suggests that these are specific mathematical or theoretical frameworks used to formalize the healthiness condition, which could be considered as part of the conceptual primitives.
 - The abstract does not provide explicit names or detailed definitions for these primitives beyond their roles and applications, nor does it discuss their orthogonality.","- ""A theory of programming starts with a complete Boolean algebra of specifications, and defines healthiness conditions which exclude infeasibility of implementation.""
  - ""These are expressed as algebraic laws useful for transformation and optimisation of designs.""
  - ""The uniformity maintains for all paradigms a single notion of correctness throughout the chain that leads from specification through designs to programs that are proved to meet the original specification.""
  - ""In all cases, we have found a single healthiness condition, formalised by constructions due to Karoubi and to Kleisli.""",,"- The abstract mentions a ""complete Boolean algebra of specifications,"" which suggests the use of Boolean algebra as a mathematical framework for defining specifications.
 - The mention of ""algebraic laws"" indicates that algebraic properties are used to formalize and guarantee properties of the conceptual primitives.
 - The reference to ""constructions due to Karoubi and to Kleisli"" implies the use of category theory, as these names are associated with categorical constructions.
 - The abstract does not explicitly mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus on ""healthiness conditions"" and ""a single notion of correctness"" suggests that the framework is designed to ensure correctness and feasibility of implementation, but specific properties or techniques are not detailed.","- ""The uniformity maintains for all paradigms a single notion of correctness throughout the chain that leads from specification through designs to programs that are proved to meet the original specification.""
  - ""In all cases, we have found a single healthiness condition, formalised by constructions due to Karoubi and to Kleisli.""
  - ""We have explored a wide range of programming paradigms, including nondeterministic, sequential, parallel, logical and probabilistic.""",,"- The abstract mentions the exploration of various programming paradigms, indicating a broad scope of integration.
 - The mention of a ""single healthiness condition"" suggests a unified approach to integrating these paradigms, as it implies a common standard or criterion for healthiness across different paradigms.
 - The use of constructions due to Karoubi and Kleisli suggests a theoretical integration strategy, as these are likely mathematical or formal methods used to unify the healthiness conditions.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques. However, it implies a theoretical integration strategy through the use of a single healthiness condition.
 - The abstract does not provide detailed information on how these paradigms interact or any specific challenges in their integration.","- ""A theory of programming starts with a complete Boolean algebra of specifications, and defines healthiness conditions which exclude infeasibility of implementation.""
  - ""These are expressed as algebraic laws useful for transformation and optimisation of designs.""
  - ""Programming notations and languages must be restricted to those preserving all the healthiness conditions.""
  - ""We have explored a wide range of programming paradigms, including nondeterministic, sequential, parallel, logical and probabilistic.""
  - ""In all cases, we have found a single healthiness condition, formalised by constructions due to Karoubi and to Kleisli.""
  - ""The uniformity maintains for all paradigms a single notion of correctness throughout the chain that leads from specification through designs to programs that are proved to meet the original specification.""",,"- The abstract discusses the unification of theories of healthiness conditions across various programming paradigms, which suggests a focus on abstraction mechanisms.
 - The mention of ""algebraic laws"" and ""constructions due to Karoubi and to Kleisli"" implies a formal approach to abstraction, which could relate to generic programming.
 - The abstract does not explicitly mention ""generic programming"" or ""abstraction mechanisms"" in the context of genericity and abstraction.
 - There is no specific mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.
 - The focus seems to be on the unification of healthiness conditions rather than generic programming or abstraction mechanisms specifically.","- ""The uniformity maintains for all paradigms a single notion of correctness throughout the chain that leads from specification through designs to programs that are proved to meet the original specification.""
  - ""In all cases, we have found a single healthiness condition, formalised by constructions due to Karoubi and to Kleisli.""
  - ""We have explored a wide range of programming paradigms, including nondeterministic, sequential, parallel, logical and probabilistic.""
  - ""These are expressed as algebraic laws useful for transformation and optimisation of designs.""
  - ""A theory of programming starts with a complete Boolean algebra of specifications, and defines healthiness conditions which exclude infeasibility of implementation.""",,"- The abstract discusses the development of a theory of programming that starts with a complete Boolean algebra of specifications. This suggests a novel approach to programming theory by focusing on algebraic laws for healthiness conditions.
 - The mention of ""healthiness conditions"" and their expression as ""algebraic laws"" indicates a theoretical contribution in terms of formalizing these conditions for programming paradigms.
 - The exploration of a wide range of programming paradigms (nondeterministic, sequential, parallel, logical, and probabilistic) and the finding of a single healthiness condition across them is a significant theoretical advancement. It implies a unification of healthiness conditions across different paradigms.
 - The use of constructions due to Karoubi and Kleisli to formalize this single healthiness condition suggests a theoretical innovation in applying these mathematical constructs to programming theory.
 - The abstract mentions the maintenance of a single notion of correctness throughout the design process, which is a theoretical contribution to ensuring consistency and reliability in programming language design."
Certifying Choreography Compilation,"L. Cruz-Filipe, F. Montesi, Marco Peressotti",10.1007/978-3-030-85315-0_8,https://doi.org/10.1007/978-3-030-85315-0_8,International Colloquium on Theoretical Aspects of Computing,18,2021,"1. Primitive Name: Communication Action
  Definition: A linguistic primitive for communication from one participant to another, e.g., ""Alice.e → Bob.x""
  Orthogonality Score: Not specified
 

 2. Primitive Name: Value Communication
  Definition: ""p. e -> q.x"" - a process evaluates an expression and sends the result to another process.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Label Selection
  Definition: ""p -> q[l]"" - a process selects from different behaviors available at another process by means of an identifier (the label).
  Orthogonality Score: Not specified
 

 4. Primitive Name: Conditional
  Definition: ""If p. b Then Ct Else Ce"" - evaluates a Boolean expression and continues based on its truth value.
  Orthogonality Score: Not specified
 

 5. Primitive Name: Procedure Call
  Definition: ""Choreography Call X"" - a call to a procedure X.
  Orthogonality Score: Not specified","- Type of mathematical framework: Type theory (Coq)
 - Specific mathematical properties guaranteed: Deadlock-freedom, confluence, Turing completeness
 - Proof techniques used: Structural induction
 - Limitations or constraints of the framework: Complexity of formalization, extensive case analysis required","- Specific integration mechanisms proposed: Choreography compilation translates choreographies into process calculus terms.
 - Interaction models between paradigms: EPP Theorem establishes operational correspondence between choreographies and endpoint projections.
 - Constraints or challenges in paradigm integration: Error-prone nature due to interplay between components.
 - Novel translation or embedding techniques: Pruning relation manages differences in branching behaviors.",Generic programming not extensively addressed,"- First certified program for choreography compilation for a nontrivial choreographic language supporting recursion.
 - Formalization of the EPP Theorem, establishing an operational correspondence between choreographies and their endpoint projections.
 - First formalization of such a correspondence for a Turing-complete choreographic language.
 - Potential implications for programming language design include support for more complex systems and future work on semi-automatic proof generation.","- ""Choreographic programming is a paradigm for developing concurrent and distributed systems, where programs are choreographies that define, from a global viewpoint, the computations and interactions that communicating processes should enact.""
  - ""The key idea is to have a linguistic primitive for a communication from a participant to another: statement Alice.e → Bob.x reads ""Alice evaluates expression e and sends the result to Bob, who stores it in variable x"".""
  - ""The syntax of choreographies is defined by the following BNF grammar.""
  - ""An eta is a communication action, where p. e -> q.x is a value communication1 and p -> q[l] is a label selection.""
  - ""Choreographies are ranged over by C. A choreography eta; C, can execute a communication eta and continue as C.""
  - ""A conditional If p. b Then Ct Else Ce evaluates the Boolean expression b in the memory of process p and continues as Ct or Ce, according to whether b evaluates to true or false.""
  - ""Choreography Call X is a call to a procedure X.""
  - ""Terms End, If b Then Bt Else Be and Call X are as in CC.""
  - ""Value communications are split into p! e; B, which evaluates e, sends the result to p, and continues as B, and by p?x; B, which receives a value from p, stores it at x, and continues as B.""
  - ""Label selections are divided into p⊕l; B -sending the label l to p and continuing as B -and p & mBl // mBr, where one of mBl or mBr is chosen according to the label selected by p.""",,"- The paper discusses choreographic programming as a paradigm for concurrent and distributed systems, focusing on global viewpoints and interactions.
 - The linguistic primitive for communication is explicitly defined as ""Alice.e → Bob.x,"" which represents a communication action from one participant to another.
 - The syntax of choreographies is detailed, including communication actions (value communications and label selections), conditionals, and procedure calls.
 - The paper provides a BNF grammar for choreographies, which includes these primitives.
 - The primitives are defined at a high level of abstraction, focusing on communication and control flow within choreographies.
 - Orthogonality is not explicitly discussed in terms of these primitives, but they are designed to be fundamental building blocks for choreographic programming.","- ""Our formalisation is developed in Coq [4], and we assume some familiarity with it.""
  - ""The formalisation of SP consists of 37 definitions, 80 lemmas, and 2000 lines.""
  - ""the formalisation of merging consists of 6 definitions, 43 lemmas, and 2550 lines -giving an average proof length of over 50 lines.""
  - ""The formalisation of pruning includes 3 definitions, 25 lemmas, and 950 lines.""
  - ""The formalisation of EPP and the proof of the EPP theorem consists of 13 definitions, 110 lemmas, and 4960 lines of Coq code.""
  - ""We use the choreographic language of [26], which is inspired by Core Choreographies (CC) [12]. So far, this is the only Turing complete choreographic language that has been formalised [13].""
  - ""The semantics of SP is defined by a labelled transition system.""
  - ""the formalisation of these rules is done in two steps. The first step defines a transition relation parameterised on the set of procedure definitions, and includes richer transition labels (necessary for doing case analysis on transitions).""",,"- The paper uses Coq, a proof assistant based on type theory, as the mathematical framework for formalization. This is evident from the repeated mention of Coq throughout the paper.
 - The framework guarantees properties such as deadlock-freedom, confluence, and Turing completeness, as these are mentioned in the context of the formalization.
 - The proof techniques used include structural induction, as indicated by the mention of ""many results about Behaviours are proved by structural induction.""
 - The limitations or constraints of the framework are not explicitly mentioned, but the complexity of the formalization and the need for extensive case analysis suggest potential challenges in scalability and automation.","- ""Choreographic programming is a paradigm for developing concurrent and distributed systems, where programs are choreographies that define, from a global viewpoint, the computations and interactions that communicating processes should enact.""
  - ""Choreography compilation translates choreographies into the local definitions of process behaviours, given as terms in a process calculus.""
  - ""The interplay between these components, where a single instruction at the choreographic level might be implemented by multiple instructions in the target language, makes the theory of choreographic programming error-prone:""
  - ""we present a certified program for EPP, which translates terms of a Turing complete choreographic language into terms of a distributed process calculus.""
  - ""Our main result is the formalisation of the hallmark result of choreographic programming, the ""EPP Theorem"": an operational correspondence between choreographies and their endpoint projections.""
  - ""EPP involves three elements: the source choreography language, the target language, and the compiler.""
  - ""The key ingredient for our correspondence result is a relation on behaviours usually called pruning [5,7]. Pruning relates two behaviours that differ only in that one offers more options in branching terms than the other;""
  - ""We have successfully formalised a translation from a Turing-complete choreographic language into a process calculus and proven its correctness in terms of an operational correspondence.""",,"- The paper discusses choreographic programming as a paradigm for concurrent and distributed systems, which integrates global viewpoints with local process behaviors.
 - Choreography compilation is a key integration mechanism that translates choreographies into process calculus terms, addressing the integration of different programming paradigms.
 - The EPP Theorem is a theoretical integration strategy that establishes an operational correspondence between choreographies and their endpoint projections, ensuring that the integration is correct and operational.
 - The paper mentions challenges in paradigm integration, such as the error-prone nature of choreographic programming due to the interplay between components.
 - The pruning relation is a novel technique used to manage differences in branching behaviors between paradigms, facilitating integration.
 - The study provides a comparative analysis by discussing the application of choreographic programming to various domains, indicating its versatility and potential for integration.","- ""Choreographic programming is an emerging programming paradigm where the desired communication behaviour of a system of communicating processes can be defined from a global viewpoint in programs known as choreographies""
  - ""The theory of such compilers is typically called EndPoint Projection (EPP).""
  - ""The interplay between these components, where a single instruction at the choreographic level might be implemented by multiple instructions in the target language, makes the theory of choreographic programming error-prone:""
  - ""Our formalisation is developed in Coq [4], and we assume some familiarity with it.""
  - ""We start from a previous formalisation [13] of a choreographic language (Core Choreographies [12]), which we recap in Sect. 2.""
  - ""The syntax of choreographies is defined by the following BNF grammar.""
  - ""The semantics of CC is defined as a labelled transition system using inductive types.""
  - ""The semantics of SP is defined by a labelled transition system.""
  - ""The formalisation of SP consists of 37 definitions, 80 lemmas, and 2000 lines.""
  - ""the formalisation of merging consists of 6 definitions, 43 lemmas, and 2550 lines""
  - ""The formalisation of pruning includes 3 definitions, 25 lemmas, and 950 lines.""
  - ""The formalisation of EPP and the proof of the EPP theorem consists of 13 definitions, 110 lemmas, and 4960 lines of Coq code.""",,"- The paper primarily focuses on choreographic programming and the formalization of EndPoint Projection (EPP) using Coq, a proof assistant. This suggests a strong emphasis on formal verification rather than generic programming.
 - The paper discusses the syntax and semantics of choreographies and their translation into a process calculus, but it does not explicitly address generic programming or abstraction mechanisms.
 - The use of Coq for formalization indicates a focus on rigorous mathematical proof rather than generic programming techniques.
 - The paper does not mention any specific mechanisms for representing generic abstractions or minimal type requirements, nor does it discuss static checking or optimization strategies related to generic programming.
 - The extensive use of formal definitions and lemmas in Coq suggests a focus on formal verification rather than generic programming.","- ""We present the first certified program for choreography compilation for a nontrivial choreographic language supporting recursion.""
  - ""Our main result is the formalisation of the hallmark result of choreographic programming, the ""EPP Theorem"": an operational correspondence between choreographies and their endpoint projections.""
  - ""This is the first time that this result has been formalised in a theorem prover, increasing our confidence in the methodology of choreographies.""
  - ""We have successfully formalised a translation from a Turing-complete choreographic language into a process calculus and proven its correctness in terms of an operational correspondence.""
  - ""To the best of our knowledge, this is the first time such a correspondence has been formalised for a full-fledged (Turing-complete) choreographic language.""
  - ""The complexity of the formalisation, combined with the similarities between several of the proofs, means that future extensions would benefit from exploiting semi-automatic generation of proof scripts.""
  - ""Combining these results with those from [13] would yield a proof that SP is also Turing complete.""",,"- The paper presents the first certified program for choreography compilation for a nontrivial choreographic language that supports recursion, which is a significant theoretical contribution.
 - The formalization of the EPP Theorem is a key theoretical advancement, as it establishes an operational correspondence between choreographies and their endpoint projections, which is a fundamental concept in choreographic programming.
 - The paper achieves this formalization using a theorem prover, which increases confidence in the methodology and provides a rigorous theoretical foundation.
 - The study is the first to formalize such a correspondence for a Turing-complete choreographic language, which is a significant theoretical contribution beyond existing approaches.
 - The potential implications for programming language design include the possibility of using choreographic programming for more complex systems, given the support for recursion and the formalized operational correspondence.
 - The paper suggests future work on semi-automatic generation of proof scripts, which could further advance theoretical contributions by making it easier to extend and apply these results."
The precise control of inheritance and the inheritance of theory in the ADABTPL language,"T. Sheard, D. Stemple",10.1109/ICCL.1988.13064,https://doi.org/10.1109/ICCL.1988.13064,Proceedings. 1988 International Conference on Computer Languages,1,1988,Not specified (the abstract does not provide explicit definitions or orthogonality scores for the conceptual primitives),Not specified (the abstract mentions a Boyer-Moore-style theorem prover and higher-order functions but does not specify the type of mathematical framework or specific properties guaranteed),No specific integration approach described (the abstract focuses on integrating theorem proving with programming rather than multiple programming paradigms),Generic programming not extensively addressed,"- Key novel insights: Separation of inheritance features from data structuring mechanisms; integration of a theorem prover for program verification.
 - Theoretical advancements: Orthogonal inheritance mechanisms; use of higher-order functions and metatheorems for tailored program theories.
 - Potential implications: New approaches to inheritance management and program correctness verification in programming language design.","- ""The ADABTPL language does this by supplying a small class of orthogonal inheritance producing and restricting mechanisms.""
  - ""ADABTPL also supports a paradigm of programming by tying the compiler to a powerful Boyer-Moore-style theorem prover that can be invoked by the programmer to verify properties of programs and validate program transformations.""
  - ""This is accomplished by the use of higher-order functions and metatheorems to produce a tailored theory about particular programs.<<ETX>>""",,"- The abstract mentions ""a small class of orthogonal inheritance producing and restricting mechanisms"" as part of the ADABTPL language. This suggests that these mechanisms are conceptual primitives related to inheritance.
 - The abstract also discusses the use of ""higher-order functions and metatheorems"" to produce a tailored theory about programs. These could be considered conceptual primitives related to programming paradigms.
 - The abstract does not provide explicit definitions for these primitives, nor does it specify their orthogonality score.
 - The abstract does not mention any other specific conceptual primitives beyond these mechanisms and functions.","- ""ADABTPL also supports a paradigm of programming by tying the compiler to a powerful Boyer-Moore-style theorem prover that can be invoked by the programmer to verify properties of programs and validate program transformations.""
  - ""This is accomplished by the use of higher-order functions and metatheorems to produce a tailored theory about particular programs.<<ETX>>""",,"- The abstract mentions the use of a ""Boyer-Moore-style theorem prover,"" which suggests a mathematical framework related to formal verification and theorem proving.
 - The mention of ""higher-order functions and metatheorems"" indicates a framework that likely involves type theory or a similar formal system, as these are common in programming languages and formal verification.
 - The abstract does not specify the exact type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no mention of limitations or constraints of the framework in the abstract.
 - The abstract does not provide detailed information about the theoretical foundations or proof methodology beyond the use of a theorem prover and higher-order functions.","- ""This is accomplished by the use of higher-order functions and metatheorems to produce a tailored theory about particular programs.<<ETX>>""
  - ""ADABTPL also supports a paradigm of programming by tying the compiler to a powerful Boyer-Moore-style theorem prover that can be invoked by the programmer to verify properties of programs and validate program transformations.""
  - ""The ADABTPL language does this by supplying a small class of orthogonal inheritance producing and restricting mechanisms.""",,"- The abstract mentions the use of ""orthogonal inheritance producing and restricting mechanisms,"" which suggests a way to integrate different inheritance features within the ADABTPL language. However, this does not explicitly address the integration of different programming paradigms.
 - The integration of a theorem prover with the compiler is highlighted, which could be seen as integrating a formal verification paradigm with programming. This is a novel approach to integrating different paradigms, as it uses theorem proving to validate program transformations.
 - The use of ""higher-order functions and metatheorems"" indicates a theoretical integration strategy, as these are used to produce a tailored theory about programs. This suggests a deep integration of formal methods with programming.
 - There is no explicit mention of specific interaction models between paradigms or constraints/challenges in paradigm integration. The focus is on the integration of theorem proving with programming rather than multiple programming paradigms.","- ""This is accomplished by the use of higher-order functions and metatheorems to produce a tailored theory about particular programs.<<ETX>>""
  - ""ADABTPL also supports a paradigm of programming by tying the compiler to a powerful Boyer-Moore-style theorem prover that can be invoked by the programmer to verify properties of programs and validate program transformations.""
  - ""The ADABTPL language does this by supplying a small class of orthogonal inheritance producing and restricting mechanisms.""
  - ""It is possible to include robust inheritance features while separating them from data structuring mechanisms to a higher degree than is accomplished in most languages.""",,"- The abstract discusses the inclusion of ""robust inheritance features"" and the separation of these features from data structuring mechanisms, which suggests a focus on abstraction mechanisms.
 - The mention of ""orthogonal inheritance producing and restricting mechanisms"" implies a structured approach to inheritance, which is a form of abstraction.
 - The use of a ""powerful Boyer-Moore-style theorem prover"" and ""higher-order functions and metatheorems"" suggests a strong emphasis on formal verification and theoretical foundations, which can be related to generic programming methodologies.
 - However, the abstract does not explicitly mention ""generic programming"" or provide specific details on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus seems to be more on inheritance and theorem proving rather than generic programming per se.","- ""It is possible to include robust inheritance features while separating them from data structuring mechanisms to a higher degree than is accomplished in most languages.""
  - ""ADABTPL also supports a paradigm of programming by tying the compiler to a powerful Boyer-Moore-style theorem prover that can be invoked by the programmer to verify properties of programs and validate program transformations.""
  - ""The ADABTPL language does this by supplying a small class of orthogonal inheritance producing and restricting mechanisms.""
  - ""This is accomplished by the use of higher-order functions and metatheorems to produce a tailored theory about particular programs.<<ETX>>""",,"- The abstract highlights a novel approach to inheritance in programming languages by separating inheritance features from data structuring mechanisms more effectively than existing languages. This is a key theoretical contribution as it addresses a common issue in language design.
 - The use of a ""small class of orthogonal inheritance producing and restricting mechanisms"" suggests a theoretical advancement in how inheritance is managed, potentially simplifying and making it more robust.
 - The integration of a Boyer-Moore-style theorem prover with the compiler is a significant theoretical contribution, as it allows for the verification of program properties and transformations. This is a novel insight into how programming languages can be designed to ensure correctness and reliability.
 - The use of ""higher-order functions and metatheorems"" to create a tailored theory for specific programs indicates a theoretical advancement in programming paradigms, enabling more precise and flexible programming practices.
 - These contributions have potential implications for programming language design, as they suggest new ways to manage inheritance and ensure program correctness, which could influence future language development."
"A framework for the development of simulation systems (computation theory, compiling expert)",D. E. Stevenson,-,-,-,0,1983,"1. Primitive Name: Typed Herbrand Universe
  Definition: Allows a semantic and pragmatic structure to be imposed on a formal language.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Computational System Property
  Definition: Evaluation functions must have a property of forming a basis.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Computational Structure
  Definition: A morphism from one formal language to another, unifying syntax, semantics, and pragmatics.
  Orthogonality Score: Not specified
 

 4. Primitive Name: State-Transition Form
  Definition: A new canonical form for programs with one entrance but multiple exits.
  Orthogonality Score: Not specified
 

 5. Primitive Name: Basis Functions for Recursive Functions
  Definition: Based on pushdown automata.
  Orthogonality Score: Not specified","- Type of mathematical framework: Computability theory, denotational semantics, type theory, category theory
 - Specific mathematical properties guaranteed: Evaluation functions, computational system property, runtime trace as a regular expression
 - Proof techniques used: Nonconstructive proof
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Dynamic combination of interpreters developed independently.
 - Interaction models between paradigms: Unified approach to syntax and semantics; computational structure unifies syntax, semantics, and pragmatics.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"" used: The typed Herbrand universe and computational structure are new concepts developed to impose semantic and pragmatic structures on formal languages.
 - Mechanisms for representing generic abstractions: The typed Herbrand universe and computational structure are used to unify ideas about language syntax, semantics, and pragmatics.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novel framework for simulation systems based on interpreters
 - Unified approach to syntax and semantics in interpreters
 - Introduction of the typed Herbrand universe
 - Concept of computational system property
 - Concept of computational structure
 - New canonical form for programs: state-transition form
 - Proof about recursive functions having basis functions based on pushdown automata
 - Potential implications for programming language design through extending algebraic aspects of computational structures","- ""A new concept, the typed Herbrand universe, is developed.""
  - ""The evaluation functions must have a property of forming a basis; this second new concept which we term the computational system property.""
  - ""The third new concept developed is the computational structure.""
  - ""A computational structure is a morphism from one formal language to another.""
  - ""The computational structure unifies ideas concerning the syntax, semantics, and pragmatics of language.""
  - ""Two technical results of interest are developed. The first result is a new canonical form for programs, called the state-transition form.""
  - ""Secondly, we give a nonconstructive proof that recursive functions have a set of basis functions which are based on pushdown automata.""",,"- The abstract mentions several new concepts developed in the study: the typed Herbrand universe, the computational system property, and the computational structure. These are explicitly identified as conceptual primitives.
 - The typed Herbrand universe is described as allowing a semantic and pragmatic structure to be imposed on a formal language, indicating its role in defining the structure of programming paradigms.
 - The computational system property is related to evaluation functions forming a basis, which suggests it is a primitive related to the foundational structure of computation.
 - The computational structure is defined as a morphism from one formal language to another, unifying syntax, semantics, and pragmatics, indicating its role in transforming and relating different programming paradigms.
 - The state-transition form and the basis functions for recursive functions based on pushdown automata are also mentioned as technical results, which could be considered as additional primitives or applications of the main primitives.
 - The level of abstraction is high, as these primitives are theoretical concepts related to the foundation of programming paradigms.
 - Orthogonality is not explicitly discussed in the abstract, but the distinct definitions suggest a level of orthogonality among the primitives.","- ""The foundation for the development of this framework is computability theory and denotational semantics.""
  - ""A unified approach to syntax and semantics in interpreters is presented.""
  - ""A new concept, the typed Herbrand universe, is developed.""
  - ""Using the typed Herbrand universe, we formalize the notion of evaluation functions.""
  - ""The evaluation functions must have a property of forming a basis; this second new concept which we term the computational system property.""
  - ""The third new concept developed is the computational structure.""
  - ""A computational structure is a morphism from one formal language to another.""
  - ""Two technical results of interest are developed. The first result is a new canonical form for programs, called the state-transition form.""
  - ""Using this form, we prove that the runtime trace of a program is a regular expression.""
  - ""Secondly, we give a nonconstructive proof that recursive functions have a set of basis functions which are based on pushdown automata.""",,"- The abstract mentions that the foundation of the framework is based on ""computability theory and denotational semantics,"" which indicates the type of mathematical framework used.
 - The ""typed Herbrand universe"" is a new concept developed within this framework, which suggests a focus on type theory.
 - The framework formalizes ""evaluation functions"" and introduces the ""computational system property,"" indicating specific mathematical properties guaranteed.
 - The use of ""morphisms"" from one formal language to another suggests an application of category theory.
 - The abstract mentions ""nonconstructive proof"" techniques, which are used to prove properties about recursive functions and their basis functions.
 - The framework is used to prove that the runtime trace of a program is a regular expression, which is a specific mathematical property guaranteed.
 - The abstract does not explicitly mention limitations or constraints of the framework.","- ""A framework for the development of computer simulation systems based on interpreters is to be developed.""
  - ""These interpreters are to be developed independently of any preconceived structure of the simulator and are to be combined dynamically by the modeler.""
  - ""A unified approach to syntax and semantics in interpreters is presented.""
  - ""The computational structure unifies ideas concerning the syntax, semantics, and pragmatics of language.""
  - ""The structure of the algorithm and the computational structure model indicates a different machine paradigm than those currently in use.""
  - ""the interpreter uses the computational structure paradigm to construct strings which are then queued for interpretation by an appropriate computational structure.""",,"- The abstract discusses the development of a framework for simulation systems based on interpreters that can be combined dynamically. This suggests a mechanism for integrating different programming paradigms by allowing interpreters to be developed independently and combined as needed.
 - The mention of a ""unified approach to syntax and semantics in interpreters"" implies a theoretical integration strategy that could facilitate the interaction between different paradigms.
 - The computational structure is described as unifying ideas concerning syntax, semantics, and pragmatics, which could be seen as a model for integrating different programming paradigms.
 - The interpreter is said to combine ideas from operating systems and macro processors, indicating a practical integration of different programming concepts.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques. However, it implies a flexible and dynamic integration approach through the use of interpreters and computational structures.","- ""A framework for the development of computer simulation systems based on interpreters is to be developed.""
  - ""A unified approach to syntax and semantics in interpreters is presented.""
  - ""A new concept, the typed Herbrand universe, is developed.""
  - ""This concept allows a semantic and pragmatic structure to be imposed on a (formal) language.""
  - ""Using the typed Herbrand universe, we formalize the notion of evaluation functions.""
  - ""The evaluation functions must have a property of forming a basis; this second new concept which we term the computational system property.""
  - ""The third new concept developed is the computational structure.""
  - ""A computational structure is a morphism from one formal language to another.""
  - ""The computational structure unifies ideas concerning the syntax, semantics, and pragmatics of language.""
  - ""An interpreter based on these new concepts is also described and examples of its use are given.""
  - ""The structure of the algorithm and the computational structure model indicates a different machine paradigm than those currently in use.""
  - ""The salient point is that the interpreter uses the computational structure paradigm to construct strings which are then queued for interpretation by an appropriate computational structure.""",,"- The abstract discusses the development of a framework for simulation systems based on interpreters, which involves a unified approach to syntax and semantics. This suggests a focus on conceptual abstraction.
 - The introduction of the ""typed Herbrand universe"" and ""computational structure"" concepts indicates mechanisms for representing generic abstractions. These concepts are used to impose semantic and pragmatic structures on formal languages.
 - The ""computational system property"" and ""computational structure"" are new concepts that unify ideas about language syntax, semantics, and pragmatics, which can be seen as mechanisms for generic programming.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, but it does discuss the use of these concepts in a computational framework.
 - The focus on interpreters and computational structures suggests a generic programming methodology, but the abstract does not provide detailed discussions on type systems or explicit generic programming methodologies.","- ""A framework for the development of computer simulation systems based on interpreters is to be developed.""
  - ""A unified approach to syntax and semantics in interpreters is presented.""
  - ""A new concept, the typed Herbrand universe, is developed.""
  - ""The evaluation functions must have a property of forming a basis; this second new concept which we term the computational system property.""
  - ""The third new concept developed is the computational structure.""
  - ""A computational structure is a morphism from one formal language to another.""
  - ""The computational structure unifies ideas concerning the syntax, semantics, and pragmatics of language.""
  - ""Two technical results of interest are developed. The first result is a new canonical form for programs, called the state-transition form.""
  - ""Secondly, we give a nonconstructive proof that recursive functions have a set of basis functions which are based on pushdown automata.""
  - ""Future directions are discussed, particularly in extending the algebraic aspects of computational structures.""",,"- The abstract introduces a novel framework for developing simulation systems based on interpreters, which is a significant theoretical contribution.
 - The development of a unified approach to syntax and semantics in interpreters is a key theoretical advancement, as it integrates different aspects of language processing.
 - The introduction of the ""typed Herbrand universe"" is a new concept that allows for the imposition of semantic and pragmatic structures on formal languages, which is a theoretical innovation.
 - The concept of ""computational system property"" and ""computational structure"" are new theoretical contributions that unify ideas about language syntax, semantics, and pragmatics.
 - The development of a new canonical form for programs, the ""state-transition form,"" and the proof about recursive functions having basis functions based on pushdown automata are significant theoretical results.
 - The discussion of future directions in extending algebraic aspects of computational structures suggests potential implications for programming language design and theoretical advancements."
A verified integration of parallel programming paradigms in CC++,P. Sivilotti,10.1109/IPPS.1994.288320,https://doi.org/10.1109/IPPS.1994.288320,Proceedings of 8th International Parallel Processing Symposium,8,1994,"1. Primitive Name: Parallel Composition
  Definition: Used to express concurrency in CC++
  Orthogonality Score: Not specified
 2. Primitive Name: Atomic Functions
  Definition: Used to express concurrency in CC++
  Orthogonality Score: Not specified
 3. Primitive Name: Single-Assignment Variables
  Definition: Used to express concurrency in CC++
  Orthogonality Score: Not specified
 4. Primitive Name: Monitors
  Definition: Traditional imperative communication model integrated with CC++
  Orthogonality Score: Not specified
 5. Primitive Name: Asynchronous Channels
  Definition: Traditional imperative synchronization model integrated with CC++
  Orthogonality Score: Not specified",Not specified (the abstract does not provide details about the mathematical framework used for formal verification),"- Specific integration mechanisms proposed: parallel composition, atomic functions, single-assignment variables
 - Interaction models between paradigms: equivalence to monitors and asynchronous channels
 - Constraints or challenges in paradigm integration: Not mentioned
 - Novel translation or embedding techniques: specification, implementation, and formal verification of libraries",Generic programming not extensively addressed,"- Key novel insights: Integration of object-oriented programming with parallel composition, atomic functions, and single-assignment variables.
 - Theoretical advancements: Equivalence to traditional models like monitors and asynchronous channels; object-oriented framework for integration.
 - Potential implications: Unified platform for integrating various programming models, implications for future programming language design.","- ""CC++ is an object-oriented parallel programming language that uses parallel composition, atomic functions, and single-assignment variables to express concurrency.""
  - ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely monitors and asynchronous channels.""
  - ""We specify, implement, and formally verify a collection of libraries that integrates these traditional models with CC++.<<ETX>>""
  - ""the object-oriented nature of CC++ provides an ideal framework for integrating these paradigms.""",,"- The abstract mentions ""parallel composition, atomic functions, and single-assignment variables"" as elements used in CC++ to express concurrency. These can be considered as conceptual primitives since they are fundamental components of the programming paradigm.
 - The abstract also refers to ""monitors and asynchronous channels"" as traditional models integrated with CC++. These could be seen as additional primitives or concepts integrated into the framework.
 - The abstract does not provide explicit definitions for these primitives beyond their mention as part of the CC++ paradigm.
 - The level of abstraction and orthogonality of these primitives are not explicitly discussed in the abstract.","- ""We specify, implement, and formally verify a collection of libraries that integrates these traditional models with CC++.<<ETX>>""
  - ""CC++ is an object-oriented parallel programming language that uses parallel composition, atomic functions, and single-assignment variables to express concurrency.""
  - ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely monitors and asynchronous channels.""",,"- The abstract mentions that CC++ uses ""parallel composition, atomic functions, and single-assignment variables"" to express concurrency, which suggests a focus on parallel programming paradigms.
 - It states that these paradigms are ""equivalent to several traditional imperative communication and synchronization models,"" indicating a theoretical comparison but not specifying a mathematical framework.
 - The abstract mentions ""formally verify a collection of libraries,"" which implies some form of formal verification, but it does not specify the type of mathematical framework used for this verification.
 - There is no explicit mention of a specific mathematical framework such as type theory or category theory, nor are there details about specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""CC++ is an object-oriented parallel programming language that uses parallel composition, atomic functions, and single-assignment variables to express concurrency.""
  - ""Furthermore, the object-oriented nature of CC++ provides an ideal framework for integrating these paradigms.""
  - ""We specify, implement, and formally verify a collection of libraries that integrates these traditional models with CC++.<<ETX>>""
  - ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely monitors and asynchronous channels.""",,"- The abstract mentions that CC++ uses parallel composition, atomic functions, and single-assignment variables, which are specific integration mechanisms for expressing concurrency.
 - It states that CC++ is equivalent to traditional imperative models like monitors and asynchronous channels, indicating an interaction model between these paradigms.
 - The object-oriented nature of CC++ is highlighted as an ideal framework for integration, suggesting a theoretical integration strategy.
 - The abstract mentions the specification, implementation, and formal verification of libraries that integrate traditional models with CC++, which implies a novel translation or embedding technique.
 - However, the abstract does not explicitly mention any constraints or challenges in paradigm integration.","- ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely monitors and asynchronous channels.""
  - ""CC++ is an object-oriented parallel programming language that uses parallel composition, atomic functions, and single-assignment variables to express concurrency.""
  - ""We specify, implement, and formally verify a collection of libraries that integrates these traditional models with CC++.<<ETX>>""
  - ""Furthermore, the object-oriented nature of CC++ provides an ideal framework for integrating these paradigms.""",,"- The abstract mentions that CC++ is an ""object-oriented parallel programming language,"" which suggests that it uses object-oriented programming (OOP) principles. OOP is known for its abstraction mechanisms, such as encapsulation and inheritance, which are fundamental to generic programming.
 - The mention of ""parallel composition, atomic functions, and single-assignment variables"" indicates mechanisms for representing concurrency, which can be related to generic abstractions in parallel programming.
 - The abstract does not explicitly mention ""generic programming"" or ""abstraction mechanisms"" in the context of genericity and abstraction. However, it does highlight the integration of traditional models with CC++, which implies some level of abstraction.
 - There is no specific mention of ""minimal type requirements,"" ""static checking,"" or ""optimization strategies"" related to generic programming.
 - The focus of the abstract is more on the integration of parallel programming paradigms rather than on generic programming methodologies or type system discussions.","- ""CC++ is an object-oriented parallel programming language that uses parallel composition, atomic functions, and single-assignment variables to express concurrency.""
  - ""Furthermore, the object-oriented nature of CC++ provides an ideal framework for integrating these paradigms.""
  - ""We specify, implement, and formally verify a collection of libraries that integrates these traditional models with CC++.<<ETX>>""
  - ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely monitors and asynchronous channels.""",,"- The abstract introduces CC++ as an object-oriented parallel programming language, which is a novel integration of parallel programming paradigms. This suggests a key novel insight in combining object-oriented programming with parallel composition, atomic functions, and single-assignment variables.
 - The equivalence of CC++'s paradigm to traditional models like monitors and asynchronous channels is a theoretical advancement. It shows that CC++ can unify different programming models, which is a significant theoretical contribution.
 - The object-oriented nature of CC++ being an ideal framework for integrating these paradigms is another theoretical advancement. It highlights the potential for CC++ to serve as a platform for integrating various programming models, which could have implications for future programming language design.
 - The formal verification of libraries integrating traditional models with CC++ is a theoretical contribution as it provides a rigorous foundation for the integration, ensuring reliability and consistency."
Functional Programming Languages with Logical Variables: A Linear Logic View,"J. Darlington, Yike Guo, Martin Köhler",10.1007/3-540-57186-8_80,https://doi.org/10.1007/3-540-57186-8_80,Symposium on Programming Language Implementation and Logic Programming,5,1993,Not specified (the abstract does not explicitly define specific conceptual primitives beyond the use of linear logic),"- Type of mathematical framework: Linear logic
 - Specific mathematical properties guaranteed: Resource-consciousness
 - Proof techniques used: Deduction in linear logic
 - Limitations or constraints of the framework: Not specified",No specific integration approach described (the abstract focuses on theoretical integration using linear logic but does not detail specific mechanisms or challenges),Generic programming not extensively addressed,"- Key novel insights: The operational behavior of functional programming languages with logical variables can be uniformly modelled using linear logic.
 - Theoretical advancements beyond existing approaches: Linear logic formalization provides a resource-conscious model for computation as deduction in the logic.
 - Potential implications for programming language design: Offers a logical meaning for computation and a general abstract machine for implementation.","- ""It is shown that, with the resource-consciousness of linear logic, the computation of the paradigm can be uniformly modelled as deduction in the logic.""
  - ""In this paper, we propose a linear logic formalization of the the computational behaviour of functional programming languages with logical variables.""
  - ""Therefore, the model provides the logical meaning for the computation as well as a general abstract machine for the implementation of these languages.""
  - ""Recently the semantic features of the languages in this paradigm have been uniformly modelled using the constraint computation formalism [RJK92].""
  - ""The idea of introducing logical variables into functional programming languages has been proposed for some years, and many concrete languages with this feature have been developed.""",,"- The abstract discusses the introduction of logical variables into functional programming languages, which suggests a conceptual primitive related to logical variables.
 - The mention of ""constraint computation formalism"" indicates a theoretical framework, but it does not explicitly define a conceptual primitive.
 - The proposal of a ""linear logic formalization"" suggests that linear logic is a conceptual primitive used to model computational behavior.
 - The abstract does not provide explicit definitions or names for specific conceptual primitives beyond the use of linear logic.
 - There is no mention of the level of abstraction or orthogonality of these primitives in the abstract.","- ""It is shown that, with the resource-consciousness of linear logic, the computation of the paradigm can be uniformly modelled as deduction in the logic.""
  - ""In this paper, we propose a linear logic formalization of the the computational behaviour of functional programming languages with logical variables.""
  - ""Therefore, the model provides the logical meaning for the computation as well as a general abstract machine for the implementation of these languages.""",,"- The abstract mentions the use of ""linear logic formalization"" to model the computational behavior of functional programming languages with logical variables. This indicates that the mathematical framework used is linear logic.
 - The mention of ""resource-consciousness of linear logic"" suggests that the framework is capable of modeling resource usage, which is a specific mathematical property.
 - The abstract states that the computation can be ""uniformly modelled as deduction in the logic,"" which implies that the proof technique used is deduction within linear logic.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""It is shown that, with the resource-consciousness of linear logic, the computation of the paradigm can be uniformly modelled as deduction in the logic.""
  - ""In this paper, we propose a linear logic formalization of the the computational behaviour of functional programming languages with logical variables.""
  - ""The idea of introducing logical variables into functional programming languages has been proposed for some years, and many concrete languages with this feature have been developed.""",,"- The abstract discusses the integration of logical variables into functional programming languages, which suggests a blending of paradigms.
 - The use of linear logic to formalize the computational behavior of these languages indicates a theoretical integration strategy.
 - The abstract mentions that the computation can be uniformly modeled as deduction in the logic, which implies a novel translation or embedding technique.
 - However, the abstract does not explicitly mention specific integration mechanisms, interaction models between paradigms, or constraints or challenges in paradigm integration.
 - The focus is on the theoretical integration strategy using linear logic rather than detailed mechanisms or challenges.","- ""In this paper, we propose a linear logic formalization of the the computational behaviour of functional programming languages with logical variables.""
  - ""Therefore, the model provides the logical meaning for the computation as well as a general abstract machine for the implementation of these languages.""
  - ""The idea of introducing logical variables into functional programming languages has been proposed for some years, and many concrete languages with this feature have been developed.""
  - ""It is shown that, with the resource-consciousness of linear logic, the computation of the paradigm can be uniformly modelled as deduction in the logic.""",,"- The abstract discusses the introduction of logical variables into functional programming languages, which could relate to generic programming concepts.
 - The paper proposes a linear logic formalization, which might imply a mechanism for representing generic abstractions through logical deduction.
 - However, the abstract does not explicitly mention generic programming methodology, type system discussions, or abstraction mechanism explanations.
 - There is no mention of minimal type requirements or static checking/optimization strategies.
 - The focus seems to be on the operational behavior and linear logic formalization rather than generic programming or abstraction mechanisms.","- ""The idea of introducing logical variables into functional programming languages has been proposed for some years, and many concrete languages with this feature have been developed.""
  - ""Recently the semantic features of the languages in this paradigm have been uniformly modelled using the constraint computation formalism [RJK92].""
  - ""However, the operational behaviour of these languages has not been studied systematically.""
  - ""In this paper, we propose a linear logic formalization of the the computational behaviour of functional programming languages with logical variables.""
  - ""It is shown that, with the resource-consciousness of linear logic, the computation of the paradigm can be uniformly modelled as deduction in the logic.""
  - ""Therefore, the model provides the logical meaning for the computation as well as a general abstract machine for the implementation of these languages.""",,"- The abstract mentions that the idea of logical variables in functional programming languages is not new, but the operational behavior of these languages has not been systematically studied. This indicates a gap in existing research that the paper aims to address.
 - The paper proposes a linear logic formalization of the computational behavior of these languages, which is a novel approach. This suggests a theoretical advancement beyond existing approaches, as it provides a new framework for understanding the operational behavior.
 - The use of linear logic to model computation as deduction in the logic is highlighted as a key contribution. This provides a theoretical innovation by offering a resource-conscious model that can uniformly represent the computation.
 - The abstract also mentions that the model provides a logical meaning for the computation and a general abstract machine for implementation. This implies potential implications for programming language design, as it offers a theoretical foundation for developing languages with logical variables.
 - Overall, the novelty and theoretical contribution of the paper lie in its proposal of a linear logic formalization for the operational behavior of functional programming languages with logical variables, which addresses a previously unexplored area and provides a new theoretical framework."
A framework for studying the semantics of object-oriented programs,"Zhuangjian Wei, Arthur T. Poe",-,-,-,1,2001,"1. Primitive Name: Three-domain Architecture
  Definition: Consists of a theory domain, a program domain, and an object domain.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Logic Theories
  Definition: Specifications are logic theories.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Program Implementations
  Definition: Programs are the implementations of these theories.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Logic Models
  Definition: Objects are logic models of these theories.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Many-sorted Logic
  Definition: Extended to accommodate the object-oriented paradigm.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Predicate Transformation
  Definition: Extended to accommodate the object-oriented paradigm.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Theory of Object Types (TOT)
  Definition: Result of extending many-sorted logic and predicate transformation.
  Orthogonality Score: Not discussed
 

 8. Primitive Name: Multi-layered Abstraction Hierarchy
  Definition: For specification, derivation, and verification of object behavior.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Many-sorted logic, predicate transformation, type theory (Theory of Object Types)
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Multi-layered abstraction hierarchy, compositional reasoning
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of the FOOS framework for specifying, deriving, and verifying object-oriented program semantics; Three-domain Architecture for organizing semantics.
 - Theoretical advancements: Extension of many-sorted logic and predicate transformation to accommodate object-oriented programming; Development of the Theory of Object Types (TOT).
 - Potential implications: Structured framework for programming language design; Simplified verification processes through multi-layered abstraction hierarchy.","- ""The framework, FOOS (Framework for Object-Oriented Semantics) is built upon a Three-domain Architecture: a theory domain, a program domain, and an object domain.""
  - ""Under this architecture, specifications are logic theories, programs are the implementations of these theories, and objects are logic models of these theories.""
  - ""Based on the compositional nature of objects, a multi-layered abstraction hierarchy is devised for the specification, derivation, as well as verification of object behavior.""
  - ""The result is the TOT (Theory of Object Types). Objects are simply regarded as models of the TOTs in FOOS.""
  - ""FOOS extends the theories of many-sorted logic and predicate transformation to accommodate the object-oriented paradigm.""
  - ""A framework that can be used to specify, derive and verify the semantics of an object-oriented program is presented.""",,"- The abstract describes a framework called FOOS, which is built on a Three-domain Architecture consisting of a theory domain, a program domain, and an object domain. This suggests that these domains are conceptual primitives in the framework.
 - The abstract mentions that specifications are logic theories, programs are implementations of these theories, and objects are logic models of these theories. This indicates that logic theories, program implementations, and logic models are conceptual primitives.
 - The extension of many-sorted logic and predicate transformation to accommodate object-oriented paradigms implies that these are also conceptual primitives, as they form the theoretical basis of the framework.
 - The Theory of Object Types (TOT) is mentioned as a result of extending these theories, suggesting that TOT is a conceptual primitive related to object types.
 - The multi-layered abstraction hierarchy is a methodological primitive for specifying, deriving, and verifying object behavior, indicating it is a conceptual primitive for organizing the framework's processes.","- ""The framework, FOOS (Framework for Object-Oriented Semantics) is built upon a Three-domain Architecture: a theory domain, a program domain, and an object domain.""
  - ""FOOS extends the theories of many-sorted logic and predicate transformation to accommodate the object-oriented paradigm.""
  - ""The result is the TOT (Theory of Object Types).""
  - ""Objects are simply regarded as models of the TOTs in FOOS.""
  - ""Based on the compositional nature of objects, a multi-layered abstraction hierarchy is devised for the specification, derivation, as well as verification of object behavior.""
  - ""This abstraction hierarchy divides a large proof obligation into layers of smaller proof tasks.""",,"- The abstract mentions that FOOS is built upon a ""Three-domain Architecture,"" which suggests a structured approach to formalizing object-oriented semantics.
 - It explicitly states that FOOS ""extends the theories of many-sorted logic and predicate transformation,"" indicating the use of these mathematical frameworks to accommodate object-oriented concepts.
 - The mention of ""Theory of Object Types (TOT)"" suggests a type theory framework, as it involves modeling objects as types.
 - The use of a ""multi-layered abstraction hierarchy"" for specification, derivation, and verification implies a structured proof methodology, likely involving compositional reasoning.
 - The division of proof obligations into smaller tasks suggests a modular approach to proof techniques, which is common in formal verification.
 - There is no explicit mention of specific mathematical properties guaranteed or limitations/constraints of the framework in the abstract.","- ""Based on the compositional nature of objects, a multi-layered abstraction hierarchy is devised for the specification, derivation, as well as verification of object behavior.""
  - ""Objects are simply regarded as models of the TOTs in FOOS.""
  - ""FOOS extends the theories of many-sorted logic and predicate transformation to accommodate the object-oriented paradigm.""
  - ""The framework, FOOS (Framework for Object-Oriented Semantics) is built upon a Three-domain Architecture: a theory domain, a program domain, and an object domain.""
  - ""A framework that can be used to specify, derive and verify the semantics of an object-oriented program is presented.""",,"- The abstract primarily focuses on the development of a framework (FOOS) for specifying, deriving, and verifying the semantics of object-oriented programs.
 - It mentions the extension of theories from many-sorted logic and predicate transformation to accommodate object-oriented programming, which suggests an integration of logical theories with object-oriented programming.
 - The framework is described as being built on a three-domain architecture, which could imply a structured approach to integrating different aspects of programming paradigms.
 - However, there is no explicit mention of integrating different programming paradigms or specific mechanisms for such integration.
 - The abstract does not discuss interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.
 - The focus is on the object-oriented paradigm rather than integrating multiple paradigms.","- ""A framework that can be used to specify, derive and verify the semantics of an object-oriented program is presented.""
  - ""The framework, FOOS (Framework for Object-Oriented Semantics) is built upon a Three-domain Architecture: a theory domain, a program domain, and an object domain.""
  - ""In addition to modeling the relationships among specification, implementation, and run-time behavior of an object-oriented program, means are also provided for reasoning the dynamic features of objects, including object references, reference aliasing, dynamic bindings, etc.""
  - ""FOOS extends the theories of many-sorted logic and predicate transformation to accommodate the object-oriented paradigm.""
  - ""The result is the TOT (Theory of Object Types). Objects are simply regarded as models of the TOTs in FOOS.""
  - ""Based on the compositional nature of objects, a multi-layered abstraction hierarchy is devised for the specification, derivation, as well as verification of object behavior.""
  - ""This abstraction hierarchy divides a large proof obligation into layers of smaller proof tasks.""",,"- The abstract discusses a framework for studying the semantics of object-oriented programs, which includes a three-domain architecture and extends theories of many-sorted logic and predicate transformation. This suggests a focus on conceptual abstraction and semantic modeling.
 - The mention of a ""multi-layered abstraction hierarchy"" indicates a mechanism for representing generic abstractions by breaking down complex tasks into smaller, manageable layers.
 - The abstract does not explicitly mention generic programming or type requirements, nor does it discuss static checking or optimization strategies. This suggests that generic programming is not a primary focus of the study.
 - The focus on object types and their models implies a conceptual abstraction mechanism, but it does not explicitly address generic programming methodologies or type system discussions.","- ""A framework that can be used to specify, derive and verify the semantics of an object-oriented program is presented.""
  - ""The framework, FOOS (Framework for Object-Oriented Semantics) is built upon a Three-domain Architecture: a theory domain, a program domain, and an object domain.""
  - ""FOOS extends the theories of many-sorted logic and predicate transformation to accommodate the object-oriented paradigm.""
  - ""The result is the TOT (Theory of Object Types).""
  - ""Based on the compositional nature of objects, a multi-layered abstraction hierarchy is devised for the specification, derivation, as well as verification of object behavior.""
  - ""This abstraction hierarchy divides a large proof obligation into layers of smaller proof tasks.""",,"- The abstract introduces a novel framework called FOOS, which is designed to specify, derive, and verify the semantics of object-oriented programs. This is a key novel insight as it provides a structured approach to understanding object-oriented programming semantics.
 - The framework is built on a Three-domain Architecture, which is a theoretical advancement as it organizes the semantics into distinct domains (theory, program, and object). This is a new way of conceptualizing the relationships between these domains.
 - FOOS extends existing theories of many-sorted logic and predicate transformation to fit the object-oriented paradigm. This is a theoretical advancement as it adapts established logical frameworks to accommodate object-oriented programming, which is a significant contribution.
 - The development of the Theory of Object Types (TOT) is another theoretical contribution. It provides a foundational theory for understanding object types within the framework.
 - The multi-layered abstraction hierarchy is a novel approach for managing the complexity of object behavior verification. It breaks down large proof obligations into smaller tasks, which is a significant theoretical innovation for simplifying verification processes.
 - The potential implications for programming language design include providing a structured framework for specifying and verifying object-oriented programs, which could lead to more robust and reliable programming languages."
Definitive programming for parallelism,M. Beynon,-,-,-,1,1989,Not specified (the abstract does not explicitly define or list conceptual primitives),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of a novel approach to concurrent programming based on definitive programming.
 - Theoretical advancements: Advancing a case for definitive programming as a basis for general-purpose parallel computing, discussing its general principles and specific features in comparison to existing paradigms.
 - Potential implications: Development of an abstract machine model for simulating concurrent systems, contributing to programming language design.","- ""An appropriate abstract machine model is motivated, described and illustrated with reference to the simulation of a simple concurrent system.""
  - ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms,""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests that this approach involves some form of conceptual primitives related to definitions.
 - The abstract discusses ""general principles and specific features"" of definitive programming, which could imply that these are the conceptual primitives. However, it does not explicitly list or define these principles or features.
 - The mention of an ""abstract machine model"" suggests that there might be some theoretical framework or model involved, but again, no specific primitives are explicitly defined or listed in the abstract.
 - The abstract does not provide precise definitions or a list of specific conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""An appropriate abstract machine model is motivated, described and illustrated with reference to the simulation of a simple concurrent system.""
  - ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms,""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests a focus on programming principles rather than a specific mathematical framework.
 - The discussion of ""general principles and specific features"" implies a conceptual rather than a mathematical framework.
 - The mention of an ""abstract machine model"" could imply some theoretical foundation, but there is no explicit mention of a mathematical framework such as type theory or category theory.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework, which are key components of a mathematical framework.","- ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms,""
  - ""the relative merits of definitive programming for general-purpose parallelism are considered.""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests a new paradigm or approach rather than an integration of existing paradigms.
 - The discussion of ""general principles and specific features of definitive programming"" in the context of existing paradigms implies a comparison or analysis rather than an integration mechanism.
 - The abstract does not explicitly mention any specific integration mechanisms, interaction models, constraints, or novel translation techniques related to integrating different programming paradigms.
 - The focus appears to be on presenting and evaluating the merits of the definitive programming paradigm rather than integrating it with other paradigms.","- ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms,""
  - ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""An appropriate abstract machine model is motivated, described and illustrated with reference to the simulation of a simple concurrent system.""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests a focus on a specific paradigm rather than generic programming.
 - The discussion of ""general principles and specific features"" implies an exploration of the paradigm's characteristics, but it does not explicitly mention generic programming or abstraction mechanisms.
 - The mention of an ""abstract machine model"" could relate to abstraction mechanisms, but it is not explicitly linked to generic programming or conceptual abstraction.
 - There is no mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies, which are key components of generic programming.","- ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms, and the relative merits of definitive programming for general-purpose parallelism are considered.""
  - ""An appropriate abstract machine model is motivated, described and illustrated with reference to the simulation of a simple concurrent system.""
  - ""A case for the further investigation and development of the definitive programming paradigm as a basis for general-purpose parallel computing is presented.""",,"- The abstract introduces a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests a new theoretical contribution in the field of parallel computing.
 - The mention of presenting a ""case for the further investigation and development"" of this paradigm indicates that the paper is advancing a theoretical argument for its potential as a basis for general-purpose parallel computing.
 - The discussion of ""general principles and specific features"" in relation to existing paradigms implies a comparative analysis that highlights the theoretical advancements of definitive programming.
 - The description of an ""abstract machine model"" suggests a theoretical innovation in how concurrent systems can be simulated, which is a contribution to programming language design."
COMBINATORY LOGIC AS THE FIRST-ORDER MATHEMATICAL THEORY,"江明德, 文蕙",-,-,-,0,1989,Not specified (the abstract does not provide explicit definitions or names of conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Integration of combinatory logic and predicate calculus for a unified mathematical foundation.
 - Theoretical advancements: Providing a strict and thorough mathematical foundation for programming languages with functional and logic paradigms.
 - Potential implications: Development of more robust and efficient programming languages integrating both paradigms.","- ""The exploration for a unified basis of the combinatory logic and the predicate calculus will promote laying a strict and thorough mathematical foundation of the programming language possessing itself of the functional and logic paradigms.""",,"- The abstract discusses the exploration of a unified basis for combinatory logic and predicate calculus, which suggests a focus on theoretical foundations rather than specific conceptual primitives.
 - The mention of ""formulize the first-order mathematical theory"" indicates a focus on developing a theoretical framework, but it does not specify any conceptual primitives.
 - The abstract does not provide explicit definitions or names of conceptual primitives, nor does it discuss their level of abstraction or orthogonality.
 - The focus is on laying a mathematical foundation rather than defining specific primitives.","- ""The exploration for a unified basis of the combinatory logic and the predicate calculus will promote laying a strict and thorough mathematical foundation of the programming language possessing itself of the functional and logic paradigms.""",,"- The abstract mentions the exploration of a unified basis for combinatory logic and predicate calculus, which suggests a focus on theoretical foundations.
 - The mention of ""algebraic perspective"" indicates that the mathematical framework might involve algebraic methods or structures.
 - The abstract does not specify the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no mention of proof techniques or limitations/constraints of the framework in the abstract.
 - The abstract does not provide explicit details about the mathematical framework used to formalize and guarantee properties of the conceptual primitives.","- ""The exploration for a unified basis of the combinatory logic and the predicate calculus will promote laying a strict and thorough mathematical foundation of the programming language possessing itself of the functional and logic paradigms.""",,"- The abstract mentions the exploration of a unified basis for combinatory logic and predicate calculus, which suggests an integration of these two logical systems. This could imply an integration of functional and logic paradigms in programming languages.
 - The abstract does not provide specific integration mechanisms, interaction models, constraints, or novel translation techniques. It only mentions the goal of laying a mathematical foundation for programming languages with these paradigms.
 - The focus is on formulating a first-order mathematical theory from an algebraic perspective, which does not explicitly describe how the integration of paradigms is achieved or what specific integration approach is used.","- ""The exploration for a unified basis of the combinatory logic and the predicate calculus will promote laying a strict and thorough mathematical foundation of the programming language possessing itself of the functional and logic paradigms.""",,"- The abstract discusses the unification of combinatory logic and predicate calculus to lay a mathematical foundation for programming languages with functional and logic paradigms. This suggests a focus on theoretical foundations rather than specific programming methodologies.
 - The mention of ""algebraic perspective"" and ""first-order mathematical theory"" indicates a focus on theoretical formulation rather than practical programming mechanisms.
 - There is no mention of generic programming, abstraction mechanisms, type systems, or static checking strategies in the abstract.
 - The abstract does not provide any information on the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or optimization strategies.","- ""The exploration for a unified basis of the combinatory logic and the predicate calculus will promote laying a strict and thorough mathematical foundation of the programming language possessing itself of the functional and logic paradigms.""",,"- The abstract mentions the exploration of a unified basis for combinatory logic and predicate calculus, which suggests a novel integration of these two areas. This integration could provide a new foundation for programming languages that combine functional and logic paradigms.
 - The mention of ""laying a strict and thorough mathematical foundation"" implies a theoretical advancement in providing a solid mathematical basis for programming languages, which could be a significant contribution.
 - The focus on ""formulizing the first-order mathematical theory"" from an algebraic perspective indicates a theoretical contribution in terms of developing a systematic mathematical framework for these programming paradigms.
 - The potential implications for programming language design are significant, as a unified mathematical foundation could lead to more robust and efficient programming languages that integrate both functional and logic programming paradigms."
Programming Language Techniques for Cryptographic Proofs,"G. Barthe, B. Grégoire, Santiago Zanella Béguelin",10.1007/978-3-642-14052-5_10,https://doi.org/10.1007/978-3-642-14052-5_10,International Conference on Interactive Theorem Proving,15,2010,"1. Primitive Name: Observational Equivalence
  Definition: A tool to prove semantic equivalence between program fragments.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Relational Hoare Logic
  Definition: Generalizes observational equivalence to consider arbitrary binary relations on memories.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Failure Events
  Definition: Formalizes non-semantics-preserving transformations.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Interprocedural Code Motion (Eager and Lazy Sampling)
  Definition: Allows for the reordering of instructions in games.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory (Coq proof assistant)
 - Specific mathematical properties guaranteed: Observational equivalence, relational Hoare logic
 - Proof techniques used: Observational equivalence, relational Hoare logic, semantics-preserving program transformations
 - Limitations or constraints of the framework: Not explicitly mentioned",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of failure events and interprocedural code motion (eager/lazy sampling) techniques.
 - Theoretical advancements: Formalization of non-semantics-preserving transformations and strategic placement of random choices.
 - Potential implications for programming language design: Integration of these techniques into a comprehensive framework like CertiCrypt for verifying cryptographic proofs.","- ""CertiCrypt adopts the code-based paradigm, in which the statement of security, and the hypotheses under which it is proved, are expressed using probabilistic programs.""
  - ""It provides a set of programming language tools (observational equivalence, relational Hoare logic, semantics-preserving program transformations) to assist in constructing proofs.""
  - ""The first technique is based on failure events and allows to formalize non-semanticspreserving transformations.""
  - ""The second technique uses interprocedural code motion to place upfront random choices made in games or, dually, to defer them until later in the game.""
  - ""CertiCrypt formalizes an equational theory of observational equivalence that allows to prove that program fragments are semantically equivalent.""
  - ""Observational equivalence provides a useful tool to reason about probabilities.""
  - ""In order to prove the correctness of such transformations, we need to generalize observational equivalence to a full-fledged Relational Hoare Logic that considers arbitrary binary relations on memories (and not just equality on a subset of variables).""
  - ""The primary tool for performing eager/lazy sampling is an extension of the Relational Hoare Logic with rules for swapping statements.""",,"- The paper discusses several programming language techniques used in cryptographic proofs, which can be considered as conceptual primitives.
 - Observational equivalence is a primitive that allows proving semantic equivalence between program fragments.
 - Relational Hoare Logic is another primitive that generalizes observational equivalence to consider arbitrary binary relations on memories.
 - Failure events are a primitive that formalizes non-semantics-preserving transformations.
 - Interprocedural code motion (eager and lazy sampling) is a primitive that allows for the reordering of instructions in games.
 - These primitives are used to reconstruct programming paradigms by providing tools for constructing and verifying game-based cryptographic proofs.","- ""CertiCrypt is a general framework to certify the security of cryptographic primitives in the Coq proof assistant.""
  - ""CertiCrypt adopts the code-based paradigm, in which the statement of security, and the hypotheses under which it is proved, are expressed using probabilistic programs.""
  - ""It provides a set of programming language tools (observational equivalence, relational Hoare logic, semantics-preserving program transformations) to assist in constructing proofs.""
  - ""CertiCrypt formalizes an equational theory of observational equivalence that allows to prove that program fragments are semantically equivalent.""
  - ""Observational equivalence provides a useful tool to reason about probabilities.""
  - ""In order to prove the correctness of such transformations, we need to generalize observational equivalence to a full-fledged Relational Hoare Logic that considers arbitrary binary relations on memories (and not just equality on a subset of variables).""
  - ""The logic deals with judgments of the form ⊢ E, (c; S) ∼ E ′ , (S; c ′ ) : Ψ ⇒ Φ""
  - ""The primary tool for performing eager/lazy sampling is an extension of the Relational Hoare Logic with rules for swapping statements.""
  - ""The game-based approach to cryptographic proofs routinely uses a number of unusual programming language techniques.""",,"- The paper describes CertiCrypt as a framework that uses the Coq proof assistant, which is based on type theory.
 - The framework adopts a code-based paradigm, using probabilistic programs to express security statements and hypotheses.
 - It employs programming language tools such as observational equivalence and relational Hoare logic to assist in constructing proofs.
 - Observational equivalence is used to prove semantic equivalence of program fragments, which is crucial for reasoning about probabilities.
 - The framework extends observational equivalence to a full-fledged relational Hoare logic, which considers arbitrary binary relations on memories.
 - The paper discusses the use of a logic for swapping statements, which is an extension of relational Hoare logic.
 - The framework is designed to guarantee properties related to the security of cryptographic primitives, specifically focusing on probabilistic programs and game-based proofs.","- ""CertiCrypt is a general framework to certify the security of cryptographic primitives in the Coq proof assistant.""
  - ""CertiCrypt adopts the code-based paradigm, in which the statement of security, and the hypotheses under which it is proved, are expressed using probabilistic programs.""
  - ""It provides a set of programming language tools (observational equivalence, relational Hoare logic, semantics-preserving program transformations) to assist in constructing proofs.""
  - ""The game-based approach [5,13] is an alternative to standard program verification methods that establishes the verification goal through successive transformations of the program and the goal.""
  - ""CertiCrypt formalizes an equational theory of observational equivalence that allows to prove that program fragments are semantically equivalent.""
  - ""The game-based approach to cryptographic proofs routinely uses a number of unusual programming language techniques.""
  - ""In this paper we report on the certification and automation of two such techniques, namely failure events, and eager/lazy sampling.""",,"- The paper discusses CertiCrypt, a framework that integrates different programming paradigms by using a code-based approach to express security statements and hypotheses as probabilistic programs.
 - It mentions the use of observational equivalence and relational Hoare logic as tools to assist in constructing proofs, which are part of the integration mechanisms.
 - The game-based approach is highlighted as an alternative to standard program verification methods, indicating an interaction model between different verification paradigms.
 - The paper does not explicitly discuss constraints or challenges in paradigm integration, nor does it mention novel translation or embedding techniques beyond the use of these tools and techniques.
 - The focus is on the application of these techniques within the CertiCrypt framework rather than on a broader integration approach across different programming paradigms.","- ""CertiCrypt is a general framework to certify the security of cryptographic primitives in the Coq proof assistant.""
  - ""CertiCrypt adopts the code-based paradigm, in which the statement of security, and the hypotheses under which it is proved, are expressed using probabilistic programs.""
  - ""It provides a set of programming language tools (observational equivalence, relational Hoare logic, semantics-preserving program transformations) to assist in constructing proofs.""
  - ""Games are formalized as programs in pWhile, a probabilistic imperative language with procedure calls.""
  - ""The language is deeply embedded in Coq, so one can define programs with holes by parametrizing them by program variables of type C (holes may appear in the main command or in the body of procedures in the environment).""
  - ""In order to reason about games in the presence of unknown adversaries, we must specify an interface for adversaries, and construct proofs under the assumption that adversaries are well-formed against their specification.""
  - ""Formally, the interface of an adversary consists of a triple (F , RW, RO), where F is the set of procedures that the adversary may call, RW the set of variables that it may read and write, and RO the set of variables that it may only read.""
  - ""The primary tool for performing eager/lazy sampling is an extension of the Relational Hoare Logic with rules for swapping statements.""",,"- The paper discusses CertiCrypt, a framework for certifying the security of cryptographic primitives, which uses a code-based paradigm. This suggests a focus on formal verification rather than generic programming.
 - The paper mentions the use of probabilistic programs and a probabilistic imperative language called pWhile, which is embedded in Coq. This indicates a focus on formal verification and programming language techniques rather than generic programming.
 - The paper discusses mechanisms for representing adversaries and their interfaces, which is more related to formal verification and security proofs than to generic programming.
 - The paper does not explicitly mention generic programming or abstraction mechanisms in the context of genericity.
 - The focus is on programming language techniques for cryptographic proofs rather than on generic programming or abstraction mechanisms.","- ""In this paper we report on the certification and automation of two such techniques, namely failure events, and eager/lazy sampling.""
  - ""The first technique is based on failure events and allows to formalize non-semanticspreserving transformations.""
  - ""The game-based approach to cryptographic proofs routinely uses a number of unusual programming language techniques.""
  - ""The goal of this article is to present two such techniques and to illustrate their usefulness.""
  - ""The techniques have been developed to complete a formal proof of IND-CCA security of the OAEP padding scheme.""
  - ""The second technique uses interprocedural code motion to place upfront random choices made in games or, dually, to defer them until later in the game.""
  - ""Our ultimate goal is to provide a comprehensive coverage of the techniques used by cryptographers, and to turn CertiCrypt into an effective platform for verifying a wide range of cryptographic proofs.""",,"- The paper introduces two novel techniques: failure events and interprocedural code motion (eager/lazy sampling). These are presented as unique contributions to the field of cryptographic proofs.
 - The techniques were developed specifically to address challenges in proving the IND-CCA security of the OAEP padding scheme, indicating a theoretical advancement beyond existing methods.
 - The use of failure events allows for the formalization of non-semantics-preserving transformations, which is a new insight in managing complexity in cryptographic proofs.
 - The interprocedural code motion technique enhances the efficiency and clarity of proofs by allowing for the strategic placement of random choices.
 - The paper aims to provide a comprehensive framework for cryptographic proofs, which implies a potential impact on programming language design by integrating these techniques into a broader platform like CertiCrypt.
 - The certification and automation of these techniques are highlighted as significant contributions, suggesting a theoretical advancement in the field."
"Choreographies, Divided and Conquered","L. Cruz-Filipe, F. Montesi",-,-,arXiv.org,5,2016,"1. Primitive Name: Choreographic Programming
  Definition: A paradigm for developing concurrent software that is correct by construction, by syntactically disallowing mismatched I/O operations in programs, called choreographies.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Procedural Choreographies (PC)
  Definition: A new language model that includes reusable choreographic procedures, parameterised on the processes they use.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Reusable Choreographic Procedures
  Definition: A feature of PC that allows for parameterized procedures based on the processes they use.
  Orthogonality Score: Not specified
 

 4. Primitive Name: General Recursion
  Definition: A feature of PC that combines general recursion with the ability to create new processes at runtime.
  Orthogonality Score: Not specified
 

 5. Primitive Name: EndPoint Projection (EPP)
  Definition: A tool that synthesizes a correct-by-construction distributed implementation in a process calculus from a well-typed choreography.
  Orthogonality Score: Not specified","- Type of mathematical framework: Not explicitly specified, but implies type theory and process calculus.
 - Specific mathematical properties guaranteed: Correct-by-construction distributed implementation, decidable type checking, type inference.
 - Proof techniques used: Not explicitly mentioned.
 - Limitations or constraints of the framework: Not explicitly mentioned.",No specific integration approach described,"- Definition of ""concept"" used: Not explicitly mentioned
 - Mechanisms for representing generic abstractions: Reusable choreographic procedures parameterised on processes
 - Minimal type requirements identified: Not explicitly mentioned
 - Static checking or optimization strategies: New typing discipline with decidable type checking and type inference","- Introduction of Procedural Choreographies (PC) as a new language model with reusable choreographic procedures and parameterization on processes.
 - Combination of general recursion with runtime process creation, enabling divide-and-conquer concurrent algorithms.
 - Enhanced expressivity for capturing complex communication structures.
 - New typing discipline supporting decidable type checking and type inference to address unrealisability.
 - EndPoint Projection (EPP) for synthesizing correct-by-construction distributed implementations.
 - Support for implicit parallelism and transparent projection in concurrent algorithms.","- ""Choreographic Programming is a paradigm for developing concurrent software that is correct by construction, by syntactically disallowing mismatched I/O operations in programs, called choreographies.""
  - ""In this paper, we present Procedural Choreographies (PC), a new language model that includes the novel feature of reusable choreographic procedures, parameterised on the processes they use.""
  - ""PC is equipped with an EndPoint Projection (EPP) that, from a well-typed choreography, synthesises a correct-byconstruction distributed implementation in a process calculus.""
  - ""This enhanced expressivity makes it possible to write new behaviours that cannot be faithfully implemented (unrealisability); to tackle this issue, we endow PC with a new typing discipline that supports both decidable type checking and type inference.""
  - ""The combination of these features yields a powerful framework where we can write divide-and-conquer concurrent algorithms based on message passing.""
  - ""PC also combines, for the first time in choreographies, general recursion with the ability to create new processes at runtime.""",,"- The abstract discusses ""Choreographic Programming"" as a paradigm, which is a conceptual framework for developing concurrent software. This is a high-level conceptual primitive.
 - ""Procedural Choreographies (PC)"" is introduced as a new language model, which is a specific conceptual primitive within the choreographic programming paradigm.
 - The features of PC include ""reusable choreographic procedures"" and ""general recursion with the ability to create new processes at runtime."" These are specific conceptual primitives that enhance the expressivity of PC.
 - The abstract mentions ""EndPoint Projection (EPP)"" as a tool that synthesizes a distributed implementation from a well-typed choreography, which is another conceptual primitive related to the implementation of choreographies.
 - The abstract does not provide explicit definitions for these primitives in terms of their level of abstraction or orthogonality, but they are clearly identified as key components of the PC model.","- ""Choreographic Programming is a paradigm for developing concurrent software that is correct by construction, by syntactically disallowing mismatched I/O operations in programs, called choreographies.""
  - ""In this paper, we present Procedural Choreographies (PC), a new language model that includes the novel feature of reusable choreographic procedures, parameterised on the processes they use.""
  - ""PC also combines, for the first time in choreographies, general recursion with the ability to create new processes at runtime.""
  - ""This enhanced expressivity makes it possible to write new behaviours that cannot be faithfully implemented (unrealisability); to tackle this issue, we endow PC with a new typing discipline that supports both decidable type checking and type inference.""
  - ""PC is equipped with an EndPoint Projection (EPP) that, from a well-typed choreography, synthesises a correct-byconstruction distributed implementation in a process calculus.""
  - ""our model supports two important properties wrt the programming of concurrent algorithms: implicit parallelism and transparent projection.""",,"- The abstract mentions ""Choreographic Programming"" as a paradigm, which suggests a focus on programming languages and their theoretical foundations.
 - The introduction of ""Procedural Choreographies (PC)"" indicates a new language model, which is likely formalized using some mathematical framework.
 - The mention of ""reusable choreographic procedures"" and ""general recursion"" suggests a structured approach to programming, possibly involving type theory or process calculus.
 - The abstract discusses a ""new typing discipline"" that supports ""decidable type checking and type inference,"" which are key concepts in type theory.
 - The use of ""EndPoint Projection (EPP)"" to synthesize a ""correct-by-construction distributed implementation"" implies a formal verification process, likely involving process calculus.
 - The abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed, but it does imply the use of type theory and process calculus through the discussion of typing disciplines and EPP.","- ""Choreographic Programming is a paradigm for developing concurrent software that is correct by construction, by syntactically disallowing mismatched I/O operations in programs, called choreographies.""
  - ""current choreography language models cannot capture many kinds of communication structures, limiting their applicability.""
  - ""we present Procedural Choreographies (PC), a new language model that includes the novel feature of reusable choreographic procedures, parameterised on the processes they use.""
  - ""PC also combines, for the first time in choreographies, general recursion with the ability to create new processes at runtime.""
  - ""The combination of these features yields a powerful framework where we can write divide-and-conquer concurrent algorithms based on message passing.""
  - ""PC is equipped with an EndPoint Projection (EPP) that, from a well-typed choreography, synthesises a correct-byconstruction distributed implementation in a process calculus.""",,"- The abstract discusses Choreographic Programming as a paradigm for concurrent software development, focusing on its ability to ensure correctness by construction.
 - It introduces Procedural Choreographies (PC) as a new language model that enhances expressivity by allowing reusable procedures and combining recursion with runtime process creation.
 - The abstract mentions the integration of general recursion and runtime process creation, which are features that enhance the paradigm's capabilities.
 - The EndPoint Projection (EPP) is highlighted as a mechanism that synthesizes distributed implementations from well-typed choreographies, indicating a method for translating choreographies into process calculus.
 - However, the abstract does not explicitly discuss the integration of different programming paradigms or specific mechanisms for integrating multiple paradigms. It focuses on enhancing the choreographic paradigm itself rather than integrating it with other paradigms.","- ""Procedural Choreographies (PC), a new language model that includes the novel feature of reusable choreographic procedures, parameterised on the processes they use.""
  - ""The combination of these features yields a powerful framework where we can write divide-and-conquer concurrent algorithms based on message passing.""
  - ""PC is equipped with an EndPoint Projection (EPP) that, from a well-typed choreography, synthesises a correct-byconstruction distributed implementation in a process calculus.""
  - ""This enhanced expressivity makes it possible to write new behaviours that cannot be faithfully implemented (unrealisability); to tackle this issue, we endow PC with a new typing discipline that supports both decidable type checking and type inference.""
  - ""PC also combines, for the first time in choreographies, general recursion with the ability to create new processes at runtime.""",,"- The abstract mentions ""reusable choreographic procedures, parameterised on the processes they use,"" which suggests a mechanism for representing generic abstractions. This implies that the language model allows for procedures to be defined in a way that they can be reused with different processes, which is a form of generic programming.
 - The mention of ""general recursion"" and ""create new processes at runtime"" indicates a level of abstraction and flexibility in the language model, which are important for generic programming.
 - The abstract discusses a ""new typing discipline that supports both decidable type checking and type inference,"" which suggests a focus on type systems and static checking. This is relevant to minimal type requirements and static checking strategies.
 - The abstract does not explicitly define a ""concept"" used in the context of generic programming, nor does it detail specific minimal type requirements or optimization strategies beyond the mention of type checking and inference.","- ""Procedural Choreographies (PC), a new language model that includes the novel feature of reusable choreographic procedures, parameterised on the processes they use.""
  - ""PC also combines, for the first time in choreographies, general recursion with the ability to create new processes at runtime.""
  - ""The combination of these features yields a powerful framework where we can write divide-and-conquer concurrent algorithms based on message passing.""
  - ""This enhanced expressivity makes it possible to write new behaviours that cannot be faithfully implemented (unrealisability); to tackle this issue, we endow PC with a new typing discipline that supports both decidable type checking and type inference.""
  - ""PC is equipped with an EndPoint Projection (EPP) that, from a well-typed choreography, synthesises a correct-byconstruction distributed implementation in a process calculus.""
  - ""Extending a previous line of work on choreographies, our model supports two important properties wrt the programming of concurrent algorithms: implicit parallelism and transparent projection.""",,"- The abstract introduces Procedural Choreographies (PC) as a new language model, which is a significant theoretical contribution. This model includes reusable choreographic procedures and combines general recursion with runtime process creation, which are novel features in the context of choreographies.
 - The combination of these features allows for the development of divide-and-conquer concurrent algorithms, which is a key theoretical advancement. This suggests a new approach to programming concurrent systems.
 - The mention of enhanced expressivity and the ability to write new behaviors indicates a theoretical contribution in terms of programming language design. This is particularly relevant for capturing complex communication structures that were previously difficult to model.
 - The introduction of a new typing discipline that supports decidable type checking and type inference is another theoretical contribution. This addresses the issue of unrealisability and provides a foundation for ensuring correctness in concurrent programming.
 - The EndPoint Projection (EPP) feature, which synthesizes a correct-by-construction distributed implementation, is a theoretical advancement in terms of ensuring correctness and efficiency in distributed systems.
 - The support for implicit parallelism and transparent projection extends previous work on choreographies, indicating a theoretical contribution to the field of concurrent programming."
Introducing a Calculus for Higher-Order Multiset Programming,"D. Cohen, J. M. Filho",10.1007/3-540-61052-9_43,https://doi.org/10.1007/3-540-61052-9_43,International Conference on Coordination Models and Languages,17,1996,Not specified (the abstract does not provide explicit definitions or names for conceptual primitives),"Not specified (the abstract does not provide explicit details about the mathematical framework, its properties, or proof techniques)","- Specific integration mechanisms proposed: Translation of terms from Lambda Calculus, first-order Gamma, and higher-order Gamma into the new calculus.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Translation of terms from different paradigms into the new calculus.",Generic programming not extensively addressed,"- Key novel insights: Introduction of a higher-order calculus for reasoning about programs based on the chemical reaction metaphor.
 - Theoretical advancements beyond existing approaches: One-shot reaction rules considered as first-class citizens, differing from Gamma's n-shot rewrite rules.
 - Potential implications for programming language design: Ability to translate terms from Lambda Calculus and Gamma into this new calculus, suggesting compatibility and flexibility.","- ""In this paper we introduce a higher-order calculus suitable for reasoning about programs written in many of the existing paradigms that adhere to the chemical reaction metaphor.""
  - ""The calculus draws its inspiration from Banâtre and Le Métayer's first-order language Gamma.""
  - ""the so-called reaction rules are one-shot and are regarded as first-class citizens — in opposition to Gamma's n-shot rewrite rules.""
  - ""First a preliminary study of the basic properties of this new calculus is pursued, then we demonstrate that it is possible to translate the Lambda Calculus, first-order Gamma and higher-order Gamma terms into it.""",,"- The abstract introduces a ""higher-order calculus"" inspired by Gamma, which suggests that the conceptual primitives are related to this calculus.
 - The mention of ""reaction rules"" being ""one-shot"" and ""first-class citizens"" implies that these are key primitives in the calculus.
 - The abstract does not provide explicit definitions for these primitives, nor does it mention any specific names or detailed descriptions.
 - The focus on translating other calculi into this new one suggests that the primitives are related to the translation process, but again, no explicit primitives are defined.
 - The abstract does not discuss the level of abstraction or orthogonality of these primitives.","- ""The calculus draws its inspiration from Banâtre and Le Métayer's first-order language Gamma.""
  - ""In this paper we introduce a higher-order calculus suitable for reasoning about programs written in many of the existing paradigms that adhere to the chemical reaction metaphor.""
  - ""First a preliminary study of the basic properties of this new calculus is pursued, then we demonstrate that it is possible to translate the Lambda Calculus, first-order Gamma and higher-order Gamma terms into it.""
  - ""the so-called reaction rules are one-shot and are regarded as first-class citizens — in opposition to Gamma's n-shot rewrite rules.""",,"- The abstract introduces a ""higher-order calculus"" which suggests a type of mathematical framework, but it does not specify the exact type (e.g., type theory, category theory).
 - The inspiration from Banâtre and Le Métayer's first-order language Gamma indicates a connection to existing formal systems, but again, the specific mathematical framework is not detailed.
 - The mention of ""reaction rules"" and their characteristics implies some formal properties, but these are not explicitly described in terms of mathematical properties or proof techniques.
 - The abstract does not provide information on specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus on translating other calculi into this new calculus suggests some level of formal verification, but the abstract does not specify the methodology or any constraints.","- ""then we demonstrate that it is possible to translate the Lambda Calculus, first-order Gamma and higher-order Gamma terms into it.""
  - ""The calculus draws its inspiration from Banâtre and Le Métayer's first-order language Gamma.""
  - ""In this paper we introduce a higher-order calculus suitable for reasoning about programs written in many of the existing paradigms that adhere to the chemical reaction metaphor.""
  - ""the so-called reaction rules are one-shot and are regarded as first-class citizens — in opposition to Gamma's n-shot rewrite rules.""",,"- The abstract mentions the introduction of a ""higher-order calculus"" that is suitable for reasoning about programs in various paradigms that follow the chemical reaction metaphor. This suggests an integration approach by providing a common framework for different paradigms.
 - The calculus is inspired by Gamma, but with a significant difference in how reaction rules are treated, indicating a novel approach to integration.
 - The ability to translate terms from different paradigms (Lambda Calculus, first-order Gamma, and higher-order Gamma) into this new calculus suggests a specific integration mechanism through translation.
 - The abstract does not explicitly mention interaction models or constraints, but the translation capability implies a form of interaction between paradigms.
 - The novel aspect is the translation technique that allows for the integration of different paradigms into this new calculus.","- ""In this paper we introduce a higher-order calculus suitable for reasoning about programs written in many of the existing paradigms that adhere to the chemical reaction metaphor.""
  - ""First a preliminary study of the basic properties of this new calculus is pursued, then we demonstrate that it is possible to translate the Lambda Calculus, first-order Gamma and higher-order Gamma terms into it.""
  - ""the so-called reaction rules are one-shot and are regarded as first-class citizens — in opposition to Gamma's n-shot rewrite rules.""
  - ""The calculus draws its inspiration from Banâtre and Le Métayer's first-order language Gamma.""",,"- The abstract discusses the introduction of a higher-order calculus inspired by Gamma, which suggests a focus on programming paradigms and their representation.
 - The mention of ""reaction rules"" being ""one-shot"" and ""first-class citizens"" implies a mechanism for abstraction, as these rules are treated as fundamental entities in the calculus.
 - The ability to translate terms from other calculi (Lambda Calculus, first-order Gamma, higher-order Gamma) into this new calculus suggests a level of genericity and abstraction, as it can accommodate different programming paradigms.
 - However, the abstract does not explicitly mention generic programming methodology, type system discussions, or specific abstraction mechanisms beyond the inspiration from Gamma and the translation capabilities.
 - There is no mention of minimal type requirements or static checking/optimization strategies in the abstract.","- ""In this paper we introduce a higher-order calculus suitable for reasoning about programs written in many of the existing paradigms that adhere to the chemical reaction metaphor.""
  - ""First a preliminary study of the basic properties of this new calculus is pursued, then we demonstrate that it is possible to translate the Lambda Calculus, first-order Gamma and higher-order Gamma terms into it.""
  - ""However, the idea behind our calculus varies in that the so-called reaction rules are one-shot and are regarded as first-class citizens — in opposition to Gamma's n-shot rewrite rules.""
  - ""The calculus draws its inspiration from Banâtre and Le Métayer's first-order language Gamma.""",,"- The abstract introduces a ""higher-order calculus"" as a novel contribution, which is designed for reasoning about programs based on the chemical reaction metaphor. This suggests a new theoretical framework.
 - The calculus is inspired by Gamma but differs significantly by having ""one-shot"" reaction rules, which are considered ""first-class citizens."" This indicates a theoretical advancement beyond existing approaches like Gamma.
 - The ability to translate terms from other calculi (Lambda Calculus, first-order Gamma, and higher-order Gamma) into this new calculus implies potential implications for programming language design, as it suggests compatibility and flexibility.
 - The focus on basic properties and translation capabilities indicates a theoretical contribution rather than an implementation detail."
Controlled evolution of adaptive programs,"A. Abdelmeged, Therapon Skotiniotis, K. Lieberherr",10.1145/1595808.1595826,https://doi.org/10.1145/1595808.1595826,IWPSE-Evol '09,3,2009,"1. Primitive Name: Traversal Strategy
  Definition: A regular-expression-like specification that selects a set of paths from the schema of the input object.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Input Object
  Definition: The object against which the adaptive program is executed.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Behavior
  Definition: A set of collaborating type-indexed methods.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Criterion 1 - Positive Core of Strategy
  Definition: The positive core of the strategy must be identical to the smoothed input schema.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Criterion 2 - Bypassed Nodes
  Definition: Every bypassed node on an edge from S to T in the strategy must appear on at least one path connecting S to T in the input schema.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Criterion 3 - Advised Nodes
  Definition: All Advised nodes must be mentioned in the strategy.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Criterion 4 - Strategy Graph Nodes
  Definition: Every strategy graph node is either advised can reach an advised node.
  Orthogonality Score: Not discussed",Not specified,No specific integration approach described,"- Definition of ""concept"" used: The concept refers to the minimal necessary structural assumptions about the input.
 - Mechanisms for representing generic abstractions: Decoupling methods from input structure using behavioral interfaces; traversal strategy and behavior.
 - Minimal type requirements identified: Hardcoding minimal structural assumptions.
 - Static checking or optimization strategies: Stricter notion of compatibility to eliminate conceptual mismatches.","- Key novel insights: Introduction of a language for expressing application-specific constraints and a stricter notion of compatibility to control unsafe evolution.
 - Theoretical advancements: Stricter compatibility notion eliminates conceptual mismatches between strategy, input schema, and behavior.
 - Potential implications: Enhancements in programming language design for ensuring correctness and maintainability of adaptive programs.","- ""The approach taken by AP for writing generic methods (called adaptive methods or adaptive programs) is to hard code the minimal necessary structural assumptions about the input.""
  - ""An adaptive method comprises three loosely coupled parts: a traversal strategy, an input object, and a behavior.""
  - ""The traversal strategy is a regular-expression-like specification that selects a set of paths from the schema of the input object.""
  - ""The behavior is a set of collaborating type indexed methods""
  - ""A strategy and an input schema are incompatible iff the set of paths selected by the strategy from the input schema is empty.""
  - ""The proposed notion has four criteria: two of them are intended to eliminate conceptual mismatches between the strategy and the input schema. The other two are intended to eliminate conceptual mismatches between the strategy and the behavior.""
  - ""Criterion 1: The positive core of the strategy must be identical to the smoothed input schema.""
  - ""Criterion 2: Every bypassed node on an edge from S to T in the strategy must appear on at least one path connecting S to T in the input schema.""
  - ""Criterion 3: All Advised nodes must be mentioned in the strategy.""
  - ""Criterion 4: Every strategy graph node is either advised can reach an advised node.""",,"- The paper discusses the Adaptive Programming (AP) paradigm, which involves writing generic methods by hardcoding minimal structural assumptions about the input.
 - The AP paradigm is structured around three main components: traversal strategy, input object, and behavior. These can be considered as conceptual primitives as they are fundamental to the paradigm.
 - The traversal strategy is a key primitive, as it specifies paths from the input schema, and its compatibility with the input schema is crucial.
 - The behavior, comprising collaborating type-indexed methods, is another primitive, as it defines how the program executes.
 - The paper also introduces a stricter notion of compatibility with four criteria, which can be seen as additional primitives for ensuring safe evolution of adaptive programs.
 - These criteria aim to eliminate conceptual mismatches between the strategy and input schema, and between the strategy and behavior, indicating they are fundamental to the paradigm's structure.","- ""The key observation behind the development of the Adaptive Programming paradigm (AP) [14] is that methods tend to hard code assumptions about the structure of their input that are not inherently relevant to their ""function"".""
  - ""The approach taken by AP for writing generic methods (called adaptive methods or adaptive programs) is to hard code the minimal necessary structural assumptions about the input.""
  - ""An adaptive method is considered legal if its strategy is compatible with the input schema.""
  - ""A strategy and an input schema are incompatible iff the set of paths selected by the strategy from the input schema is empty.""
  - ""The proposed notion has four criteria: two of them are intended to eliminate conceptual mismatches between the strategy and the input schema. The other two are intended to eliminate conceptual mismatches between the strategy and the behavior.""
  - ""The problem we addressed in this paper is similar in essence to the Fragile Pointcut Problem [17] in the Aspect Oriented Programming community.""
  - ""There are a number of generic programming technologies [12,10,7,6]. To the best of our knowledge, the most relevant work was done in the Strategic Programming (SP) and AP communities.""",,"- The paper discusses the Adaptive Programming paradigm and its focus on minimizing structural assumptions in methods, which suggests a theoretical foundation in programming paradigms rather than a specific mathematical framework like type theory or category theory.
 - The paper mentions compatibility criteria and the elimination of conceptual mismatches, which are more related to programming principles than to a formal mathematical framework.
 - There is no explicit mention of a mathematical framework such as type theory or category theory, nor are there discussions of formal verification or proof techniques.
 - The paper references related work in Strategic Programming and Aspect-Oriented Programming, but does not specify a mathematical framework for these paradigms.
 - The focus of the paper is on programming paradigms and their evolution rather than on a specific mathematical framework.","- ""The problem that we tackle in this paper is the unsafe evolution of adaptive programs.""
  - ""This paper aims at controlling the unsafe evolutions of adaptive programs.""
  - ""The problem we addressed in this paper is similar in essence to the Fragile Pointcut Problem [17] in the Aspect Oriented Programming community.""
  - ""There are a number of generic programming technologies [12,10,7,6]. To the best of our knowledge, the most relevant work was done in the Strategic Programming (SP) and AP communities.""
  - ""In the AP community, Demeter Interfaces [16] focuses on establishing compatibility between the input schema and the constraints imposed by the traversal strategy.""
  - ""The DemeterF [1] type system [4] focuses on establishing compatibility between the traversal strategy and the set of collaborating methods comprising the behavior.""",,"- The paper primarily focuses on controlling the unsafe evolution of adaptive programs, which is a specific issue within the Adaptive Programming (AP) paradigm rather than an integration approach between different paradigms.
 - The mention of the Fragile Pointcut Problem in Aspect-Oriented Programming (AOP) suggests a comparison or similarity in challenges, but it does not describe an integration approach between AP and AOP.
 - The paper discusses compatibility within the AP paradigm, particularly between input schemas and traversal strategies, but does not explicitly address integration with other programming paradigms.
 - The references to Strategic Programming (SP) and Demeter Interfaces/Type System indicate related work within the AP community, but again, these are not described as integration mechanisms with other paradigms.
 - There is no explicit discussion of specific integration mechanisms, interaction models, constraints, or novel translation/embedding techniques for integrating different programming paradigms.","- ""The key observation behind the development of the Adaptive Programming paradigm (AP) [14] is that methods tend to hard code assumptions about the structure of their input that are not inherently relevant to their ""function"".""
  - ""One approach for restoring genericity, is to decouple the method from the structure via the use of a behavioral interface to the structure""
  - ""The approach taken by AP for writing generic methods (called adaptive methods or adaptive programs) is to hard code the minimal necessary structural assumptions about the input.""
  - ""An adaptive method comprises three loosely coupled parts: a traversal strategy, an input object, and a behavior.""
  - ""The traversal strategy is a regular-expression-like specification that selects a set of paths from the schema of the input object.""
  - ""The behavior is a set of collaborating type indexed methods""
  - ""A strategy that selects the correct set of paths is called a correct strategy.""
  - ""The smoothed traversal graph is a multi-graph that contains only the advised nodes from the traversal graph.""
  - ""In this section we present a stricter notion of compatibility between the parts of an adaptive program.""
  - ""The proposed notion has four criteria: two of them are intended to eliminate conceptual mismatches between the strategy and the input schema. The other two are intended to eliminate conceptual mismatches between the strategy and the behavior.""
  - ""the new notion of compatibility tightens the coupling between the three parts of an adaptive program.""
  - ""The tighter coupling does not sacrifice the genericity of adaptive programs because the excluded adaptive programs contain some form of a conceptual mismatch.""",,"- The paper discusses the Adaptive Programming (AP) paradigm, which aims to restore genericity by decoupling methods from input structure using behavioral interfaces.
 - AP involves writing generic methods by hardcoding minimal structural assumptions about the input, which is a mechanism for representing generic abstractions.
 - The traversal strategy and behavior are key components of AP, with the strategy selecting paths from the input schema and the behavior comprising collaborating type-indexed methods.
 - The paper introduces a stricter notion of compatibility to eliminate conceptual mismatches, which tightens the coupling between AP components without sacrificing genericity.
 - The focus is on ensuring that the strategy and behavior are compatible, which is a form of static checking to prevent unsafe evolutions.","- ""In this paper we study the evolution of adaptive programs and present two complementary approaches for controlling their unsafe evolution: a language for expressing application-specific constraints on the runtime behavior of adaptive programs, and a stricter notion of compatibility between the parts of an adaptive program, that does not sacrifice the expressiveness of the AP paradigm.""
  - ""The problem that we tackle in this paper is the unsafe evolution of adaptive programs.""
  - ""This paper aims at controlling the unsafe evolutions of adaptive programs. To that end, we propose solutions for the two aforementioned problems.""
  - ""As for the first problem, developers should be able to declare a correctness criteria for their specific application.""
  - ""As for the second problem, we propose a stricter notion of compatibility that encompasses all three parts of an adaptive program and excludes those adaptive programs containing some form of a ""conceptual mismatch"", regardless of their correctness.""
  - ""The proposed notion has four criteria: two of them are intended to eliminate conceptual mismatches between the strategy and the input schema. The other two are intended to eliminate conceptual mismatches between the strategy and the behavior.""
  - ""Adopting the new notion of compatibility tightens the coupling between the three parts of an adaptive program.""
  - ""In this paper we presented a study of adaptive program evolution and two complementary approaches for controlling unsafe evolution of adaptive programs.""
  - ""We plan to introduce adaptive programming as a technology for event based processing of XML""",,"- The paper introduces two novel approaches to control unsafe evolution in adaptive programs: a language for expressing application-specific constraints and a stricter notion of compatibility.
 - The language for expressing constraints allows developers to declare correctness criteria, which is a new insight into managing the evolution of adaptive programs.
 - The stricter notion of compatibility is designed to eliminate conceptual mismatches between the strategy, input schema, and behavior, which is a theoretical advancement beyond existing approaches.
 - The paper's focus on controlling unsafe evolution and introducing a stricter compatibility notion has potential implications for programming language design, particularly in ensuring the correctness and maintainability of adaptive programs.
 - The study's findings and proposed solutions are theoretically significant as they address a critical issue in adaptive programming, which is the susceptibility to unsafe evolutions."
Abstract Behavior Types: a foundation model for components and their composition,F. Arbab,10.1016/j.scico.2004.05.010,https://doi.org/10.1016/j.scico.2004.05.010,Science of Computer Programming,206,2002,"1. Primitive Name: Abstract Behavior Type (ABT)
  Definition: An abstract behavior as a relation among a set of timed-data-streams, without specifying any detail about the operations that may be used to implement such behavior or the data types it may manipulate for its realization.
  Orthogonality Score: High (implied by looser coupling and exogenous coordination)",Not specified (the abstract does not provide explicit details on the mathematical framework used to formalize and guarantee properties of the conceptual primitives),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of Abstract Behavior Type (ABT) as a higher-level alternative to Abstract Data Type (ADT) for component-based systems.
 - Theoretical advancements: ABT provides looser coupling and is inherently amenable to exogenous coordination, addressing limitations of ADT in component-based systems.
 - Potential implications for programming language design: Offers a new paradigm for component-based systems and exogenous coordination, potentially influencing future programming language design.","- ""We introduce the notion of Abstract Behavior Type (ABT) as a higher-level alternative to ADT and propose it as a proper foundation model for both components and their composition.""
  - ""An ABT defines an abstract behavior as a relation among a set of timed-data-streams, without specifying any detail about the operations that may be used to implement such behavior or the data types it may manipulate for its realization.""
  - ""The notion of Abstract Data Type (ADT) has served as a foundation model for structured and object oriented programming for some thirty years.""
  - ""The ABT model supports a much looser coupling than is possible with the ADT’s operational interface, and is inherently amenable to exogenous coordination.""
  - ""To demonstrate the utility of the ABT model, we describe Reo: an exogenous coordination language for compositional construction of component connectors based on a calculus of channels.""",,"- The abstract introduces the concept of Abstract Behavior Type (ABT) as a foundational model for components and their composition, which is a conceptual primitive.
 - The definition of ABT is provided as ""an abstract behavior as a relation among a set of timed-data-streams,"" which is a specific conceptual primitive.
 - The abstract does not mention any other conceptual primitives beyond ABT.
 - The level of abstraction is high since ABT is described as a ""higher-level alternative"" to ADT, indicating a more abstract level of modeling.
 - Orthogonality is implied by the mention of ""looser coupling"" and ""exogenous coordination,"" suggesting that ABT allows for more flexible and independent component interactions.","- ""An ABT defines an abstract behavior as a relation among a set of timed-data-streams, without specifying any detail about the operations that may be used to implement such behavior or the data types it may manipulate for its realization.""
  - ""We introduce the notion of Abstract Behavior Type (ABT) as a higher-level alternative to ADT and propose it as a proper foundation model for both components and their composition.""
  - ""To demonstrate the utility of the ABT model, we describe Reo: an exogenous coordination language for compositional construction of component connectors based on a calculus of channels.""
  - ""The notion of Abstract Data Type (ADT) has served as a foundation model for structured and object oriented programming for some thirty years.""
  - ""The ABT model supports a much looser coupling than is possible with the ADT’s operational interface, and is inherently amenable to exogenous coordination.""",,"- The abstract discusses the introduction of Abstract Behavior Type (ABT) as a foundation model for components and their composition, which suggests a conceptual framework rather than a specific mathematical framework.
 - The description of ABT as defining ""an abstract behavior as a relation among a set of timed-data-streams"" implies a focus on behavioral aspects rather than a specific mathematical framework.
 - The mention of ""a calculus of channels"" in relation to Reo suggests some mathematical underpinnings, but it does not specify the type of mathematical framework or any specific mathematical properties guaranteed.
 - There is no explicit mention of a theoretical foundations section, proof methodology, or formal verification discussions in the abstract, which are typically where mathematical framework details would be found.
 - The abstract does not provide details on the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework.","- ""The notion of Abstract Data Type (ADT) has served as a foundation model for structured and object oriented programming for some thirty years.""
  - ""The current trend in software engineering toward component based systems requires a foundation model as well.""
  - ""The most basic inherent property of an ADT, i.e., that it provides a set of operations, subverts some highly desirable properties in emerging formal models for components that are based on the object oriented paradigm.""
  - ""We introduce the notion of Abstract Behavior Type (ABT) as a higher-level alternative to ADT and propose it as a proper foundation model for both components and their composition.""
  - ""An ABT defines an abstract behavior as a relation among a set of timed-data-streams, without specifying any detail about the operations that may be used to implement such behavior or the data types it may manipulate for its realization.""
  - ""The ABT model supports a much looser coupling than is possible with the ADT’s operational interface, and is inherently amenable to exogenous coordination.""
  - ""To demonstrate the utility of the ABT model, we describe Reo: an exogenous coordination language for compositional construction of component connectors based on a calculus of channels.""",,"- The abstract discusses the transition from Abstract Data Types (ADTs) to Abstract Behavior Types (ABTs) as a foundation model for component-based systems, which implies a shift in programming paradigms.
 - The ABT is proposed as a higher-level alternative to ADT, suggesting a new approach to integrating different programming paradigms, particularly moving away from the operational interface of ADTs.
 - The ABT model is described as supporting looser coupling and being amenable to exogenous coordination, which are desirable properties for component integration.
 - The mention of Reo, an exogenous coordination language, suggests a specific integration mechanism for component connectors based on a calculus of channels.
 - However, the abstract does not explicitly discuss specific integration mechanisms, interaction models, constraints, or novel translation techniques between different programming paradigms.","- ""The notion of Abstract Data Type (ADT) has served as a foundation model for structured and object oriented programming for some thirty years.""
  - ""The ABT model supports a much looser coupling than is possible with the ADT’s operational interface, and is inherently amenable to exogenous coordination.""
  - ""An ABT defines an abstract behavior as a relation among a set of timed-data-streams, without specifying any detail about the operations that may be used to implement such behavior or the data types it may manipulate for its realization.""
  - ""We introduce the notion of Abstract Behavior Type (ABT) as a higher-level alternative to ADT and propose it as a proper foundation model for both components and their composition.""
  - ""The most basic inherent property of an ADT, i.e., that it provides a set of operations, subverts some highly desirable properties in emerging formal models for components that are based on the object oriented paradigm.""",,"- The abstract discusses the transition from Abstract Data Types (ADTs) to Abstract Behavior Types (ABTs) as a foundation model for components and their composition. This indicates a shift in abstraction mechanisms from focusing on operations to focusing on behavior.
 - The definition of ""concept"" used here is the Abstract Behavior Type (ABT), which is described as defining an abstract behavior as a relation among timed-data-streams. This is a conceptual abstraction mechanism that focuses on behavior rather than operations.
 - The mechanism for representing generic abstractions is the ABT model itself, which provides a higher-level alternative to ADTs by not specifying operations or data types, thus allowing for more generic and abstract representations.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, suggesting that these aspects are not extensively addressed in the study.
 - The focus on ABTs and their ability to support looser coupling and exogenous coordination implies a focus on abstraction mechanisms rather than generic programming methodologies or type systems.","- ""The notion of Abstract Data Type (ADT) has served as a foundation model for structured and object oriented programming for some thirty years.""
  - ""The current trend in software engineering toward component based systems requires a foundation model as well.""
  - ""The most basic inherent property of an ADT, i.e., that it provides a set of operations, subverts some highly desirable properties in emerging formal models for components that are based on the object oriented paradigm.""
  - ""We introduce the notion of Abstract Behavior Type (ABT) as a higher-level alternative to ADT and propose it as a proper foundation model for both components and their composition.""
  - ""An ABT defines an abstract behavior as a relation among a set of timed-data-streams, without specifying any detail about the operations that may be used to implement such behavior or the data types it may manipulate for its realization.""
  - ""The ABT model supports a much looser coupling than is possible with the ADT’s operational interface, and is inherently amenable to exogenous coordination.""
  - ""We propose that both of these are highly desirable, if not essential, properties for models of components and their composition.""
  - ""To demonstrate the utility of the ABT model, we describe Reo: an exogenous coordination language for compositional construction of component connectors based on a calculus of channels.""",,"- The abstract introduces the concept of Abstract Behavior Type (ABT) as a novel theoretical contribution, positioning it as a higher-level alternative to the traditional Abstract Data Type (ADT).
 - The ABT is designed to address the limitations of ADT in component-based systems, particularly in terms of operational interfaces and exogenous coordination.
 - The ABT model is characterized by its focus on abstract behavior as a relation among timed-data-streams, which allows for looser coupling and better support for exogenous coordination.
 - The introduction of ABT is theoretically significant because it provides a foundation model for components and their composition that is more suitable for current software engineering trends.
 - The mention of Reo, an exogenous coordination language, demonstrates the practical application and utility of the ABT model, although the focus is on theoretical contributions rather than implementation details.
 - The abstract suggests that the ABT model has potential implications for programming language design by offering a new paradigm that is more aligned with component-based systems and exogenous coordination."
Unifying sets and programs via dependent types,Wojciech Moczydlowski,10.1016/j.apal.2011.09.016,https://doi.org/10.1016/j.apal.2011.09.016,Annals of Pure and Applied Logic,0,2009,Not specified (the abstract does not provide explicit definitions or details about the conceptual primitives),"- Type of mathematical framework: Dependent type theory
 - Specific mathematical properties guaranteed: Numerical Existence Property, Program Extraction
 - Proof techniques used: Correctness by construction, post-construction verification
 - Limitations or constraints: Not specified","- Specific integration mechanisms proposed: Unification via dependent types
 - Interaction models between paradigms: Supports correctness by construction and post-construction verification
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Key novel insights: Unification of a lazy programming language with an impredicative constructive set theory (IZFR) using dependent types.
 - Theoretical advancements: Integration of programming and set theory, support for correctness by construction and post-construction verification, new expressive power for meta-theoretic properties.
 - Potential implications for programming language design: Enrichment of set theory, stronger than IZFR, improved real number behavior.","- ""D provides new expressive power, which makes it possible to internalize and prove inside D the standard meta-theoretic properties of constructive systems, such as Numerical Existence Property and Program Extraction.""
  - ""D supports two paramount paradigms of creating reliable software: correctness by construction and post-construction verification, while retaining the expressiveness of set theory.""
  - ""computation arising from the programming language significantly enriches set theory, as we show that D is stronger than IZFR and that its real numbers behave in a better way.""
  - ""We present a foundational framework, which we call D, unifying a lazy programming language with an impredicative constructive set theory IZFR by means of dependent types.""",,"- The abstract discusses a foundational framework called ""D"" that unifies a programming language with set theory using dependent types. This suggests that dependent types are a key conceptual primitive in the framework.
 - The framework supports two paradigms: correctness by construction and post-construction verification. These are likely conceptual primitives related to software reliability.
 - The abstract mentions that ""D"" provides new expressive power for internalizing and proving meta-theoretic properties like Numerical Existence Property and Program Extraction. These could be considered conceptual primitives related to the expressiveness of the framework.
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality or level of abstraction.","- ""We present a foundational framework, which we call D, unifying a lazy programming language with an impredicative constructive set theory IZFR by means of dependent types.""
  - ""D supports two paramount paradigms of creating reliable software: correctness by construction and post-construction verification, while retaining the expressiveness of set theory.""
  - ""computation arising from the programming language significantly enriches set theory, as we show that D is stronger than IZFR and that its real numbers behave in a better way.""
  - ""D provides new expressive power, which makes it possible to internalize and prove inside D the standard meta-theoretic properties of constructive systems, such as Numerical Existence Property and Program Extraction.""",,"- The abstract mentions a ""foundational framework"" called D, which unifies a programming language with an impredicative constructive set theory (IZFR) using dependent types. This indicates that the mathematical framework is based on type theory, specifically dependent types.
 - The framework supports ""correctness by construction and post-construction verification,"" suggesting that it uses proof techniques related to these paradigms, which are common in type theory.
 - The framework provides ""new expressive power"" to internalize and prove meta-theoretic properties like Numerical Existence Property and Program Extraction, indicating specific mathematical properties guaranteed by the framework.
 - The abstract does not explicitly mention limitations or constraints of the framework, but it does highlight that D is stronger than IZFR, suggesting an improvement over previous frameworks.","- ""We present a foundational framework, which we call D, unifying a lazy programming language with an impredicative constructive set theory IZFR by means of dependent types.""
  - ""computation arising from the programming language significantly enriches set theory, as we show that D is stronger than IZFR and that its real numbers behave in a better way.""
  - ""D provides new expressive power, which makes it possible to internalize and prove inside D the standard meta-theoretic properties of constructive systems, such as Numerical Existence Property and Program Extraction.""
  - ""D supports two paramount paradigms of creating reliable software: correctness by construction and post-construction verification, while retaining the expressiveness of set theory.""",,"- The abstract discusses the integration of a lazy programming language with an impredicative constructive set theory (IZFR) using dependent types. This suggests a theoretical integration strategy where dependent types serve as the mechanism for unifying these two paradigms.
 - The mention of ""correctness by construction and post-construction verification"" indicates that the framework supports both paradigms of creating reliable software, suggesting an interaction model where these paradigms are integrated to enhance reliability.
 - The abstract does not explicitly mention specific constraints or challenges in paradigm integration, nor does it detail novel translation or embedding techniques beyond the use of dependent types.
 - The integration approach is described as unifying these paradigms, which implies a theoretical strategy rather than a detailed interaction model or specific constraints.","- ""We present a foundational framework, which we call D, unifying a lazy programming language with an impredicative constructive set theory IZFR by means of dependent types.""
  - ""computation arising from the programming language significantly enriches set theory, as we show that D is stronger than IZFR and that its real numbers behave in a better way.""
  - ""D provides new expressive power, which makes it possible to internalize and prove inside D the standard meta-theoretic properties of constructive systems, such as Numerical Existence Property and Program Extraction.""
  - ""D supports two paramount paradigms of creating reliable software: correctness by construction and post-construction verification, while retaining the expressiveness of set theory.""",,"- The abstract discusses the unification of a programming language with set theory using dependent types, which suggests a focus on type systems and abstraction mechanisms.
 - The mention of ""dependent types"" implies a mechanism for representing generic abstractions, as dependent types are a way to express genericity and abstraction in programming languages.
 - The abstract does not explicitly define a ""concept"" or provide specific mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus is more on the unification and its benefits rather than detailed generic programming methodology or type system discussions.
 - The abstract does not extensively address generic programming or provide specific details on abstraction mechanisms, type requirements, or static checking strategies.","- ""We present a foundational framework, which we call D, unifying a lazy programming language with an impredicative constructive set theory IZFR by means of dependent types.""
  - ""computation arising from the programming language significantly enriches set theory, as we show that D is stronger than IZFR and that its real numbers behave in a better way.""
  - ""D supports two paramount paradigms of creating reliable software: correctness by construction and post-construction verification, while retaining the expressiveness of set theory.""
  - ""D provides new expressive power, which makes it possible to internalize and prove inside D the standard meta-theoretic properties of constructive systems, such as Numerical Existence Property and Program Extraction.""
  - ""We show that unification brings many benefits to both worlds.""",,"- The abstract introduces a novel framework ""D"" that unifies a lazy programming language with an impredicative constructive set theory (IZFR) using dependent types. This is a key novel insight as it integrates two previously separate areas.
 - The unification brings benefits to both programming and set theory, indicating a theoretical advancement beyond existing approaches by combining these fields.
 - The framework supports both correctness by construction and post-construction verification, which are significant paradigms in software reliability. This is a theoretical contribution as it enhances the reliability of software development.
 - The framework provides new expressive power, allowing for the internalization and proof of meta-theoretic properties like Numerical Existence Property and Program Extraction. This is a theoretical advancement as it enables deeper analysis within the framework.
 - The integration enriches set theory by making it stronger than IZFR and improving the behavior of real numbers. This is a potential implication for programming language design, as it suggests a more robust foundation for mathematical computations."
Design of Core Calculus for Implicit Programming,"Wonchan Lee, K. Yi",-,-,-,0,2012,"1. Primitive Name: Core Calculus for Implicit Programming
  Definition: A calculus that supports all useful features of implicit programming without current limitations.
  Orthogonality Score: Not discussed
 2. Primitive Name: Higher-Order Rules
  Definition: Rules that support higher-order functionality within the calculus.
  Orthogonality Score: Not discussed
 3. Primitive Name: Overlapping Rules
  Definition: Rules that allow for overlapping within the calculus.
  Orthogonality Score: Not discussed
 4. Primitive Name: Syntax
  Definition: The syntax of the core calculus.
  Orthogonality Score: Not discussed
 5. Primitive Name: Operational Semantics
  Definition: The operational semantics of the core calculus.
  Orthogonality Score: Not discussed
 6. Primitive Name: Polymorphic Type System
  Definition: A type system that supports polymorphism within the calculus.
  Orthogonality Score: Not discussed
 7. Primitive Name: Type Soundness
  Definition: The property of type soundness within the calculus.
  Orthogonality Score: Not discussed
 8. Primitive Name: Type-Directed Translation into System F
  Definition: A compilation technique using type-directed translation into System F.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,"- Definition of ""concept"" used: Not explicitly mentioned
 - Mechanisms for representing generic abstractions: Implicit programming paradigm, polymorphic type system
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: Proposal of a core calculus for implicit programming that supports all useful features without current limitations.
 - Theoretical advancements: Supports higher-order and overlapping rules, addressing limitations in current implicit programming paradigms.
 - Potential implications: Provides a comprehensive theoretical framework with syntax, operational semantics, polymorphic type system, and type soundness, and offers an efficient compilation technique through type-directed translation into System F.","- ""We propose a core calculus for implicit programming.""
  - ""The calculus supports all useful features of implicit programming, but it does not suffer from the limitations of the current practice.""
  - ""Furthermore, our calculus supports higher-order and overlapping rules.""
  - ""We also provide a type-directed translation into System F as an efficient compilation technique.""
  - ""We present the syntax, operational semantics, polymorphic type system, and type soundness.""",,"- The abstract mentions the proposal of a ""core calculus for implicit programming,"" which suggests that this calculus is a conceptual primitive for reconstructing programming paradigms.
 - The calculus is described as supporting ""all useful features of implicit programming,"" indicating that it is designed to encompass a broad range of functionalities.
 - The mention of ""higher-order and overlapping rules"" suggests that these are specific features or primitives within the calculus.
 - The abstract also discusses the presentation of ""syntax, operational semantics, polymorphic type system, and type soundness,"" which are likely components or primitives of the calculus.
 - The ""type-directed translation into System F"" is an additional primitive or technique used for compilation.","- ""We present the syntax, operational semantics, polymorphic type system, and type soundness.""
  - ""We also provide a type-directed translation into System F as an efficient compilation technique.""
  - ""The calculus supports all useful features of implicit programming, but it does not suffer from the limitations of the current practice.""
  - ""Furthermore, our calculus supports higher-order and overlapping rules.""
  - ""We propose a core calculus for implicit programming.""",,"- The abstract mentions the proposal of a ""core calculus for implicit programming,"" which suggests a mathematical framework based on calculus.
 - The mention of ""polymorphic type system"" and ""type soundness"" indicates that the framework is related to type theory.
 - The ""type-directed translation into System F"" further supports that the framework is based on type theory, as System F is a well-known type system in programming language theory.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, nor does it discuss limitations or constraints of the framework.
 - The focus on ""syntax, operational semantics, polymorphic type system, and type soundness"" suggests a theoretical foundation in type theory, but specific details about mathematical properties or proof techniques are not provided.","- ""Many programming languages support implicit programming paradigm.""
  - ""Haskell type classes and C++ templates are the most prominent examples in that regards.""
  - ""We propose a core calculus for implicit programming.""
  - ""The calculus supports all useful features of implicit programming, but it does not suffer from the limitations of the current practice.""
  - ""Furthermore, our calculus supports higher-order and overlapping rules.""
  - ""We present the syntax, operational semantics, polymorphic type system, and type soundness.""
  - ""We also provide a type-directed translation into System F as an efficient compilation technique.""",,"- The abstract discusses the support of implicit programming paradigms in languages like Haskell and C++, indicating a focus on implicit programming rather than integration of different paradigms.
 - The proposal of a core calculus for implicit programming suggests an improvement or enhancement within the implicit programming paradigm rather than integration with other paradigms.
 - The mention of higher-order and overlapping rules, as well as the presentation of syntax, operational semantics, and type soundness, further supports the focus on implicit programming.
 - The type-directed translation into System F is a compilation technique, which does not explicitly address integration of different programming paradigms.
 - There is no explicit mention of interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques for integrating different paradigms.","- ""Many programming languages support implicit programming paradigm.""
  - ""Haskell type classes and C++ templates are the most prominent examples in that regards.""
  - ""We propose a core calculus for implicit programming.""
  - ""The calculus supports all useful features of implicit programming, but it does not suffer from the limitations of the current practice.""
  - ""Furthermore, our calculus supports higher-order and overlapping rules.""
  - ""We present the syntax, operational semantics, polymorphic type system, and type soundness.""
  - ""We also provide a type-directed translation into System F as an efficient compilation technique.""",,"- The abstract discusses implicit programming, which is related to generic programming and abstraction mechanisms.
 - It mentions Haskell type classes and C++ templates, which are examples of generic programming mechanisms.
 - The proposed core calculus is designed to support all useful features of implicit programming, suggesting an approach to generic programming.
 - The mention of a ""polymorphic type system"" indicates a focus on genericity and abstraction.
 - The abstract does not explicitly define a ""concept"" or provide detailed mechanisms for representing generic abstractions, but it implies these through the discussion of the calculus and type system.
 - There is no explicit mention of minimal type requirements or static checking strategies in the abstract.","- ""We also provide a type-directed translation into System F as an efficient compilation technique.""
  - ""We present the syntax, operational semantics, polymorphic type system, and type soundness.""
  - ""Furthermore, our calculus supports higher-order and overlapping rules.""
  - ""The calculus supports all useful features of implicit programming, but it does not suffer from the limitations of the current practice.""
  - ""We propose a core calculus for implicit programming.""",,"- The abstract mentions the proposal of a ""core calculus for implicit programming,"" which suggests a novel theoretical contribution by providing a foundational framework for implicit programming.
 - The statement that the calculus ""supports all useful features of implicit programming"" without the limitations of current practices implies a theoretical advancement beyond existing approaches.
 - The support for ""higher-order and overlapping rules"" is highlighted as a feature, indicating a theoretical innovation that addresses limitations in current implicit programming paradigms.
 - The presentation of ""syntax, operational semantics, polymorphic type system, and type soundness"" indicates a comprehensive theoretical framework, which is a significant theoretical contribution.
 - The provision of a ""type-directed translation into System F"" suggests an efficient compilation technique, which has implications for programming language design by potentially improving the compilation process."
First-order Lax Logicas a framework for Constraint Logic,"M. Fairtlough, M. Mendler, M. Walton",-,-,-,0,1997,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: First-order Lax Logic, Gentzen-type system, Curry-Howard isomorphism (type theory), classical first-order bimodal theory (modal logic)
 - Specific mathematical properties guaranteed: Soundness and completeness theorem
 - Proof techniques used: Syntactic translation into classical first-order bimodal theory
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Syntactic translation into a classical first-order bimodal theory; factoring CLP programs into abstract LLP programs and constraint tables.
 - Interaction models between paradigms: Integration of Lax Logic with Constraint Logic Programming (CLP) through the Lax Logic Programming (LLP) fragment.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Use of the Curry-Howard isomorphism to connect natural deduction proofs with computational lambda calculus terms.",Generic programming not extensively addressed,"- Extension of Propositional Lax Logic to a first-order language (QLL) with soundness and completeness theorem.
 - Use of Lax Logic Programming (LLP) to reveal abstractions behind Constraint Logic Programming (CLP).
 - Extension of the Curry-Howard isomorphism to a first-order context.
 - Factoring CLP programs into abstract LLP programs and constraint tables.
 - Generalization of the standard notion of constraint by choosing different constraint algebras.
 - Potential implications for programming language design: application to program abstraction and refinement.","- ""Instantiating the monadic operator of QLL by a generic notion of constraint computation, we factor a concrete CLP program into two parts: an abstract LLP program and an associated constraint table.""
  - ""Choosing diierent constraint algebras allows us to generalize the standard notion of constraint (as in CLP) and to apply the LLP paradigm to the complementary problems of program abstraction and program reenement.""
  - ""Our main tool is an in-tensional rst-order extension of the Curry-Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus.""
  - ""We rst extend existing work FM95, FM97] on Propositional Lax Logic to a rst-order language (QLL), presenting a soundness and completeness theorem for a Gentzen-type system via a syntactic translation into a classical rst-order bimodal theory.""",,"- The abstract discusses the extension of Propositional Lax Logic to a first-order language (QLL), which suggests a conceptual framework rather than specific primitives.
 - The mention of a ""Gentzen-type system"" and ""syntactic translation into a classical rst-order bimodal theory"" indicates a theoretical framework but does not specify conceptual primitives.
 - The ""in-tensional rst-order extension of the Curry-Howard isomorphism"" is a methodological tool but not a conceptual primitive.
 - The ""monadic operator of QLL"" and ""generic notion of constraint computation"" are part of the theoretical framework, but again, they are not explicitly defined as conceptual primitives.
 - The abstract does not provide explicit definitions or names for conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""We rst extend existing work FM95, FM97] on Propositional Lax Logic to a rst-order language (QLL), presenting a soundness and completeness theorem for a Gentzen-type system via a syntactic translation into a classical rst-order bimodal theory.""
  - ""These tables allow us to recover concrete answer constraints for CLP programs from abstract LLP derivations, and thus to establish precise proof-and model-theoretic connections between our Lax logical account of CLP and existing work such as Llo87] and AV96].""
  - ""Our main tool is an in-tensional rst-order extension of the Curry-Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus.""
  - ""Instantiating the monadic operator of QLL by a generic notion of constraint computation, we factor a concrete CLP program into two parts: an abstract LLP program and an associated constraint table.""
  - ""Choosing diierent constraint algebras allows us to generalize the standard notion of constraint (as in CLP) and to apply the LLP paradigm to the complementary problems of program abstraction and program reenement.""",,"- The abstract mentions the extension of Propositional Lax Logic to a first-order language (QLL), which suggests a type of mathematical framework related to propositional and first-order logic.
 - The mention of a ""soundness and completeness theorem for a Gentzen-type system"" indicates the use of proof theory, specifically Gentzen-type systems, which are a part of mathematical logic.
 - The ""in-tensional rst-order extension of the Curry-Howard isomorphism"" suggests the use of type theory, as the Curry-Howard isomorphism is a fundamental concept in type theory that relates types to propositions.
 - The use of ""syntactic translation into a classical rst-order bimodal theory"" implies a connection to modal logic, which is another mathematical framework.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it specify particular mathematical properties guaranteed beyond soundness and completeness.
 - The framework seems to be focused on formal verification and proof methodology, as indicated by the establishment of ""precise proof-and model-theoretic connections.""","- ""We rst extend existing work FM95, FM97] on Propositional Lax Logic to a rst-order language (QLL), presenting a soundness and completeness theorem for a Gentzen-type system via a syntactic translation into a classical rst-order bimodal theory.""
  - ""Previous work Men90, Men93, MF96, Men96] on applying Lax Logic to deal with behavioural constraints in formal hardware veriication has demonstrated the complementary nature of abstraction and constraints; we proceed to show how the Lax Logic Programming (LLP) fragment of QLL can reveal abstractions behind Constraint Logic Programming (CLP).""
  - ""Our main tool is an in-tensional rst-order extension of the Curry-Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus.""
  - ""Instantiating the monadic operator of QLL by a generic notion of constraint computation, we factor a concrete CLP program into two parts: an abstract LLP program and an associated constraint table.""
  - ""These tables allow us to recover concrete answer constraints for CLP programs from abstract LLP derivations, and thus to establish precise proof-and model-theoretic connections between our Lax logical account of CLP and existing work such as Llo87] and AV96].""
  - ""Choosing diierent constraint algebras allows us to generalize the standard notion of constraint (as in CLP) and to apply the LLP paradigm to the complementary problems of program abstraction and program reenement.""",,"- The abstract discusses the extension of Propositional Lax Logic to a first-order language (QLL), which involves a syntactic translation into a classical first-order bimodal theory. This suggests a theoretical integration strategy by translating one paradigm into another.
 - The integration of Lax Logic with Constraint Logic Programming (CLP) is highlighted, particularly through the Lax Logic Programming (LLP) fragment. This indicates an interaction model where LLP is used to reveal abstractions behind CLP.
 - The use of the Curry-Howard isomorphism as a tool for integration is mentioned, which is a novel translation technique that connects natural deduction proofs with computational lambda calculus terms.
 - The abstract describes factoring CLP programs into abstract LLP programs and constraint tables, which is a specific integration mechanism. This allows for the recovery of concrete answer constraints from abstract derivations.
 - The mention of choosing different constraint algebras suggests a flexibility in the integration approach, allowing for generalization and application to various problems.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does imply a focus on theoretical integration strategies and novel translation techniques.","- ""Instantiating the monadic operator of QLL by a generic notion of constraint computation, we factor a concrete CLP program into two parts: an abstract LLP program and an associated constraint table.""
  - ""Choosing diierent constraint algebras allows us to generalize the standard notion of constraint (as in CLP) and to apply the LLP paradigm to the complementary problems of program abstraction and program reenement.""
  - ""Our main tool is an in-tensional rst-order extension of the Curry-Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus.""
  - ""Previous work Men90, Men93, MF96, Men96] on applying Lax Logic to deal with behavioural constraints in formal hardware veriication has demonstrated the complementary nature of abstraction and constraints; we proceed to show how the Lax Logic Programming (LLP) fragment of QLL can reveal abstractions behind Constraint Logic Programming (CLP).""
  - ""We rst extend existing work FM95, FM97] on Propositional Lax Logic to a rst-order language (QLL), presenting a soundness and completeness theorem for a Gentzen-type system via a syntactic translation into a classical rst-order bimodal theory.""",,"- The abstract discusses the extension of Propositional Lax Logic to a first-order language (QLL), which involves a soundness and completeness theorem. This suggests a focus on logical frameworks rather than generic programming.
 - The mention of ""abstraction and constraints"" and ""reveal abstractions behind Constraint Logic Programming (CLP)"" indicates a focus on abstraction mechanisms, particularly in the context of Lax Logic Programming (LLP).
 - The use of the Curry-Howard isomorphism and the extension of it to a first-order context implies a connection to type systems and abstraction, but it does not explicitly address generic programming.
 - The instantiation of the monadic operator by a ""generic notion of constraint computation"" suggests a form of genericity in the context of constraint computation, but it is not explicitly related to generic programming.
 - The abstract does not provide specific details on minimal type requirements, static checking, or optimization strategies related to generic programming.","- ""We rst extend existing work FM95, FM97] on Propositional Lax Logic to a rst-order language (QLL), presenting a soundness and completeness theorem for a Gentzen-type system via a syntactic translation into a classical rst-order bimodal theory.""
  - ""Previous work Men90, Men93, MF96, Men96] on applying Lax Logic to deal with behavioural constraints in formal hardware veriication has demonstrated the complementary nature of abstraction and constraints; we proceed to show how the Lax Logic Programming (LLP) fragment of QLL can reveal abstractions behind Constraint Logic Programming (CLP).""
  - ""These tables allow us to recover concrete answer constraints for CLP programs from abstract LLP derivations, and thus to establish precise proof-and model-theoretic connections between our Lax logical account of CLP and existing work such as Llo87] and AV96].""
  - ""Our main tool is an in-tensional rst-order extension of the Curry-Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus.""
  - ""Instantiating the monadic operator of QLL by a generic notion of constraint computation, we factor a concrete CLP program into two parts: an abstract LLP program and an associated constraint table.""
  - ""Choosing diierent constraint algebras allows us to generalize the standard notion of constraint (as in CLP) and to apply the LLP paradigm to the complementary problems of program abstraction and program reenement.""",,"- The abstract extends existing work on Propositional Lax Logic to a first-order language (QLL), which is a novel theoretical contribution as it expands the scope of Lax Logic.
 - The extension to a first-order language and the presentation of a soundness and completeness theorem for a Gentzen-type system are significant theoretical advancements.
 - The use of the Lax Logic Programming (LLP) fragment to reveal abstractions behind Constraint Logic Programming (CLP) is a key novel insight, as it provides a new perspective on how abstraction and constraints interact.
 - The extension of the Curry-Howard isomorphism to a first-order context is a theoretical advancement, as it bridges natural deduction proofs and computational lambda calculus terms.
 - The ability to factor CLP programs into abstract LLP programs and constraint tables is a novel approach that allows for the recovery of concrete answer constraints, which is a significant theoretical contribution.
 - The generalization of the standard notion of constraint by choosing different constraint algebras is a theoretical advancement that broadens the applicability of the LLP paradigm.
 - The potential implications for programming language design include the ability to apply the LLP paradigm to program abstraction and refinement, which could lead to more efficient and flexible programming practices."
A foundation for typed concatenative languages,Robert Kleffner,10.17760/d20467250,https://doi.org/10.17760/d20467250,-,3,-,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Sound type system, sound and complete type inference algorithm
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of a core programming language that captures the essence of the concatenative paradigm.
 - Theoretical advancements: Moving away from the functional setting to avoid cumbersome encoding; introduction of a sound type system and a sound and complete type inference algorithm.
 - Potential implications: Serving as a starting point for future explorations of the concatenative language design space.","- ""The design space for concatenative programming languages, also known as stack-based programming languages, is largely under-explored.""
  - ""Most formal investigations of higher-order stack-based languages are done in the functional setting, requiring a cumbersome and unnecessary encoding.""
  - ""We expect that this model will serve as a starting point for future explorations of the concatenative language design space.--Author's""
  - ""This dissertation describes a core programming language that captures the essence of the concatenative paradigm, provides a reduction semantics for this language, and introduces a sound type system.""
  - ""It also presents a sound and complete type inference algorithm.""",,"- The abstract discusses the exploration of the design space for concatenative programming languages, which suggests a focus on understanding and defining the fundamental elements or primitives of these languages.
 - The mention of a ""core programming language"" and ""reduction semantics"" implies that the study involves defining basic elements or rules that govern how these languages operate.
 - The introduction of a ""sound type system"" and a ""sound and complete type inference algorithm"" suggests that the study involves defining primitives related to type systems and inference, which are crucial for programming languages.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It mentions the essence of the concatenative paradigm and the introduction of a type system and type inference algorithm, but it does not provide detailed definitions or names of these primitives.
 - The abstract does not provide information on the level of abstraction or orthogonality of any primitives.","- ""This dissertation describes a core programming language that captures the essence of the concatenative paradigm, provides a reduction semantics for this language, and introduces a sound type system.""
  - ""It also presents a sound and complete type inference algorithm.""",,"- The abstract mentions the introduction of a ""sound type system"" and a ""sound and complete type inference algorithm,"" which suggests that the mathematical framework used is related to type theory.
 - The mention of ""reduction semantics"" indicates that the framework likely involves formal semantics, which is a common approach in programming language theory.
 - The abstract does not specify any other mathematical properties guaranteed or proof techniques used beyond the type system and type inference algorithm.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""This dissertation describes a core programming language that captures the essence of the concatenative paradigm, provides a reduction semantics for this language, and introduces a sound type system.""
  - ""We expect that this model will serve as a starting point for future explorations of the concatenative language design space.--Author's""
  - ""It also presents a sound and complete type inference algorithm.""
  - ""Most formal investigations of higher-order stack-based languages are done in the functional setting, requiring a cumbersome and unnecessary encoding.""
  - ""The design space for concatenative programming languages, also known as stack-based programming languages, is largely under-explored.""",,"- The abstract discusses the exploration of the concatenative programming paradigm, which is a specific type of programming paradigm.
 - It mentions that most formal investigations are done in a functional setting, which implies a focus on integrating or comparing with functional programming.
 - However, there is no explicit mention of integrating different programming paradigms or specific mechanisms for doing so.
 - The abstract focuses on developing a core language and type system for concatenative programming, rather than integrating it with other paradigms.
 - There is no discussion of interaction models, constraints, or novel translation techniques related to integrating different paradigms.","- ""The design space for concatenative programming languages, also known as stack-based programming languages, is largely under-explored.""
  - ""This dissertation describes a core programming language that captures the essence of the concatenative paradigm, provides a reduction semantics for this language, and introduces a sound type system.""
  - ""We expect that this model will serve as a starting point for future explorations of the concatenative language design space.--Author's""
  - ""It also presents a sound and complete type inference algorithm.""
  - ""Most formal investigations of higher-order stack-based languages are done in the functional setting, requiring a cumbersome and unnecessary encoding.""",,"- The abstract discusses the design space for concatenative programming languages and the introduction of a sound type system, which could relate to genericity and abstraction mechanisms.
 - However, there is no specific mention of generic programming methodology, mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies in the abstract.
 - The focus appears to be on establishing a core language and type system rather than exploring generic programming or abstraction mechanisms in depth.
 - The abstract does not provide details on how genericity or abstraction is addressed in the dissertation.","- ""This dissertation describes a core programming language that captures the essence of the concatenative paradigm, provides a reduction semantics for this language, and introduces a sound type system.""
  - ""We expect that this model will serve as a starting point for future explorations of the concatenative language design space.--Author's""
  - ""Most formal investigations of higher-order stack-based languages are done in the functional setting, requiring a cumbersome and unnecessary encoding.""
  - ""The design space for concatenative programming languages, also known as stack-based programming languages, is largely under-explored.""
  - ""It also presents a sound and complete type inference algorithm.""",,"- The abstract highlights that the design space for concatenative programming languages is under-explored, indicating a gap in current research that this study aims to address.
 - It critiques existing approaches by noting that they are often done in a functional setting, which requires unnecessary encoding. This suggests a theoretical advancement by moving away from this cumbersome approach.
 - The dissertation introduces a core programming language that captures the essence of the concatenative paradigm, which is a novel insight as it provides a foundational model for these languages.
 - The introduction of a sound type system and a sound and complete type inference algorithm are significant theoretical contributions, as they provide a rigorous framework for understanding and working with concatenative languages.
 - The expectation that this model will serve as a starting point for future explorations indicates potential implications for programming language design, suggesting that this work could influence future developments in the field."
Certifying Choreography Compilation ⋆,"L. Cruz-Filipe, F. Montesi, Marco Peressotti",-,-,-,0,-,Not specified (the abstract does not explicitly define specific conceptual primitives),Not specified (the abstract does not provide details on the mathematical framework used),"- Specific integration mechanisms proposed: Choreography compilation translates global choreographies into local process behaviors.
 - Interaction models between paradigms: Global interactions vs local actions.
 - Constraints or challenges in paradigm integration: Relating languages in different paradigms and dealing with a combinatorial explosion of proof cases.
 - Novel translation or embedding techniques: First certified program for choreography compilation for a nontrivial choreographic language supporting recursion.",Generic programming not extensively addressed,"- Key novel insights: The first certified program for choreography compilation for a nontrivial choreographic language supporting recursion.
 - Theoretical advancements beyond existing approaches: Addressing the challenges of proving choreography compilation correct by relating languages in different paradigms and handling combinatorial explosion of proof cases.
 - Potential implications for programming language design: Influence on future programming language design for concurrent and distributed systems through certified choreography compilation.","- ""Choreographic programming is a paradigm for developing concurrent and distributed systems, where programs are choreographies that define, from a global viewpoint, the computations and interactions that communicating processes should enact.""
  - ""We present the first certified program for choreography compilation for a nontrivial choreographic language supporting recursion.""
  - ""Choreography compilation translates choreographies into the local definitions of process behaviours, given as terms in a process calculus.""",,"- The abstract discusses choreographic programming as a paradigm, which implies a conceptual framework for developing concurrent and distributed systems.
 - It mentions that choreographies define computations and interactions from a global viewpoint, suggesting that these are conceptual primitives in the context of choreographic programming.
 - The process of choreography compilation involves translating these global definitions into local process behaviors, which are represented as terms in a process calculus. This indicates that the local definitions of process behaviors are also conceptual primitives.
 - The abstract does not explicitly list or define specific conceptual primitives beyond these general concepts. It focuses on the process of compilation and the novelty of the certified program rather than detailing specific primitives.
 - There is no mention of the level of abstraction or orthogonality of these primitives in the abstract.","- ""We present the first certified program for choreography compilation for a nontrivial choreographic language supporting recursion.""
  - ""Choreography compilation translates choreographies into the local definitions of process behaviours, given as terms in a process calculus.""
  - ""Choreographic programming is a paradigm for developing concurrent and distributed systems, where programs are choreographies that define, from a global viewpoint, the computations and interactions that communicating processes should enact.""
  - ""Proving choreography compilation correct is challenging and error-prone, because it requires relating languages in different paradigms (global interactions vs local actions) and dealing with a combinatorial explosion of proof cases.""",,"- The abstract discusses choreographic programming and its compilation into process calculus, which suggests a theoretical foundation in process calculus.
 - The mention of ""relating languages in different paradigms"" and ""dealing with a combinatorial explosion of proof cases"" implies a need for formal verification techniques, but it does not specify the type of mathematical framework used.
 - The abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no mention of specific proof techniques or limitations/constraints of the framework in the abstract.","- ""We present the first certified program for choreography compilation for a nontrivial choreographic language supporting recursion.""
  - ""Proving choreography compilation correct is challenging and error-prone, because it requires relating languages in different paradigms (global interactions vs local actions) and dealing with a combinatorial explosion of proof cases.""
  - ""Choreography compilation translates choreographies into the local definitions of process behaviours, given as terms in a process calculus.""
  - ""Choreographic programming is a paradigm for developing concurrent and distributed systems, where programs are choreographies that define, from a global viewpoint, the computations and interactions that communicating processes should enact.""",,"- The abstract discusses choreographic programming as a paradigm for developing concurrent and distributed systems, which implies an integration of global and local viewpoints.
 - Choreography compilation is described as translating global choreographies into local process behaviors, indicating a mechanism for integrating global interactions with local actions.
 - The challenge of relating languages in different paradigms (global vs local) suggests a constraint in paradigm integration, specifically the difficulty in proving correctness due to the combinatorial explosion of proof cases.
 - The mention of a ""certified program for choreography compilation"" implies a novel translation or embedding technique, as it is described as the first for a nontrivial choreographic language supporting recursion.","- ""We present the first certified program for choreography compilation for a nontrivial choreographic language supporting recursion.""
  - ""Choreographic programming is a paradigm for developing concurrent and distributed systems, where programs are choreographies that define, from a global viewpoint, the computations and interactions that communicating processes should enact.""
  - ""Proving choreography compilation correct is challenging and error-prone, because it requires relating languages in different paradigms (global interactions vs local actions) and dealing with a combinatorial explosion of proof cases.""
  - ""Choreography compilation translates choreographies into the local definitions of process behaviours, given as terms in a process calculus.""",,"- The abstract discusses choreographic programming and compilation, focusing on the translation of global choreographies into local process behaviors. This suggests a focus on abstraction mechanisms related to process behaviors and interactions.
 - The mention of ""relating languages in different paradigms"" implies a need for abstraction to bridge these paradigms, but it does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not provide specific details on generic programming methodology, type system discussions, or explicit abstraction mechanisms beyond the general concept of choreography compilation.
 - The focus is on the correctness and certification of choreography compilation rather than on generic programming or abstraction mechanisms.","- ""We present the first certified program for choreography compilation for a nontrivial choreographic language supporting recursion.""
  - ""Proving choreography compilation correct is challenging and error-prone, because it requires relating languages in different paradigms (global interactions vs local actions) and dealing with a combinatorial explosion of proof cases.""
  - ""Choreography compilation translates choreographies into the local definitions of process behaviours, given as terms in a process calculus.""
  - ""Choreographic programming is a paradigm for developing concurrent and distributed systems, where programs are choreographies that define, from a global viewpoint, the computations and interactions that communicating processes should enact.""",,"- The abstract introduces choreographic programming as a paradigm for developing concurrent and distributed systems, which is a theoretical contribution by itself as it provides a new perspective on how to design and analyze such systems.
 - The process of choreography compilation is highlighted as a significant theoretical advancement, as it involves translating global choreographies into local process behaviors, which is a complex task due to the paradigm shift from global to local.
 - The mention of ""proving choreography compilation correct"" being ""challenging and error-prone"" indicates that previous approaches may not have adequately addressed these challenges, suggesting a theoretical advancement in addressing these issues.
 - The presentation of the ""first certified program for choreography compilation for a nontrivial choreographic language supporting recursion"" is a key novel insight, as it provides a certified solution to a previously unsolved problem, which is a significant theoretical contribution.
 - The potential implications for programming language design are implicit in the development of a certified program for choreography compilation, as it could influence how future programming languages are designed to handle concurrent and distributed systems."
Component-Based Description of Programming Languages,Peter D. Mosses,10.14236/EWIC/VOCS2008.23,https://doi.org/10.14236/EWIC/VOCS2008.23,BCS International Academic Conference,18,2008,"1. Primitive Name: seq(Cmd, . . . , Cmd)
  Definition: normal left-to-right command sequencing
 2. Primitive Name: skip
  Definition: normal termination
 3. Primitive Name: cond-loop(Exp, Cmd)
  Definition: corresponds to a simple while-loop (not handling break)
 4. Primitive Name: catch(Cmd, Pcd)
  Definition: handles abrupt termination if Cmd terminates abruptly and the parameter of Pcd matches
 5. Primitive Name: throw(Exp)
  Definition: terminates abruptly with the computed entity if Exp terminates normally
 6. Primitive Name: bind(Id, Exp)
  Definition: binds Id to the entity computed by Exp
 7. Primitive Name: lookup(Id)
  Definition: computes the entity currently bound to Id
 8. Primitive Name: abs(Prm, Cmd)
  Definition: parameterised procedure abstraction (with static scoping)
 9. Primitive Name: alt(Pcd, Pcd)
  Definition: alternative procedures
 10. Primitive Name: bind(Id)
  Definition: parameter that matches any argument entity and binds Id to it
 11. Primitive Name: eq(Exp)
  Definition: parameter that matches only the entity computed by Exp",Not specified (the paper discusses various semantic frameworks and mathematical properties but does not explicitly specify a type of mathematical framework or detailed proof techniques),No specific integration approach described,"- Definition of ""concept"" used: Abstract constructs with fixed, language-independent abstract syntax and semantics.
 - Mechanisms for representing generic abstractions: Language-independent notation for common programming constructs.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novel component-based paradigm for language description
 - Introduction of language-independent notation for common programming constructs
 - Proposal for language-independent nomenclature for abstract programming constructs
 - Paradigm shift in semantic description development
 - Potential implications: more efficient and modular language development, leading to more reliable and maintainable languages","- ""The following selected examples of abstract constructs are given to illustrate the kinds of constructs that may be considered as basic.""
  - ""Cmd ::= seq(Cmd, . . . , Cmd) -normal left-to-right command sequencing;""
  - ""Cmd ::= skip -normal termination;""
  - ""Cmd ::= cond-loop(Exp, Cmd) -corresponds to a simple while-loop (not handling break);""
  - ""Cmd ::= catch(Cmd, Pcd) -if Cmd terminates abruptly, and the parameter of the abstraction Pcd matches the accompanying entity, the abrupt termination is handled;""
  - ""Cmd ::= throw(Exp) -if Exp terminates normally, the command terminates abruptly with the computed entity;""
  - ""Dcl ::= bind(Id, Exp) -binds Id to the entity computed by Exp;""
  - ""Exp ::= lookup(Id) -computes the entity currently bound to Id;""
  - ""Pcd ::= abs(Prm, Cmd) -parameterised procedure abstraction (with static scoping);""
  - ""Pcd ::= alt(Pcd, Pcd) -alternative procedures;""
  - ""Prm ::= bind(Id) -parameter that matches any argument entity, and binds Id to it;""
  - ""Prm ::= eq(Exp) -parameter that matches only the entity computed by Exp.""",,"- The paper discusses the concept of abstract constructs as a way to describe programming languages in a component-based manner.
 - The listed examples are described as ""basic"" abstract constructs, which suggests they are conceptual primitives.
 - Each construct is defined with a specific syntax and semantics, indicating they are intended to be fundamental building blocks.
 - The constructs are categorized into different sorts (e.g., Cmd, Dcl, Exp, Pcd, Prm), which implies a structured approach to defining these primitives.
 - The definitions provided for each construct are precise and include their intended semantics, which is characteristic of conceptual primitives.
 - The paper does not explicitly mention an ""orthogonality score,"" but the constructs are designed to be independent and reusable, suggesting a high level of orthogonality.","- ""Theoretical studies have addressed advanced features that might be included in future mainstream languages; they have also led to a deeper understanding of programming languages in terms of abstract mathematical structures, and to significant theorems about substantial fragments of real languages, such as soundness of type systems.""
  - ""The semantic mapping is required to be compositional, i.e. the denotation of each compound phrase depends on the denotations of its sub-phrases, but not on their form.""
  - ""Denotations are said to be fully abstract when observationally-equivalent phrases always have the same denotations.""
  - ""The monadic variant of denotational semantics was introduced by Moggi at the end of the 1980s [21]. Although reuse was not Moggi's original motivation, the pragmatic benefits of monadic semantics in that respect were soon realised.""
  - ""The more recent work on computational effects and operations by Plotkin and Power [30] obtains monads as models of combinations of Lawvere theories, giving further benefits regarding modularity and reuse.""
  - ""A further variant of denotational semantics that supports reuse is action semantics [23]. There, denotations are so-called actions, expressed in action notation; the semantics of action notation itself is defined operationally (originally using an unorthodox variant of SOS, later in MSOS).""
  - ""The action primitives and combinators provide an adequate basis for expressing the dynamic semantics of a wide range of programming constructs.""
  - ""The action semantics description for blocks is as follows:
 

 execute""",,"- The paper discusses theoretical foundations and mathematical structures related to programming languages, particularly focusing on denotational semantics and its variants.
 - The mention of ""compositional"" and ""fully abstract"" denotations suggests a focus on mathematical properties related to these concepts.
 - The paper references monadic semantics and action semantics as frameworks that support reuse and modularity, indicating these are part of the mathematical framework.
 - The use of monads and Lawvere theories suggests a connection to category theory, although it is not explicitly stated as the primary framework.
 - The paper does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it detail specific proof techniques or limitations.","- ""The introduction of a language-independent notation for common programming constructs maximises the reusability of components.""
  - ""The provision of reusable components should make formal description of programming languages considerably more attractive to designers and implementers, since different languages (even those from different families) often have many constructs in common.""
  - ""An abstract construct, in contrast, has a fixed, language-independent abstract syntax and semantics.""
  - ""The relationship between the syntax and semantics of individual abstract constructs is not only language-independent but also 1-1: if two abstract constructs have different semantics, they have different syntax (to avoid confusion); and no two abstract constructs with different syntax have exactly the same semantics (to avoid pointless duplication).""
  - ""Component-Based Description of Programming Languages Another difference from previous metalanguages is that each abstract construct usually corresponds directly to (a simplified or idealised version of) some concrete construct found in major programming languages.""
  - ""A programming language consists of a collection of concrete constructs, each of which has a particular concrete syntax and semantics. However, the relationship between concrete syntax and semantics depends on the language.""
  - ""The next section motivates and introduces a language-independent notation for common programming constructs. These constructs should be significantly more familiar than action primitives and combinators.""
  - ""The action semantics description for blocks is as follows:
 

 execute""",,"- The paper discusses the use of a ""language-independent notation for common programming constructs"" which suggests a mechanism for integrating different programming paradigms by providing a common framework for describing constructs across languages.
 - The emphasis on ""reusable components"" implies that these components can be used across different languages, facilitating integration by allowing common constructs to be shared.
 - The concept of ""abstract constructs"" with ""fixed, language-independent abstract syntax and semantics"" provides a theoretical integration strategy by standardizing the description of constructs across paradigms.
 - The paper does not explicitly discuss interaction models between paradigms or specific constraints or challenges in paradigm integration.
 - There is no mention of novel translation or embedding techniques for integrating paradigms.","- ""The introduction of a language-independent notation for common programming constructs maximises the reusability of components.""
  - ""The use of a language-independent notation for common programming constructs maximises the reusability of components.""
  - ""An abstract construct, in contrast, has a fixed, language-independent abstract syntax and semantics.""
  - ""The relationship between the syntax and semantics of individual abstract constructs is not only language-independent but also 1-1: if two abstract constructs have different semantics, they have different syntax (to avoid confusion); and no two abstract constructs with different syntax have exactly the same semantics (to avoid pointless duplication).""
  - ""the collection of abstract constructs is intended to be open-ended: new constructs may be added whenever the previous constructs are found to be insufficiently expressive.""
  - ""Thanks to the independence of our definitions of abstract constructs, adding new constructs should never require reformulation or extension of the definitions of the existing constructs.""
  - ""Our main contribution is the principle that complete language descriptions should be based on reusable components consisting of independent descriptions of individual abstract programming constructs.""
  - ""Another contribution is our proposal to establish language-independent nomenclature for common abstract programming constructs, to maximise the reusability of their formal descriptions, and provide a stable yet extensible basis for analysing the more complicated concrete constructs found in practical programming languages.""",,"- The paper discusses the use of ""language-independent notation"" for common programming constructs, which suggests a focus on genericity and abstraction. This notation is designed to maximize the reusability of components, indicating a mechanism for representing generic abstractions.
 - The concept of an ""abstract construct"" is defined as having a fixed, language-independent abstract syntax and semantics. This implies a definition of ""concept"" that is abstract and independent of specific languages.
 - The paper emphasizes the independence of abstract constructs, which allows for adding new constructs without affecting existing ones. This suggests a mechanism for representing generic abstractions that can be extended without reformulation.
 - The paper does not explicitly discuss minimal type requirements or static checking strategies, but it does mention the importance of language-independent nomenclature for abstract constructs, which could imply a need for consistent type systems.
 - The focus on reusable components and language-independent notation suggests an approach to generic programming, but the paper does not delve into specific type system discussions or optimization strategies.","- ""Part of the proposed remedy is a radical shift to a novel component-based paradigm for the development of complete language descriptions, based on simple interfaces between descriptions of syntactic and semantic aspects, and employing frameworks that allow independent description of individual programming constructs.""
  - ""Our main contribution is the principle that complete language descriptions should be based on reusable components consisting of independent descriptions of individual abstract programming constructs.""
  - ""Another contribution is our proposal to establish language-independent nomenclature for common abstract programming constructs, to maximise the reusability of their formal descriptions, and provide a stable yet extensible basis for analysing the more complicated concrete constructs found in practical programming languages.""
  - ""Adoption of this principle will require a significant paradigm shift regarding the development of semantic descriptions, involving the study of the essential features of each individual construct in isolation, instead of considering its relationship with other constructs.""
  - ""The introduction of a language-independent notation for common programming constructs maximises the reusability of components.""",,"- The paper introduces a novel component-based paradigm for language description, which is a significant theoretical contribution. This paradigm allows for the independent description of individual programming constructs, which is a departure from traditional methods.
 - The introduction of a language-independent notation for common programming constructs is a key novel insight. This notation maximizes the reusability of components, which is a significant theoretical advancement.
 - The proposal to establish a language-independent nomenclature for abstract programming constructs is another theoretical contribution. This nomenclature will provide a stable and extensible basis for analyzing complex concrete constructs.
 - The paper suggests a paradigm shift in how semantic descriptions are developed, focusing on individual constructs rather than their relationships. This is a theoretical advancement beyond existing approaches.
 - The potential implications for programming language design include more efficient and modular development of language descriptions, which could lead to more reliable and maintainable languages."
Applicative bidirectional programming with lenses,"Kazutaka Matsuda, Meng Wang",10.1145/2784731.2784750,https://doi.org/10.1145/2784731.2784750,ACM SIGPLAN International Conference on Functional Programming,38,2015,"1. Primitive Name: Lifting
  Definition: Transforming lenses into polymorphic functions that can be composed and passed to higher-order functions.
  Orthogonality Score: High
 

 2. Primitive Name: Unlifting
  Definition: Serving as a left inverse to the lifting function, transforming functions back into lenses.
  Orthogonality Score: High
 

 3. Primitive Name: Abstract Types
  Definition: Treating lens functions as abstract types to ensure compositional reasoning of well-behavedness.
  Orthogonality Score: High
 

 4. Primitive Name: Local Well-Behavedness
  Definition: A property of bidirectional transformations that ensures they behave correctly under certain conditions.
  Orthogonality Score: High","- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Injectivity, left inverses, preservation of well-behavedness
 - Proof techniques used: Yoneda embedding, natural transformations, free theorems
 - Limitations or constraints of the framework: Category of lenses is monoidal but not closed, requires abstract types","- Specific integration mechanisms proposed: Lifting lenses to lens functions to combine lens framework and semantic bidirectionalization.
 - Interaction models between paradigms: Combining strengths of both paradigms to enhance applicability and control.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Use of the Yoneda Lemma to express lenses as functions.","- Definition of ""concept"" used: Abstract types and polymorphism.
 - Mechanisms for representing generic abstractions: Lifting lenses to functions with generic type parameters (∀s. L s a → L s b), use of traverse from Data.Traversable.
 - Minimal type requirements identified: Type constraints like Eq a, Traversable t.
 - Static checking or optimization strategies: Implied by use of type constraints and lawful instances.","- Novel framework combining lens framework and semantic bidirectionalization.
 - Lifting lenses to functions for applicative-style programming.
 - More general form of semantic bidirectionalization.
 - Enhanced applicability and control with user-defined lenses and higher-order functions.
 - Guaranteed well-behavedness by construction.
 - Potential implications for programming language design in handling shape updates.","- ""we lift lenses of type L a b to polymorphic functions of type ∀s. L s a → L s b by lens composition""
  - ""We call such lifted lenses lens functions.""
  - ""The lifting function lift is injective, and has the following left inverse.""
  - ""Functions lift and unlift have the following desirable properties.""
  - ""we require that L is used as an ""abstract type"" in defining lens functions of type ∀s. L s A → L s B""
  - ""The n-tuple above is then generalized to data structures such as lists in Section 4.""
  - ""We can now show that the new unlift2 is the left-inverse of lift2""
  - ""We call ( ) ""split"" in this paper.""
  - ""We can recreate fst L and snd L with unlift2""
  - ""The idea is that O-tagged elements in s are not connected to the view v , and thus changing them will not affect v""
  - ""Definition 2 (Local Well-Behavedness). A bidirectional transformation :: L T a b is called locally well-behaved if the following four conditions hold.""
  - ""Corollary 2. Let f be a function of type ∀s. (L T s A, L T s B ) → L T s C in which L T is abstract. Then, unlift2 f is well-behaved, assuming that lift is applied only to well-behaved lenses.""",,"- The paper introduces the concept of ""lifting"" lenses to create ""lens functions,"" which are polymorphic functions that can be composed and passed to higher-order functions. This is a key conceptual primitive.
 - The ""lifting"" function is defined as a way to transform lenses into functions that can be manipulated in an applicative style, which is another primitive.
 - The ""unlifting"" function serves as a left inverse to the lifting function, which is another primitive.
 - The use of ""abstract types"" for lens functions is emphasized, which is a conceptual primitive related to how lenses are treated in the framework.
 - The generalization of these concepts to data structures like lists is also a part of the framework, indicating a broader applicability of these primitives.
 - The introduction of ""local well-behavedness"" as a property of bidirectional transformations is another conceptual primitive, defining how these transformations should behave.
 - The primitives are designed to be orthogonal, as they are used to construct and manipulate bidirectional transformations in a modular way.","- ""Inspired by the Yoneda embedding in category theory [19], we lift lenses of type L a b to polymorphic functions of type ∀s. L s a → L s b by lens composition""
  - ""The key idea of our proposal is to lift lenses of type L (A1, . . . , An ) B to lens functions of type""
  - ""The lifting function lift is injective, and has the following left inverse.""
  - ""We reconfirm that lift is injective with unlift as its left inverse.""
  - ""We say that a function f preserves well-behavedness, if f is well-behaved for any well-behaved lens . Functions lift and unlift have the following desirable properties.""
  - ""Theorem 3 (An Analogue of the Yoneda Lemma (Section III.2 in [19])). A pair of functions (lift, unlift) is a bijection between""
  - ""The condition f x • y = f (x • y) is required to make f a natural transformation between functors L (-) A and L (-) B ; here, the contravariant functor L (-) A maps a lens of type L Y X to a function""
  - ""Theorem 4. Let f be a function of type ∀s. (L T s A, L T s B ) → L T s C in which L T is abstract. Then, f (x , y) is locally wellbehaved if x and y are also locally well-behaved, assuming that lift is applied only to well-behaved lenses.""
  - ""Corollary 2. Let f be a function of type ∀s. (L T s A, L T s B ) → L T s C in which L T is abstract. Then, unlift2 f is well-behaved, assuming that lift is applied only to well-behaved lenses.""
  - ""Theorem 2. For any f ::∀s. L s A → L s B in which L is abstract, lift (unlift f ) = f holds.""",,"- The paper uses category theory as the mathematical framework, specifically referencing the Yoneda embedding and natural transformations.
 - The framework guarantees properties such as injectivity and left inverses for the lifting and unlifting functions, which are crucial for maintaining well-behavedness.
 - The framework ensures that functions preserve well-behavedness, which is a key property for bidirectional transformations.
 - The use of free theorems is a proof technique employed to establish certain properties, such as the relationship between lifting and unlifting functions.
 - The framework has limitations, such as the category of lenses being monoidal but not closed, which affects the handling of higher-order functions.
 - The framework requires abstract types to ensure compositional reasoning of well-behavedness, which is a constraint.","- ""Our framework essentially bridges two very different approaches of bidirectional programming, namely the lens framework and Voigtländer's semantic bidirectionalization, creating a new programming style that is able to bag benefits from both.""
  - ""Our work's unique ability of combining lenses and semantic bidirectionalization results in more applicability and control than those offered by bidirectionalization alone: user-defined lenses on base types can now be passed to higher-order functions.""
  - ""Our framework can be viewed as a more general form of semantic bidirectionalization.""
  - ""By using the Yoneda embedding, we can also express L A B as functions of type ∀v . L B v → L A v""",,"- The paper discusses the integration of two programming paradigms: the lens framework and semantic bidirectionalization. This is explicitly mentioned in the first quote, indicating a bridging of these two approaches.
 - The integration mechanism involves lifting lenses to lens functions, as described in the second quote. This allows for a more flexible and general form of bidirectional programming.
 - The interaction model between these paradigms is described as combining the strengths of both, enabling user-defined lenses to be used with higher-order functions, as noted in the fourth quote.
 - The paper does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the novelty of combining these paradigms in a way that enhances applicability and control.
 - The use of the Yoneda Lemma is a novel translation technique that underpins the integration approach, as indicated in the fifth and sixth quotes.","- ""we use the datatype-generic function traverse, which can be found in Data.Traversable, to give data-type generic lifting and unlifting functions.""
  - ""We use traverse to define two functions that are able to extract data from the structure holding them (contents), and redecorate an ""empty"" structures with given data (fill""
  - ""A future step will be to extend the current ability of handling shape updates.""
  - ""In this paper, we develop a framework for applicative-style and higher-order bidirectional programming, in which we can write bidirectional transformations as unidirectional programs in standard functional languages, opening up access to the bundle of language features previously only available to conventional unidirectional languages.""
  - ""In this section, we demonstrate the expressiveness of our framework by defining a bidirectional evaluator in it.""
  - ""We can now define a generic lsequence function as follows.""
  - ""The n-tuple above is then generalized to data structures such as lists in Section 4.""",,"- The paper discusses a framework for applicative-style and higher-order bidirectional programming, which involves lifting lenses to functions. This suggests a focus on generic programming by abstracting over specific types.
 - The use of ""∀s. L s a → L s b"" indicates a generic type parameter ""s,"" which is a common mechanism in generic programming to represent abstractions over different types.
 - The generalization to data structures like lists and the use of ""traverse"" from Data.Traversable suggest a generic programming approach that can handle various data types.
 - The mention of ""generic lsequence function"" and ""datatype-generic lifting and unlifting functions"" further supports the use of generic programming mechanisms.
 - The paper does not explicitly define a ""concept"" in the context of generic programming, but it implies the use of abstract types and polymorphism.
 - Minimal type requirements are implied by the use of type constraints like ""Eq a"" and ""Traversable t,"" which are necessary for the generic functions to work.
 - Static checking or optimization strategies are not explicitly discussed, but the use of type constraints and lawful instances suggests some level of static checking.","- ""Our framework essentially bridges two very different approaches of bidirectional programming, namely the lens framework and Voigtländer's semantic bidirectionalization, creating a new programming style that is able to bag benefits from both.""
  - ""Our framework can be viewed as a more general form of semantic bidirectionalization.""
  - ""Our work's unique ability of combining lenses and semantic bidirectionalization results in more applicability and control than those offered by bidirectionalization alone: user-defined lenses on base types can now be passed to higher-order functions.""
  - ""We have proposed a novel framework of applicative bidirectional programming, which features the strengths of lens [4,9,10] and semantics bidirectionalization [21,22,33,41].""
  - ""The well-behavedness of the resulting bidirectional transformations are guaranteed by construction.""
  - ""A future step will be to extend the current ability of handling shape updates.""",,"- The paper introduces a novel framework that combines the strengths of the lens framework and semantic bidirectionalization, creating a new programming style (Quote 1). This is a key theoretical contribution as it bridges two different approaches.
 - The framework lifts lenses to functions, allowing for applicative-style programming (Quote 2). This is a theoretical advancement as it enables a new way of constructing bidirectional transformations.
 - The framework is described as a more general form of semantic bidirectionalization (Quote 3), indicating a theoretical advancement beyond existing semantic bidirectionalization techniques.
 - The combination of lenses and semantic bidirectionalization allows for more applicability and control, particularly in handling user-defined lenses and higher-order functions (Quote 4). This is a significant theoretical contribution as it enhances the expressiveness and flexibility of bidirectional programming.
 - The framework guarantees well-behavedness by construction (Quote 6), which is a theoretical innovation as it ensures the correctness of bidirectional transformations without additional effort.
 - The paper suggests future work on extending the ability to handle shape updates (Quote 7), indicating potential implications for programming language design in terms of flexibility and expressiveness."
Set-Theoretic Models of Computations,J. Abrial,10.1007/978-3-642-39698-4_1,https://doi.org/10.1007/978-3-642-39698-4_1,Theories of Programming and Formal Methods,1,2013,Not specified (the abstract does not provide explicit definitions or names for conceptual primitives),"- Type of mathematical framework: Set-theoretic models
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Presentation of set-theoretic models of computation.
 - Theoretical advancements: Unifying various mechanical computation paradigms under a unified mathematical theory, focusing on computation rather than programming languages.
 - Potential implications: Provides a broader theoretical framework for understanding and developing computational models, which could influence programming language design by offering a more unified and formal approach to computation.","- ""The purpose of this paper is to present some set-theoretic models of computation.""
  - ""Our purpose is also to study how these computations can be specified and then developed by means of refinements and proofs.""
  - ""our purpose is not so much to unify various ways of programming (using different programming languages) but rather to see how various mechanical computation paradigms (be they sequential, distributed, parallel, and so on) can be given a unified mathematical theory.""",,"- The abstract mentions the use of ""set-theoretic models of computation,"" which suggests that these models are the conceptual primitives being defined. However, it does not explicitly list or define these primitives.
 - The focus is on unifying mechanical computation paradigms, but the abstract does not specify what these paradigms are or how they are defined.
 - The abstract discusses the specification and development of computations through refinements and proofs, but again, it does not provide explicit definitions or names for these conceptual primitives.
 - The abstract does not mention any specific names or definitions for the conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""The purpose of this paper is to present some set-theoretic models of computation.""
  - ""Our purpose is also to study how these computations can be specified and then developed by means of refinements and proofs.""",,"- The abstract mentions ""set-theoretic models of computation,"" which indicates that the mathematical framework used is based on set theory.
 - The mention of ""refinements and proofs"" suggests that the framework involves some form of formal verification, likely using proof techniques to guarantee properties.
 - However, the abstract does not specify the type of mathematical properties guaranteed or the specific proof techniques used.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""Our purpose is also to study how these computations can be specified and then developed by means of refinements and proofs.""
  - ""However, we prefer to use here the term ""computation"" to that of ""programming"" as our purpose is not so much to unify various ways of programming (using different programming languages) but rather to see how various mechanical computation paradigms (be they sequential, distributed, parallel, and so on) can be given a unified mathematical theory.""
  - ""This topic and its usefulness are clearly related to those presented in the book by Hoare and He: ""Unifying Theories of Programming"" [12].""
  - ""The purpose of this paper is to present some set-theoretic models of computation.""",,"- The abstract mentions the presentation of set-theoretic models of computation, which implies a focus on theoretical integration strategies.
 - The reference to ""Unifying Theories of Programming"" suggests a connection to integrating different programming paradigms, but the abstract clarifies that the focus is on computation rather than programming languages.
 - The abstract explicitly states that the purpose is to unify various mechanical computation paradigms, indicating an integration approach.
 - However, the abstract does not provide specific details on integration mechanisms, interaction models, constraints, or novel translation techniques.
 - The focus on a unified mathematical theory suggests a theoretical integration strategy, but specific mechanisms or techniques are not described.","- ""Our purpose is also to study how these computations can be specified and then developed by means of refinements and proofs.""
  - ""The purpose of this paper is to present some set-theoretic models of computation.""",,"- The abstract does not mention ""genericity and abstraction mechanisms"" or any related terms such as ""generic programming,"" ""abstraction,"" or ""type system.""
 - The focus of the paper is on set-theoretic models of computation and unifying various mechanical computation paradigms, not on generic programming or abstraction mechanisms.
 - There is no mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The abstract does not provide any information on the definition of ""concept"" used or any specific mechanisms related to generic programming.","- ""The purpose of this paper is to present some set-theoretic models of computation.""
  - ""However, we prefer to use here the term ""computation"" to that of ""programming"" as our purpose is not so much to unify various ways of programming (using different programming languages) but rather to see how various mechanical computation paradigms (be they sequential, distributed, parallel, and so on) can be given a unified mathematical theory.""
  - ""This topic and its usefulness are clearly related to those presented in the book by Hoare and He: ""Unifying Theories of Programming"" [12].""
  - ""Our purpose is also to study how these computations can be specified and then developed by means of refinements and proofs.""",,"- The abstract mentions the presentation of ""set-theoretic models of computation,"" which suggests a novel approach to understanding computation through set theory.
 - The reference to ""Unifying Theories of Programming"" by Hoare and He indicates a connection to existing theoretical frameworks, but the abstract distinguishes its focus from unifying programming languages to unifying mathematical theories of computation.
 - The shift from ""programming"" to ""computation"" and the focus on mechanical computation paradigms suggest a broader theoretical contribution by encompassing various computational models under a unified mathematical framework.
 - The study of specification, refinement, and proof development for these computations implies a theoretical advancement in how computations are formally analyzed and developed."
"Choreographies , Computationally Luı́s","O. Kouchnarenko, K., Ramtin",-,-,-,0,2016,Not specified (the abstract does not explicitly define or list the conceptual primitives within Minimal Choreographies),Not specified (the abstract does not explicitly mention the type of mathematical framework or specific mathematical properties),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of Choreographic Programming for deadlock-free concurrent programs; Minimal Choreographies (MC) as a minimal language for Turing completeness.
 - Theoretical advancements: MC is minimal wrt Turing completeness; methodology for automatic generation of concurrent implementations; projection to process calculus that is deadlock free and Turing complete.
 - Potential implications: Streamlines concurrent programming by ensuring deadlock-free constructions; provides a minimalistic approach to achieving Turing completeness; enhances programming language design by integrating choreographic principles.","- ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""
  - ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""
  - ""MC is minimal wrt Turing completeness: it implements all computable functions, and restricting its syntax breaks this property.""
  - ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""",,"- The abstract introduces ""Minimal Choreographies (MC)"" as a language that includes ""only the essential primitives of the paradigm."" This suggests that MC is a foundational element in the study, likely containing the conceptual primitives.
 - The abstract does not explicitly list or define specific conceptual primitives within MC. It only mentions that MC is ""minimal wrt Turing completeness,"" which implies that it includes the necessary elements to achieve Turing completeness, but does not specify what these elements are.
 - The abstract discusses the methodology and results related to MC, such as its ability to generate concurrent implementations and its projection to a process calculus, but it does not provide explicit definitions or names of the primitives.
 - The level of abstraction and orthogonality of the primitives are not discussed in the abstract.","- ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""
  - ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""
  - ""MC is minimal wrt Turing completeness: it implements all computable functions, and restricting its syntax breaks this property.""
  - ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""",,"- The abstract discusses the foundations of Choreographic Programming, which suggests a focus on theoretical foundations.
 - The introduction of Minimal Choreographies (MC) as a language with essential primitives indicates a formal approach to programming.
 - The mention of MC being minimal with respect to Turing completeness implies a focus on computational properties.
 - The ability to generate concurrent implementations automatically suggests a formal verification process.
 - The projection of a Turing complete fragment of MC to a process calculus indicates a synthesis process, which is a mathematical framework characteristic.
 - However, the abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) used.
 - There is no explicit mention of specific mathematical properties guaranteed, proof techniques used, or limitations/constraints of the framework.","- ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""
  - ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""
  - ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""",,"- The abstract discusses the ""Choreographic Programming"" paradigm, which is focused on writing concurrent programs that are deadlock free by construction. This suggests a specific approach to programming, but it does not explicitly mention the integration of different programming paradigms.
 - The introduction of ""Minimal Choreographies (MC)"" as a language with essential primitives indicates a focus on the foundational elements of choreographic programming, but again, there is no mention of integrating different paradigms.
 - The mention of generating ""concurrent implementations of independent computations automatically"" implies a method for handling concurrent programming, but it does not specify how different paradigms are integrated.
 - The projection of a ""Turing complete fragment of MC to a process calculus"" suggests a synthesis or translation technique, but this is more about projecting one paradigm onto another rather than integrating multiple paradigms.
 - Overall, the abstract does not explicitly discuss the integration of different programming paradigms or provide specific mechanisms, models, constraints, or novel techniques for such integration.","- ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""
  - ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""
  - ""MC is minimal wrt Turing completeness: it implements all computable functions, and restricting its syntax breaks this property.""
  - ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""",,"- The abstract discusses the introduction of Minimal Choreographies (MC) as a language that includes only the essential primitives of the Choreographic Programming paradigm. This suggests a focus on minimalism and essential features rather than generic programming or abstraction mechanisms.
 - The mention of MC being ""minimal wrt Turing completeness"" indicates that the focus is on ensuring the language can implement all computable functions, but it does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not mention any specific mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.
 - The focus of the abstract is on the foundations of Choreographic Programming and ensuring deadlock-free concurrent programs, rather than on generic programming or abstraction mechanisms.","- ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""
  - ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""
  - ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""
  - ""MC is minimal wrt Turing completeness: it implements all computable functions, and restricting its syntax breaks this property.""",,"- The abstract introduces Choreographic Programming as a paradigm for writing concurrent programs that are deadlock free by construction. This is a novel insight as it addresses a significant challenge in concurrent programming.
 - The introduction of Minimal Choreographies (MC) as a language with only the essential primitives is a theoretical advancement. It provides a minimalistic approach to achieving Turing completeness, which is a fundamental property in computation.
 - The fact that MC is minimal with respect to Turing completeness and that restricting its syntax would break this property is a key theoretical contribution. It highlights the essential elements required for Turing completeness in choreographic programming.
 - The methodology developed in the study provides a natural notion of computation for choreographies, enabling the automatic generation of concurrent implementations. This is a significant theoretical advancement as it streamlines the process of creating concurrent programs.
 - The projection of a Turing complete fragment of MC to a process calculus that is both deadlock free and Turing complete is another theoretical contribution. It demonstrates the applicability and effectiveness of the choreographic programming paradigm in practical contexts."
Unifying Framework for Optimizations in non-boolean Formalisms,Yuliya Lierler,10.48550/arXiv.2206.07862,https://doi.org/10.48550/arXiv.2206.07862,Theory and Practice of Logic Programming,2,2022,"1. Primitive Name: Extended Weight Systems
  Definition: A unifying framework that eliminates syntactic distinctions between paradigms.
  Orthogonality Score: High
 

 2. Primitive Name: Extended Logics
  Definition: A framework capable of capturing formalisms with distinct kinds of variables.
  Orthogonality Score: High
 

 3. Primitive Name: Extended Modules (e-modules)
  Definition: Subsets of the language of an extended logic.
  Orthogonality Score: High
 

 4. Primitive Name: Ew-conditions
  Definition: Pairs consisting of an extended module and an expression with a weight, coefficient function, and level.
  Orthogonality Score: High
 

 5. Primitive Name: Ew-systems
  Definition: Pairs of an EAMS and a set of ew-conditions capturing hard and soft constraints.
  Orthogonality Score: High
 

 6. Primitive Name: Optimal Models
  Definition: Models satisfying equations based on weights and levels of ew-conditions.
  Orthogonality Score: High
 

 7. Primitive Name: Optimal Extended Models
  Definition: Extended models satisfying equations based on weights and levels of ew-conditions.
  Orthogonality Score: High","- Type of mathematical framework: Extended weight systems and abstract logic
 - Specific mathematical properties guaranteed: Formal properties of paradigms captured within the framework
 - Proof techniques used: Inductive argument
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Extended weight systems, extension of abstract modular systems to extended weighted systems.
 - Interaction models between paradigms: Unified view to boost cross-fertilization between approaches.
 - Constraints or challenges in paradigm integration: Syntactic distinctions between paradigms.
 - Novel translation or embedding techniques: Translational solver EZSMT extended with optimization support.","- Definition of ""concept"" used: Extended weight systems and abstract logic to unify paradigms.
 - Mechanisms for representing generic abstractions: Extended logic and EAMS to capture different formalisms.
 - Minimal type requirements identified: Coherence between extended logics and e-modules requires domain alignment.
 - Static checking or optimization strategies: Not explicitly addressed.","- Novel framework of extended weight systems unifying different automated reasoning paradigms.
 - Extension of abstract logic and w-systems to accommodate various types of variables.
 - Facilitation of cross-fertilization between fields through a unified perspective on optimization criteria.
 - Support for levels of optimization criteria.
 - Clear link between optimization statements and solving techniques across subfields.","- ""Here we propose a unifying framework of so-called extended weight systems that eliminates syntactic distinctions between paradigms.""
  - ""we extend the concepts of an abstract logic and w-systems to provide us with a framework capable to capture formalisms that utilize distinct kinds of variables in their languages.""
  - ""Definition 5 (Extended Modules (or e-modules) and their Models) Let L + be an extended logic. A theory of L +, that is, a subset of the language L L + is called an extended (model-based) L +-module (or an e-module, if the explicit reference to its logic is not necessary).""
  - ""Definition 7 (Ew-conditions and their models) An ew-condition in an extended logic L + is a pair (T, w; c@l) -consisting of an L + emodule T and an expression w; c@l, where
 

 • w is an integer,
 

 • c is a function from variables in ϒ T to reals, and • l is a positive integer.""
  - ""Definition 9 (Ew-systems and their models) A pair (H , Z ) consisting of an EAMS H and a set Z of ew-conditions so that every element in Z is coherent with H is called an ew-system (H and Z intuitively stand for hard and soft, respectively).""
  - ""Definition 13 (Optimal extended models of ew-systems) Let (I, ν) and (I ′ , ν ′ ) be extended models of ew-system W . Extended model (I ′ , ν ′ ) min- dominates (I, ν) if there exists a level l ∈ λ (W ) such that following conditions are satisfied:""",,"- The paper introduces a unifying framework called ""extended weight systems"" to eliminate syntactic differences between various automated reasoning paradigms.
 - The framework is built upon ""extended logics"" and ""extended weighted modular systems"" (ew-systems), which are central to capturing different formalisms.
 - ""Extended modules"" (e-modules) are defined as subsets of the language of an extended logic, serving as a fundamental component of ew-systems.
 - ""Ew-conditions"" are pairs consisting of an extended module and an expression with a weight, coefficient function, and level, which are used to define optimality criteria.
 - ""Ew-systems"" are pairs of an extended abstract modular system (EAMS) and a set of ew-conditions, which capture both hard and soft constraints of a problem.
 - The paper defines ""optimal models"" and ""optimal extended models"" of ew-systems, which are determined by equations that consider the weights and levels of ew-conditions.
 - These conceptual primitives are designed to be orthogonal and abstract, allowing for the capture of various formalisms and optimization criteria in a unified manner.","- ""we propose a unifying framework of so-called extended weight systems that eliminates syntactic distinctions between paradigms.""
  - ""We also study formal properties of the proposed systems that immediately translate into formal properties of paradigms that can be captured within our framework.""
  - ""we extend the concepts of an abstract logic and w-systems to provide us with a framework capable to capture formalisms that utilize distinct kinds of variables in their languages.""
  - ""We conclude by enumerating formal properties of these systems and an account of proofs for presented formal results.""
  - ""Lierler (2021) stated many interesting formal results for the case of w-systems; Lierler (2022) presented proofs for these results. Many of these results/proofs can be lifted to the case of ewsystems.""
  - ""The logic and structure of proofs for the case of ewsystems follows the proofs for the case of w-systems.""
  - ""In this section, we often remark on the connection to the proofs by Lierler (2022) and point at any details worth noting.""
  - ""Given recursive Definitions 10 and 11 of l-(min)-optimal (extended) models, inductive argument is a common technique in proof construction about properties of such models.""",,"- The paper introduces a ""unifying framework of so-called extended weight systems"" which suggests a mathematical framework for formalizing and guaranteeing properties of optimization statements across different automated reasoning paradigms.
 - The framework is based on ""extended weight systems"" and ""abstract logic,"" which are used to capture formalisms with distinct types of variables.
 - The paper discusses ""formal properties"" and ""proofs for presented formal results,"" indicating a focus on mathematical verification.
 - The use of ""inductive argument"" as a proof technique is mentioned, which is a common method in mathematical proofs.
 - The framework is designed to eliminate syntactic distinctions between paradigms, suggesting a focus on abstracting away from specific syntax to focus on semantic properties.
 - The paper does not explicitly mention a specific type of mathematical framework like type theory or category theory, but it does emphasize the use of abstract logic and extended weight systems.","- ""Here we propose a unifying framework of so-called extended weight systems that eliminates syntactic distinctions between paradigms.""
  - ""We also study formal properties of the proposed systems that immediately translate into formal properties of paradigms that can be captured within our framework.""
  - ""We trust that such birds eye view on these distinct paradigms will boost cross-fertilization between approaches used in design of algorithms supporting optimizations in distinct fields.""
  - ""This work provides theoretical grounds for devising translations for related optimization statements in CASP and OMT.""
  - ""We proposed the extension of abstract modular systems to extended weighted systems in a way that modern approaches to optimizations stemming from a variety of different logic based formalisms can be studied in unified terminological ways so that their differences and similarities become clear not only on intuitive but also formal level.""
  - ""The EZSMT (Shen and Lierler, 2018) system is a translational constraint answer set solver that translates its programs into satisfiability modulo theories formulas. We trust that results obtained here lay the groundwork for extending a ""translational"" solver EZSMT with the support for optimization statements.""",,"- The paper proposes a unifying framework called ""extended weight systems"" to integrate different automated reasoning paradigms by eliminating syntactic differences (Quote 1). This suggests a theoretical integration strategy.
 - The framework allows for the study of formal properties that can be applied to various paradigms, indicating a comparative analysis (Quote 2).
 - The paper aims to facilitate cross-fertilization between different fields by providing a unified view, which implies interaction models between paradigms (Quote 3).
 - The work provides theoretical grounds for translating optimization statements between paradigms like CASP and OMT, suggesting novel translation techniques (Quote 4).
 - The extension of abstract modular systems to extended weighted systems is a specific integration mechanism that allows for unified study of optimizations across different formalisms (Quote 5).
 - The paper mentions the EZSMT system as an example of a translational solver that can be extended with optimization support, indicating a novel embedding technique (Quote 6).","- ""Here we propose a unifying framework of so-called extended weight systems that eliminates syntactic distinctions between paradigms.""
  - ""we extend the concepts of an abstract logic and w-systems to provide us with a framework capable to capture formalisms that utilize distinct kinds of variables in their languages.""
  - ""the concept of extended logic is helpful in capturing problems expressed as satisfiability modulo theories (SMT).""
  - ""extended logics (L, σ , D,V, sem) and (L ′ , σ ′ , D ′ ,V ′ , sem ′ ) (and, respectively e-modules in these logics) coherent if D = D ′ , whenever V ∩V ′ = / 0.""
  - ""A set of coherent e-modules, possibly in different logics, over different vocabularies and/or variables, is an extended (model-based) abstract modular system (EAMS).""
  - ""the concept of EAMS is a generalization of AMS by Lierler and Truszczynski (2015).""
  - ""We trust that such birds eye view on these distinct paradigms will boost cross-fertilization between approaches used in design of algorithms supporting optimizations in distinct fields.""",,"- The paper introduces a ""unifying framework"" and ""extended weight systems"" to eliminate syntactic differences between various automated reasoning paradigms, indicating a focus on abstraction.
 - The extension of abstract logic and w-systems suggests a mechanism for representing generic abstractions by capturing different types of variables and formalisms.
 - The concept of coherence between extended logics and e-modules implies a type of genericity where domains must align when variables overlap, which can be seen as a minimal type requirement.
 - The use of EAMS as a generalization of AMS indicates a mechanism for abstraction, allowing for the combination of different logics and vocabularies.
 - The paper does not explicitly discuss static checking or optimization strategies in the context of generic programming, but the framework itself is designed to facilitate cross-fertilization and abstraction.","- ""Here we propose a unifying framework of so-called extended weight systems that eliminates syntactic distinctions between paradigms.""
  - ""we extend the concepts of an abstract logic and w-systems to provide us with a framework capable to capture formalisms that utilize distinct kinds of variables in their languages.""
  - ""We trust that such birds eye view on these distinct paradigms will boost cross-fertilization between approaches used in design of algorithms supporting optimizations in distinct fields.""
  - ""We proposed the extension of abstract modular systems to extended weighted systems in a way that modern approaches to optimizations stemming from a variety of different logic based formalisms can be studied in unified terminological ways so that their differences and similarities become clear not only on intuitive but also formal level.""
  - ""The framework also provides immediate support for the concept of levels of optimization criteria.""
  - ""We trust that establishing clear link between optimization statements, criteria, and solving in distinct automated reasoning subfields is a truly fruitful endeavor allowing a streamlined cross-fertilization between the fields.""",,"- The paper introduces a novel framework called ""extended weight systems"" that unifies different automated reasoning paradigms by eliminating syntactic differences, which is a significant theoretical contribution (Quote 1).
 - The extension of abstract logic and w-systems to accommodate various types of variables is a theoretical advancement, as it allows for a broader range of formalisms to be captured within the framework (Quote 2).
 - The framework is designed to facilitate cross-fertilization between different fields by providing a unified perspective on optimization criteria, which has potential implications for programming language design by enabling more integrated and efficient optimization techniques (Quotes 3 and 6).
 - The framework provides support for the concept of levels of optimization criteria, which is a novel aspect that enhances the flexibility and applicability of the framework (Quote 5).
 - The paper aims to establish a clear link between optimization statements and solving techniques across different subfields, which is a theoretical contribution towards a more unified understanding of optimization in automated reasoning (Quote 6)."
Unification Modulo an Equality Theory for Equational Logic Programming,Jia-Huai You,10.1016/0022-0000(91)90039-8,https://doi.org/10.1016/0022-0000(91)90039-8,Journal of computer and system sciences (Print),13,1991,Not specified (the abstract does not explicitly define or list specific conceptual primitives),Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Unification in equational theories
 - Interaction models between paradigms: Not explicitly mentioned
 - Constraints or challenges in paradigm integration: Not explicitly mentioned
 - Any novel translation or embedding techniques: Novel technique of transforming narrowing derivations",Generic programming not extensively addressed,"- Key novel insights: Introduction of equational logic programming as an extended paradigm; definition of an equality theory for O'Donnell's equational language.
 - Theoretical advancements: Novel technique for transforming narrowing derivations; demonstration of complete and minimal sets of solutions under the equality theory.
 - Potential implications: Enhancements in programming language design through the use of equational logic programming and the defined equality theory.","- ""We define an equality theory for this language which adequately captures the intended notion of equational programming in the original language.""
  - ""We present a novel technique of transforming narrowing derivations and show the effect of such a transformation on the generality of solutions.""
  - ""Central to the notion of equational logic programming is the problem of solving equations, which is also called unification in equational theories.""
  - ""As the main result of this paper we show semantically and operationally that complete and minimal sets of solutions under this equality theory always exist and can be generated by a special class of narrowing derivations.""
  - ""Equational logic programming is an extended programming paradigm of equational programming.""",,"- The abstract discusses equational logic programming as an extension of equational programming, indicating a focus on solving equations or unification in equational theories.
 - The mention of defining an ""equality theory"" suggests a conceptual framework for understanding equational programming, but it does not explicitly list specific primitives.
 - The abstract refers to a ""novel technique of transforming narrowing derivations,"" which implies a methodological contribution but does not specify conceptual primitives.
 - The focus on ""complete and minimal sets of solutions"" and their generation through ""a special class of narrowing derivations"" suggests operational results rather than explicit definitions of conceptual primitives.
 - Overall, the abstract does not explicitly define or list specific conceptual primitives for reconstructing programming paradigms.","- ""We present a novel technique of transforming narrowing derivations and show the effect of such a transformation on the generality of solutions.""
  - ""As the main result of this paper we show semantically and operationally that complete and minimal sets of solutions under this equality theory always exist and can be generated by a special class of narrowing derivations.""
  - ""We define an equality theory for this language which adequately captures the intended notion of equational programming in the original language.""
  - ""Central to the notion of equational logic programming is the problem of solving equations, which is also called unification in equational theories.""
  - ""Equational logic programming is an extended programming paradigm of equational programming.""",,"- The abstract discusses equational logic programming and the problem of solving equations, which suggests a focus on equational theories.
 - The mention of defining an ""equality theory"" indicates a mathematical framework related to equational logic.
 - The abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory.
 - The use of ""novel technique of transforming narrowing derivations"" and the focus on ""semantically and operationally"" showing the existence of complete and minimal sets of solutions suggest a proof methodology involving operational semantics.
 - The abstract does not provide specific details about the mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""Central to the notion of equational logic programming is the problem of solving equations, which is also called unification in equational theories.""
  - ""We define an equality theory for this language which adequately captures the intended notion of equational programming in the original language.""
  - ""Equational logic programming is an extended programming paradigm of equational programming.""
  - ""As the main result of this paper we show semantically and operationally that complete and minimal sets of solutions under this equality theory always exist and can be generated by a special class of narrowing derivations.""
  - ""We present a novel technique of transforming narrowing derivations and show the effect of such a transformation on the generality of solutions.""",,"- The abstract discusses the integration of equational programming and logic programming paradigms, as indicated by the term ""equational logic programming.""
 - The mention of ""unification in equational theories"" suggests a mechanism for integrating these paradigms by solving equations, which is a key aspect of equational logic programming.
 - The definition of an ""equality theory"" implies a theoretical integration strategy that captures the essence of equational programming within the logic programming framework.
 - The ""novel technique of transforming narrowing derivations"" could be considered a novel translation or embedding technique, as it involves transforming one type of derivation into another, which is a form of integration.
 - The abstract does not explicitly mention interaction models or constraints/challenges in paradigm integration, but it does focus on the theoretical and operational aspects of integrating these paradigms.","- ""Equational logic programming is an extended programming paradigm of equational programming.""
  - ""We define an equality theory for this language which adequately captures the intended notion of equational programming in the original language.""
  - ""We present a novel technique of transforming narrowing derivations and show the effect of such a transformation on the generality of solutions.""
  - ""Central to the notion of equational logic programming is the problem of solving equations, which is also called unification in equational theories.""
  - ""As the main result of this paper we show semantically and operationally that complete and minimal sets of solutions under this equality theory always exist and can be generated by a special class of narrowing derivations.""",,"- The abstract discusses equational logic programming and the problem of solving equations, which is central to this paradigm. This suggests a focus on logical and mathematical aspects rather than generic programming or abstraction mechanisms.
 - The mention of defining an equality theory and transforming narrowing derivations indicates a focus on theoretical foundations and operational techniques rather than generic programming or abstraction.
 - The abstract does not explicitly mention generic programming, abstraction mechanisms, type systems, or static checking strategies, which are key components of genericity and abstraction.
 - The focus on solving equations and unification in equational theories does not directly relate to generic programming or conceptual abstraction as typically understood in programming paradigms.","- ""Equational logic programming is an extended programming paradigm of equational programming.""
  - ""Central to the notion of equational logic programming is the problem of solving equations, which is also called unification in equational theories.""
  - ""We define an equality theory for this language which adequately captures the intended notion of equational programming in the original language.""
  - ""We present a novel technique of transforming narrowing derivations and show the effect of such a transformation on the generality of solutions.""
  - ""As the main result of this paper we show semantically and operationally that complete and minimal sets of solutions under this equality theory always exist and can be generated by a special class of narrowing derivations.""",,"- The abstract introduces equational logic programming as an extension of equational programming, indicating a new paradigm.
 - The focus on solving equations (unification in equational theories) suggests a theoretical contribution in addressing this problem.
 - The definition of an equality theory for O'Donnell's equational language is a key theoretical contribution, as it captures the intended notion of equational programming.
 - The presentation of a novel technique for transforming narrowing derivations is a significant theoretical advancement, as it impacts the generality of solutions.
 - The demonstration that complete and minimal sets of solutions exist and can be generated operationally and semantically under this equality theory is a major theoretical contribution, ensuring the feasibility and effectiveness of the approach."
Modular Monadic Semantics for Aspect-Oriented Programming,Garrin Kimmell,-,-,-,0,2004,"1. Primitive Name: Functors
  Definition: Algebraic data types modeled as least fixed-points of functors, where each language element is represented as a single functor.
  Orthogonality Score: High (implied by independent specification and separation of semantics)
 2. Primitive Name: Updatable Algebras
  Definition: Data types with function-valued members, allowing for dynamic updates and used to specify traditional language constructs and aspect language semantics.
  Orthogonality Score: High (implied by independent specification and separation of semantics)","- Type of mathematical framework: Modular monadic semantics, Category theory
 - Specific mathematical properties guaranteed: Independent specification of language elements as algebras over a functor
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Modular monadic semantics with updatable algebras.
 - Interaction models between paradigms: Weaving different behaviors into a complete program.
 - Constraints or challenges in paradigm integration: Difficulty in reasoning about interactions of different aspects.
 - Novel translation or embedding techniques: Use of updatable algebras to represent language elements.","- Definition of ""concept"" used: Not explicitly mentioned
 - Mechanisms for representing generic abstractions: Representation of language elements as functors and algebras; use of updatable algebras
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Novel insights: Use of modular monadic semantics for aspect-oriented languages; representation of algebras as data types with function-valued members for dynamic updates.
 - Theoretical advancements: Clear separation between aspect meta-language and object language semantics; facilitation of aspect weaving as metaprogramming.
 - Potential implications: Enhanced modularity and composability in programming language design; separation of dynamic and static semantics.","- ""Our work builds on the idea of semantics as functors.""
  - ""A solution to this problem models algebraic data types as least fixed-points of functors. Each language element is represented as a single functor.""
  - ""In contrast to the work above, which defines an algebra as a simple function over a functor, we represent an algebra as an explicitly as a data type with function valued members [9].""
  - ""Traditional language constructs are specified as updatable algebras. Aspect language semantics are specified as transformations on those semantic algebras.""
  - ""Modular monadic semantics [2, 11, 13] was first introduced as a method for independently specifying denotations for various language constructs.""",,"- The abstract discusses the use of ""modular monadic semantics"" as a method for specifying the semantics of aspect-oriented languages. This suggests that the conceptual primitives are related to this semantic framework.
 - The mention of ""algebraic data types as least fixed-points of functors"" and ""each language element is represented as a single functor"" indicates that functors are a key conceptual primitive in this framework.
 - The abstract also introduces the concept of ""updatable algebras,"" which are represented as data types with function-valued members. This is another conceptual primitive, as it allows for dynamic updates and is used to specify traditional language constructs and aspect language semantics.
 - The abstract does not provide explicit names for these primitives, but they are clearly defined in terms of their roles and characteristics within the modular monadic semantics framework.
 - The level of abstraction is high, as these primitives are used to represent and manipulate language constructs at a semantic level.
 - Orthogonality is implied by the ability to specify language elements independently and the separation between aspect meta-language and object language semantics.","- ""This research examines the use of modular monadic semantics to specify the semantics of aspect oriented languages.""
  - ""Modular monadic semantics [2, 11, 13] was first introduced as a method for independently specifying denotations for various language constructs.""
  - ""A solution to this problem models algebraic data types as least fixed-points of functors.""
  - ""Each language element is represented as a single functor.""
  - ""This model allows language elements to be specified completely independently as algebras over a functor [4, 1, 6, 7, 8, 4].""
  - ""An interpretation is then simply the folding of the collection of algebras for the language.""
  - ""Our work builds on the idea of semantics as functors.""
  - ""In contrast to the work above, which defines an algebra as a simple function over a functor, we represent an algebra as an explicitly as a data type with function valued members [9].""
  - ""The use of updatable algebras facilitate the treatment of the aspect weaving process formally as a metaprogramming activity.""
  - ""By using modular monadic semantics with updatable algebras, we expect to realize several benefits.""",,"- The abstract discusses the use of ""modular monadic semantics"" as the mathematical framework for specifying the semantics of aspect-oriented languages. This indicates that the type of mathematical framework used is modular monadic semantics.
 - The framework involves modeling algebraic data types as ""least fixed-points of functors,"" which is a characteristic of category theory. This suggests that category theory is a part of the mathematical framework.
 - The abstract mentions that each language element is represented as a ""single functor,"" which is a concept from category theory. This further supports the use of category theory.
 - The framework allows for language elements to be specified independently as ""algebras over a functor,"" which is a property guaranteed by this framework.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, but it does highlight the benefits of composability and separation of semantics.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""Aspect-oriented programming [5] is a paradigm where different facets of a system’s behavior are programmed independently.""
  - ""Aspect languages then provide a mechanism for “weaving” the different behavior into a complete program.""
  - ""A principal criticism of the paradigm is the difficulty in reasoning about the interaction of different aspects in a woven system.""
  - ""The aspect language is expressed in terms of the object language, eliminating the distinction between the aspect meta-language and the object language.""
  - ""Modular monadic semantics [2, 11, 13] was first introduced as a method for independently specifying denotations for various language constructs.""
  - ""Our work builds on the idea of semantics as functors.""
  - ""In contrast to the work above, which defines an algebra as a simple function over a functor, we represent an algebra as an explicitly as a data type with function valued members [9].""
  - ""The use of updatable algebras facilitate the treatment of the aspect weaving process formally as a metaprogramming activity.""
  - ""Traditional language constructs are specified as updatable algebras. Aspect language semantics are specified as transformations on those semantic algebras.""
  - ""By using modular monadic semantics with updatable algebras, we expect to realize several benefits. Composability allows experimentation with various AOP semantic definitions.""
  - ""Additionally, updatable algebras provide a clear separation between the aspect meta-language semantics and the object language semantics, simplifying reasoning about a composed system.""",,"- The abstract discusses aspect-oriented programming (AOP) as a paradigm where different system behaviors are programmed independently and then woven together.
 - The integration mechanism proposed is the use of ""modular monadic semantics"" to specify the semantics of AOP languages, which allows for independent specification of language constructs.
 - The interaction model involves ""weaving"" different behaviors into a complete program, with aspect languages expressed in terms of the object language.
 - A challenge in paradigm integration is the difficulty in reasoning about the interaction of different aspects in a woven system.
 - The novel technique proposed is the use of ""updatable algebras"" to represent language elements, which facilitates the treatment of aspect weaving as a metaprogramming activity and provides a clear separation between aspect and object language semantics.
 - The abstract does not explicitly mention any comparative analysis or theoretical integration strategies beyond the use of modular monadic semantics and updatable algebras.","- ""Modular monadic semantics [2, 11, 13] was first introduced as a method for independently specifying denotations for various language constructs.""
  - ""A solution to this problem models algebraic data types as least fixed-points of functors. Each language element is represented as a single functor.""
  - ""This model allows language elements to be specified completely independently as algebras over a functor [4, 1, 6, 7, 8, 4].""
  - ""An interpretation is then simply the folding of the collection of algebras for the language.""
  - ""Our work builds on the idea of semantics as functors. In contrast to the work above, which defines an algebra as a simple function over a functor, we represent an algebra as an explicitly as a data type with function valued members [9].""
  - ""Doing this allows us to dynamically update the algebras.""
  - ""The use of updatable algebras facilitate the treatment of the aspect weaving process formally as a metaprogramming activity.""
  - ""Traditional language constructs are specified as updatable algebras. Aspect language semantics are specified as transformations on those semantic algebras.""",,"- The abstract discusses the use of modular monadic semantics, which involves representing language elements as functors and algebras. This suggests a mechanism for generic programming by allowing independent specification of language constructs.
 - The representation of language elements as functors and algebras provides a way to abstractly define generic constructs, which is a key aspect of generic programming.
 - The use of updatable algebras allows for dynamic updates, which can be seen as a mechanism for representing generic abstractions that can be modified or extended.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on modular monadic semantics implies a structured approach to abstraction.
 - The abstract does not provide a specific definition of ""concept"" used in the study, nor does it explicitly discuss static checking or optimization strategies.","- ""This research examines the use of modular monadic semantics to specify the semantics of aspect oriented languages.""
  - ""Our work builds on the idea of semantics as functors.""
  - ""In contrast to the work above, which defines an algebra as a simple function over a functor, we represent an algebra as an explicitly as a data type with function valued members""
  - ""Doing this allows us to dynamically update the algebras.""
  - ""The use of updatable algebras facilitate the treatment of the aspect weaving process formally as a metaprogramming activity.""
  - ""By using modular monadic semantics with updatable algebras, we expect to realize several benefits.""
  - ""Composability allows experimentation with various AOP semantic definitions.""
  - ""updatable algebras provide a clear separation between the aspect meta-language semantics and the object language semantics, simplifying reasoning about a composed system.""
  - ""monadic semantics provides a convenient mechanism for staging compilers, allowing the separation of the dynamic and static semantics of aspect languages.""",,"- The abstract introduces the use of modular monadic semantics for specifying the semantics of aspect-oriented languages, which is a novel approach in this context.
 - The representation of algebras as data types with function-valued members is a theoretical advancement beyond existing approaches, as it allows for dynamic updates and facilitates the formal treatment of aspect weaving as metaprogramming.
 - The use of updatable algebras provides a clear separation between aspect meta-language and object language semantics, which is a significant theoretical contribution for simplifying reasoning about composed systems.
 - The composability and staging mechanisms enabled by modular monadic semantics are novel insights that allow for experimentation with different semantic definitions and separation of dynamic and static semantics, respectively.
 - These contributions have potential implications for programming language design by enhancing the modularity and composability of aspect-oriented programming languages."
Verifiable and Executable Logic Specifications of Concurrent Objects in s,"Luls Caires, Luis Monteiro",-,-,-,1,2006,"1. Primitive Name: π-calculus
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed
 2. Primitive Name: Logic of hereditary Harrop formulas
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed
 3. Primitive Name: Reduction and state-oriented style of specification
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed
 4. Primitive Name: Object-oriented constructs
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed",Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),"- Specific integration mechanisms proposed: Encoding of π-calculus and logic of hereditary Harrop formulas into ""s,"" and encoding of ""s"" into classical linear logic.
 - Interaction models between paradigms: Use of ""s"" as a specification language for operational semantics and as a meta-language for defining operational semantics and program verification logics.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Encoding of ""s"" into classical linear logic, aligning computations with proofs.",Generic programming not extensively addressed,"- Key novel insights: Integration of reduction and state-oriented style with relational style of logic programming; encoding in classical linear logic for proof correspondence.
 - Theoretical advancements: Unified scenario for declarative object-oriented specification of concurrent systems; use of E~ framework for modeling and reasoning.
 - Potential implications: Advancements in programming language design through a unified specification language and meta-language for operational semantics and verification logics.","- ""In [1] we presented s a simple language that supports the reduction and state-oriented style of specification of mobile process calculi without compromising the relational style of specification typical of logic programming.""
  - ""In particular, we have shown that both the 7rcalculus [10] and a version of the logic of hereditary Harrop formulas [7] can be adequately encoded into""
  - ""As illustrated in [2],/:~ suits itself well as a gpecification language of the operational semantics of programming languages with concurrent and logic features; we also proposed/:~ as a meta-language for the compositional definition of operational semantics and program verification logics of languages of such a kind.""
  - ""Herein, we pursue this general directions, picking the case of declarative object-oriented specification of concurrent systems.""
  - ""In this paper, we develop a contribution in this general theme, stressing the instrumental use of the E~ framework in the spirit stated above.""
  - ""More specifically, we consider the case of a declarative specification language and program logic for concurrent objects that provides a unified scenario for specifying and reasoning about systems.""",,"- The abstract discusses the language ""s"" and its ability to encode both the π-calculus and a version of the logic of hereditary Harrop formulas. This suggests that these are conceptual primitives used in the study.
 - The language ""s"" is described as supporting both reduction and state-oriented styles of specification, which are likely conceptual primitives in the context of programming paradigms.
 - The abstract mentions the use of ""s"" as a specification language for operational semantics and as a meta-language for compositional definitions, indicating that these are also conceptual primitives.
 - The focus on declarative object-oriented specification of concurrent systems suggests that object-oriented constructs are another set of conceptual primitives.
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality.","- ""The ""proof-search as computation"" paradigm has inspired the design of several programming and specification languages""
  - ""we presented s a simple language that supports the reduction and state-oriented style of specification of mobile process calculi without compromising the relational style of specification typical of logic programming.""
  - ""both the 7rcalculus [10] and a version of the logic of hereditary Harrop formulas [7] can be adequately encoded into""
  - ""s can itself be encoded in classical linear logic, in such a way that successful computations correspond to proofs [3].""
  - ""we pursue this general directions, picking the case of declarative object-oriented specification of concurrent systems.""
  - ""we develop a contribution in this general theme, stressing the instrumental use of the E~ framework in the spirit stated above.""
  - ""we consider the case of a declarative specification language and program logic for concurrent objects that provides a unified scenario for specifying and reasoning about systems.""",,"- The abstract mentions the ""proof-search as computation"" paradigm, which suggests a connection to proof theory and possibly type theory.
 - The language ""s"" is described as supporting both reduction and state-oriented specification styles, which are typical of process calculi and logic programming, respectively.
 - The encoding of ""s"" into classical linear logic indicates that this framework is used to formalize properties, as successful computations correspond to proofs.
 - The mention of the ""E~ framework"" suggests a specific mathematical framework, but its details are not explicitly provided in the abstract.
 - The abstract does not specify the type of mathematical framework beyond the mention of classical linear logic and the encoding of ""s"" into it.
 - There is no explicit mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.","- ""In [1] we presented s a simple language that supports the reduction and state-oriented style of specification of mobile process calculi without compromising the relational style of specification typical of logic programming.""
  - ""In particular, we have shown that both the 7rcalculus [10] and a version of the logic of hereditary Harrop formulas [7] can be adequately encoded into""
  - ""On the other hand, s can itself be encoded in classical linear logic, in such a way that successful computations correspond to proofs [3].""
  - ""As illustrated in [2],/:~ suits itself well as a gpecification language of the operational semantics of programming languages with concurrent and logic features; we also proposed/:~ as a meta-language for the compositional definition of operational semantics and program verification logics of languages of such a kind.""
  - ""Herein, we pursue this general directions, picking the case of declarative object-oriented specification of concurrent systems.""
  - ""Several embeddings of object-oriented constructs into variants of r-calculus have been presented in the li terature [12, 16, 14].""
  - ""In this paper, we develop a contribution in this general theme, stressing the instrumental use of the E~ framework in the spirit stated above.""
  - ""More specifically, we consider the case of a declarative specification language and program logic for concurrent objects that provides a unified scenario for specifying and reasoning about systems.""",,"- The abstract discusses the integration of different programming paradigms through the language ""s,"" which supports both the reduction and state-oriented style of specification typical of mobile process calculi and the relational style of specification typical of logic programming.
 - It mentions that both the π-calculus and a version of the logic of hereditary Harrop formulas can be encoded into ""s,"" indicating a mechanism for integrating these paradigms.
 - The language ""s"" can itself be encoded in classical linear logic, suggesting a novel translation technique that aligns computations with proofs.
 - The abstract highlights the use of ""s"" as a specification language for operational semantics and as a meta-language for defining operational semantics and program verification logics, which implies an interaction model between paradigms.
 - The study focuses on declarative object-oriented specification of concurrent systems, suggesting a novel approach to integrating object-oriented programming with concurrent systems.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it implies that the integration is facilitated by the encoding and embedding techniques described.","- ""Herein, we pursue this general directions, picking the case of declarative object-oriented specification of concurrent systems.""
  - ""In this paper, we develop a contribution in this general theme, stressing the instrumental use of the E~ framework in the spirit stated above.""
  - ""More specifically, we consider the case of a declarative specification language and program logic for concurrent objects that provides a unified scenario for specifying and reasoning about systems.""
  - ""In [1] we presented s a simple language that supports the reduction and state-oriented style of specification of mobile process calculi without compromising the relational style of specification typical of logic programming.""
  - ""On the other hand, s can itself be encoded in classical linear logic, in such a way that successful computations correspond to proofs [3].""",,"- The abstract discusses the language ""s"" and its ability to support both reduction and state-oriented specification styles, which suggests a focus on flexibility and abstraction.
 - The encoding of ""s"" in classical linear logic implies a formal approach to abstraction, as it relates computations to proofs.
 - The mention of a ""declarative object-oriented specification of concurrent systems"" suggests an emphasis on abstracting away from operational details, focusing on declarative specifications.
 - The abstract does not explicitly mention generic programming or type systems, nor does it discuss minimal type requirements or static checking strategies.
 - The focus is on the use of the ""E~ framework"" for declarative specifications and reasoning about concurrent systems, which implies an abstraction mechanism but does not explicitly address generic programming.","- ""In [1] we presented s a simple language that supports the reduction and state-oriented style of specification of mobile process calculi without compromising the relational style of specification typical of logic programming.""
  - ""On the other hand, s can itself be encoded in classical linear logic, in such a way that successful computations correspond to proofs [3].""
  - ""As illustrated in [2],/:~ suits itself well as a gpecification language of the operational semantics of programming languages with concurrent and logic features; we also proposed/:~ as a meta-language for the compositional definition of operational semantics and program verification logics of languages of such a kind.""
  - ""Herein, we pursue this general directions, picking the case of declarative object-oriented specification of concurrent systems.""
  - ""In this paper, we develop a contribution in this general theme, stressing the instrumental use of the E~ framework in the spirit stated above.""
  - ""More specifically, we consider the case of a declarative specification language and program logic for concurrent objects that provides a unified scenario for specifying and reasoning about systems.""",,"- The abstract introduces a language ""s"" that combines the reduction and state-oriented style of mobile process calculi with the relational style of logic programming, which is a novel integration.
 - The language ""s"" can be encoded in classical linear logic, which is a theoretical advancement as it allows successful computations to correspond to proofs.
 - The language is proposed as a specification language for operational semantics and a meta-language for compositional definitions, which is a theoretical contribution to programming language design.
 - The paper focuses on declarative object-oriented specification of concurrent systems, providing a unified scenario for specification and reasoning, which is a novel approach compared to existing operational semantics or type-focused approaches.
 - The use of the E~ framework is highlighted as an instrumental contribution, indicating a theoretical advancement in how concurrent systems are modeled and reasoned about."
A history of the Oz multiparadigm language,"P. V. Roy, Seif Haridi, C. Schulte, G. Smolka",10.1145/3386333,https://doi.org/10.1145/3386333,Proc. ACM Program. Lang.,5,2020,Not specified (the paper describes the kernel language approach as a whole rather than listing individual conceptual primitives),Not specified (the paper does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Kernel language approach with a layered structure.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"Theoretical contributions include the development of a kernel language approach that supports multiparadigm programming within a single language, organized in a layered structure. This approach is designed to be directly useful to programmers, distinguishing it from other formal models and facilitating the integration of different paradigms in a clean and simple manner. These innovations have implications for creating versatile programming languages that can seamlessly integrate multiple paradigms.","- ""The Oz language supports the combination of paradigms within a single language by using a kernel language approach.""
  - ""The kernel language is organized in a layered structure, which makes it straightforward to write programs that use different paradigms in different parts.""
  - ""The Oz 3 language, which we will refer to simply as Oz, is defined in terms of the kernel language by adding syntactic sugar and linguistic abstractions.""
  - ""The kernel language is important to define precisely the Oz language and its semantics.""
  - ""The kernel language contains concepts directly useful to programmers.""
  - ""The kernel language is useful to understand how programs execute (in fact, the Oz implementation can run kernel language programs directly), but it is usually not the best way to write practical programs.""
  - ""The kernel language is organized in a layered structure,""
  - ""The kernel language tends to be larger, and while it is usually not minimal, it does respect other formal requirements such as factorization and compositionality.""
  - ""the kernel language is designed to be directly useful to the programmer.""",,"- The paper discusses the kernel language approach as a foundational aspect of the Oz language, which is designed to support multiple programming paradigms. This kernel language is a formal model with mathematical semantics, intended to be directly useful to programmers.
 - The kernel language is organized in a layered structure, allowing for the straightforward combination of different paradigms within a single program.
 - The kernel language is not minimal but respects formal requirements such as factorization and compositionality, making it larger and more practical for programmers.
 - The kernel language approach is central to defining the Oz language and its semantics, providing a basis for understanding program execution and supporting the integration of multiple paradigms.
 - The paper does not explicitly list individual conceptual primitives with precise definitions and orthogonality scores. Instead, it describes the kernel language as a whole as the conceptual framework for supporting multiparadigm programming.","- ""The Oz language supports the combination of paradigms within a single language by using a kernel language approach.""
  - ""The kernel language contains concepts directly useful to programmers.""
  - ""The Oz 3 language, which we will refer to simply as Oz, is defined in terms of the kernel language by adding syntactic sugar and linguistic abstractions.""
  - ""The kernel language is important to define precisely the Oz language and its semantics.""
  - ""The kernel language is useful to understand how programs execute (in fact, the Oz implementation can run kernel language programs directly), but it is usually not the best way to write practical programs.""
  - ""The kernel language is organized in a layered structure, which makes it straightforward to write programs that use different paradigms in different parts.""
  - ""The CTM textbook presented in Section 4.1 is organized around this kernel language: each chapter corresponds to a particular subset of the kernel language.""
  - ""the kernel language is designed to be directly useful to the programmer.""",,"- The paper discusses the use of a ""kernel language"" as a formal model with mathematical semantics, which suggests a type of mathematical framework.
 - The kernel language is described as being similar to a foundational calculus but with a different goal, indicating it might be related to type theory or a similar formal system.
 - The paper does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it detail specific mathematical properties guaranteed or proof techniques used.
 - The focus on the kernel language as a formal model suggests that it might be used for formal verification, but this is not explicitly stated.
 - The paper does not provide specific details about limitations or constraints of the framework.","- ""Oz is a programming language designed to support multiple programming paradigms in a clean factored way that is easy to program despite its broad coverage.""
  - ""The Oz language supports the combination of paradigms within a single language by using a kernel language approach.""
  - ""Starting with a small language containing just a few concepts, we first explore how to program and reason in this language. We then add concepts one by one to overcome limitations in expressiveness.""
  - ""This design process resulted in a uniform framework that covers all major programming paradigms that were known at that time.""
  - ""the Oz language cleanly and simply supports programs that use multiple paradigms.""
  - ""The kernel language is organized in a layered structure, which makes it straightforward to write programs that use different paradigms in different parts.""
  - ""The Oz 3 language, which we will refer to simply as Oz, is defined in terms of the kernel language by adding syntactic sugar and linguistic abstractions.""
  - ""To make explicit the multiparadigm nature of Oz, the kernel language is organized in a layered structure. Each paradigm is defined by a set of concepts within this structure.""
  - ""The kernel language contains concepts directly useful to programmers. The programmer can write practical programs directly in the kernel language, and define linguistic abstractions to make these programs more compact and readable""
  - ""The practical Oz language seen by programmers extends the kernel language by adding syntactic sugar and linguistic abstractions.""
  - ""Oz can express many programming techniques of different paradigms and use them together cleanly in the same program.""",,"- The paper describes Oz as a language designed to support multiple programming paradigms, indicating a focus on integration.
 - The kernel language approach is highlighted as the mechanism for integrating different paradigms, suggesting a layered structure where each paradigm is defined by a set of concepts.
 - The paper mentions that the kernel language is designed to be directly useful to programmers, allowing them to write programs that use multiple paradigms in a straightforward manner.
 - The use of syntactic sugar and linguistic abstractions is mentioned as a way to extend the kernel language, making it more practical for programming.
 - The paper does not explicitly mention specific interaction models or constraints in paradigm integration, nor does it discuss novel translation or embedding techniques in detail.","- ""The Oz language supports the combination of paradigms within a single language by using a kernel language approach.""
  - ""The kernel language is organized in a layered structure, which makes it straightforward to write programs that use different paradigms in different parts.""
  - ""The kernel language contains concepts directly useful to programmers.""
  - ""The kernel language is important to define precisely the Oz language and its semantics.""
  - ""The practical Oz language seen by programmers extends the kernel language by adding syntactic sugar and linguistic abstractions.""
  - ""A linguistic abstraction is a construct that defines a syntax for an abstraction, i.e., a new programmer concept.""
  - ""Oz provides common linguistic abstractions such as functions (keyword fun), classes (keywords class, self, meth), loops (keyword for), and locks (keyword lock).""
  - ""The relational programming primitives choice and fail are also provided as linguistic abstractions.""
  - ""The translation of these linguistic abstractions into kernel language defines their semantics.""
  - ""The kernel language is useful to understand how programs execute (in fact, the Oz implementation can run kernel language programs directly), but it is usually not the best way to write practical programs.""
  - ""The Oz 3 language, which we will refer to simply as Oz, is defined in terms of the kernel language by adding syntactic sugar and linguistic abstractions.""
  - ""The kernel language tends to be larger, and while it is usually not minimal, it does respect other formal requirements such as factorization and compositionality.""",,"- The paper discusses the Oz programming language and its design principles, focusing on its multiparadigm nature and the use of a kernel language.
 - The kernel language is described as a formal model with a mathematical semantics, designed to be directly useful to programmers.
 - The kernel language is organized in a layered structure, which allows for the combination of different programming paradigms.
 - The paper mentions linguistic abstractions as a way to extend the kernel language with new programmer concepts.
 - The paper does not explicitly address generic programming or abstraction mechanisms in the context of genericity.
 - The focus is on the multiparadigm nature and the kernel language approach rather than generic programming.","- ""The Oz language supports the combination of paradigms within a single language by using a kernel language approach.""
  - ""The kernel language is organized in a layered structure, which makes it straightforward to write programs that use different paradigms in different parts.""
  - ""the Oz language cleanly and simply supports programs that use multiple paradigms.""
  - ""The Oz 3 language, which we will refer to simply as Oz, is defined in terms of the kernel language by adding syntactic sugar and linguistic abstractions.""
  - ""The kernel language is important to define precisely the Oz language and its semantics.""
  - ""the kernel language is designed to be directly useful to the programmer.""
  - ""The kernel language contains concepts directly useful to programmers.""
  - ""the kernel language, is less well-known.""",,"- The paper highlights the novelty of the Oz language in its ability to support multiple programming paradigms within a single language framework. This is achieved through the use of a kernel language approach, which is a significant theoretical contribution.
 - The kernel language is organized in a layered structure, allowing for straightforward integration of different paradigms. This structure is a novel insight as it facilitates multiparadigm programming in a clean and simple manner.
 - The kernel language is designed to be directly useful to programmers, distinguishing it from other formal models like foundational calculus, which are typically more abstract and less directly applicable to practical programming.
 - The paper emphasizes that the kernel language approach is less well-known, suggesting that it represents a theoretical advancement beyond existing approaches in programming language design.
 - The implications for programming language design include the potential for creating languages that can seamlessly integrate multiple paradigms, making them more versatile and powerful for developers."
Compositional theories for embedded languages,"Davide Trotta, M. Zorzi",-,-,arXiv.org,0,2020,Not specified (the abstract does not provide explicit definitions or details about the conceptual primitives),"- Type of mathematical framework: Type theory, Category theory
 - Specific mathematical properties guaranteed: Soundness, Completeness
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Embedded programming style splitting syntax into host and core languages.
 - Interaction models between paradigms: Morphisms between models.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.","Generic programming not extensively addressed (the abstract focuses on type theory and categorical semantics for embedded languages, but does not explicitly address generic programming methodologies or abstraction mechanisms as typically understood)","- Key novel insights: The paper addresses the unexplored area of defining a systematized type theory for embedded languages.
 - Theoretical advancements: It presents a flexible fragment of this type theory and uses categorical semantics in terms of enriched categories, providing a stronger result than standard soundness and completeness by including morphisms between models.
 - Potential implications: The work could have implications for programming language design, particularly in managing data linearity in non-classical computational paradigms like quantum computing.","- ""We observe that the definition of the morphisms between models highlights further advantages of the embedded languages and we discuss some concrete instances, extensions and specializations of the syntax and the semantics.""
  - ""The definition of a systematised type theory to capture and standardize common properties of embedded languages is unexplored.""
  - ""We present the calculus HC0 and we use the notion of internal language of a category to relate the language to the class of its models, showing the equivalence between the category of models and the one of theories.""
  - ""Embedded programming style allows to split the syntax in two parts, representing respectively a host language H and a core language C embedded in H.""
  - ""The aim of this paper is to present a flexible fragment of such a type theory, together with its categorical semantics in terms of enriched categories, following previous investigations.""",,"- The abstract discusses the concept of embedded programming languages, which involves splitting syntax into a host language (H) and a core language (C). This suggests a conceptual primitive related to the structure of embedded languages.
 - The paper aims to present a ""flexible fragment of such a type theory,"" which implies a focus on developing theoretical foundations for embedded languages. This could involve defining conceptual primitives related to type theory.
 - The mention of ""categorical semantics in terms of enriched categories"" and ""the calculus HC0"" suggests that these are part of the theoretical framework, potentially serving as conceptual primitives.
 - The abstract does not provide explicit definitions for these primitives, nor does it specify their level of abstraction or orthogonality.","- ""The definition of a systematised type theory to capture and standardize common properties of embedded languages is unexplored.""
  - ""The aim of this paper is to present a flexible fragment of such a type theory, together with its categorical semantics in terms of enriched categories, following previous investigations.""
  - ""We present the calculus HC0 and we use the notion of internal language of a category to relate the language to the class of its models, showing the equivalence between the category of models and the one of theories.""
  - ""This provides a stronger result w.r.t. standard soundness and completeness since it involves not only the models but also morphisms between models.""",,"- The abstract mentions the development of a ""systematised type theory"" to formalize properties of embedded languages, indicating that type theory is a key component of the mathematical framework.
 - The use of ""categorical semantics in terms of enriched categories"" suggests that category theory is also a significant part of the framework.
 - The mention of ""calculus HC0"" implies a specific mathematical structure or system being developed.
 - The equivalence between the category of models and the one of theories suggests a focus on soundness and completeness, which are specific mathematical properties guaranteed by the framework.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it detail specific proof techniques used.","- ""Embedded programming style allows to split the syntax in two parts, representing respectively a host language H and a core language C embedded in H.""
  - ""This formally models several situations in which a user writes code in a main language and delegates some tasks to an ad hoc domain specific language.""
  - ""a particular case of the host-core approach allows a flexible management of data linearity, which is particularly useful in non-classical computational paradigms such as quantum computing.""
  - ""The definition of a systematised type theory to capture and standardize common properties of embedded languages is unexplored.""
  - ""We present the calculus HC0 and we use the notion of internal language of a category to relate the language to the class of its models, showing the equivalence between the category of models and the one of theories.""
  - ""We observe that the definition of the morphisms between models highlights further advantages of the embedded languages and we discuss some concrete instances, extensions and specializations of the syntax and the semantics.""",,"- The abstract discusses an ""embedded programming style"" that splits syntax into a host language and a core language, which is a mechanism for integrating different programming paradigms.
 - The host-core approach is highlighted as useful for managing data linearity in non-classical paradigms like quantum computing, indicating a specific integration mechanism.
 - The abstract mentions the development of a type theory and the calculus HC0, which are theoretical integration strategies.
 - The discussion of morphisms between models suggests an interaction model between paradigms, as it involves relationships between different models.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it specify novel translation or embedding techniques beyond the general framework of embedded languages.","- ""Embedded programming style allows to split the syntax in two parts, representing respectively a host language H and a core language C embedded in H.""
  - ""We observe that the definition of the morphisms between models highlights further advantages of the embedded languages and we discuss some concrete instances, extensions and specializations of the syntax and the semantics.""
  - ""We present the calculus HC0 and we use the notion of internal language of a category to relate the language to the class of its models, showing the equivalence between the category of models and the one of theories.""
  - ""The aim of this paper is to present a flexible fragment of such a type theory, together with its categorical semantics in terms of enriched categories, following previous investigations.""
  - ""The definition of a systematised type theory to capture and standardize common properties of embedded languages is unexplored.""",,"- The abstract discusses the concept of embedded languages and the development of a type theory to standardize their properties. This suggests a focus on abstraction mechanisms related to embedded languages.
 - The mention of ""a flexible fragment of such a type theory"" implies a level of genericity in the approach, as it suggests a flexible framework that can be applied to various embedded languages.
 - The use of ""categorical semantics in terms of enriched categories"" and ""the notion of internal language of a category"" indicates a high-level abstraction mechanism, which is typical in generic programming methodologies.
 - The abstract does not explicitly mention ""generic programming"" or ""abstraction mechanisms"" in the context of genericity and abstraction as typically understood in programming languages. However, the focus on type theory and categorical semantics suggests an abstract and generic approach to embedded languages.
 - The abstract does not provide specific details on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies, which are typically discussed in generic programming methodologies.","- ""The definition of a systematised type theory to capture and standardize common properties of embedded languages is unexplored.""
  - ""The aim of this paper is to present a flexible fragment of such a type theory, together with its categorical semantics in terms of enriched categories, following previous investigations.""
  - ""We observe that the definition of the morphisms between models highlights further advantages of the embedded languages and we discuss some concrete instances, extensions and specializations of the syntax and the semantics.""
  - ""We present the calculus HC0 and we use the notion of internal language of a category to relate the language to the class of its models, showing the equivalence between the category of models and the one of theories.""
  - ""This provides a stronger result w.r.t. standard soundness and completeness since it involves not only the models but also morphisms between models.""",,"- The abstract mentions that the definition of a systematized type theory for embedded languages is unexplored, indicating a gap in current research that this paper aims to address.
 - The paper presents a ""flexible fragment of such a type theory,"" which suggests a novel contribution by providing a new theoretical framework for embedded languages.
 - The use of categorical semantics in terms of enriched categories is highlighted as a theoretical advancement, as it follows previous investigations but likely extends them in some way.
 - The presentation of the calculus HC0 and the equivalence between the category of models and theories is a key theoretical contribution, as it provides a stronger result than standard soundness and completeness by including morphisms between models.
 - The discussion of morphisms between models and their advantages suggests a theoretical innovation that could have implications for programming language design by highlighting new ways to manage data linearity, particularly useful in non-classical computational paradigms like quantum computing."
1 LFG qua concurrent constraint programming,V. Saraswat,-,-,-,0,2007,"1. Primitive Name: Constituent Structure
  Definition: Describes the structure of an utterance using a context-free grammar.
  Orthogonality Score: High
 2. Primitive Name: Functional Structure
  Definition: Describes grammatical relations between constituents using attribute-value matrices.
  Orthogonality Score: High
 3. Primitive Name: Semantic Structure
  Definition: Describes the meaning of an utterance, with interrelations specified by formulas in a ""glue logic.""
  Orthogonality Score: High
 4. Primitive Name: Constraints
  Definition: Pieces of partial information that tie dimensions together, specifying restrictions on variables.
  Orthogonality Score: High","- Type of mathematical framework: Concurrent constraint programming
 - Specific mathematical properties guaranteed: Constraints specify partial information, are additive, rarely inde-accumulating, and non-directional
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Constraints tie different dimensions together.
 - Interaction models between paradigms: Constraint-based communication allows each dimension to influence others.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Elegant compositionality and compositional computing.","- Definition of ""concept"" used: Constraints as pieces of partial information about finite aspects of interest.
 - Mechanisms for representing generic abstractions: Constraints tying together different dimensions of analysis.
 - Minimal type requirements identified: Not mentioned.
 - Static checking or optimization strategies: Not mentioned.","- Key novel insights: The use of constraints to integrate analyses from multiple dimensions in LFG.
 - Theoretical advancements: Separation of concerns in LFG's architecture, properties of constraints (additive, non-directional, accumulative).
 - Potential implications: Inspiration for programming language design through compositional computing.","- ""The key idea is to analyze an utterance simultaneously along several dimensions — constituent structure, functional structure, semantic structure, with provision for additional dimensions.""
  - ""This notion of constraint-based communication at the heart of its architecture is what crucially supports LFG' s elegant compositionality, and makes it a prime exemplar of a general paradigm of compositional computing (Saraswat, 1997).""
  - ""Fourth, they are non-directional: typically a constraint on""
  - ""Third, they are rarely inde-accumulating more constraints can yield much more information than processing them separately.""
  - ""Second, they are additive: the order of imposition of constraints does not matter.""
  - ""Constraints enjoy several remarkable properties (?). First, they specify partial information — a constraint (e.g., X + Y Z) need not uniquely specify the value of its variables , only impose certain restrictions on them.""
  - ""The analyses on each dimension are not independent, rather they are tied together via constraints — pieces of partial information, about some finite aspects of interest.""",,"- The abstract discusses the framework of Lexical Functional Grammar (LFG) and its application to concurrent constraint programming.
 - The key conceptual primitives in this context are the dimensions of analysis: constituent structure, functional structure, and semantic structure.
 - Constraints are a fundamental primitive, defined as pieces of partial information that tie these dimensions together.
 - The properties of constraints are highlighted as specifying partial information, being additive, rarely independent, and non-directional.
 - These properties suggest a high level of abstraction and orthogonality, as they can be applied across different dimensions without dictating primacy or simulating techniques from one dimension to another.","- ""The key idea is to analyze an utterance simultaneously along several dimensions — constituent structure, functional structure, semantic structure, with provision for additional dimensions.""
  - ""The analyses on each dimension are not independent, rather they are tied together via constraints — pieces of partial information, about some finite aspects of interest.""
  - ""As (Dalrymple et al., 1993) shows, it is possible to augment such an architecture by introducing a semantic projection (projection) from the f-structure.""
  - ""Interrelationships between semantic projections are specified by means of formulas in a "" glue logic "" (taken to be linear logic).""
  - ""Conceptually, deductions with these formulas are performed simultaneously with the elaboration of the c-structure and the f-structure, resulting, on a successful analysis, with the simultaneous synthesis of the c-, f-and-structures of the original utterance.""
  - ""Constraints enjoy several remarkable properties (?). First, they specify partial information — a constraint (e.g., X + Y Z) need not uniquely specify the value of its variables , only impose certain restrictions on them.""
  - ""Second, they are additive: the order of imposition of constraints does not matter.""
  - ""Third, they are rarely inde-accumulating more constraints can yield much more information than processing them separately.""
  - ""Fourth, they are non-directional: typically a constraint on""
  - ""This notion of constraint-based communication at the heart of its architecture is what crucially supports LFG' s elegant compositionality, and makes it a prime exemplar of a general paradigm of compositional computing (Saraswat, 1997).""",,"- The abstract discusses the use of constraints to analyze utterances along multiple dimensions, which suggests a framework that involves constraint-based reasoning.
 - The mention of ""glue logic"" and ""linear logic"" indicates that the mathematical framework involves logical systems, specifically linear logic, to specify interrelationships between semantic projections.
 - The properties of constraints listed (partial information, additive, rarely inde-accumulating, non-directional) suggest that the framework is based on constraint programming principles.
 - The abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it discuss proof techniques or limitations.
 - The focus on constraints and their properties aligns with concurrent constraint programming, which is a paradigm for solving problems by combining constraints.","- ""The analyses on each dimension are not independent, rather they are tied together via constraints — pieces of partial information, about some finite aspects of interest.""
  - ""A very attractive and appealing aspect of LFG' s architecture is the separation of concerns. Different processing techniques and different vocabularies of constraints are appropriate for different aspects of analysis.""
  - ""Nevertheless it is possible for the analysis along these dimensions to be interrelated since each produces constraints that can influence others.""
  - ""The key idea is to analyze an utterance simultaneously along several dimensions — constituent structure, functional structure, semantic structure, with provision for additional dimensions.""
  - ""This notion of constraint-based communication at the heart of its architecture is what crucially supports LFG' s elegant compositionality, and makes it a prime exemplar of a general paradigm of compositional computing""",,"- The abstract discusses the integration of different dimensions of analysis in LFG, which can be seen as analogous to integrating different programming paradigms. It mentions that these dimensions are tied together via constraints, which is a mechanism for integration.
 - The separation of concerns and the use of different processing techniques and vocabularies for different aspects suggest a modular approach to integration, where each paradigm can operate independently without dictating primacy over others.
 - The abstract highlights the interrelated nature of these dimensions through constraint-based communication, which is a novel approach to integration by allowing each dimension to influence others.
 - The mention of ""elegant compositionality"" and ""compositional computing"" suggests a theoretical integration strategy that emphasizes the combination of different components in a flexible and modular way.","- ""The analyses on each dimension are not independent, rather they are tied together via constraints — pieces of partial information, about some finite aspects of interest.""
  - ""A very attractive and appealing aspect of LFG' s architecture is the separation of concerns. Different processing techniques and different vocabularies of constraints are appropriate for different aspects of analysis.""
  - ""Constraints enjoy several remarkable properties (?). First, they specify partial information — a constraint (e.g., X + Y Z) need not uniquely specify the value of its variables , only impose certain restrictions on them.""
  - ""This notion of constraint-based communication at the heart of its architecture is what crucially supports LFG' s elegant compositionality, and makes it a prime exemplar of a general paradigm of compositional computing (Saraswat, 1997).""
  - ""The key idea is to analyze an utterance simultaneously along several dimensions — constituent structure, functional structure, semantic structure, with provision for additional dimensions.""",,"- The abstract discusses the analysis of utterances in multiple dimensions (constituent structure, functional structure, semantic structure) which suggests a form of abstraction by considering different aspects of language analysis.
 - The use of constraints to tie together these dimensions indicates a mechanism for representing generic abstractions, as constraints can impose restrictions without uniquely specifying values.
 - The separation of concerns and the use of different processing techniques and vocabularies for different aspects suggest a form of generic programming methodology, where different dimensions are treated independently but interconnected through constraints.
 - The mention of ""elegant compositionality"" and ""compositional computing"" implies a focus on abstraction mechanisms that allow for modular and flexible analysis.
 - However, the abstract does not explicitly discuss minimal type requirements, static checking, or optimization strategies, which are typically part of generic programming methodologies.","- ""The key idea is to analyze an utterance simultaneously along several dimensions — constituent structure, functional structure, semantic structure, with provision for additional dimensions.""
  - ""The analyses on each dimension are not independent, rather they are tied together via constraints — pieces of partial information, about some finite aspects of interest.""
  - ""A very attractive and appealing aspect of LFG' s architecture is the separation of concerns.""
  - ""This notion of constraint-based communication at the heart of its architecture is what crucially supports LFG' s elegant compositionality, and makes it a prime exemplar of a general paradigm of compositional computing (Saraswat, 1997).""
  - ""Constraints enjoy several remarkable properties (?). First, they specify partial information — a constraint (e.g., X + Y Z) need not uniquely specify the value of its variables , only impose certain restrictions on them.""
  - ""Second, they are additive: the order of imposition of constraints does not matter.""
  - ""Third, they are rarely inde-accumulating more constraints can yield much more information than processing them separately.""
  - ""Fourth, they are non-directional: typically a constraint on""",,"- The abstract discusses the theoretical framework of Lexical Functional Grammar (LFG) as a well-established framework for natural language analysis, emphasizing its ability to analyze utterances along multiple dimensions simultaneously.
 - The novelty lies in the use of constraints to tie together analyses from different dimensions, which is a key theoretical contribution. This approach allows for the integration of partial information from various aspects of language structure.
 - The separation of concerns in LFG's architecture is highlighted as a significant theoretical advancement, as it allows different processing techniques and vocabularies to be used for different aspects of analysis without dictating primacy.
 - The abstract also mentions the properties of constraints, such as being additive, non-directional, and able to accumulate information, which are theoretical innovations in the context of LFG.
 - The mention of LFG as a prime exemplar of a general paradigm of compositional computing suggests potential implications for programming language design, as it could inspire new approaches to handling complex data structures and constraints in programming."
Object-oriented software specification in programming language design and implementation,"Barrett R. Bryant, V. Vaidyanathan",10.1109/CMPSAC.1998.716685,https://doi.org/10.1109/CMPSAC.1998.716685,Annual International Computer Software and Applications Conference,3,1998,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),"No specific integration approach described (the abstract implies a theoretical integration strategy through object-oriented representation and denotational semantics, but does not provide explicit details on integration mechanisms, interaction models, constraints, or novel techniques)",Generic programming not extensively addressed (the abstract focuses on object-oriented specification and abstraction but does not explicitly discuss generic programming methodology or type system details),"- Key novel insights: Object-oriented formal specification workbench for programming languages.
 - Theoretical advancements: Use of denotational semantics methodology for elegant syntax and semantics definition; inheritance and specialization of details for language semantics; reusability and modifiability across paradigms.
 - Potential implications: Streamlined process for compiler/interpreter development and reuse; more flexible and adaptable framework for programming language design.","- ""Our specification approach is an object-oriented representation, structured around a denotational semantics methodology which abstracts out various common details so that formal syntax and semantics can be defined elegantly.""
  - ""An object-oriented formal specification workbench is proposed for defining the syntax and semantics of programming languages,""
  - ""Specific details can be inherited and specialized in defining the semantics of various programming languages, and the reusability and modifiability of many programming language features can be manifested across language paradigms.""",,"- The abstract mentions an ""object-oriented formal specification workbench"" and an ""object-oriented representation,"" which suggests that the conceptual primitives are related to object-oriented programming (OOP) concepts.
 - The use of ""denotational semantics methodology"" implies that the primitives are likely related to abstracting common details in programming languages, but specific primitives are not explicitly listed.
 - The abstract discusses the inheritance and specialization of details, which are fundamental concepts in OOP, but again, no specific primitives are defined.
 - The abstract does not provide explicit names or definitions of conceptual primitives, nor does it mention their level of abstraction or orthogonality.","- ""Furthermore, prototype implementations for these languages may be automatically developed from the formal specifications, providing a mechanism for compiler/interpreter reuse at the specification level.""
  - ""Our specification approach is an object-oriented representation, structured around a denotational semantics methodology which abstracts out various common details so that formal syntax and semantics can be defined elegantly.""
  - ""An object-oriented formal specification workbench is proposed for defining the syntax and semantics of programming languages, using which the formal properties of different languages can be elaborated and analyzed.""
  - ""Specific details can be inherited and specialized in defining the semantics of various programming languages, and the reusability and modifiability of many programming language features can be manifested across language paradigms.""",,"- The abstract mentions an ""object-oriented formal specification workbench"" and an ""object-oriented representation,"" which suggests a focus on object-oriented programming principles rather than a specific mathematical framework like type theory or category theory.
 - The use of ""denotational semantics methodology"" indicates a focus on the meaning of programming language constructs, but it does not specify a particular mathematical framework.
 - The abstract does not mention any specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework.
 - The focus is on the reusability and modifiability of language features and automatic prototype implementations, which are more related to software engineering and programming language design rather than a detailed mathematical framework.","- ""Our specification approach is an object-oriented representation, structured around a denotational semantics methodology which abstracts out various common details so that formal syntax and semantics can be defined elegantly.""
  - ""Furthermore, prototype implementations for these languages may be automatically developed from the formal specifications, providing a mechanism for compiler/interpreter reuse at the specification level.""
  - ""An object-oriented formal specification workbench is proposed for defining the syntax and semantics of programming languages, using which the formal properties of different languages can be elaborated and analyzed.""
  - ""Specific details can be inherited and specialized in defining the semantics of various programming languages, and the reusability and modifiability of many programming language features can be manifested across language paradigms.""",,"- The abstract discusses an object-oriented formal specification workbench for defining syntax and semantics of programming languages, which implies a method for integrating different programming paradigms by abstracting common details.
 - The use of an object-oriented representation and denotational semantics methodology suggests a structured approach to integrating paradigms by allowing for the inheritance and specialization of specific details.
 - The mention of reusability and modifiability across language paradigms indicates a mechanism for integrating different paradigms by facilitating the reuse of features.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques, but it implies a theoretical integration strategy through the use of object-oriented representation and denotational semantics.","- ""An object-oriented formal specification workbench is proposed for defining the syntax and semantics of programming languages,""
  - ""Specific details can be inherited and specialized in defining the semantics of various programming languages, and the reusability and modifiability of many programming language features can be manifested across language paradigms.""
  - ""Furthermore, prototype implementations for these languages may be automatically developed from the formal specifications, providing a mechanism for compiler/interpreter reuse at the specification level.""
  - ""Our specification approach is an object-oriented representation, structured around a denotational semantics methodology which abstracts out various common details so that formal syntax and semantics can be defined elegantly.""",,"- The abstract discusses an ""object-oriented formal specification workbench,"" which implies a focus on object-oriented programming principles. This suggests a potential for generic programming through inheritance and polymorphism, common in object-oriented design.
 - The mention of ""denotational semantics methodology"" indicates a structured approach to defining language semantics, which could involve abstracting common details. This abstraction is a key aspect of generic programming.
 - The ability to ""inherit and specialize"" details for different languages suggests a mechanism for representing generic abstractions, as it allows for the reuse and modification of language features across paradigms.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, which are typically discussed in the context of generic programming.
 - The focus on ""reusability and modifiability"" and ""compiler/interpreter reuse"" implies a level of abstraction and genericity in the approach, but these are not explicitly detailed in terms of generic programming methodology or type system discussions.","- ""An object-oriented formal specification workbench is proposed for defining the syntax and semantics of programming languages, using which the formal properties of different languages can be elaborated and analyzed.""
  - ""Furthermore, prototype implementations for these languages may be automatically developed from the formal specifications, providing a mechanism for compiler/interpreter reuse at the specification level.""
  - ""Our specification approach is an object-oriented representation, structured around a denotational semantics methodology which abstracts out various common details so that formal syntax and semantics can be defined elegantly.""
  - ""Specific details can be inherited and specialized in defining the semantics of various programming languages, and the reusability and modifiability of many programming language features can be manifested across language paradigms.""",,"- The abstract proposes an ""object-oriented formal specification workbench,"" which is a novel approach to defining the syntax and semantics of programming languages. This suggests a key novel insight in using object-oriented methods for formal specification.
 - The use of ""denotational semantics methodology"" to abstract common details is a theoretical advancement, as it allows for elegant definitions of formal syntax and semantics. This is a theoretical contribution beyond existing approaches.
 - The ability to ""inherit and specialize"" details for different languages and to manifest ""reusability and modifiability"" across paradigms is a significant theoretical advancement. It implies a more flexible and adaptable framework for programming language design.
 - The potential for ""prototype implementations"" to be automatically developed from formal specifications is a theoretical contribution, as it suggests a streamlined process for compiler/interpreter development and reuse.
 - The abstract does not explicitly mention comparative analysis with existing work, but the novelty of the approach and its theoretical advancements are implied by the description of the proposed workbench and methodology."
Purely functional programming and the object-oriented inheritance,"C. L., G. LÃ©grÃ¡di",-,-,-,0,2002,"1. Primitive Name: Pure Values
  Definition: The value of an expression depends only on the values of its subexpressions.
  Orthogonality Score: High
 2. Primitive Name: First-Class Functions
  Definition: Functions are treated as first-class citizens.
  Orthogonality Score: High
 3. Primitive Name: Implicit Storage Management
  Definition: Memory management is handled implicitly.
  Orthogonality Score: High
 4. Primitive Name: Higher-Order, Explicitly-Typed, Polymorphic λ-Calculus with Subtyping (F ω ≤)
  Definition: A type system for typing values.
  Orthogonality Score: High
 5. Primitive Name: Encapsulation
  Definition: Hiding internal implementation details.
  Orthogonality Score: High
 6. Primitive Name: Message Passing
  Definition: Communication between objects.
  Orthogonality Score: High
 7. Primitive Name: Subtyping
  Definition: A mechanism for type hierarchy.
  Orthogonality Score: High
 8. Primitive Name: Inheritance
  Definition: A mechanism for code reuse.
  Orthogonality Score: High
 9. Primitive Name: Polymorphic Functions
  Definition: Functions that can work with multiple types.
  Orthogonality Score: High","- Type of mathematical framework: Type theory (higher-order, explicitly-typed, polymorphic λ-calculus with subtyping, called F ω ≤)
 - Specific mathematical properties guaranteed: Higher-order, polymorphic
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Extending functional language properties into object-oriented paradigm; using a strong type-system (F ω ≤).
 - Interaction models between paradigms: Preparing type-system for object-oriented mechanisms like encapsulation, message passing, subtyping, and inheritance.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned, but interesting questions about introducing object-oriented inheritance and polymorphism.
 - Novel translation or embedding techniques: Polymorphic functions in list manipulation.","- Definition of ""concept"" used: Not mentioned
 - Mechanisms for representing generic abstractions: Higher-order, explicitly-typed, polymorphic λ-calculus with subtyping (F ω ≤ )
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Implied by ""higher-order, explicitly-typed"" type system","- Key novel insights: Introduction of purely functional programming principles into the object-oriented paradigm.
 - Theoretical advancements: Integration of functional language properties with a strong type system (F ω ≤) and object-oriented mechanisms.
 - Potential implications: Enhanced programming language design through the integration of functional and object-oriented paradigms.","- ""According to the purely functional paradigm, the value of an expression depends only on the values of its subexpressions, if any.""
  - ""The simplicity and power of functional languages is due to properties like pure values, first-class functions, and implicit storage management.""
  - ""We must extend these properties with a strong type-system.""
  - ""The values must be typed, the type system used for this purpose is the higher-order, explicitly-typed, polymorphic λ-calculus with subtyping, called F ω""
  - ""This type-system must be prepared for basic mechanisms of objectoriented programming: encapsulation, message passing, subtyping and inheritance.""
  - ""Polymorphic functions arise naturally when lists are manipulated and lists with elements of any types can be accomplished by a straightforward generalization of inheritance.""",,"- The abstract discusses the integration of purely functional programming principles into the object-oriented paradigm, focusing on properties like pure values, first-class functions, and implicit storage management.
 - It mentions the need for a strong type system, specifically the higher-order, explicitly-typed, polymorphic λ-calculus with subtyping (F ω ≤), which is a conceptual primitive for typing values.
 - The abstract highlights the importance of encapsulation, message passing, subtyping, and inheritance as basic mechanisms of object-oriented programming, which are conceptual primitives in this context.
 - Polymorphic functions are also mentioned as a natural outcome of list manipulation, indicating another conceptual primitive related to polymorphism.
 - The level of abstraction is high, as these primitives are foundational concepts in programming paradigms.
 - Orthogonality is implied by the integration of functional and object-oriented principles, suggesting that these primitives are designed to work together without redundancy.","- ""This type-system must be prepared for basic mechanisms of objectoriented programming: encapsulation, message passing, subtyping and inheritance.""
  - ""The values must be typed, the type system used for this purpose is the higher-order, explicitly-typed, polymorphic λ-calculus with subtyping, called F ω""",,"- The abstract mentions the use of a ""higher-order, explicitly-typed, polymorphic λ-calculus with subtyping, called F ω ≤"" as the type system. This indicates that the mathematical framework is based on type theory, specifically a form of lambda calculus.
 - The type system is described as ""higher-order"" and ""polymorphic,"" which are specific mathematical properties that guarantee certain behaviors in the programming paradigm.
 - The abstract does not explicitly mention proof techniques or limitations of the framework, but it does highlight the need for the type system to support object-oriented programming mechanisms like encapsulation, message passing, subtyping, and inheritance.
 - There is no mention of category theory or other mathematical frameworks, nor are there details on proof methodologies or formal verification discussions.","- ""According to the purely functional paradigm, the value of an expression depends only on the values of its subexpressions, if any.""
  - ""In this paper we introduce this principle in the object-oriented paradigm.""
  - ""The simplicity and power of functional languages is due to properties like pure values, first-class functions, and implicit storage management.""
  - ""We must extend these properties with a strong type-system.""
  - ""The values must be typed, the type system used for this purpose is the higher-order, explicitly-typed, polymorphic λ-calculus with subtyping, called F ω""
  - ""This type-system must be prepared for basic mechanisms of objectoriented programming: encapsulation, message passing, subtyping and inheritance.""
  - ""Polymorphic functions arise naturally when lists are manipulated and lists with elements of any types can be accomplished by a straightforward generalization of inheritance.""
  - ""Interesting questions are also, how to introduce the objectoriented inheritance, the subtyping mechanism and the object oriented polymorphism.""",,"- The abstract discusses integrating the purely functional paradigm into the object-oriented paradigm, indicating a focus on combining these two programming paradigms.
 - The integration mechanism proposed involves extending functional language properties like pure values and first-class functions into the object-oriented paradigm.
 - The use of a strong type-system, specifically the higher-order, explicitly-typed, polymorphic λ-calculus with subtyping (F ω ≤), is a key integration strategy.
 - The abstract mentions preparing this type-system for object-oriented mechanisms like encapsulation, message passing, subtyping, and inheritance, suggesting an interaction model between the paradigms.
 - The mention of polymorphic functions and their natural occurrence in list manipulation suggests a novel translation or embedding technique.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does highlight interesting questions related to introducing object-oriented inheritance and polymorphism, which could imply challenges.","- ""This type-system must be prepared for basic mechanisms of objectoriented programming: encapsulation, message passing, subtyping and inheritance.""
  - ""the type system used for this purpose is the higher-order, explicitly-typed, polymorphic λ-calculus with subtyping, called F ω""
  - ""The simplicity and power of functional languages is due to properties like pure values, first-class functions, and implicit storage management.""
  - ""Polymorphic functions arise naturally when lists are manipulated and lists with elements of any types can be accomplished by a straightforward generalization of inheritance.""
  - ""We must extend these properties with a strong type-system.""",,"- The abstract discusses the integration of functional programming principles into object-oriented programming, focusing on the use of a strong type system to support these principles.
 - The type system mentioned is the ""higher-order, explicitly-typed, polymorphic λ-calculus with subtyping, called F ω ≤ ,"" which suggests a mechanism for representing generic abstractions through polymorphism and subtyping.
 - The abstract mentions that polymorphic functions arise naturally when manipulating lists, indicating a mechanism for generic programming.
 - The type system is described as ""higher-order, explicitly-typed,"" which implies a level of static checking or optimization strategy.
 - The abstract does not explicitly define a ""concept"" used in the study, nor does it specify minimal type requirements or detailed static checking strategies.","- ""According to the purely functional paradigm, the value of an expression depends only on the values of its subexpressions, if any.""
  - ""In this paper we introduce this principle in the object-oriented paradigm.""
  - ""The simplicity and power of functional languages is due to properties like pure values, first-class functions, and implicit storage management.""
  - ""We must extend these properties with a strong type-system.""
  - ""The values must be typed, the type system used for this purpose is the higher-order, explicitly-typed, polymorphic λ-calculus with subtyping, called F ω""
  - ""This type-system must be prepared for basic mechanisms of objectoriented programming: encapsulation, message passing, subtyping and inheritance.""
  - ""Polymorphic functions arise naturally when lists are manipulated and lists with elements of any types can be accomplished by a straightforward generalization of inheritance.""
  - ""Interesting questions are also, how to introduce the objectoriented inheritance, the subtyping mechanism and the object oriented polymorphism.""",,"- The abstract introduces the principle of purely functional programming into the object-oriented paradigm, which is a novel integration of two programming paradigms.
 - It highlights the importance of extending functional language properties like pure values and first-class functions with a strong type system, specifically the higher-order, explicitly-typed, polymorphic λ-calculus with subtyping (F ω ≤).
 - The integration of this type system with object-oriented programming mechanisms such as encapsulation, message passing, subtyping, and inheritance is a theoretical advancement.
 - The mention of polymorphic functions arising naturally from list manipulation and the generalization of inheritance suggests a new approach to handling polymorphism in object-oriented programming.
 - The abstract implies potential implications for programming language design by integrating functional and object-oriented paradigms, which could lead to more powerful and flexible programming languages."
On the algebraic structure of declarative programming languages,-,10.1016/j.tcs.2009.07.038,https://doi.org/10.1016/j.tcs.2009.07.038,Theoretical Computer Science,31,2009,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: Category theory (indexed premonoidal categories)
 - Specific mathematical properties guaranteed: Algebraic axiomatization of bottom-up semantics
 - Proof techniques used: Algebraic methods
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Incorporation of constraints, abstract data types, and features from other paradigms into logic programming.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Embedding data structures into logic programming derivations using indexed categories.",Generic programming not extensively addressed,"- Key novel insights: Development of the ""Logic Programming Doctrines"" framework for Horn Clause logic programming; embedding data information into logic programming derivations using indexed categories.
 - Theoretical advancements: Uniform framework for logic programming and its extensions; algebraic axiomatization of bottom-up semantics.
 - Potential implications: More comprehensive and flexible framework for declarative programming; integration of constraints, abstract data types, and features from other paradigms.","- ""We develop an algebraic framework, Logic Programming Doctrines, for the syntax, proof theory, operational semantics and model theory of Horn Clause logic programming based on indexed premonoidal categories.""
  - ""We define a new way to embed information about data into logic programming derivations by building a sketch-like description of data structures directly into an indexed category of proofs.""
  - ""We give an algebraic axiomatization of bottom-up semantics in this general setting, describing categorical models as fixed points of a continuous operator.""",,"- The abstract mentions the development of an ""algebraic framework"" called ""Logic Programming Doctrines,"" which suggests a theoretical framework rather than specific conceptual primitives.
 - The mention of ""indexed premonoidal categories"" and ""indexed category of proofs"" indicates a focus on categorical structures, but these are not explicitly defined as conceptual primitives.
 - The abstract discusses embedding data into logic programming derivations and an algebraic axiomatization of bottom-up semantics, but again, these are not explicitly listed as conceptual primitives.
 - The abstract does not provide explicit definitions or names for conceptual primitives, nor does it mention their level of abstraction or orthogonality.","- ""We develop an algebraic framework, Logic Programming Doctrines, for the syntax, proof theory, operational semantics and model theory of Horn Clause logic programming based on indexed premonoidal categories.""
  - ""We define a new way to embed information about data into logic programming derivations by building a sketch-like description of data structures directly into an indexed category of proofs.""
  - ""We give an algebraic axiomatization of bottom-up semantics in this general setting, describing categorical models as fixed points of a continuous operator.""",,"- The abstract mentions the development of an ""algebraic framework"" called ""Logic Programming Doctrines,"" which is based on ""indexed premonoidal categories."" This indicates that the mathematical framework used is category theory.
 - The framework is designed to incorporate various aspects of logic programming, including syntax, proof theory, operational semantics, and model theory, suggesting a comprehensive approach to formalizing these aspects.
 - The mention of ""embedding information about data into logic programming derivations"" and ""building a sketch-like description of data structures"" implies that the framework provides a way to formally describe data structures within the context of logic programming.
 - The ""algebraic axiomatization of bottom-up semantics"" and the description of ""categorical models as fixed points of a continuous operator"" suggest that the framework uses algebraic methods to guarantee certain properties of the semantics.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or limitations of the framework, but it does highlight the use of category theory and algebraic axiomatization.","- ""Our aim is to provide a uniform framework for logic programming and its extensions capable of incorporating constraints, abstract data types, features imported from other programming language paradigms and a mathematical description of the state space in a declarative manner.""
  - ""We define a new way to embed information about data into logic programming derivations by building a sketch-like description of data structures directly into an indexed category of proofs.""",,"- The abstract mentions the aim of providing a ""uniform framework for logic programming and its extensions capable of incorporating constraints, abstract data types, features imported from other programming language paradigms."" This suggests an integration approach where features from other paradigms are incorporated into logic programming.
 - The abstract describes a method to ""embed information about data into logic programming derivations by building a sketch-like description of data structures directly into an indexed category of proofs."" This indicates a novel embedding technique for integrating data structures from other paradigms into logic programming.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models between paradigms, or constraints/challenges in paradigm integration. It focuses on the theoretical framework and embedding techniques rather than detailed integration strategies or challenges.","- ""Our aim is to provide a uniform framework for logic programming and its extensions capable of incorporating constraints, abstract data types, features imported from other programming language paradigms and a mathematical description of the state space in a declarative manner.""
  - ""We give an algebraic axiomatization of bottom-up semantics in this general setting, describing categorical models as fixed points of a continuous operator.""
  - ""We develop an algebraic framework, Logic Programming Doctrines, for the syntax, proof theory, operational semantics and model theory of Horn Clause logic programming based on indexed premonoidal categories.""
  - ""We define a new way to embed information about data into logic programming derivations by building a sketch-like description of data structures directly into an indexed category of proofs.""",,"- The abstract discusses the development of an algebraic framework for logic programming, which suggests a focus on formal and abstract structures rather than generic programming methodologies.
 - The mention of ""abstract data types"" and ""features imported from other programming language paradigms"" implies some level of abstraction, but it does not specifically address generic programming or abstraction mechanisms in the context of genericity.
 - The abstract does not explicitly mention ""generic programming"" or ""abstraction mechanisms"" related to genericity, nor does it discuss type systems, minimal type requirements, or static checking strategies.
 - The focus is on algebraic structures and categorical models rather than generic programming or abstraction mechanisms.","- ""We develop an algebraic framework, Logic Programming Doctrines, for the syntax, proof theory, operational semantics and model theory of Horn Clause logic programming based on indexed premonoidal categories.""
  - ""We define a new way to embed information about data into logic programming derivations by building a sketch-like description of data structures directly into an indexed category of proofs.""
  - ""Our aim is to provide a uniform framework for logic programming and its extensions capable of incorporating constraints, abstract data types, features imported from other programming language paradigms and a mathematical description of the state space in a declarative manner.""
  - ""We give an algebraic axiomatization of bottom-up semantics in this general setting, describing categorical models as fixed points of a continuous operator.""",,"- The abstract introduces a novel algebraic framework called ""Logic Programming Doctrines"" for Horn Clause logic programming, which is a significant theoretical contribution as it provides a new perspective on the syntax, proof theory, operational semantics, and model theory.
 - The framework is designed to be uniform and capable of incorporating various extensions such as constraints, abstract data types, and features from other programming paradigms, which is a theoretical advancement beyond existing approaches.
 - The method of embedding data information into logic programming derivations using indexed categories is a new insight, offering a unique way to integrate data structures into the framework.
 - The algebraic axiomatization of bottom-up semantics and the description of categorical models as fixed points of a continuous operator are theoretical innovations that provide a deeper understanding of the semantics in this context.
 - These contributions have potential implications for programming language design by providing a more comprehensive and flexible framework for declarative programming."
"An algebraic model of class, message passing and inheritance",R. J. McKenzie,-,-,-,2,1992,Not specified (the abstract does not explicitly list or define the conceptual primitives),"- Type of mathematical framework: Algebraic theory, likely involving category theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,"- Definition of ""concept"" used: Fundamental concepts contributing to class, objects, message passing, and inheritance are formally defined in the form of signatures and algebras.
 - Mechanisms for representing generic abstractions: Signatures and algebras are used to define these concepts.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: A formal theory characterizing class, objects, message passing, and inheritance; identification and formal definition of fundamental concepts in a single algebraic theory; formal semantics of abstract data types and polymorphic operations using initial algebras.
 - Theoretical advancements: A unifying model for object-oriented programming phenomena; comprehensive and consistent algebraic theory; new perspective on implementation inheritance.
 - Potential implications for programming language design: Ability to compare implementations in formal terms; justification of simplifications in implementations.","- ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""In order to be accurate, other more fundamental concepts contributing to class, objects, message passing, and inheritance are first identified and then formally defined in the form of signatures and algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""
  - ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""
  - ""Such contributing concepts are included in a single comprehensive and consistent algebraic theory.""",,"- The abstract mentions that the study presents a formal theory that characterizes the principal phenomena of object-oriented programming, specifically class, objects, message passing, and inheritance.
 - It indicates that more fundamental concepts contributing to these phenomena are identified and formally defined using signatures and algebras, suggesting these are the conceptual primitives.
 - The abstract does not explicitly list specific primitives or provide their precise definitions, but it implies that these fundamental concepts are part of a comprehensive algebraic theory.
 - The mention of ""signatures and algebras"" suggests a level of abstraction, as these are mathematical constructs used to define the primitives.
 - The abstract does not provide an orthogonality score or explicit definitions for the primitives, nor does it list them explicitly.","- ""Such contributing concepts are included in a single comprehensive and consistent algebraic theory.""
  - ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""
  - ""other more fundamental concepts contributing to class, objects, message passing, and inheritance are first identified and then formally defined in the form of signatures and algebras.""
  - ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""",,"- The abstract mentions the use of a ""formal theory"" and ""algebraic theory"" to characterize object-oriented programming concepts, indicating the type of mathematical framework used.
 - The framework involves ""signatures and algebras,"" which are specific mathematical structures used to define the concepts formally.
 - The use of ""initial algebras"" suggests a focus on category theory, as initial algebras are a concept within category theory used to define the semantics of data types and operations.
 - The abstract does not explicitly mention type theory or other specific mathematical properties guaranteed by the framework, nor does it discuss proof techniques or limitations.
 - The focus on algebraic structures and initial algebras implies a category theory approach, but the abstract does not provide detailed information on specific mathematical properties or proof techniques.","- ""Object-oriented programming, although benefiting from a continuing surge of popularity, suffers from being vaguely defined.""
  - ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""
  - ""While a number of other efforts have formally modeled some aspects of these phenomena, the lack of a unifying model, capable of describing the different interactions between these individual features, makes obtaining a complete picture impossible.""
  - ""In order to be accurate, other more fundamental concepts contributing to class, objects, message passing, and inheritance are first identified and then formally defined in the form of signatures and algebras.""
  - ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""
  - ""Once the contributing concepts are incorporated in a single theory, there is the opportunity to study and possibly generalize the individual concepts contributing to the basic phenomena.""
  - ""Interactions between the concepts can also be studied.""
  - ""Furthermore, as the relevant features of each of the implementations are consistently captured, they can then be compared in formal terms.""",,"- The abstract discusses the development of a formal theory to characterize object-oriented programming concepts such as class, objects, message passing, and inheritance. This suggests a focus on integrating these concepts within the object-oriented paradigm rather than integrating different programming paradigms.
 - The abstract mentions the lack of a unifying model for describing interactions between these features, which implies an effort to integrate these concepts within the object-oriented paradigm.
 - The use of signatures and algebras to define these concepts suggests a theoretical integration strategy within the object-oriented paradigm.
 - The abstract does not explicitly mention the integration of different programming paradigms or specific mechanisms for integrating paradigms like procedural or functional programming with object-oriented programming.
 - There is no mention of interaction models between different paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques for integrating different paradigms.","- ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""In order to be accurate, other more fundamental concepts contributing to class, objects, message passing, and inheritance are first identified and then formally defined in the form of signatures and algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""
  - ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""
  - ""Once the contributing concepts are incorporated in a single theory, there is the opportunity to study and possibly generalize the individual concepts contributing to the basic phenomena.""",,"- The abstract discusses the development of a formal theory that characterizes object-oriented programming concepts such as class, objects, message passing, and inheritance. This suggests a focus on conceptual abstraction.
 - The use of ""signatures and algebras"" to define fundamental concepts indicates a mechanism for representing generic abstractions, as these mathematical structures are often used to formalize abstract concepts.
 - The mention of ""formal semantics of abstract data types and polymorphic operations"" suggests a focus on generic programming, as polymorphism is a key aspect of genericity.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, but the focus on formal semantics and algebras implies a structured approach to abstraction.
 - The abstract does not provide specific details on generic programming methodology or type system discussions, but it implies a theoretical framework that could support generic programming.","- ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""
  - ""the lack of a unifying model, capable of describing the different interactions between these individual features, makes obtaining a complete picture impossible.""
  - ""other more fundamental concepts contributing to class, objects, message passing, and inheritance are first identified and then formally defined in the form of signatures and algebras.""
  - ""Such contributing concepts are included in a single comprehensive and consistent algebraic theory.""
  - ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""
  - ""Once the contributing concepts are incorporated in a single theory, there is the opportunity to study and possibly generalize the individual concepts contributing to the basic phenomena.""
  - ""Interactions between the concepts can also be studied.""
  - ""Furthermore, as the relevant features of each of the implementations are consistently captured, they can then be compared in formal terms.""
  - ""Simplifications occurring in some of the implementations can also be justified.""",,"- The abstract presents a formal theory that characterizes key phenomena in object-oriented programming, which is a novel contribution as it addresses the lack of a unifying model in existing approaches.
 - The identification and formal definition of fundamental concepts contributing to class, objects, message passing, and inheritance in a single algebraic theory is a significant theoretical advancement.
 - The use of signatures and algebras to define these concepts provides a comprehensive and consistent framework, which is a theoretical innovation.
 - The formal semantics of abstract data types and polymorphic operations using initial algebras is another novel insight, as it provides a structured way to understand these concepts.
 - The description of implementation inheritance as a means of defining algebras offers a new perspective on this concept.
 - The potential for studying and generalizing individual concepts and their interactions is a significant theoretical contribution, as it opens up new avenues for research and understanding.
 - The ability to compare implementations in formal terms and justify simplifications is an implication for programming language design, as it could lead to more efficient and effective language development."
Foundations of Total Functional Data-Flow Programming,"B. T. Widemann, M. Lepper",10.4204/EPTCS.153.10,https://doi.org/10.4204/EPTCS.153.10,MSFP,8,2014,Not specified (the abstract does not explicitly define conceptual primitives or their characteristics),"- Type of mathematical framework: Coalgebraic coinduction, relational model
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Unification of data-flow graph and functional reactive paradigms into a single framework based on set theory.
 - Interaction models between paradigms: Symmetrical reduction to a low-level middle ground with strongly compositional semantics.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"- Key novel insights: Unification of data-flow graph and functional reactive paradigms using set theory.
 - Theoretical advancements: Symmetric reduction of paradigms to a low-level middle ground with compositional semantics; derivation from mathematical first principles (coalgebraic coinduction and relational model).
 - Potential implications: Introduction of a novel stream programming language with unified and efficient programming frameworks.","- ""The abstract syntax and semantics introduced here constitute the full core of a novel stream programming language.""
  - ""The design of the framework is derived from mathematical first principles, in particular coalgebraic coinduction and a standard relational model of stateful computation.""
  - ""we describe the foundations of a framework for unifying functional and data-flow styles that differs from FRP proper in significant ways: It is based on set theory to match the expectations of domain experts, and the two paradigms are reduced symmetrically to a low-level middle ground, with strongly compositional semantics.""
  - ""The field of declarative stream programming (discrete time, clocked synchronous, modular, data-centric) is divided between the data-flow graph paradigm favored by domain experts, and the functional reactive paradigm favored by academics.""",,"- The abstract discusses the unification of functional and data-flow programming paradigms, indicating a focus on conceptual primitives related to these areas.
 - The mention of ""set theory"" suggests that set theory is a foundational element or primitive in the framework.
 - The use of ""coalgebraic coinduction"" and a ""standard relational model of stateful computation"" implies these are mathematical primitives or concepts used in the framework.
 - The abstract does not provide explicit definitions for these primitives, nor does it specify their orthogonality or level of abstraction.
 - The abstract focuses on the framework's design and its mathematical underpinnings rather than detailing specific conceptual primitives.","- ""The design of the framework is derived from mathematical first principles, in particular coalgebraic coinduction and a standard relational model of stateful computation.""",,"- The abstract mentions that the framework is derived from ""mathematical first principles,"" which suggests a theoretical foundation.
 - Specifically, it references ""coalgebraic coinduction"" and a ""standard relational model of stateful computation,"" indicating the type of mathematical framework used.
 - Coalgebraic coinduction is a mathematical technique used in category theory, which is a branch of mathematics that studies the commonalities and patterns between different mathematical structures.
 - The mention of a ""standard relational model of stateful computation"" suggests a focus on relational models, which are often used in formal verification to describe and analyze systems.
 - The abstract does not provide specific mathematical properties guaranteed or proof techniques used, nor does it mention any limitations or constraints of the framework.
 - The abstract does not explicitly mention type theory or other specific mathematical frameworks beyond coalgebraic coinduction and relational models.","- ""The design of the framework is derived from mathematical first principles, in particular coalgebraic coinduction and a standard relational model of stateful computation.""
  - ""It is based on set theory to match the expectations of domain experts, and the two paradigms are reduced symmetrically to a low-level middle ground, with strongly compositional semantics.""
  - ""we describe the foundations of a framework for unifying functional and data-flow styles that differs from FRP proper in significant ways:""
  - ""The field of declarative stream programming (discrete time, clocked synchronous, modular, data-centric) is divided between the data-flow graph paradigm favored by domain experts, and the functional reactive paradigm favored by academics.""",,"- The abstract discusses the integration of two programming paradigms: the data-flow graph paradigm and the functional reactive paradigm.
 - The integration approach involves unifying these paradigms into a single framework, which is based on set theory to align with domain experts' expectations.
 - The integration is achieved by reducing both paradigms symmetrically to a common ground, which suggests a balanced interaction model between the paradigms.
 - The framework is designed using mathematical first principles, specifically coalgebraic coinduction and a relational model of stateful computation, which indicates a theoretical integration strategy.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques beyond the general framework and theoretical basis.","- ""The abstract syntax and semantics introduced here constitute the full core of a novel stream programming language.""
  - ""The field of declarative stream programming (discrete time, clocked synchronous, modular, data-centric) is divided between the data-flow graph paradigm favored by domain experts, and the functional reactive paradigm favored by academics.""
  - ""The design of the framework is derived from mathematical first principles, in particular coalgebraic coinduction and a standard relational model of stateful computation.""
  - ""we describe the foundations of a framework for unifying functional and data-flow styles that differs from FRP proper in significant ways: It is based on set theory to match the expectations of domain experts, and the two paradigms are reduced symmetrically to a low-level middle ground, with strongly compositional semantics.""",,"- The abstract discusses the unification of functional and data-flow programming styles, which implies a focus on integrating different programming paradigms rather than specifically addressing generic programming or abstraction mechanisms.
 - The mention of ""set theory"" and ""coalgebraic coinduction"" suggests a mathematical foundation for the framework, but these are not directly related to generic programming or abstraction mechanisms.
 - The abstract does not explicitly mention generic programming, type systems, or abstraction mechanisms, which are key components of genericity and abstraction.
 - The focus is on the design of a novel stream programming language and its mathematical foundations rather than on generic programming methodologies or type system discussions.","- ""The field of declarative stream programming (discrete time, clocked synchronous, modular, data-centric) is divided between the data-flow graph paradigm favored by domain experts, and the functional reactive paradigm favored by academics.""
  - ""we describe the foundations of a framework for unifying functional and data-flow styles that differs from FRP proper in significant ways:""
  - ""It is based on set theory to match the expectations of domain experts, and the two paradigms are reduced symmetrically to a low-level middle ground, with strongly compositional semantics.""
  - ""The design of the framework is derived from mathematical first principles, in particular coalgebraic coinduction and a standard relational model of stateful computation.""
  - ""The abstract syntax and semantics introduced here constitute the full core of a novel stream programming language.""",,"- The abstract discusses the division between data-flow graph and functional reactive paradigms, indicating a gap in current approaches that the study aims to address.
 - The novelty lies in the unification of these two paradigms, which is a significant theoretical contribution as it bridges a gap between domain experts and academics.
 - The use of set theory to match domain experts' expectations is a key novel insight, as it provides a common ground for both paradigms.
 - The reduction of both paradigms to a symmetric low-level middle ground with compositional semantics is a theoretical advancement, as it simplifies and unifies the underlying structure.
 - The derivation from mathematical first principles, specifically coalgebraic coinduction and a relational model of stateful computation, is a theoretical advancement beyond existing approaches, as it provides a rigorous foundation.
 - The introduction of a novel stream programming language based on these principles has potential implications for programming language design, as it could lead to more unified and efficient programming frameworks."
From Category Theory to Functional Programming: A Formal Representation of Intent,"D. Borsatti, W. Cerroni, S. Clayman",10.1109/NetSoft54395.2022.9844061,https://doi.org/10.1109/NetSoft54395.2022.9844061,IEEE Conference on Network Softwarization,7,2022,"1. Primitive Name: Intent
  Definition: Subset of all possible sentences in English that express an intent.
  Orthogonality Score: High
 

 2. Primitive Name: Morphism (Intent Category)
  Definition: Describes relationships between similar intent requests.
  Orthogonality Score: High
 

 3. Primitive Name: Service
  Definition: Represents services requested by intents.
  Orthogonality Score: High
 

 4. Primitive Name: Morphism (Service Category)
  Definition: Embeds composition rules between services.
  Orthogonality Score: High
 

 5. Primitive Name: SrvRequirement
  Definition: Represents modifiers such as scope, time, latency constraints, and throughput constraints.
  Orthogonality Score: High","- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Reasoning with abstract concepts, preserving structure through functors
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Use of category theory concepts like functors to map intents to services and requirements.
 - Interaction models between paradigms: Category theory provides a mathematical foundation for IBN, which is implemented using Haskell.
 - Constraints or challenges in paradigm integration: Not explicitly discussed.
 - Any novel translation or embedding techniques: Use of functors as ""meaning extracting"" functions.","- Definition of ""concept"" used: Category theory is used to describe abstract concepts.
 - Mechanisms for representing generic abstractions: Construction of categories like Hask, use of functors to map objects between categories.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Automatic validation of NSD format through Haskell's type checking features.","- Key novel insights: Application of category theory to formalize Intent-Based Networking (IBN) for a rigorous mathematical foundation.
 - Theoretical advancements: Provides a formal representation of IBN using category theory, enhancing reasoning about the paradigm.
 - Potential implications for programming language design: Use of category theory concepts like lenses to model system interactions, integrating mathematical concepts with programming paradigms.","- ""Morphisms can be defined to describe the relationships between ""similar"" intent requests.""
  - ""The objects of this category represent all the services that can be requested by an intent, while morphisms between these objects could embed composition rules between services.""
  - ""The objects of this category Ob(I) can be seen as a subset of all possible sentences in English (or even in other languages) that express an intent.""",,"- The paper defines several conceptual primitives within the context of Intent-Based Networking (IBN) and their representation using category theory and functional programming.
 - The first set of primitives is related to the intent category (I), where objects are defined as sentences expressing intents, and morphisms describe relationships between similar intent requests.
 - The second set of primitives is related to the service category (S), where objects represent services requested by intents, and morphisms describe composition rules between services.
 - The third set of primitives is related to the requirement category (R), where objects represent modifiers such as scope, time, latency constraints, and throughput constraints.
 - These primitives are defined at a high level of abstraction, focusing on the structure and relationships within the categories rather than specific implementation details.
 - The primitives are orthogonal in the sense that they are distinct and do not overlap in their definitions or roles within the framework.","- ""This paper proposes a formalization of this declarative paradigm obtained with concepts from category theory.""
  - ""we present a formal description of the IBN problem using tools from category theory.""
  - ""The focus of this work is to formalize an approach for an IBN system using categorical tools, to then be implemented with a functional language, namely Haskell.""
  - ""The strength of category theory lies in the capability of reasoning with abstract concepts.""
  - ""The link between Haskell, or functional programming in general, and category theory might not be easy to see.""
  - ""By considering Hask as a category we can of course use all the other constructions defined in category theory (e.g., functors, monads, etc.).""
  - ""The intent category could then be linked to this new category S through a functor, which would map all objects from I to objects in S, while preserving the structure of the starting category.""
  - ""the functors going from the intent category I to categories S and R can be seen as ""meaning extracting"" functions, i.e. extracting requested services and their requirements from natural language intent expressions.""
  - ""This work has directly applied category theory concepts to IBN in order to build a formal representation of the intent specifications.""",,"- The paper explicitly states that it uses ""concepts from category theory"" to formalize the Intent-Based Networking (IBN) paradigm, indicating that category theory is the mathematical framework used.
 - Category theory is used to describe and work on abstract concepts, which aligns with the paper's focus on formalizing intent specifications.
 - The paper discusses the use of functors to map objects between categories, which is a key concept in category theory, ensuring that the structure of the starting category is preserved.
 - The framework is used to reason about abstract concepts and to extract meaning from natural language intent expressions, which are specific mathematical properties guaranteed by the framework.
 - The paper does not explicitly mention any limitations or constraints of the framework, nor does it detail specific proof techniques used beyond the application of category theory concepts.
 - The connection to Haskell is highlighted, but the paper does not specify any limitations or constraints related to this connection.","- ""The possibility of managing network infrastructures through software-based programmable interfaces is becoming a cornerstone in the evolution of communication networks.""
  - ""The Intent-Based Networking (IBN) paradigm is a novel declarative approach towards network management proposed by a few Standards Developing Organizations.""
  - ""This paper proposes a formalization of this declarative paradigm obtained with concepts from category theory.""
  - ""Taking this approach to Intent, an initial implementation of this formalization is presented using Haskell, a well-known functional programming language.""
  - ""The link between Haskell, or functional programming in general, and category theory might not be easy to see.""
  - ""By considering Hask as a category we can of course use all the other constructions defined in category theory (e.g., functors, monads, etc.).""
  - ""The focus of this work is to formalize an approach for an IBN system using categorical tools, to then be implemented with a functional language, namely Haskell.""
  - ""the functors going from the intent category I to categories S and R can be seen as ""meaning extracting"" functions, i.e. extracting requested services and their requirements from natural language intent expressions.""
  - ""This work has directly applied category theory concepts to IBN in order to build a formal representation of the intent specifications.""",,"- The paper discusses the integration of category theory with functional programming (Haskell) to formalize Intent-Based Networking (IBN).
 - Category theory is used to provide a mathematical foundation for IBN, which is then implemented using Haskell.
 - The paper describes how category theory concepts like functors are used to map intents to services and requirements, which is a form of integration between the declarative approach of IBN and the functional programming paradigm.
 - The use of functors as ""meaning extracting"" functions is a specific integration mechanism that bridges the gap between natural language intents and formal representations in Haskell.
 - The paper does not explicitly discuss constraints or challenges in paradigm integration, nor does it mention novel translation or embedding techniques beyond the use of category theory and functors.","- ""The notation used in functional languages is very close to that used in formal methods [3], hence any system designed using these methods can be implemented very rapidly as functional languages are often considered as executable specification languages [4], particularly with its close link to category theory.""
  - ""Category theory is a branch of mathematics that provides a powerful methodology to describe and work on abstract concepts, including math itself.""
  - ""The focus of this work is to formalize an approach for an IBN system using categorical tools, to then be implemented with a functional language, namely Haskell.""
  - ""The link between Haskell, or functional programming in general, and category theory might not be easy to see. However, it is possible to construct a category Hask [17] in which Ob(Hask) contains all Haskell data types (e.g., Int, Bool, etc.) and morphisms between these are function between types (e.g., isEven :: Int → Bool).""
  - ""The objects in I could be described with a type defined as:
 

 This example could also be used to explain how types can be defined in Haskell.""
  - ""The objects of this category represent all the services that can be requested by an intent, while morphisms between these objects could embed composition rules between services.""
  - ""the functors going from the intent category I to categories S and R can be seen as ""meaning extracting"" functions, i.e. extracting requested services and their requirements from natural language intent expressions.""
  - ""the type checking features of Haskell, the NSD format is automatically validated during every parsing and rendering of the YAML file, thus increasing the robustness of the code.""",,"- The paper uses category theory as a mathematical tool to describe abstract concepts, which is a key mechanism for representing generic abstractions.
 - The use of Haskell as a functional programming language is highlighted for its ability to implement these abstract concepts rapidly, indicating a focus on generic programming.
 - The paper discusses the construction of categories like Hask, which contains all Haskell data types and morphisms, showing how Haskell's type system supports generic programming.
 - The definition of types in Haskell is used to describe objects in categories, which is a mechanism for representing generic abstractions.
 - The use of functors to map objects from one category to another is a mechanism for abstraction, as it extracts meaning from intent expressions.
 - The paper mentions the automatic validation of the NSD format through Haskell's type checking features, which is a static checking strategy.
 - The paper does not explicitly mention minimal type requirements or specific optimization strategies beyond type checking.","- ""This paper proposes a formalization of this declarative paradigm obtained with concepts from category theory.""
  - ""In this work, we present a formal description of the IBN problem using tools from category theory.""
  - ""The focus of this work is to formalize an approach for an IBN system using categorical tools, to then be implemented with a functional language, namely Haskell.""
  - ""This work has directly applied category theory concepts to IBN in order to build a formal representation of the intent specifications.""
  - ""This representation aims to help with the reasoning about this new paradigm, while keeping a close relationship with functional programming and the possible implementations.""
  - ""Further works can be made in both directions. For example, lenses in category theory [18] are used to describe in mathematical terms the concepts of agent and environment, thus they could serve as a valid tool to model the interaction between the Intent System and the network infrastructure it is managing.""",,"- The paper introduces a novel application of category theory to formalize Intent-Based Networking (IBN), which is a significant theoretical contribution. This is evident from the repeated emphasis on using category theory to formalize IBN concepts.
 - The use of category theory provides a rigorous mathematical foundation for IBN, which is a theoretical advancement beyond existing approaches that may not have such a formal basis.
 - The paper highlights the potential for category theory to enhance reasoning about IBN, which is a key theoretical insight. This suggests that the formal representation can aid in understanding and designing IBN systems more effectively.
 - The mention of lenses in category theory as a future direction indicates potential implications for programming language design, particularly in modeling interactions between systems and environments.
 - The paper's focus on formalizing IBN using category theory and its connection to functional programming languages like Haskell suggests a theoretical contribution in integrating mathematical concepts with programming paradigms."
Computing Surveys symposium on models of programming languages and computation,"C. Hankin, H. R. Nielson",10.1145/234528.234729,https://doi.org/10.1145/234528.234729,CSUR,0,1996,Not specified (the abstract does not explicitly define any conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework used to formalize and guarantee properties of conceptual primitives),"- Specific integration mechanisms proposed: Algebraic view of the problem (Mycroft)
 - Interaction models between paradigms: Not mentioned
 - Constraints or challenges in paradigm integration: Issues involved in integration (Mycroft)
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Key novel insights: Integration of techniques from different areas for modern programming languages; emphasis on declarative languages and programming languages for open systems.
 - Theoretical advancements: Algebraic view for paradigm integration; use of higher-order modal logics and temporal logics for concurrent system verification; resource-bounded partial evaluation.
 - Potential implications: Advancements in programming language design through paradigm integration; improved efficiency and verification in concurrent systems.","- ""Taking into account that the demands for modern programming languages involve the skillful integration of techniques from different areas, the aim is to describe the state of the art, present the challenging problems, and outline emerging directions.""
  - ""The articles on programming language design give an overview of some of the major issues in language design.""
  - ""The main emphasis is on declarative languages (Gilbert, Hanus and Kuchen, Reddy, and Wadler) and programming languages for open systems (Agha, and Andreoli and Pareschi), a notable example being Web languages (Ciancarini, and Volpano and Smith).""
  - ""Mycroft discusses issues involved in the integration of paradigms and proposes an algebraic view of the problem.""
  - ""The articles on program analysis give a broad and comprehensive overview of the variety of the field.""
  - ""the article by Danvy, Heintze, and Malmkjær discusses resource-bounded partial evaluation; partial evaluation often relies on the results of program analyses to ensure termination and efficiency.""
  - ""Finally, a few articles are concerned with program verification and types.""",,"- The abstract discusses various aspects of programming languages and computation, including design, analysis, verification, and types, but it does not explicitly mention any conceptual primitives.
 - The focus is on describing the state of the art, challenging problems, and emerging directions rather than defining specific primitives.
 - The mention of ""integration of paradigms"" and ""algebraic view"" suggests a theoretical framework, but no specific primitives are listed or defined.
 - The abstract does not provide explicit definitions or lists of conceptual primitives for reconstructing programming paradigms.","- ""The articles on programming language design give an overview of some of the major issues in language design.""
  - ""The main emphasis is on declarative languages (Gilbert, Hanus and Kuchen, Reddy, and Wadler) and programming languages for open systems (Agha, and Andreoli and Pareschi), a notable example being Web languages (Ciancarini, and Volpano and Smith).""
  - ""Mycroft discusses issues involved in the integration of paradigms and proposes an algebraic view of the problem.""
  - ""The articles on program analysis give a broad and comprehensive overview of the variety of the field.""
  - ""Cousot and Filé, Giacobazzi, and Ranzato present the overall aims of abstract interpretation as well as some of the recent more exciting developments.""
  - ""The article by Jagannathan and Wright presents the use of interprocedural flow analysis for compilation.""
  - ""Nielson gives an overview of a rather recent inference-based approach to program analysis.""
  - ""The contributions by Le Métayer and Schmidt and by Benton show the breadth of semantics underpinnings of program analysis.""
  - ""Finally, a few articles are concerned with program verification and types.""
  - ""The article by Dam discusses how higherorder modal logics and temporal logics can be used to verify concurrent systems.""
  - ""Cartwright and Felleisen show how soft typing can be used for restricted forms of""",,"- The abstract mentions various topics related to programming languages and computation, including programming language design, program analysis, and program verification.
 - It highlights the emphasis on declarative languages and programming languages for open systems, which might involve specific mathematical frameworks, but it does not specify any particular framework.
 - Mycroft's proposal of an ""algebraic view"" suggests a potential mathematical framework, but it is not detailed further in the abstract.
 - The mention of abstract interpretation and inference-based approaches to program analysis implies the use of mathematical frameworks, but again, no specific framework is named.
 - The discussion of higher-order modal logics and temporal logics for verifying concurrent systems indicates a mathematical framework, but it is not explicitly described as a framework for formalizing conceptual primitives.
 - The abstract does not provide specific details about the type of mathematical framework, mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""Mycroft discusses issues involved in the integration of paradigms and proposes an algebraic view of the problem.""
  - ""Taking into account that the demands for modern programming languages involve the skillful integration of techniques from different areas, the aim is to describe the state of the art, present the challenging problems, and outline emerging directions.""",,"- The abstract mentions the integration of techniques from different areas, indicating a focus on integrating different programming paradigms.
 - Mycroft's contribution is specifically highlighted as discussing issues involved in the integration of paradigms, suggesting that there is some discussion of integration challenges.
 - Mycroft proposes an ""algebraic view of the problem,"" which implies a theoretical integration strategy or mechanism.
 - However, the abstract does not provide specific details about interaction models, constraints, or novel translation techniques, nor does it elaborate on the algebraic view beyond mentioning it.","- ""the aim is to describe the state of the art, present the challenging problems, and outline emerging directions.""
  - ""The articles on programming language design give an overview of some of the major issues in language design.""
  - ""The main emphasis is on declarative languages (Gilbert, Hanus and Kuchen, Reddy, and Wadler) and programming languages for open systems (Agha, and Andreoli and Pareschi), a notable example being Web languages (Ciancarini, and Volpano and Smith).""
  - ""Mycroft discusses issues involved in the integration of paradigms and proposes an algebraic view of the problem.""
  - ""The articles on program analysis give a broad and comprehensive overview of the variety of the field.""
  - ""The contributions by Le Métayer and Schmidt and by Benton show the breadth of semantics underpinnings of program analysis.""
  - ""Finally, a few articles are concerned with program verification and types.""",,"- The abstract provides an overview of the symposium's focus on models of programming languages and computation, but it does not specifically mention generic programming or abstraction mechanisms.
 - The emphasis on declarative languages and programming languages for open systems suggests a focus on language design, but there is no explicit mention of genericity or abstraction mechanisms.
 - The discussion of program analysis and verification includes topics like abstract interpretation and type systems, but again, there is no specific mention of generic programming or abstraction mechanisms.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""Taking into account that the demands for modern programming languages involve the skillful integration of techniques from different areas, the aim is to describe the state of the art, present the challenging problems, and outline emerging directions.""
  - ""The articles on programming language design give an overview of some of the major issues in language design.""
  - ""The main emphasis is on declarative languages (Gilbert, Hanus and Kuchen, Reddy, and Wadler) and programming languages for open systems (Agha, and Andreoli and Pareschi), a notable example being Web languages (Ciancarini, and Volpano and Smith).""
  - ""Mycroft discusses issues involved in the integration of paradigms and proposes an algebraic view of the problem.""
  - ""The articles on program analysis give a broad and comprehensive overview of the variety of the field.""
  - ""the article by Danvy, Heintze, and Malmkjær discusses resource-bounded partial evaluation; partial evaluation often relies on the results of program analyses to ensure termination and efficiency.""
  - ""Finally, a few articles are concerned with program verification and types.""
  - ""The article by Dam discusses how higherorder modal logics and temporal logics can be used to verify concurrent systems.""",,"- The abstract highlights the integration of techniques from different areas as a key focus, indicating a novel approach to programming language design by combining various paradigms.
 - The emphasis on declarative languages and programming languages for open systems suggests a theoretical contribution in these areas, particularly with the mention of Web languages, which were emerging at the time.
 - Mycroft's proposal of an algebraic view for paradigm integration is a theoretical advancement, as it offers a new perspective on how to integrate different programming paradigms.
 - The discussion on program analysis and verification indicates theoretical contributions in these areas, particularly with the use of higher-order modal logics and temporal logics for concurrent system verification.
 - The mention of resource-bounded partial evaluation and its reliance on program analysis results suggests a theoretical contribution in optimizing program efficiency and termination."
A programming calculus based on partial inductive definitions (with an introduction to the theory of partial inductive definitions),"L. Eriksson, Lars Hallnäs",-,-,-,4,1988,Not specified (the abstract does not explicitly define conceptual primitives or their definitions),"- Type of mathematical framework: Theory of partial inductive definitions
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,"- Definition of ""concept"" used: Partial inductive definitions
 - Mechanisms for representing generic abstractions: Extension to Horn clauses of logic
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: Introduction of a general framework for program specification, verification, and synthesis based on partial inductive definitions.
 - Theoretical advancements: Use of partial inductive definitions instead of predicate logic, extension of Horn clauses, and flexibility in using arbitrary specification languages.
 - Potential implications: Broadens the scope of logic programming, offers versatility in programming language design, and introduces a new theoretical foundation for programming calculus.","- ""The program language is based on partial inductive definitions.""
  - ""The programming calculus permits us to use an arbitrary specification language, as long as this language itself can be defined within our framework.""
  - ""The underlying programming paradigm is similar in spirit to logic programming but based on the theory of partial inductive definitions instead of predicate logic.""
  - ""We present a general framework (a programming calculus) for the specification, verification and synthesis of programs.""
  - ""Such definitions can be regarded as sets of an extension to Horn clauses of logic, so traditional logic (pure Prolog) programs are included as a special case.""",,"- The abstract discusses a ""programming calculus"" as a framework for specifying, verifying, and synthesizing programs, which suggests a theoretical framework rather than specific conceptual primitives.
 - The underlying paradigm is based on ""partial inductive definitions,"" which is a theoretical foundation rather than a specific primitive.
 - The abstract mentions that the programming language is based on ""partial inductive definitions,"" which are described as an extension to Horn clauses, but this does not explicitly define conceptual primitives.
 - There is no explicit mention of specific conceptual primitives or their definitions in the abstract.
 - The abstract does not provide a list of primitives or their precise definitions, nor does it discuss their level of abstraction or orthogonality.","- ""We present a general framework (a programming calculus) for the specification, verification and synthesis of programs.""
  - ""The underlying programming paradigm is similar in spirit to logic programming but based on the theory of partial inductive definitions instead of predicate logic.""
  - ""The programming calculus permits us to use an arbitrary specification language, as long as this language itself can be defined within our framework.""
  - ""The program language is based on partial inductive definitions.""
  - ""Such definitions can be regarded as sets of an extension to Horn clauses of logic, so traditional logic (pure Prolog) programs are included as a special case.""
  - ""Since the theory of partial inductive definitions is not widely known, we include an introduction to it.""",,"- The abstract mentions a ""programming calculus"" as the mathematical framework, which is based on the ""theory of partial inductive definitions.""
 - This framework is distinct from predicate logic, which is commonly used in logic programming, indicating a unique mathematical foundation.
 - The framework allows for the use of any specification language that can be defined within it, suggesting flexibility in its application.
 - The mention of ""partial inductive definitions"" as an extension to Horn clauses implies a specific mathematical property related to inductive reasoning.
 - The abstract does not explicitly mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework, but it does introduce the theory of partial inductive definitions, which is central to the framework.","- ""The programming calculus permits us to use an arbitrary specification language, as long as this language itself can be defined within our framework.""
  - ""Such definitions can be regarded as sets of an extension to Horn clauses of logic, so traditional logic (pure Prolog) programs are included as a special case.""
  - ""The underlying programming paradigm is similar in spirit to logic programming but based on the theory of partial inductive definitions instead of predicate logic.""",,"- The abstract mentions that the programming paradigm is similar to logic programming but is based on partial inductive definitions, indicating a shift from traditional predicate logic.
 - It suggests that the framework allows for the use of any specification language that can be defined within it, which implies flexibility in integrating different languages or paradigms.
 - The mention of partial inductive definitions being an extension to Horn clauses indicates a theoretical integration strategy, as it includes traditional logic programs as a special case.
 - However, the abstract does not explicitly discuss specific integration mechanisms, interaction models, constraints, or novel translation techniques between different paradigms.","- ""The underlying programming paradigm is similar in spirit to logic programming but based on the theory of partial inductive definitions instead of predicate logic.""
  - ""The program language is based on partial inductive definitions.""
  - ""Such definitions can be regarded as sets of an extension to Horn clauses of logic, so traditional logic (pure Prolog) programs are included as a special case.""
  - ""We present a general framework (a programming calculus) for the specification, verification and synthesis of programs.""
  - ""The programming calculus permits us to use an arbitrary specification language, as long as this language itself can be defined within our framework.""",,"- The abstract discusses a programming calculus that allows for the specification, verification, and synthesis of programs, which suggests a focus on abstraction mechanisms.
 - The use of ""partial inductive definitions"" as the basis for the programming language indicates a mechanism for representing generic abstractions, as it extends traditional logic programming.
 - The mention of using ""an arbitrary specification language"" implies flexibility and genericity in the framework, as it can accommodate various languages.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on a general framework and the use of partial inductive definitions suggests a level of abstraction and genericity.
 - The abstract does not provide detailed information on type systems or specific optimization strategies, but it does imply a level of abstraction through the use of partial inductive definitions.","- ""We present a general framework (a programming calculus) for the specification, verification and synthesis of programs.""
  - ""The underlying programming paradigm is similar in spirit to logic programming but based on the theory of partial inductive definitions instead of predicate logic.""
  - ""The programming calculus permits us to use an arbitrary specification language, as long as this language itself can be defined within our framework.""
  - ""The program language is based on partial inductive definitions.""
  - ""Such definitions can be regarded as sets of an extension to Horn clauses of logic, so traditional logic (pure Prolog) programs are included as a special case.""
  - ""Since the theory of partial inductive definitions is not widely known, we include an introduction to it.""",,"- The abstract introduces a ""general framework"" for programming, which suggests a novel approach to program specification, verification, and synthesis.
 - The use of ""partial inductive definitions"" instead of ""predicate logic"" indicates a theoretical advancement beyond traditional logic programming paradigms.
 - The flexibility to use ""an arbitrary specification language"" as long as it can be defined within the framework is a key novel insight, offering versatility in programming language design.
 - The extension of Horn clauses to include partial inductive definitions is a theoretical advancement, as it broadens the scope of logic programming.
 - The inclusion of an introduction to the theory of partial inductive definitions implies that this is a new or underutilized area in programming calculus, contributing to theoretical knowledge."
"Confluence: The Unifying, Expressive Power of Locality","Jiaxiang Liu, J. Jouannaud",10.1007/978-3-642-54624-2_17,https://doi.org/10.1007/978-3-642-54624-2_17,"Specification, Algebra, and Software",6,2014,Not specified (the paper does not explicitly define conceptual primitives or provide precise definitions and orthogonality scores),Not specified (the paper does not explicitly mention the type of mathematical framework or specific mathematical properties guaranteed),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The paper provides a novel approach to handling multiple overlaps through the Parallel Closure Theorem, which relies on an ingenious induction.
 - Theoretical advancements: The paper offers a unique perspective on locality and its unifying power, which is a theoretical contribution beyond existing approaches.
 - Potential implications: The focus on locality could have implications for programming language design by offering new ways to unify different paradigms.","- ""The field of programming languages is in a phase of specialization. Among the main programming paradigms are imperative programming, functional programming, logic programming, object oriented programming, concurrent programming and distributed programming.""
  - ""Each of these fields is further specialized. For example, there are many different paradigms for functional programming: LISP, Mac Carthy’s original functional programming paradigm based on pure lambda-calculus for lists enriched with recursion; ML, Milner’s paradigm based on a typed lambda-calculus enriched with data types, a let construct and recursion which has become a standard; O’Donnel’s paradigm based on orthogonal rewriting; and OBJ, Goguen’s paradigm based on terminating rewriting in first-order algebra to cite a few.""
  - ""Similarly, logic programming has given rise to constraint logic programming, as well as query languages for data bases.""
  - ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""van Oostrom (June 16, 2020, private communication) liu's proof may look quite different to your proof, but it seems based on a similar main idea""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper discusses various programming paradigms and their specializations, indicating a focus on the diversity within these paradigms.
 - The mention of different paradigms within functional programming (e.g., LISP, ML, O’Donnel’s, OBJ) suggests that these could be considered as conceptual primitives, as they are foundational elements within the broader paradigm.
 - The paper does not explicitly define these paradigms as ""conceptual primitives,"" nor does it provide a precise definition or orthogonality score for them.
 - The tables referenced in the paper do not contain explicit definitions or discussions of conceptual primitives.
 - The paper's focus on the Parallel Closure Theorem and its reliance on induction suggests a theoretical framework, but it does not explicitly define conceptual primitives within this context.","- ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""the book keeping required by working with sets of positions as well as formally reasoning about this measure in Isabelle became so convoluted that it very much obscured the ingenuity and elegance of Huet's original idea while at the same time defeating our formalization efforts.""
  - ""van Oostrom (June 16, 2020, private communication) liu's proof may look quite different to your proof, but it seems based on a similar main idea""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper mentions the use of ""ingenious induction"" in the context of the Parallel Closure Theorem, which suggests a proof technique involving induction.
 - The mention of ""Isabelle"" indicates the use of a formal verification tool, likely Isabelle/HOL, which is based on higher-order logic.
 - The reference to ""sets of positions"" and ""formally reasoning about this measure"" implies a focus on formal verification, possibly using type theory or a similar framework.
 - The tables referenced do not provide explicit details about the mathematical framework, but they may contain data related to the formal verification process.
 - The paper does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - The limitations or constraints of the framework are hinted at by the mention of ""book keeping"" becoming ""convoluted,"" which suggests challenges in formalizing certain concepts.","- ""The field of programming languages is in a phase of specialization. Among the main programming paradigms are imperative programming, functional programming, logic programming, object oriented programming, concurrent programming and distributed programming.""
  - ""Each of these fields is further specialized. For example, there are many different paradigms for functional programming: LISP, Mac Carthy’s original functional programming paradigm based on pure lambda-calculus for lists enriched with recursion; ML, Milner’s paradigm based on a typed lambda-calculus enriched with data types, a let construct and recursion which has become a standard; O’Donnel’s paradigm based on orthogonal rewriting; and OBJ, Goguen’s paradigm based on terminating rewriting in first-order algebra to cite a few.""
  - ""Similarly, logic programming has given rise to constraint logic programming, as well as query languages for data bases.""
  - ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""Consequently, when starting the present formalization, we also adopted this definition. However, the book keeping required by working with sets of positions as well as formally reasoning about this measure in Isabelle became so convoluted that it very much obscured the ingenuity and elegance of Huet's original idea while at the same time defeating our formalization efforts.""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper discusses the specialization phase in the field of programming languages, mentioning various paradigms such as imperative, functional, logic, object-oriented, concurrent, and distributed programming. This indicates a focus on the diversity of programming paradigms.
 - The paper provides examples of further specialization within these paradigms, such as different functional programming paradigms (LISP, ML, O’Donnel’s, OBJ) and the evolution of logic programming into constraint logic programming and query languages. This suggests a recognition of the complexity and diversity within each paradigm.
 - The mention of the Parallel Closure Theorem and its reliance on induction to reduce overlaps to critical pairs suggests a theoretical approach to handling complexity in programming paradigms, but it does not explicitly address integration mechanisms or interaction models between paradigms.
 - The paper does not provide specific integration mechanisms, interaction models, constraints, or novel translation techniques for integrating different programming paradigms. The focus appears to be more on the theoretical aspects and challenges in formalization rather than on integration strategies.
 - The tables included in the paper do not provide explicit information on integration approaches or mechanisms.","- ""The field of programming languages is in a phase of specialization.""
  - ""Among the main programming paradigms are imperative programming, functional programming, logic programming, object oriented programming, concurrent programming and distributed programming.""
  - ""Each of these fields is further specialized.""
  - ""For example, there are many different paradigms for functional programming: LISP, Mac Carthy’s original functional programming paradigm based on pure lambda-calculus for lists enriched with recursion; ML, Milner’s paradigm based on a typed lambda-calculus enriched with data types, a let construct and recursion which has become a standard; O’Donnel’s paradigm based on orthogonal rewriting; and OBJ, Goguen’s paradigm based on terminating rewriting in first-order algebra to cite a few.""
  - ""Similarly, logic programming has given rise to constraint logic programming, as well as query languages for data bases.""
  - ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""Consequently, when starting the present formalization, we also adopted this definition.""
  - ""van Oostrom (June 16, 2020, private communication) liu's proof may look quite different to your proof, but it seems based on a similar main idea""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper discusses various programming paradigms and their specializations, indicating a focus on the diversity and evolution of programming languages rather than generic programming.
 - The mention of different paradigms for functional programming and logic programming suggests a focus on the theoretical aspects of programming languages rather than generic programming methodologies.
 - The paper does not explicitly mention generic programming or abstraction mechanisms, nor does it discuss type systems or static checking strategies related to genericity.
 - The tables included in the paper do not provide information on generic programming or abstraction mechanisms.
 - The paper's focus on the Parallel Closure Theorem and formalization efforts suggests a theoretical approach rather than a focus on generic programming.","- ""The field of programming languages is in a phase of specialization.""
  - ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""van Oostrom (June 16, 2020, private communication) liu's proof may look quite different to your proof, but it seems based on a similar main idea""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper discusses the specialization phase in programming languages, indicating a focus on theoretical contributions within this context.
 - The mention of the Parallel Closure Theorem suggests a theoretical advancement in handling multiple overlaps, which is a novel insight in the field.
 - The comparison with van Oostrom's work implies that the paper offers a unique perspective or approach, even if it shares a similar main idea, which is a theoretical contribution.
 - The tables included at the end of the paper likely provide data or results that support these theoretical contributions, although their specific content is not detailed here.
 - The paper's focus on locality and its unifying, expressive power suggests potential implications for programming language design, as it may offer new ways to approach or unify different programming paradigms."
Multi-paradigm Programming in Maude,Santiago Escobar,10.1007/978-3-319-99840-4_2,https://doi.org/10.1007/978-3-319-99840-4_2,WRLA@ETAPS,1,2018,Not specified (the abstract does not explicitly define new conceptual primitives),Not specified (the abstract does not provide explicit details on the mathematical framework characteristics),"- Specific integration mechanisms proposed: Replacing functional viewpoint with an equational viewpoint; changing focus from narrowing with rules to narrowing with variant equations (equational unification).
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Integration of multi-paradigm programming into Maude with an equational viewpoint.
 - Theoretical advancements: Use of equational properties (associativity, commutativity) and order-sorted information; shift from narrowing with rules to narrowing with variant equations.
 - Potential implications: Enhanced performance and functionality in programming language design through equational unification.","- ""Modern multi-paradigm programming languages combine the most important features of functional programming, logic programming, concurrent programming, and constraint programming.""
  - ""A former paper illustrated how many features available in modern functional logic languages are easily definable and simulated in Maude, and showed how Maude goes beyond standard practices in the functional logic area by using, e.g. equational properties such as associativity and commutativity or order-sorted information.""
  - ""Multi-paradigm programming applied to the Maude specification language would replace the functional viewpoint by an equational viewpoint while retaining and extending the other features.""
  - ""In this paper we provide more relevant execution results by changing the focus from narrowing with rules (i.e., symbolic reachability) into narrowing with variant equations (i.e., equational unification), the latter now implemented in Maude 2.7.1 with very good performance.""",,"- The abstract discusses the integration of various programming paradigms (functional, logic, concurrent, constraint) into Maude, which suggests a focus on combining different programming features rather than defining new conceptual primitives.
 - The mention of replacing the functional viewpoint with an equational viewpoint indicates a shift in perspective but does not explicitly define new primitives.
 - The abstract highlights the use of equational properties like associativity and commutativity, which are existing concepts rather than new primitives.
 - The focus on narrowing with variant equations and equational unification is a methodological change rather than the definition of new conceptual primitives.
 - There is no explicit mention of new conceptual primitives being defined or proposed in the abstract.","- ""Multi-paradigm programming applied to the Maude specification language would replace the functional viewpoint by an equational viewpoint while retaining and extending the other features.""
  - ""In this paper we provide more relevant execution results by changing the focus from narrowing with rules (i.e., symbolic reachability) into narrowing with variant equations (i.e., equational unification), the latter now implemented in Maude 2.7.1 with very good performance.""
  - ""Modern multi-paradigm programming languages combine the most important features of functional programming, logic programming, concurrent programming, and constraint programming.""
  - ""A former paper illustrated how many features available in modern functional logic languages are easily definable and simulated in Maude, and showed how Maude goes beyond standard practices in the functional logic area by using, e.g. equational properties such as associativity and commutativity or order-sorted information.""",,"- The abstract discusses the integration of various programming paradigms into Maude, which suggests a focus on the theoretical foundations of these paradigms.
 - The mention of ""equational viewpoint"" and ""equational properties such as associativity and commutativity or order-sorted information"" indicates a mathematical framework based on equational logic.
 - The abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it detail specific mathematical properties guaranteed or proof techniques used.
 - The focus on ""equational unification"" and ""narrowing with variant equations"" suggests a framework that involves equational reasoning, but the abstract does not provide further details on the theoretical foundations or proof methodology.
 - The abstract does not mention any limitations or constraints of the framework.","- ""Multi-paradigm programming applied to the Maude specification language would replace the functional viewpoint by an equational viewpoint while retaining and extending the other features.""
  - ""In this paper we provide more relevant execution results by changing the focus from narrowing with rules (i.e., symbolic reachability) into narrowing with variant equations (i.e., equational unification), the latter now implemented in Maude 2.7.1 with very good performance.""
  - ""A former paper illustrated how many features available in modern functional logic languages are easily definable and simulated in Maude, and showed how Maude goes beyond standard practices in the functional logic area by using, e.g. equational properties such as associativity and commutativity or order-sorted information.""
  - ""Modern multi-paradigm programming languages combine the most important features of functional programming, logic programming, concurrent programming, and constraint programming.""",,"- The abstract discusses the integration of different programming paradigms in the context of the Maude specification language. It mentions that Maude combines features from functional, logic, concurrent, and constraint programming.
 - The integration approach involves replacing the functional viewpoint with an equational viewpoint, which suggests a shift in how programming is conceptualized within Maude.
 - The abstract highlights that Maude can simulate features from modern functional logic languages and extends them by using equational properties like associativity and commutativity. This indicates a mechanism for integrating logic programming with other paradigms.
 - The change from narrowing with rules to narrowing with variant equations (equational unification) is a specific integration mechanism that improves performance in Maude 2.7.1.
 - There is no explicit mention of interaction models between paradigms or specific constraints or challenges in paradigm integration in the abstract.
 - The abstract does not provide novel translation or embedding techniques beyond the shift to an equational viewpoint and the implementation of equational unification.","- ""Modern multi-paradigm programming languages combine the most important features of functional programming, logic programming, concurrent programming, and constraint programming.""
  - ""Multi-paradigm programming applied to the Maude specification language would replace the functional viewpoint by an equational viewpoint while retaining and extending the other features.""
  - ""In this paper we provide more relevant execution results by changing the focus from narrowing with rules (i.e., symbolic reachability) into narrowing with variant equations (i.e., equational unification), the latter now implemented in Maude 2.7.1 with very good performance.""
  - ""A former paper illustrated how many features available in modern functional logic languages are easily definable and simulated in Maude, and showed how Maude goes beyond standard practices in the functional logic area by using, e.g. equational properties such as associativity and commutativity or order-sorted information.""",,"- The abstract discusses the integration of various programming paradigms into Maude, which suggests a focus on multi-paradigm programming rather than generic programming specifically.
 - The mention of ""equational viewpoint"" and ""equational properties"" indicates a focus on equational logic rather than generic programming mechanisms.
 - The abstract does not explicitly mention generic programming, abstraction mechanisms, or type systems, which are key components of generic programming.
 - The focus on ""narrowing with variant equations"" and ""equational unification"" suggests a focus on execution and implementation rather than genericity or abstraction mechanisms.","- ""Multi-paradigm programming applied to the Maude specification language would replace the functional viewpoint by an equational viewpoint while retaining and extending the other features.""
  - ""Modern multi-paradigm programming languages combine the most important features of functional programming, logic programming, concurrent programming, and constraint programming.""
  - ""In this paper we provide more relevant execution results by changing the focus from narrowing with rules (i.e., symbolic reachability) into narrowing with variant equations (i.e., equational unification), the latter now implemented in Maude 2.7.1 with very good performance.""
  - ""A former paper illustrated how many features available in modern functional logic languages are easily definable and simulated in Maude, and showed how Maude goes beyond standard practices in the functional logic area by using, e.g. equational properties such as associativity and commutativity or order-sorted information.""",,"- The abstract discusses the integration of multi-paradigm programming features into the Maude specification language, which is a novel approach as it shifts from a functional to an equational viewpoint.
 - The mention of replacing the functional viewpoint with an equational one suggests a theoretical contribution by extending the capabilities of Maude beyond traditional functional logic languages.
 - The use of equational properties like associativity and commutativity, as well as order-sorted information, indicates a theoretical advancement beyond standard practices in functional logic programming.
 - The shift from narrowing with rules to narrowing with variant equations represents a theoretical innovation in how Maude handles symbolic reachability and equational unification, which could have implications for programming language design by enhancing performance and functionality."
A Formal Theory of Choreographic Programming,"L. Cruz-Filipe, F. Montesi, Marco Peressotti",10.1007/s10817-023-09665-3,https://doi.org/10.1007/s10817-023-09665-3,Journal of automated reasoning,9,2022,"1. Primitive Name: Choreographic Programming
  Definition: A paradigm for writing coordination plans for distributed systems from a global point of view.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Linguistic Primitive for Communication
  Definition: A primitive like ""Alice.e → Bob.x"" for specifying communication between processes.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Endpoint Projection (EPP)
  Definition: A procedure that automatically synthesizes executable code from choreographies.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Signature
  Definition: Defines types for process names, local variables, values, expressions, and procedure names.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Labelled Transition Systems
  Definition: A method for defining the semantics of choreographies.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory (Coq)
 - Specific mathematical properties guaranteed: Deadlock-freedom, determinism, confluence
 - Proof techniques used: Inductive definitions and proofs
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Endpoint Projection (EPP) translates choreographies into executable code for each process.
 - Interaction models between paradigms: Choreographic languages are integrated with process languages through EPP.
 - Constraints or challenges in paradigm integration: Complexity in translating choreographic instructions into multiple process language instructions.
 - Novel translation or embedding techniques: Operational correspondence between choreographies and their projections ensures correctness.",Generic programming not extensively addressed,"The paper introduces a formalisation of choreographic programming using Coq, enhancing confidence in proof correctness and simplifying the theory. It provides a foundation for future developments, addresses concerns about proof correctness, and offers insights into formalising concurrent system semantics. The approach of defining procedures at the top level simplifies the theory, and the proof of confluence is significantly streamlined. These contributions advance the theoretical framework of choreographic programming and have implications for programming language design.","- ""Choreographic programming is a paradigm for writing coordination plans for distributed systems from a global point of view, from which correct-by-construction decentralised implementations can be generated automatically.""
  - ""choreographic languages are used to define interaction protocols that communicating processes should abide by""
  - ""These languages are akin to the ""Alice and Bob"" notation found in security protocols, and inherit the key idea of making data communication manifest in programs""
  - ""This is usually obtained through a linguistic primitive like Alice.e → Bob.x, read ""Alice communicates the result of evaluating expression e to Bob, which stores it in its local variable x"".""
  - ""Choreographic programming languages come with a procedure known as Endpoint Projection (EPP), which automatically synthesises executable code for each process described in a choreography, with the guarantee that executing these processes together implements the communications prescribed in the choreography""
  - ""The interplay between these components, where a single instruction at the choreographic level might be implemented by multiple instructions in the target language, makes the theory of choreographic programming error-prone:""
  - ""Choreographies are parameterised by a signature, which defines the types for process names (processes for short) pid, local variables var (used to access the processes' storage), values val, expressions expr, Boolean expressions bexpr, and procedure names recvar (from recursion variables).""
  - ""Choreographies are defined inductively by the following grammar.4""
  - ""The semantics of CC is defined by means of labelled transition systems, in three layers.""",,"- The paper discusses choreographic programming as a paradigm for distributed systems, focusing on global coordination plans that can be automatically translated into decentralized implementations.
 - Choreographic languages are defined by their ability to specify interaction protocols between processes, emphasizing data communication.
 - The linguistic primitive ""Alice.e → Bob.x"" is a fundamental concept, representing communication between processes.
 - Endpoint Projection (EPP) is a key procedure that translates choreographies into executable code, ensuring that the communications are correctly implemented.
 - The paper mentions the importance of signatures in defining types for process names, variables, values, expressions, and procedure names, which are essential for choreographic programming.
 - The semantics of choreographies are defined using labelled transition systems, indicating a structured approach to understanding the behavior of these systems.","- ""In this work, we formalise the theory of a choreographic programming language in Coq.""
  - ""Our development includes the basic properties of this language, a proof of its Turing completeness, a compilation procedure to a process language, and an operational characterisation of the correctness of this procedure.""
  - ""Our formalisation experience illustrates the benefits of using a theorem prover: we get both an additional degree of confidence from the mechanised proof, and a significant simplification of the underlying theory.""
  - ""The semantics of CC is defined by means of labelled transition systems, in three layers.""
  - ""The transition relations are defined inductively by the rules in Figs. 5, 6, 7.""
  - ""The first key property of choreographies is that they are deadlock-free by design: any choreography that is not terminated can execute.""
  - ""The second property of our semantics is that it is deterministic, in the sense that transitions can be uniquely inferred from their label or the resulting state.""
  - ""The third key property is confluence, which has some relevant implications for our calculus: if a choreography has two different transition paths, then these paths either end at the same configuration, or both resulting configurations can reach the same one.""
  - ""Using these results, we can establish Turing completeness of CC.""
  - ""The formalisation of partial recursive functions contains 22 definitions and 84 lemmas, with a total of 1464 lines of code.""
  - ""The proof of Turing completeness consists of 28 definitions and 65 lemmas, with a total of 2371 lines of code.""",,"- The paper uses Coq, a theorem prover based on type theory, as the mathematical framework to formalize the choreographic programming language.
 - The framework guarantees properties such as deadlock-freedom, determinism, and confluence, which are essential for the correctness and reliability of choreographic programming.
 - The proof techniques used include inductive definitions and proofs, as indicated by the use of labelled transition systems and the formalization of partial recursive functions.
 - The framework simplifies the underlying theory and provides additional confidence through mechanized proofs.
 - The limitations or constraints of the framework are not explicitly mentioned, but the use of Coq implies a focus on formal verification and proof-based reasoning.","- ""Choreographic programming is a paradigm for writing coordination plans for distributed systems from a global point of view, from which correct-by-construction decentralised implementations can be generated automatically.""
  - ""Choreographic programming languages come with a procedure known as Endpoint Projection (EPP), which automatically synthesises executable code for each process described in a choreography, with the guarantee that executing these processes together implements the communications prescribed in the choreography""
  - ""EPP involves three elements: the source choreographic language, the target process language, and the compiler.""
  - ""The interplay between these components, where a single instruction at the choreographic level might be implemented by multiple instructions in the target language, makes the theory of choreographic programming error-prone:""
  - ""The formalisation of partial recursive functions contains 22 definitions and 84 lemmas, with a total of 1464 lines of code. The proof of Turing completeness consists of 28 definitions and 65 lemmas, with a total of 2371 lines of code.""
  - ""The second part of our formalisation concerns the process calculus that we use for implementing CC: Stateful Processes (SP).""
  - ""The syntax of SP is structured in three layers: behaviours, which express the local actions performed by individual processes; networks, which combine processes in a system where they can interact; and programs, which pair a network with a set of procedure definitions (which all processes can call).""
  - ""The formalisation of SP consists of 25 definitions, 81 lemmas, 11 simple tactics, and approximately 1960 lines of Coq code.""
  - ""The operational correspondence between choreographies and their projections, which is the topic of Sect. 6, states that a projectable choreography can make a transition iff its projection can make a corresponding transition.""",,"- The paper discusses choreographic programming as a paradigm that integrates global coordination plans with decentralized implementations, which suggests an integration approach between these two aspects.
 - Endpoint Projection (EPP) is a key mechanism for integrating choreographic languages with process languages, as it translates choreographies into executable code for each process.
 - The paper describes the interplay between the source choreographic language, the target process language, and the compiler, which are essential components of the integration process.
 - The formalization of partial recursive functions and the proof of Turing completeness indicate a theoretical integration strategy that ensures the expressiveness and computational power of the choreographic language.
 - The use of Stateful Processes (SP) as a process calculus for implementing choreographies suggests an interaction model between choreographic and process paradigms.
 - The paper highlights the challenges in paradigm integration, such as the potential for errors due to the complexity of translating choreographic instructions into multiple process language instructions.
 - The operational correspondence between choreographies and their projections is a novel translation technique that ensures the correctness of the integration.","- ""Choreographic programming languages come with a procedure known as Endpoint Projection (EPP), which automatically synthesises executable code for each process described in a choreography, with the guarantee that executing these processes together implements the communications prescribed in the choreography""
  - ""The interplay between these components, where a single instruction at the choreographic level might be implemented by multiple instructions in the target language, makes the theory of choreographic programming error-prone:""
  - ""Our formalisation experience illustrates the benefits of using a theorem prover: we get both an additional degree of confidence from the mechanised proof, and a significant simplification of the underlying theory.""
  - ""Our results offer a foundation for the future formal development of choreographic languages.""
  - ""The semantics of CC is defined by means of labelled transition systems, in three layers.""
  - ""The transition relations are defined inductively by the rules in Figs. 5, 6, 7.""
  - ""The formalisation of partial recursive functions contains 22 definitions and 84 lemmas, with a total of 1464 lines of code.""
  - ""The proof of Turing completeness consists of 28 definitions and 65 lemmas, with a total of 2371 lines of code.""
  - ""The formalisation of SP consists of 25 definitions, 81 lemmas, 11 simple tactics, and approximately 1960 lines of Coq code.""
  - ""The operational correspondence between choreographies and their projections, which is the topic of Sect. 6, states that a projectable choreography can make a transition iff its projection can make a corresponding transition.""",,"- The paper primarily focuses on the formalization of choreographic programming languages and their properties, such as Turing completeness and operational correspondence.
 - The concept of ""genericity"" is not explicitly addressed in terms of generic programming or abstraction mechanisms.
 - The paper discusses the use of theorem provers for formalization, which can be seen as a tool for abstraction, but it does not delve into generic programming methodologies or type systems specifically.
 - The focus is on the formalization of choreographic languages and their properties rather than on generic programming or abstraction mechanisms.
 - The paper does not provide specific mechanisms for representing generic abstractions or minimal type requirements.","- ""Our formalisation experience illustrates the benefits of using a theorem prover: we get both an additional degree of confidence from the mechanised proof, and a significant simplification of the underlying theory.""
  - ""Our results offer a foundation for the future formal development of choreographic languages.""
  - ""The direct result of our work is a formalisation that can be used as a basis for future work on choreographic programming, both in theory and in practice.""
  - ""our formalisation dispels any concerns that there may be regarding the correctness of our results-which is especially relevant in an area where many proofs are extremely technical and tedious both to write down and to check in detail.""
  - ""Our work also provides some valuable lessons about formalising semantics of concurrent systems.""
  - ""Our formalisation further benefits from the design choice of defining all procedures at the top level, which allows us to bypass all the complexity of having to work explicitly with binders and substitution.""
  - ""The current proof of confluence takes about 300 lines of Coq code, including a total of 11 lemmas.""
  - ""Our formalisation was done in parallel with the pen-and-paper revision of CC carried out in [41].""",,"- The paper presents a formalisation of choreographic programming using the Coq theorem prover, which provides a higher degree of confidence in the correctness of the proofs and simplifies the underlying theory. This is a significant theoretical advancement as it addresses the complexity and potential errors in manual proofs.
 

 - The work offers a foundation for future formal development of choreographic languages, suggesting that it can be a basis for further theoretical advancements in this area.
 

 - The formalisation dispels concerns about the correctness of results in choreographic programming, which is crucial given the technical and tedious nature of these proofs. This contributes to the theoretical robustness of choreographic programming.
 

 - The paper provides insights into formalising semantics of concurrent systems, which can influence future theoretical work in programming language design.
 

 - By defining all procedures at the top level, the formalisation avoids complexities associated with binders and substitution, which is a novel approach that simplifies the theory.
 

 - The proof of confluence is significantly simplified compared to previous attempts, indicating a theoretical improvement in the formalisation process.
 

 - The parallel development with pen-and-paper revisions suggests that the formalisation process itself contributed to refining and improving the theoretical framework of choreographic programming."
"A Proposal to Merge Object Orientation, Logic Programming, and Multiple Tuple Spaces","V. Ambriola, G. A. Cignoni, L. Semini",-,-,ICLP Workshop: Process-Based Parallel Logic Programming,4,1994,"1. Primitive Name: Object Orientation
  Definition: Supplies a well-defined frame for modular development of large systems.
  Orthogonality Score: Orthogonal
 2. Primitive Name: Logic Programming
  Definition: Allows for declarative definition of computation properties.
  Orthogonality Score: Orthogonal
 3. Primitive Name: Multiple Tuple Spaces
  Definition: Provides a powerful model for describing cooperation of concurrent activities.
  Orthogonality Score: Orthogonal",Not specified (the abstract does not mention any mathematical framework or theoretical foundations),"- Specific integration mechanisms proposed: Combining object orientation, logic programming, and multiple tuple spaces to leverage modularity, declarativity, and concurrency.
 - Interaction models between paradigms: Paradigms belong to orthogonal dimensions, allowing for independent operation without interference.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Integration of object orientation, logic programming, and multiple tuple spaces.
 - Theoretical advancements: Combining orthogonal paradigms to integrate modularity, declarativity, and concurrency.
 - Potential implications: Enhanced programming language design for modular, declarative, and concurrent systems.","- ""We propose to merge in a new programming paradigm object orientation, logic programming, and multiple tuple spaces.""
  - ""The object oriented model supplies a well deened frame for the design of languages to be used for modular development of large systems.""
  - ""These three paradigms do not interfere each other, as they belong to orthogonal dimensions of a programming language construction.""
  - ""multiple tuple spaces provide a powerful model to describe cooperation of concurrent activities.""
  - ""Logic programming allows to describe a computation by declarative deenition of its properties.""",,"- The abstract proposes a new programming paradigm by merging three existing paradigms: object orientation, logic programming, and multiple tuple spaces.
 - Each of these paradigms is described in terms of its contribution to the new paradigm:
  - Object orientation provides a framework for modular development.
  - Logic programming allows for declarative definitions of computations.
  - Multiple tuple spaces enable the description of concurrent activities.
 - The abstract states that these paradigms are orthogonal, meaning they do not interfere with each other and can be combined without conflicts.
 - The level of abstraction is high, as these are broad programming paradigms rather than specific primitives.
 - The orthogonality of these paradigms is explicitly mentioned, indicating they can be combined without interference.","- ""These three paradigms do not interfere each other, as they belong to orthogonal dimensions of a programming language construction.""
  - ""The object oriented model supplies a well deened frame for the design of languages to be used for modular development of large systems.""
  - ""Finally, multiple tuple spaces provide a powerful model to describe cooperation of concurrent activities.""
  - ""Logic programming allows to describe a computation by declarative deenition of its properties.""
  - ""We propose to merge in a new programming paradigm object orientation, logic programming, and multiple tuple spaces.""",,"- The abstract discusses the integration of object orientation, logic programming, and multiple tuple spaces into a new programming paradigm.
 - It mentions the roles of these paradigms in terms of modularity, declarative definition, and concurrency, but it does not specify any mathematical framework or theoretical foundations.
 - There is no mention of a specific type of mathematical framework such as type theory or category theory.
 - The abstract does not discuss any specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the conceptual integration of programming paradigms rather than on mathematical formalization or verification.","- ""We propose to merge in a new programming paradigm object orientation, logic programming, and multiple tuple spaces.""
  - ""The object oriented model supplies a well deened frame for the design of languages to be used for modular development of large systems.""
  - ""Logic programming allows to describe a computation by declarative deenition of its properties.""
  - ""Finally, multiple tuple spaces provide a powerful model to describe cooperation of concurrent activities.""
  - ""These three paradigms do not interfere each other, as they belong to orthogonal dimensions of a programming language construction.""
  - ""They can hence be combined in a language that well integrates modularity, declarativity, and concurrency.""",,"- The abstract proposes a new programming paradigm that integrates object orientation, logic programming, and multiple tuple spaces. This suggests a specific integration mechanism where these paradigms are combined to leverage their respective strengths.
 - The object-oriented model is highlighted for its role in modular development, logic programming for declarative definitions, and multiple tuple spaces for concurrent activities. This indicates how each paradigm contributes to the integration.
 - The abstract states that these paradigms do not interfere with each other because they belong to orthogonal dimensions, which implies a theoretical integration strategy where each paradigm operates independently without conflict.
 - The integration approach is described as combining these paradigms to achieve modularity, declarativity, and concurrency, suggesting a novel way to integrate these aspects into a single language.
 - There is no mention of specific constraints or challenges in the integration process, nor are there any novel translation or embedding techniques explicitly discussed.","- ""These three paradigms do not interfere each other, as they belong to orthogonal dimensions of a programming language construction.""
  - ""Logic programming allows to describe a computation by declarative deenition of its properties.""
  - ""We propose to merge in a new programming paradigm object orientation, logic programming, and multiple tuple spaces.""
  - ""multiple tuple spaces provide a powerful model to describe cooperation of concurrent activities.""
  - ""The object oriented model supplies a well deened frame for the design of languages to be used for modular development of large systems.""",,"- The abstract discusses the integration of object orientation, logic programming, and multiple tuple spaces, which are related to modularity, declarativity, and concurrency. However, it does not explicitly mention generic programming or abstraction mechanisms.
 - The mention of ""object oriented model"" and ""modular development"" suggests some level of abstraction, but it does not provide specific details on generic programming or abstraction mechanisms.
 - The abstract does not mention any specific mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The focus is on the integration of different programming paradigms rather than on generic programming or abstraction mechanisms.","- ""We propose to merge in a new programming paradigm object orientation, logic programming, and multiple tuple spaces.""
  - ""The object oriented model supplies a well deened frame for the design of languages to be used for modular development of large systems.""
  - ""Logic programming allows to describe a computation by declarative deenition of its properties.""
  - ""multiple tuple spaces provide a powerful model to describe cooperation of concurrent activities.""
  - ""These three paradigms do not interfere each other, as they belong to orthogonal dimensions of a programming language construction.""
  - ""They can hence be combined in a language that well integrates modularity, declarativity, and concurrency.""",,"- The abstract proposes a novel integration of three programming paradigms: object orientation, logic programming, and multiple tuple spaces. This integration is a key novel insight as it combines different strengths of each paradigm.
 - The theoretical advancement lies in the combination of these paradigms, which are typically considered orthogonal and not interfering with each other. This suggests a new way of thinking about programming language design that integrates modularity, declarativity, and concurrency.
 - The potential implications for programming language design are significant, as the proposed paradigm could lead to more modular, declarative, and concurrent systems. This could enhance the development of large systems by providing a more comprehensive framework.
 - The abstract does not mention specific existing work or comparative analysis, but the novelty and theoretical contribution are clear in the proposed integration of these paradigms."
A General Approach to Derive Uncontrolled Reversible Semantics,"Ivan Lanese, Doriana Medic",10.4230/LIPIcs.CONCUR.2020.33,https://doi.org/10.4230/LIPIcs.CONCUR.2020.33,International Conference on Concurrency Theory,14,2020,"1. Primitive Name: Keys
  Definition: Unique identifiers attached to every entity (process, messages, etc.) to track past states.
  Orthogonality Score: Not discussed
 2. Primitive Name: Memories
  Definition: Store past information to enable backward semantics.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Labelled Transition System with Independence (LTSI)
 - Specific mathematical properties guaranteed: Loop Lemma, Square Lemma, Causal Consistency
 - Proof techniques used: Axiomatic approach, proving basic axioms
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Attaching unique identifiers (keys) to entities and enriching the model with memories to store past information.
 - Interaction models between paradigms: Causality relation based on resources consumed and produced.
 - Constraints or challenges in paradigm integration: Covering complex features like remote error handling in Core Erlang.
 - Any novel translation or embedding techniques: Generalization of previous work in reversible semantics.","- Definition of ""concept"" used: The concept of attaching unique identifiers (keys) to entities and enriching models with memories to represent past states.
 - Mechanisms for representing generic abstractions: Attaching unique identifiers (keys) to entities and enriching models with memories.
 - Minimal type requirements identified: The approach is based on consumed and produced resources, with a need to identify resources that are read but not consumed for read-write concurrency.
 - Static checking or optimization strategies: Not explicitly mentioned, but the discussion on limitations and extensions implies potential optimization strategies for handling different types of concurrency.","- Key novel insights: General and automatic technique for deriving causal-consistent reversible extensions; extension of reversible models to cover remote error handling in Core Erlang.
 - Theoretical advancements: Use of unique identifiers (keys) and memories to track past states; satisfaction of causal consistency properties.
 - Potential implications for programming language design: Applicability to a wider range of formalisms; potential for adapting the approach to handle more complex concurrency models.","- ""We define below the function key(•) that computes the set of keys in a configuration R:""
  - ""Our approach works in two main steps. First, we attach a unique identifier, called key, to every entity (process, messages, etc.) of the forward system, and then we enrich the model with memories, where past information is stored""
  - ""The backward rules, depicted in Figure 3 , are symmetric w.r.t. the forward ones.""
  - ""The forward rules of the uncontrolled reversible semantics are in Figure 2 . For schemas (F-Scm-Act) and (F-Scm-Opn) we have one instance for each instance of the corresponding schema in the original semantics.""
  - ""In order to define the causal-consistent reversible extension of a given system, one first needs to extend the forward semantics so to keep track of past states. This information will be used by the backward semantics.""",,"- The paper discusses a method for deriving a causal-consistent reversible extension of a given forward model. This involves two main steps: attaching unique identifiers (keys) to entities and enriching the model with memories to store past information.
 - The use of keys and memories are central to the approach, as they enable the tracking of past states and the reversal of actions.
 - The forward and backward rules are defined in terms of these primitives, indicating their fundamental role in the methodology.
 - The paper does not explicitly mention ""conceptual primitives"" or provide a list of such primitives. However, the concepts of keys and memories can be inferred as foundational elements in the approach.","- ""The main objective of the theoretical computer science community in this research area has been to provide a foundational understanding of reversibility.""
  - ""In a concurrent setting, where many processes are running at the same time, identifying the last action is not an easy task, and may sometimes be impossible. Therefore, alternative approaches have been considered. Here we consider the causal-consistent approach [10, 41, 26] , which focuses on the causality relations between actions to decide which actions can be undone.""
  - ""In order to show that a reversible model follows the causal-consistent approach, a number of properties need to be proved [10] . The most relevant are the Loop Lemma, showing that each action can be undone, the Square Lemma, showing that the chosen notion of causality is compatible with the semantics, and Causal Consistency, showing that the correct information is stored.""
  - ""We extend the reduction semantics to a notion of transitions, which carry in the label information on the used resources, in form of the memory involved in the transition.""
  - ""Having fixed a notion of concurrency, we can proceed to show the Causal Consistency of the reversible semantics. To prove it, we use the recent axiomatic approach given in [31] , which allows one to show a number of properties relevant for reversible calculi, such as the Parabolic Lemma (PL) and Causal Consistency (CC), by just proving a few basic axioms.""
  - ""we re-formulate our framework as a Labelled Transition System with Independence (LTSI, see also [44] ) (R, L, -→, ι), where R is a set of systems, L is the set of action labels, -→ ⊂ R × L × R is a transition relation and ι is the independence relation, namely an irreflexive symmetric binary relation on transitions.""
  - ""Given that our reversible semantics satisfies all basic axioms (Proposition 20), thanks to [31] , all instances of our framework satisfy the Parabolic Lemma and Causal Consistency.""",,"- The paper discusses the use of a ""causal-consistent approach"" which is a theoretical framework for handling reversibility in concurrent systems. This suggests a focus on causality relations and properties like Loop Lemma, Square Lemma, and Causal Consistency.
 - The paper uses a ""Labelled Transition System with Independence (LTSI)"" as a mathematical framework to formalize the reversible semantics. This is a specific type of mathematical framework used in theoretical computer science to model concurrent systems.
 - The paper guarantees specific mathematical properties such as the Loop Lemma, Square Lemma, and Causal Consistency, which are fundamental to reversible computing.
 - The proof techniques used involve proving basic axioms as part of an axiomatic approach, which simplifies the proof of more complex properties like Causal Consistency.
 - The framework is based on reduction semantics and uses transitions with labels to model resource usage and causality, indicating a focus on operational semantics.","- ""Our approach works in two main steps. First, we attach a unique identifier, called key, to every entity (process, messages, etc.) of the forward system, and then we enrich the model with memories, where past information is stored""
  - ""Beyond ours, the only work that we are aware of providing a general and fully automatic method to derive a reversible semantics is [41] , which considers calculi defined in a specific SOS format.""
  - ""This paper presents a general and automatic technique to define a causal-consistent reversible extension for given forward models.""
  - ""We support models defined using a reduction semantics in a specific format and consider a causality relation based on resources consumed and produced.""
  - ""The considered format is general enough to fit many formalisms studied in the literature on causal-consistent reversibility, notably Higher-Order π-calculus and Core Erlang, an intermediate language in the Erlang compilation.""
  - ""Our technique also allows us to go beyond the reversible models in the literature: we cover a larger fragment of Core Erlang, including remote error handling based on links, which has never been considered in the reversibility literature.""
  - ""In the concurrency literature, one can find many approaches defining a single reversible formalism or studying its properties, all using techniques tailored to the chosen model (e.g., [10, 9, 25, 38, 17, 37, 3, 18, 28, 36] ). Indeed, our work can be seen as a generalisation of [25, 28] , which we also used as case studies.""",,"- The paper discusses a general approach to derive reversible semantics for forward models, which can be seen as a form of integration by extending different programming paradigms (e.g., Higher-Order π-calculus and Core Erlang) with reversible capabilities.
 - The integration mechanism involves attaching unique identifiers (keys) to entities and enriching the model with memories to store past information, which is a novel technique for integrating reversible semantics into existing paradigms.
 - The interaction model is based on a causality relation that considers resources consumed and produced, which is a key aspect of integrating different paradigms under a reversible framework.
 - The paper mentions that the approach can cover a larger fragment of Core Erlang, including remote error handling, which indicates a challenge in integrating complex features from different paradigms.
 - The paper does not explicitly discuss novel translation or embedding techniques beyond the use of keys and memories, but it does generalize previous work in the field.","- ""Our approach works in two main steps. First, we attach a unique identifier, called key, to every entity (process, messages, etc.) of the forward system, and then we enrich the model with memories, where past information is stored""
  - ""In order to extend our method to cope with read-write concurrency, we need to identify resources which are read but not consumed.""
  - ""The considered format is general enough to fit many formalisms studied in the literature on causal-consistent reversibility, notably Higher-Order π-calculus and Core Erlang, an intermediate language in the Erlang compilation.""
  - ""This paper presents a general and automatic technique to define a causal-consistent reversible extension for given forward models.""
  - ""Our technique also allows us to go beyond the reversible models in the literature: we cover a larger fragment of Core Erlang, including remote error handling based on links, which has never been considered in the reversibility literature.""
  - ""our approach is based on consumed and produced resources, while in [17] resources can also be read without being consumed.""",,"- The paper focuses on developing a general and automatic technique for deriving causal-consistent reversible extensions of forward models. This suggests a focus on generic programming methodologies.
 - The approach involves attaching unique identifiers (keys) to entities and enriching models with memories, which can be seen as mechanisms for representing generic abstractions.
 - The paper mentions that the considered format is general enough to fit many formalisms, indicating a level of abstraction and genericity.
 - The technique is applied to various formalisms like Higher-Order π-calculus and Core Erlang, showing its applicability across different models.
 - The paper discusses limitations and potential extensions, such as dealing with read-write concurrency, which implies a consideration of minimal type requirements and potential optimization strategies.","- ""This paper presents a general and automatic technique to define a causal-consistent reversible extension for given forward models.""
  - ""Our technique also allows us to go beyond the reversible models in the literature: we cover a larger fragment of Core Erlang, including remote error handling based on links, which has never been considered in the reversibility literature.""
  - ""Our approach works in two main steps. First, we attach a unique identifier, called key, to every entity (process, messages, etc.) of the forward system, and then we enrich the model with memories, where past information is stored""
  - ""we show that the reversible semantics defined using the approach in the previous section satisfies a number of properties expected from a causal-consistent reversible semantics.""
  - ""Beyond ours, the only work that we are aware of providing a general and fully automatic method to derive a reversible semantics is [41] , which considers calculi defined in a specific SOS format.""
  - ""our approach based on a reduction semantics considers only close systems. On the other hand, the higher degree of abstraction provided by reduction semantics simplifies the approach and makes it applicable to a wider range of formalisms.""
  - ""Uncontrolled reversible semantics as obtained by our approach are the foundation of a reversible model on which one can build on, by adding control mechanisms""
  - ""Another direction for future work is to adapt our approach so to handle further forward models. For instance, we currently cannot cope with the semantics of muKlaim defined in [17] , since its concurrency model includes read dependencies.""",,"- The paper introduces a novel, general, and automatic technique for deriving causal-consistent reversible extensions from forward models, which is a significant theoretical contribution.
 - It extends existing reversible models by covering a larger fragment of Core Erlang, including remote error handling, which is a new application area for reversibility.
 - The approach uses unique identifiers (keys) and memories to track past states, which is a theoretical innovation in managing reversible semantics.
 - The paper demonstrates that the reversible semantics satisfy expected properties, such as causal consistency, which is a theoretical advancement.
 - The method is compared to existing work, highlighting its generality and applicability to a wider range of formalisms, particularly those defined by reduction semantics.
 - The potential for future work includes adapting the approach to handle more complex concurrency models, indicating potential implications for programming language design."
A unified proof technique for verifying program correctness with big-step semantics,"Ximeng Li, Qianying Zhang, Guohui Wang, Zhiping Shi, Yong-Yuan Guan",10.1016/j.sysarc.2022.102820,https://doi.org/10.1016/j.sysarc.2022.102820,Journal of systems architecture,0,2023,Not specified (the abstract does not explicitly define any conceptual primitives),"- Type of mathematical framework: Type theory (Coq proof assistant)
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Big-step operational semantics, general-purpose logic
 - Limitations or constraints of the framework: Not specified",No specific integration approach described (the abstract mentions language-independent verification and illustration across paradigms but lacks specific details on integration mechanisms or interaction models),"- Definition of ""concept"" used: Language-independent verification techniques focusing on common features across languages.
 - Mechanisms for representing generic abstractions: Big-step operational semantics and general-purpose logic.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: The use of big-step operational semantics and a general-purpose logic for language-independent verification.
 - Theoretical advancements beyond existing approaches: Departure from small-step semantics and special-purpose logics; applicability across different language paradigms; verification of blockchain smart contracts with unknown code interactions.
 - Potential implications for programming language design: Development of languages more amenable to verification, leading to more robust programming practices.","- ""All the theoretical results and verification examples are formalized in the Coq proof assistant.""
  - ""The deductive verification of computer programs helps ascertain the absence of errors for all possible inputs and executions.""
  - ""Existing language-independent verification techniques either work with small-step operational semantics or require the definition of a special-purpose logic.""
  - ""We use the technique to develop a method for verifying blockchain smart contracts that could call into unknown code and be reentered from the callee.""
  - ""We present a language-independent verification technique that works with big-step operational semantics and a general-purpose logic.""",,"- The abstract discusses a language-independent verification technique that uses big-step operational semantics and a general-purpose logic. This suggests a focus on verification methods rather than specific conceptual primitives for programming paradigms.
 - The abstract does not explicitly mention any conceptual primitives or their definitions. It focuses on the verification technique and its application rather than the primitives themselves.
 - The mention of ""big-step operational semantics"" and ""general-purpose logic"" could be related to the methodology or theoretical framework, but these are not explicitly defined as conceptual primitives in the abstract.
 - The abstract does not provide any specific names or definitions for conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""All the theoretical results and verification examples are formalized in the Coq proof assistant.""
  - ""The deductive verification of computer programs helps ascertain the absence of errors for all possible inputs and executions.""
  - ""Existing language-independent verification techniques either work with small-step operational semantics or require the definition of a special-purpose logic.""
  - ""We present a language-independent verification technique that works with big-step operational semantics and a general-purpose logic.""",,"- The abstract mentions the use of ""big-step operational semantics"" and a ""general-purpose logic,"" which are key components of the mathematical framework.
 - The use of ""big-step operational semantics"" suggests a focus on the overall behavior of programs rather than detailed step-by-step execution, which is a characteristic of the framework.
 - The mention of a ""general-purpose logic"" implies that the framework is not limited to specific languages or contexts, making it versatile.
 - The abstract states that ""all the theoretical results and verification examples are formalized in the Coq proof assistant,"" which indicates that the Coq proof assistant is used to formalize and guarantee properties of the conceptual primitives.
 - The Coq proof assistant is based on type theory, which is a type of mathematical framework used for formal verification.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or limitations of the framework, but it does highlight the use of big-step semantics and general-purpose logic as key features.","- ""We illustrate the technique by verifying programs in languages of different paradigms.""
  - ""We present a language-independent verification technique that works with big-step operational semantics and a general-purpose logic.""
  - ""The identification of mechanisms for reasoning about the common features of different languages gives rise to language-independent program verification techniques.""",,"- The abstract mentions the identification of mechanisms for reasoning about common features of different languages, which implies a focus on integrating different programming paradigms.
 - The study presents a language-independent verification technique that uses big-step operational semantics and a general-purpose logic, suggesting a theoretical integration strategy.
 - The technique is illustrated by verifying programs in languages of different paradigms, indicating an interaction model between paradigms.
 - However, the abstract does not provide specific details on the integration mechanisms, interaction models, constraints, or novel translation techniques.","- ""The identification of mechanisms for reasoning about the common features of different languages gives rise to language-independent program verification techniques.""
  - ""We present a language-independent verification technique that works with big-step operational semantics and a general-purpose logic.""
  - ""We illustrate the technique by verifying programs in languages of different paradigms.""
  - ""We use the technique to develop a method for verifying blockchain smart contracts that could call into unknown code and be reentered from the callee.""",,"- The abstract discusses the development of a ""language-independent verification technique,"" which implies a focus on genericity and abstraction mechanisms. This is because language independence typically involves abstracting away from specific language features to apply to multiple languages.
 - The mention of ""common features of different languages"" suggests an approach to identifying generic abstractions that can be applied across languages.
 - The use of ""big-step operational semantics and a general-purpose logic"" indicates a mechanism for representing generic abstractions, as these are tools that can be applied broadly across different programming languages.
 - The application to ""programs in languages of different paradigms"" further supports the idea that the study involves generic programming methodologies, as it implies the technique can be applied across various programming paradigms.
 - The development of a method for verifying blockchain smart contracts that can interact with unknown code suggests a level of abstraction and genericity in handling complex, dynamic interactions.","- ""The deductive verification of computer programs helps ascertain the absence of errors for all possible inputs and executions.""
  - ""Existing language-independent verification techniques either work with small-step operational semantics or require the definition of a special-purpose logic.""
  - ""We present a language-independent verification technique that works with big-step operational semantics and a general-purpose logic.""
  - ""We illustrate the technique by verifying programs in languages of different paradigms.""
  - ""We use the technique to develop a method for verifying blockchain smart contracts that could call into unknown code and be reentered from the callee.""
  - ""All the theoretical results and verification examples are formalized in the Coq proof assistant.""",,"- The abstract highlights the novelty of using big-step operational semantics and a general-purpose logic for language-independent verification, which is a departure from existing techniques that rely on small-step semantics or special-purpose logics.
 - The technique is demonstrated by verifying programs across different language paradigms, indicating its broad applicability.
 - The application to blockchain smart contracts, particularly those that can call into unknown code and be reentered, represents a significant theoretical advancement in handling complex and dynamic program interactions.
 - The formalization of results in the Coq proof assistant suggests a rigorous theoretical foundation for these contributions.
 - The potential implications for programming language design include the possibility of developing languages that are more amenable to verification using this technique, potentially leading to more robust and error-free programming practices."
Trampoline variables: a general method for state accumulation in reactive programming,"Bjarno Oeyen, Sam Van den Vonder, Wolfgang De Meuter",10.1145/3486605.3486787,https://doi.org/10.1145/3486605.3486787,REBLS@SPLASH,3,2021,"1. Primitive Name: Trampoline Variables
  Definition: A general mechanism for maintaining state in RP programs, allowing explicit state manipulation without imperative programming.
  Orthogonality Score: Not discussed",Not specified,"- Specific integration mechanisms proposed: Trampoline variables as pseudo-inputs for explicit state management in reactive programming.
 - Interaction models between paradigms: Trampoline variables are updated at the end of each turn, allowing for state accumulation without causing dependency graph cycles.
 - Constraints or challenges in paradigm integration: Managing state explicitly in reactive programming without resorting to imperative constructs.
 - Novel translation or embedding techniques: Trampoline variables are similar to state management in process-oriented actor languages, providing a novel approach to integrating state management into reactive programming.","- Definition of ""concept"" used: Trampoline variables as a general mechanism for state management in reactive programming.
 - Mechanisms for representing generic abstractions: Trampoline variables allow for explicit state manipulation and can implement various stateful operators.
 - Minimal type requirements identified: Not explicitly discussed.
 - Static checking or optimization strategies: Not explicitly discussed.","- Introduction of trampoline variables as a general mechanism for state management in reactive programming.
 - Trampoline variables are at least as powerful as existing built-in reactive operators.
 - Ability to compose first-class stateful reactors.
 - Granularity for hot-code reloading.
 - Direct access to stateful values during hot-swapping.
 - Integration of trampoline variables into the reactive programming language.","- ""Trampoline variables are a general mechanism that can be used to implement the stateful operators that exist in several other RP languages.""
  - ""Trampoline variables are allocated and initialised when a reactor is deployed. Hence, every deployment of a reactor manages its own ""copy"" of that reactor's trampoline variables.""
  - ""In this paper, we present trampoline variables: a general mechanism, for maintaining state in RP programs that does not confront programmers with the problems resulting from unrestricted assignment statements in their reactive code, while avoiding a built-in set of stateful operators (like foldp).""
  - ""Trampoline variables make it possible to remember values produced in a previous turn and reactive programs themselves do not react to changes of the trampoline variables, it is only when another signal in a deployment changes, that the value of the trampoline variable is used.""",,"- The paper introduces ""trampoline variables"" as a conceptual primitive for managing state in reactive programming (RP) without relying on imperative constructs or built-in stateful operators.
 - Trampoline variables are defined as a mechanism for maintaining state in RP programs, allowing for explicit state manipulation without imperative programming.
 - They are allocated and initialized when a reactor is deployed, with each deployment managing its own copy of trampoline variables.
 - Trampoline variables enable remembering values from previous turns and are updated only when another signal in the deployment changes.
 - The paper positions trampoline variables as a general mechanism for implementing various stateful operators found in other RP languages.","- ""The paper is structured as follows. In Section 2 we give an overview of the stateful operators that exist in various kinds of existing RP languages. In Section 3 we present a brief overview of Haai's semantics, and Section 4 presents the extension of Haai that provides trampoline variables.""
  - ""In this paper, we show that:
 

 • Trampoline variables are a general mechanism that can be used to implement the stateful operators that exist in several other RP languages.""
  - ""The main idea of the paper is to allow a reactor to declare a number of pseudo-inputs, called trampoline variables (trampolines for short).""
  - ""Trampoline variables are allocated and initialised when a reactor is deployed. Hence, every deployment of a reactor manages its own ""copy"" of that reactor's trampoline variables.""
  - ""The memory footprint of each reactor deployment is constant:
 

 • Each trampoline variable stores one single value corresponding to the last value produced by a signal.""
  - ""Haai as a language is part of a larger project. The goal is to understand reactive systems in terms of reactions ""all the way down"".""
  - ""This paper presented trampoline variables, a generalised approach for stateful variables which are integrated directly in the RP language itself.""",,"- The paper primarily focuses on introducing trampoline variables as a mechanism for state management in reactive programming, rather than detailing a specific mathematical framework.
 - The paper discusses the semantics and implementation of trampoline variables within the Haai language but does not explicitly mention a mathematical framework such as type theory or category theory.
 - There is no mention of formal verification or proof techniques related to a specific mathematical framework.
 - The paper does not provide specific mathematical properties guaranteed by a framework or discuss limitations or constraints of such a framework.","- ""This paper introduces trampoline variables, a new general mechanism that allows reactive programs to manipulate state explicitly without resorting to imperative programming.""
  - ""Trampoline variables make it possible to remember values produced in a previous turn and reactive programs themselves do not react to changes of the trampoline variables, it is only when another signal in a deployment changes, that the value of the trampoline variable is used.""
  - ""The introduction of state with trampoline variables is very similar to the introduction of state with tail-recursion in process-oriented actor languages""
  - ""The main idea of the paper is to allow a reactor to declare a number of pseudo-inputs, called trampoline variables (trampolines for short).""
  - ""Trampoline variables are allocated and initialised when a reactor is deployed. Hence, every deployment of a reactor manages its own ""copy"" of that reactor's trampoline variables.""
  - ""Reactive programming is all about relegating the management of a program’s state changes to the realm of the runtime environment. Nevertheless, sometimes it is still necessary to enrich a reactive program with state variables that are explicitly updated by the programmer.""",,"- The paper discusses the integration of reactive programming with explicit state management, which is typically associated with imperative programming.
 - The proposed integration mechanism is the use of ""trampoline variables,"" which allow reactive programs to manipulate state without resorting to imperative constructs.
 - Trampoline variables are allocated and initialized at the deployment level, ensuring each deployment manages its own state, which is a key aspect of integrating state management into reactive programming.
 - The interaction model involves using trampoline variables as pseudo-inputs that can be updated at the end of each turn, allowing for state accumulation without causing cycles in the dependency graph.
 - The paper highlights that trampoline variables are similar to state management in process-oriented actor languages, indicating a comparison with other paradigms.
 - The main challenge addressed is the need to manage state explicitly in reactive programming without compromising its paradigm, which is achieved through trampoline variables.","- ""we present trampoline variables: a general mechanism, for maintaining state in RP programs that does not confront programmers with the problems resulting from unrestricted assignment statements in their reactive code, while avoiding a built-in set of stateful operators (like foldp).""
  - ""Trampoline variables are a general mechanism that can be used to implement the stateful operators that exist in several other RP languages.""
  - ""Trampoline variables make it possible to remember values produced in a previous turn and reactive programs themselves do not react to changes of the trampoline variables, it is only when another signal in a deployment changes, that the value of the trampoline variable is used.""
  - ""Trampoline variables allow us to compose first-class stateful reactors in an elegant way.""
  - ""Trampoline variables interact with nested reactors in a clean way.""
  - ""The memory footprint of each reactor deployment is constant:
 

 • Each trampoline variable stores one single value corresponding to the last value produced by a signal.""
  - ""Trampoline variables are allocated and initialised when a reactor is deployed. Hence, every deployment of a reactor manages its own ""copy"" of that reactor's trampoline variables.""",,"- The paper introduces ""trampoline variables"" as a general mechanism for state management in reactive programming (RP), which is a key aspect of generic programming. This mechanism allows for explicit state manipulation without relying on imperative constructs or built-in operators.
 - Trampoline variables are described as a general mechanism that can implement various stateful operators found in other RP languages, indicating a level of abstraction and genericity.
 - The ability to compose first-class stateful reactors and interact with nested reactors suggests a high degree of abstraction and modularity, which are essential for generic programming.
 - The allocation and initialization of trampoline variables at deployment time, along with their constant memory footprint, suggest a well-defined and efficient abstraction mechanism.
 - The paper does not explicitly discuss type systems or static checking strategies, but the focus on trampoline variables as a general mechanism implies a level of abstraction that could be applied across different types and contexts.","- ""This paper introduces trampoline variables, a new general mechanism that allows reactive programs to manipulate state explicitly without resorting to imperative programming.""
  - ""We show that our proposal is at least as powerful as existing built-in reactive operators.""
  - ""Trampoline variables are a general mechanism that can be used to implement the stateful operators that exist in several other RP languages.""
  - ""Trampoline variables allow us to compose first-class stateful reactors in an elegant way.""
  - ""Reactors with trampoline variables are the exact level of granularity that is needed to replace parts of a stateful reactor program while it is reacting, i.e. hot-code reloading.""
  - ""The main insight that shows the use of trampoline variables when hot-swapping is that every stateful computation is required to store any stateful data in a trampoline variable: no state is hidden by a built-in operator.""
  - ""Trampoline variables, on the other hand, give direct access to the stateful values held by the stateful reactor that is being hot-swapped.""
  - ""This paper presented trampoline variables, a generalised approach for stateful variables which are integrated directly in the RP language itself.""",,"- The paper introduces ""trampoline variables"" as a novel mechanism for managing state in reactive programming, which is a significant theoretical contribution.
 - Trampoline variables are shown to be at least as powerful as existing built-in reactive operators, indicating a theoretical advancement in terms of expressiveness.
 - The ability to compose first-class stateful reactors and the granularity for hot-code reloading are unique insights that contribute to the theoretical understanding of reactive programming.
 - The direct access to stateful values during hot-swapping is a theoretical innovation that addresses a limitation in existing approaches.
 - The integration of trampoline variables directly into the reactive programming language itself is a theoretical contribution that enhances the language's capabilities."
First-order Lax Logic as a framework for Constraint Logic Programming,"M. Fairtlough, M. Walton, M. Mendler",-,-,-,19,1997,"1. Primitive Name: QLL (intuitionistic first-order modal logic)
  Definition: Used to capture both extensional and intensional aspects of Constraint Logic Programming.
  Orthogonality Score: Not discussed
 2. Primitive Name: Formulas in QLL
  Definition: Directly represent programs rather than specifying properties.
  Orthogonality Score: Not discussed
 3. Primitive Name: Intensional first-order extension of the Curry Howard isomorphism
  Definition: Links natural deduction proofs with computational lambda calculus terms.
  Orthogonality Score: Not discussed
 4. Primitive Name: Monadic operator instantiation
  Definition: Generic notion of constraint computation.
  Orthogonality Score: Not discussed
 5. Primitive Name: Factoring into abstract LLP programs and constraint tables
  Definition: Allows recovery of concrete answer constraints from abstract derivations.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Intuitionistic first-order modal logic (QLL)
 - Specific mathematical properties guaranteed: Soundness and completeness, precise proof and model-theoretic connections
 - Proof techniques used: Syntactic translation into a classical first-order bimodal theory, natural deduction proofs
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Use of QLL as an internal logic to integrate model-theoretic and operational semantics; extension of the Curry-Howard isomorphism to factor CLP programs into abstract LLP programs and constraint tables.
 - Interaction models between paradigms: QLL integrates extensional and intensional aspects of CLP.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Use of QLL as an internal logic where formulas represent programs themselves.","- Definition of ""concept"" used: Programs themselves are represented by formulas in QLL.
 - Mechanisms for representing generic abstractions: Use of Curry-Howard isomorphism and instantiation of monadic operator with generic constraint computation.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novelty: Introduction of a new proof-theoretic approach using QLL to capture both extensional and intensional aspects of Constraint Logic Programming.
 - Theoretical Advancements: Direct link between model-theoretic and operational semantics; use of QLL as an internal logic; extension of the Curry-Howard isomorphism to an intensional first-order context.
 - Potential Implications: Generalization of constraints; application to program abstraction and refinement; precise proof and model-theoretic connections.","- ""In this report we introduce a new proof theoretic approach to the semantics of Constraint Logic Programming based on an intuitionistic rst order modal logic called QLL""
  - ""The dis tinguishing feature of this new approach is that the logic calculus of QLL is used not only to capture the usual extensional aspects of Logic Programming i e which queries are success ful but also some of the intensional aspects i e what is the answer constraint and how is it constructed""
  - ""Formulas in QLL do not specify properties of programs but the programs themselves""
  - ""Our main tool is an intensional rst order extension of the Curry Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus""
  - ""Instantiating the monadic operator of QLL by a generic notion of constraint computation we factor a concrete CLP program into two parts an abstract LLP program and an associated constraint table""",,"- The abstract introduces a new approach based on an intuitionistic first-order modal logic called QLL, which is used to capture both extensional and intensional aspects of Constraint Logic Programming.
 - The logic calculus of QLL is used to capture not just what queries are successful but also how the answer constraints are constructed, indicating a focus on the process rather than just the outcome.
 - The mention of ""Formulas in QLL do not specify properties of programs but the programs themselves"" suggests that QLL is used to directly represent programs, which could be considered a conceptual primitive.
 - The use of an ""intensional rst order extension of the Curry Howard isomorphism"" implies a connection between logical proofs and computational terms, which might be seen as a conceptual primitive in linking logic and computation.
 - The instantiation of the monadic operator by a generic notion of constraint computation and the factoring of CLP programs into abstract LLP programs and constraint tables suggest that these elements could be considered conceptual primitives in reconstructing programming paradigms.","- ""introduce a new proof theoretic approach to the semantics of Constraint Logic Programming based on an intuitionistic rst order modal logic called QLL""
  - ""the logic calculus of QLL is used not only to capture the usual extensional aspects of Logic Programming i e which queries are success ful but also some of the intensional aspects i e what is the answer constraint and how is it constructed""
  - ""provides for a direct link between the model theoretic and the operational semantics following a formulas as programs and proofs as constraints principle""
  - ""our approach is distinguished from so called external logic characterizations of the operational semantics of logic programming""
  - ""Formulas in QLL do not specify properties of programs but the programs themselves""
  - ""factor a concrete CLP program into two parts an abstract LLP program and an associated constraint table""
  - ""recover concrete answer constraints for CLP programs from abstract LLP derivations and thus to establish precise proof and model theoretic connections between our Lax logical account of CLP and existing work""",,"- The abstract introduces a new proof-theoretic approach based on an intuitionistic first-order modal logic called QLL, which is used to capture both extensional and intensional aspects of Constraint Logic Programming.
 - QLL provides a direct link between model-theoretic and operational semantics, following a principle where formulas are treated as programs and proofs as constraints.
 - The framework is distinguished from external logic characterizations by using QLL as an internal logic, where operational semantics are differentiated by rule systems rather than axiom systems.
 - The abstract mentions the extension of Propositional Lax Logic to a first-order language, presenting a soundness and completeness theorem for a Gentzen-style system.
 - The framework involves an intensional first-order extension of the Curry-Howard isomorphism, which is a key mathematical property guaranteed by the framework.
 - The abstract discusses the factorization of CLP programs into abstract LLP programs and constraint tables, which allows for the recovery of concrete answer constraints.
 - The framework is based on a type of mathematical framework that involves modal logic and proof theory, specifically using Gentzen-style systems and Curry-Howard isomorphism.
 - Specific mathematical properties guaranteed include soundness and completeness, as well as the ability to establish precise proof and model-theoretic connections.
 - Proof techniques used include syntactic translation into a classical first-order bimodal theory and the use of natural deduction proofs.
 - Limitations or constraints of the framework are not explicitly mentioned in the abstract.","- ""In this report we introduce a new proof theoretic approach to the semantics of Constraint Logic Programming based on an intuitionistic rst order modal logic called QLL""
  - ""The dis tinguishing feature of this new approach is that the logic calculus of QLL is used not only to capture the usual extensional aspects of Logic Programming i e which queries are success ful but also some of the intensional aspects i e what is the answer constraint and how is it constructed""
  - ""It provides for a direct link between the model theoretic and the operational semantics following a formulas as programs and proofs as constraints principle""
  - ""This approach makes use of logic in a di erent way than other approaches based on logic calculi""
  - ""our approach is distinguished from so called external logic characterizations of the operational semantics of logic programming""
  - ""Formulas in QLL do not specify properties of programs but the programs themselves""
  - ""Our main tool is an intensional rst order extension of the Curry Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus""
  - ""Instantiating the monadic operator of QLL by a generic notion of constraint computation we factor a concrete CLP program into two parts an abstract LLP program and an associated constraint table""
  - ""These tables allow us to recover concrete answer constraints for CLP programs from abstract LLP derivations and thus to establish precise proof and model theoretic connections between our Lax logical account of CLP and existing work""",,"- The abstract discusses a new proof-theoretic approach using QLL to integrate aspects of Constraint Logic Programming (CLP), focusing on both extensional and intensional aspects.
 - The approach integrates model-theoretic and operational semantics, which suggests a mechanism for integrating different programming paradigms by linking these two aspects.
 - The use of QLL as an internal logic, where formulas represent programs themselves, indicates a novel embedding technique.
 - The extension of the Curry-Howard isomorphism to first-order logic and its application to factor CLP programs into abstract LLP programs and constraint tables is a specific integration mechanism.
 - The abstract does not explicitly mention challenges or constraints in paradigm integration, but it does highlight the novelty of using QLL in this context.","- ""Formulas in QLL do not specify properties of programs but the programs themselves""
  - ""the logic calculus of QLL is used not only to capture the usual extensional aspects of Logic Programming i e which queries are success ful but also some of the intensional aspects i e what is the answer constraint and how is it constructed""
  - ""Instantiating the monadic operator of QLL by a generic notion of constraint computation we factor a concrete CLP program into two parts an abstract LLP program and an associated constraint table""",,"- The abstract discusses the use of QLL to capture both extensional and intensional aspects of logic programming, which suggests a focus on abstraction mechanisms.
 - The mention of ""Formulas in QLL do not specify properties of programs but the programs themselves"" indicates a direct representation of programs within the logic, which is a form of abstraction.
 - The use of the Curry-Howard isomorphism and the extension to first-order logic suggests a mechanism for representing generic abstractions through the connection between proofs and computational terms.
 - The instantiation of the monadic operator with a generic notion of constraint computation and the factorization of CLP programs into abstract LLP programs and constraint tables indicate mechanisms for generic programming.
 - The ability to generalize constraints and apply the LLP paradigm to abstraction and refinement problems suggests a focus on generic programming methodology.","- ""In this report we introduce a new proof theoretic approach to the semantics of Constraint Logic Programming based on an intuitionistic rst order modal logic called QLL""
  - ""The dis tinguishing feature of this new approach is that the logic calculus of QLL is used not only to capture the usual extensional aspects of Logic Programming i e which queries are success ful but also some of the intensional aspects i e what is the answer constraint and how is it constructed""
  - ""It provides for a direct link between the model theoretic and the operational semantics following a formulas as programs and proofs as constraints principle""
  - ""This approach makes use of logic in a di erent way than other approaches based on logic calculi""
  - ""On the one side it is to be distinguished from the well known provability semantics which is concerned merely with what is derivable as opposed to how it is derivable paying attention to the fact that it is the how that determines the answer constraint""
  - ""On the other side our approach is distinguished from so called external logic characterizations of the operational semantics of logic programming""
  - ""Here in contrast QLL is used as an internal logic in which operational semantics are not di erentiated by di erent axiom systems but by di erent rule systems""
  - ""Formulas in QLL do not specify properties of programs but the programs themselves""
  - ""Our main tool is an intensional rst order extension of the Curry Howard isomorphism between natural deduction proofs in PLL and terms of the computational lambda calculus""
  - ""Choosing di erent notions of constraint allows us to generalize the standard notion of constraint as in CLP and to apply the LLP paradigm to the complementary problems of program abstraction and program re nement""",,"- The abstract introduces a new proof-theoretic approach using an intuitionistic first-order modal logic called QLL, which is a novel contribution to the semantics of Constraint Logic Programming.
 - The approach captures both extensional and intensional aspects of logic programming, providing a direct link between model-theoretic and operational semantics, which is a unique theoretical contribution.
 - The use of QLL as an internal logic differentiates it from external logic characterizations and provability semantics, offering a new perspective on operational semantics.
 - The extension of the Curry-Howard isomorphism to an intensional first-order context is a theoretical advancement, enabling the generalization of constraints and application to program abstraction and refinement.
 - The ability to factor CLP programs into abstract LLP programs and constraint tables allows for precise proof and model-theoretic connections, which is a significant theoretical contribution."
Constraints: A uniform model for data and control,L. Peter Deutsch,10.1145/960128.806893,https://doi.org/10.1145/960128.806893,"Workshop on Data Abstraction, Databases and Conceptual Modelling",3,1981,"1. Primitive Name: Constraint
  Definition: An object with parts corresponding to data fields or procedure parameters, and a body describing computations between parts.
  Orthogonality Score: Not specified",Not specified (the abstract does not mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Unification of data and procedures into a single object type
 - Interaction models between paradigms: Flexible computation based on available data
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed (the abstract focuses on the constraints paradigm but does not detail type systems or static checking strategies),"- Key novel insights: A unified model for data and control, challenging the traditional distinction between data and procedures.
 - Theoretical advancements: Constraints can model both data and procedures, allowing for flexible computation based on available data.
 - Potential implications: More flexible and adaptive programming systems, with constraints computing in different directions based on data availability.","- ""A (primitive) constraint is an object with some parts, which correspond to fields of a data structure or input/output parameters of a procedure, and a body which describes how to compute the values of some parts from other parts.""
  - ""a constraint may compute in different directions depending on the available data.""
  - ""Constraints with no body behave like ordinary data structures; constraints with substantial bodies behave more like procedures.""
  - ""a single kind of object models both data and procedures,""",,"- The abstract introduces a new paradigm called ""constraints"" which integrates both data and procedures into a single object type. This suggests a fundamental conceptual primitive is the ""constraint"" itself.
 - A constraint is defined as an object with parts (corresponding to data fields or procedure parameters) and a body (describing computations between parts). This is a specific definition of a conceptual primitive.
 - The abstract distinguishes between constraints with and without bodies, indicating different behaviors akin to data structures or procedures. This implies a level of abstraction where constraints can represent both data and procedural elements.
 - The orthogonality of these primitives is not explicitly discussed in terms of a score, but the ability of constraints to compute in different directions suggests a flexible and orthogonal nature.","- ""a single kind of object models both data and procedures,""
  - ""the description of procedures minimizes commitment to the order in which computational steps will be executed.""
  - ""A (primitive) constraint is an object with some parts, which correspond to fields of a data structure or input/output parameters of a procedure, and a body which describes how to compute the values of some parts from other parts.""
  - ""The body consists of rules written in an implementation language (Lisp in the MIT systems).""
  - ""Constraints with no body behave like ordinary data structures; constraints with substantial bodies behave more like procedures.""
  - ""a constraint may compute in different directions depending on the available data.""",,"- The abstract discusses a new paradigm called ""constraints"" that integrates data and procedures into a single object type. This suggests a conceptual framework rather than a specific mathematical framework.
 - The description of constraints and their behavior does not mention any specific mathematical framework such as type theory or category theory.
 - There is no mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract.
 - The abstract focuses on the conceptual model and its implications for computation rather than on mathematical formalization or verification.","- ""a single kind of object models both data and procedures,""
  - ""the description of procedures minimizes commitment to the order in which computational steps will be executed.""
  - ""a constraint may compute in different directions depending on the available data.""",,"- The abstract discusses a new paradigm called ""constraints"" that integrates data and procedures into a single object type. This suggests a mechanism for integrating different programming paradigms by unifying data and procedural elements.
 - The mention of minimizing commitment to the order of computational steps indicates a flexible interaction model between paradigms, allowing for dynamic execution based on available data.
 - The ability of constraints to compute in different directions based on available data implies a novel approach to paradigm integration, as it allows for flexible and adaptive computation.
 - There is no explicit mention of specific integration mechanisms, interaction models, constraints, or challenges in paradigm integration beyond the unified object model and flexible computation.","- ""a constraint may compute in different directions depending on the available data.""
  - ""Constraints with no body behave like ordinary data structures; constraints with substantial bodies behave more like procedures.""
  - ""A (primitive) constraint is an object with some parts, which correspond to fields of a data structure or input/output parameters of a procedure,""
  - ""a single kind of object models both data and procedures,""",,"- The abstract discusses a new paradigm called ""constraints"" where a single object type can represent both data and procedures, indicating a form of abstraction.
 - The definition of a ""concept"" in this context is related to the idea of a constraint, which is an object with parts and a body that describes how to compute values.
 - The mechanism for representing generic abstractions is through the use of constraints, which can behave like either data structures or procedures depending on their body content.
 - There is no mention of minimal type requirements or static checking/optimization strategies in the abstract.
 - The focus is on the flexibility and generic nature of constraints rather than specific type systems or static checking strategies.","- ""Most programming systems reflect a model of computation which sharply distinguishes between “passive” data objects and “active” program objects (procedures).""
  - ""In contrast, a group at MIT is investigating a new paradigm called constraints in which a single kind of object models both data and procedures, and in which the description of procedures minimizes commitment to the order in which computational steps will be executed.""
  - ""A (primitive) constraint is an object with some parts, which correspond to fields of a data structure or input/output parameters of a procedure, and a body which describes how to compute the values of some parts from other parts.""
  - ""However, unlike procedures, which always compute the same set of outputs from the same set of inputs, a constraint may compute in different directions depending on the available data.""
  - ""Constraints with no body behave like ordinary data structures; constraints with substantial bodies behave more like procedures.""",,"- The abstract introduces a new paradigm called ""constraints"" that challenges the traditional distinction between data and procedures in programming systems. This is a key novel insight as it suggests a unified model for both data and control.
 - The theoretical advancement lies in the concept of constraints that can model both data and procedures, allowing for a more flexible computation model. This is beyond existing approaches that strictly separate data and procedures.
 - The abstract highlights that constraints can compute in different directions based on available data, which is a departure from traditional procedures that always produce the same outputs from the same inputs. This flexibility is a significant theoretical contribution.
 - The potential implications for programming language design are significant, as this paradigm could lead to more flexible and adaptive programming systems. The abstract suggests a shift towards a more dynamic and less rigid computation model."
Using Adaptive Automata in a Multi-paradigm Programming Environment,J. José,-,-,-,0,2001,Not specified (the abstract does not provide explicit definitions or a list of specific conceptual primitives beyond adaptive automata),"Not specified (the abstract does not provide details on the type of mathematical framework, specific properties, proof techniques, or limitations)","- Specific integration mechanisms proposed: Adaptive automata
 - Interaction models between paradigms: Not mentioned
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Key novel insights: The use of adaptive automata in a multi-paradigm programming environment to integrate different programming languages and paradigms.
 - Theoretical advancements: Adaptive automata have the same formal power as Turing Machines, allowing for the modeling of arbitrarily complex systems.
 - Potential implications: Enables more flexible and powerful modeling capabilities in programming language design.","- ""Adaptive automata have been proven to have the same formal power as Turing Machines.""
  - ""Adaptive automata are special self-modifying formal state machines used as a design and implementation tool in the representation of complex systems.""
  - ""The present work briefly introduces such formal tool and presents case studies showing how to use them in two very different situations: the first one, in the name management module of a multiparadigmatic and multi-language programming environment, and the second one, in an application program implementing an adaptive automaton that accepts a context-sensitive language.""",,"- The abstract mentions ""adaptive automata"" as a key concept, which are described as ""special self-modifying formal state machines."" This suggests that adaptive automata are a conceptual primitive used in the study.
 - The abstract states that adaptive automata have the same formal power as Turing Machines, indicating their capability to model complex systems.
 - The use of adaptive automata in different contexts, such as name management and accepting context-sensitive languages, implies their versatility and potential as a primitive for reconstructing programming paradigms.
 - However, the abstract does not provide explicit definitions or a list of specific conceptual primitives beyond the mention of adaptive automata.
 - There is no mention of the level of abstraction or orthogonality of these primitives in the abstract.","- ""Adaptive automata are special self-modifying formal state machines used as a design and implementation tool in the representation of complex systems.""
  - ""Adaptive automata have been proven to have the same formal power as Turing Machines.""
  - ""Therefore, at least in theory, arbitrarily complex systems may be modeled with adaptive automata.""",,"- The abstract mentions ""adaptive automata"" as a mathematical tool used for representing complex systems. This suggests that the mathematical framework involves automata theory.
 - The statement that ""adaptive automata have been proven to have the same formal power as Turing Machines"" indicates a theoretical foundation related to computability theory, as Turing Machines are a fundamental model in this field.
 - The abstract does not specify any particular type of mathematical framework like type theory or category theory, nor does it mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the capability of adaptive automata to model complex systems, but there is no detailed discussion of the mathematical framework's characteristics.","- ""Adaptive automata have been proven to have the same formal power as Turing Machines.""
  - ""Adaptive automata are special self-modifying formal state machines used as a design and implementation tool in the representation of complex systems.""
  - ""the architecture of an experimental multiparadigmatic programming environment is sketched, showing how its parts combine together with application modules in order to perform the integration of program modules written in different programming languages and paradigms.""
  - ""The present work briefly introduces such formal tool and presents case studies showing how to use them in two very different situations: the first one, in the name management module of a multiparadigmatic and multi-language programming environment, and the second one, in an application program implementing an adaptive automaton that accepts a context-sensitive language.""",,"- The abstract mentions the integration of program modules written in different programming languages and paradigms, indicating that the study addresses paradigm integration.
 - Adaptive automata are used as a tool for integration, suggesting that they are a specific integration mechanism proposed in the study.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration.
 - There is no mention of novel translation or embedding techniques beyond the use of adaptive automata.
 - The abstract does not provide detailed theoretical integration strategies or comparative analysis sections.","- ""the architecture of an experimental multiparadigmatic programming environment is sketched, showing how its parts combine together with application modules in order to perform the integration of program modules written in different programming languages and paradigms.""
  - ""The present work briefly introduces such formal tool and presents case studies showing how to use them in two very different situations: the first one, in the name management module of a multiparadigmatic and multi-language programming environment, and the second one, in an application program implementing an adaptive automaton that accepts a context-sensitive language.""
  - ""Adaptive automata have been proven to have the same formal power as Turing Machines.""
  - ""Adaptive automata are special self-modifying formal state machines used as a design and implementation tool in the representation of complex systems.""",,"- The abstract discusses the use of adaptive automata as a tool for representing complex systems, which suggests a focus on abstraction mechanisms.
 - The mention of integrating program modules written in different languages and paradigms implies a level of genericity in the programming environment.
 - However, the abstract does not explicitly address generic programming methodology, type system discussions, or specific abstraction mechanisms beyond the use of adaptive automata.
 - There is no mention of minimal type requirements, static checking, or optimization strategies related to generic programming.
 - The focus is more on the integration and representation of complex systems using adaptive automata rather than on generic programming principles.","- ""the architecture of an experimental multiparadigmatic programming environment is sketched,""
  - ""Adaptive automata are special self-modifying formal state machines used as a design and implementation tool in the representation of complex systems.""
  - ""Adaptive automata have been proven to have the same formal power as Turing Machines.""
  - ""presents case studies showing how to use them in two very different situations:""
  - ""arbitrarily complex systems may be modeled with adaptive automata.""",,"- The abstract introduces the concept of using adaptive automata in a multi-paradigm programming environment, which suggests a novel approach to integrating different programming languages and paradigms.
 - The mention of adaptive automata having the same formal power as Turing Machines indicates a significant theoretical contribution, as it implies that these automata can model complex systems with the same level of computational power as Turing Machines.
 - The abstract highlights the use of adaptive automata in two different scenarios, which demonstrates their versatility and potential for application in various contexts.
 - The theoretical contribution lies in the application of adaptive automata to model complex systems and their integration into a multi-paradigm programming environment, which could have implications for programming language design by enabling more flexible and powerful modeling capabilities."
A New Paradigm for Component-based Development,J. Granström,10.4304/JSW.7.5.1136-1148,https://doi.org/10.4304/JSW.7.5.1136-1148,Journal of Software,4,2012,"1. Primitive Name: Worlds
  Definition: Decomposition of Haskell’s monolithic IO monad in dependently typed languages.
  Orthogonality Score: Not specified
 2. Primitive Name: World Maps
  Definition: Form a category with arbitrary products, replacing the standard notion of component.
  Orthogonality Score: Not specified","- Type of mathematical framework: Type theory, Category theory
 - Specific mathematical properties guaranteed: Not mentioned
 - Proof techniques used: Not mentioned
 - Limitations or constraints of the framework: Not mentioned","- Specific integration mechanisms proposed: Decomposition of Haskell's IO monad into ""worlds,"" introduction of ""world maps"" forming a category with arbitrary products.
 - Interaction models between paradigms: Replacement of traditional notions of interface and component with ""world"" and ""world map.""
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Use of type theory for category construction.","Generic programming not extensively addressed (the abstract focuses on component-based development using type theory and dependently typed languages, but does not explicitly address generic programming methodology or minimal type requirements)","- Key novel insights: Introduction of the concept of ""world map"" and the decomposition of Haskell's IO monad into worlds.
 - Theoretical advancements: Worlds and world maps form a category with arbitrary products, offering a new paradigm for component-based development.
 - Potential implications: Provides a rigorous approach to component-based development and offers a clean solution to the problem of session state, impacting programming language design.","- ""This paper introduces the notion of world map and shows that worlds and world maps form a category with arbitrary products.""
  - ""Hancock and Setzer describe how Haskell’s monolithic IO monad can be decomposed into worlds when working in a dependently typed language, like Martin-Lof’s type theory.""
  - ""If we let the notion of world replace the standard notion of interface, and the notion of world map replace the standard notion of component, we get a rigorous paradigm for component- based development.""",,"- The abstract mentions two key concepts: ""worlds"" and ""world maps."" These are introduced as part of a new paradigm for component-based development.
 - The concept of ""worlds"" is described as a decomposition of Haskell's monolithic IO monad, suggesting it is a fundamental unit or primitive in this new paradigm.
 - The concept of ""world maps"" is introduced as forming a category with arbitrary products, indicating it is another primitive that organizes or relates these worlds.
 - The abstract suggests that these primitives replace traditional notions of ""interface"" and ""component,"" indicating a shift in conceptual framework.
 - The level of abstraction is high, as these primitives are defined within the context of dependently typed languages and type theory, which are abstract mathematical frameworks.
 - Orthogonality is not explicitly discussed in the abstract, but the fact that these primitives form a category suggests a structured and potentially orthogonal relationship.","- ""The construction of the category is carried out entirely in type theory and directly implementable in dependently typed programming languages.""
  - ""Hancock and Setzer describe how Haskell’s monolithic IO monad can be decomposed into worlds when working in a dependently typed language, like Martin-Lof’s type theory.""
  - ""This paper introduces the notion of world map and shows that worlds and world maps form a category with arbitrary products.""",,"- The abstract mentions the use of ""dependently typed language, like Martin-Lof’s type theory,"" which indicates that the mathematical framework is based on type theory.
 - The concept of ""worlds and world maps form a category with arbitrary products"" suggests the use of category theory within this framework.
 - The abstract states that ""The construction of the category is carried out entirely in type theory,"" which implies that type theory is the primary mathematical framework used.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework in the abstract.","- ""This new paradigm is investigated and several applications are given.""
  - ""If we let the notion of world replace the standard notion of interface, and the notion of world map replace the standard notion of component, we get a rigorous paradigm for component- based development.""
  - ""The construction of the category is carried out entirely in type theory and directly implementable in dependently typed programming languages.""
  - ""This paper introduces the notion of world map and shows that worlds and world maps form a category with arbitrary products.""
  - ""Hancock and Setzer describe how Haskell’s monolithic IO monad can be decomposed into worlds when working in a dependently typed language, like Martin-Lof’s type theory.""",,"- The abstract discusses the decomposition of Haskell's IO monad into ""worlds"" in a dependently typed language, which suggests a theoretical integration strategy involving type theory.
 - The introduction of ""world maps"" and their formation into a category with arbitrary products indicates a specific integration mechanism, as it provides a structured way to manage interactions between different components or paradigms.
 - The replacement of traditional notions of interface and component with ""world"" and ""world map"" implies a novel approach to component-based development, which could be seen as an interaction model between paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the use of type theory.
 - The focus on dependently typed programming languages suggests a theoretical integration strategy, but the abstract does not provide detailed comparative analysis or discussion of paradigm interactions beyond the introduction of new concepts.","- ""The construction of the category is carried out entirely in type theory and directly implementable in dependently typed programming languages.""
  - ""If we let the notion of world replace the standard notion of interface, and the notion of world map replace the standard notion of component, we get a rigorous paradigm for component- based development.""
  - ""This paper introduces the notion of world map and shows that worlds and world maps form a category with arbitrary products.""
  - ""Hancock and Setzer describe how Haskell’s monolithic IO monad can be decomposed into worlds when working in a dependently typed language, like Martin-Lof’s type theory.""",,"- The abstract discusses the decomposition of Haskell's IO monad into ""worlds"" in a dependently typed language, which suggests a focus on abstraction mechanisms.
 - The introduction of ""world map"" and its relation to forming a category with arbitrary products indicates a mechanism for representing generic abstractions.
 - The use of type theory and dependently typed programming languages implies a focus on type systems and potentially static checking.
 - The abstract does not explicitly mention generic programming methodology or minimal type requirements, but it does imply a conceptual abstraction through the use of ""worlds"" and ""world maps.""
 - The abstract does not provide specific details on static checking or optimization strategies, nor does it explicitly define ""concept"" or discuss minimal type requirements.","- ""Hancock and Setzer describe how Haskell’s monolithic IO monad can be decomposed into worlds when working in a dependently typed language, like Martin-Lof’s type theory.""
  - ""This paper introduces the notion of world map and shows that worlds and world maps form a category with arbitrary products.""
  - ""The construction of the category is carried out entirely in type theory and directly implementable in dependently typed programming languages.""
  - ""If we let the notion of world replace the standard notion of interface, and the notion of world map replace the standard notion of component, we get a rigorous paradigm for component- based development.""
  - ""This new paradigm is investigated and several applications are given.""
  - ""For example, the problem of session state is given a very clean solution.""",,"- The abstract introduces a novel concept of ""world map"" and demonstrates how worlds and world maps form a category with arbitrary products. This is a key theoretical contribution as it provides a new framework for understanding and organizing components in programming.
 - The paper offers a theoretical advancement by decomposing Haskell's IO monad into worlds, which is a significant departure from traditional approaches. This decomposition is facilitated by working in a dependently typed language, indicating a theoretical innovation in how programming concepts are structured.
 - The abstract suggests that this new paradigm can replace traditional notions of interfaces and components, offering a more rigorous approach to component-based development. This is a theoretical contribution as it challenges existing paradigms and offers a new perspective.
 - The mention of a ""clean solution"" to the problem of session state implies that the new paradigm has practical implications for programming language design, particularly in addressing complex issues like session state management.
 - The abstract does not provide specific details from the conclusion or discussion sections, but the introduction of new concepts and their application suggests significant theoretical contributions."
Proof-oriented programming for high-assurance systems,Aseem Rastogi,10.1145/3578527.3581769,https://doi.org/10.1145/3578527.3581769,International Symposium on Electronic Commerce,0,2023,Not specified (the abstract does not provide explicit conceptual primitives),"Not specified (the abstract does not provide details about the type of mathematical framework, specific properties guaranteed, proof techniques, or limitations)",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of the Zeta framework for retrofitting strong, formal guarantees on existing legacy services.
 - Theoretical advancements: Proof-oriented programming paradigm, use of F* programming language, and the Zeta framework's approach to ensuring security and correctness.
 - Potential implications for programming language design: Influence on future language development to incorporate proof-oriented programming principles.","- ""I will provide an overview of this paradigm in the context of F*, a proof-oriented programming language developed at Microsoft Research.""
  - ""Zeta works by running a small, proven correct monitor in a trusted execution environment validating responses from the service.""
  - ""As a complementary methodology for retrofitting strong, formal guarantees on existing legacy services, I will present the Zeta framework.""
  - ""Proof-oriented programming is a paradigm where programs are designed and developed along with mathematical proofs of their correctness and security.""",,"- The abstract discusses ""proof-oriented programming"" as a paradigm, which suggests a conceptual framework rather than specific primitives.
 - The mention of F* as a ""proof-oriented programming language"" implies that it is a tool or platform for implementing this paradigm, but it does not specify conceptual primitives.
 - The Zeta framework is described as a methodology for retrofitting formal guarantees, but again, no specific conceptual primitives are defined.
 - The abstract does not provide explicit definitions or lists of conceptual primitives for reconstructing programming paradigms.","- ""I will provide an overview of this paradigm in the context of F*, a proof-oriented programming language developed at Microsoft Research.""
  - ""As a complementary methodology for retrofitting strong, formal guarantees on existing legacy services, I will present the Zeta framework.""
  - ""Proof-oriented programming is a paradigm where programs are designed and developed along with mathematical proofs of their correctness and security.""
  - ""Zeta works by running a small, proven correct monitor in a trusted execution environment validating responses from the service.""",,"- The abstract mentions ""mathematical proofs of their correctness and security,"" indicating that a mathematical framework is used to formalize and guarantee properties.
 - The mention of ""F*, a proof-oriented programming language"" suggests that F* is the mathematical framework used, as it is a language designed for proof-oriented programming.
 - The abstract does not specify the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed by F*.
 - There is no mention of specific proof techniques used or limitations/constraints of the framework in the abstract.
 - The Zeta framework is mentioned as a methodology for retrofitting formal guarantees, but no details about its mathematical framework are provided.","- ""The key idea is that we only need to develop the monitor using proof-oriented programming once-and-for-all, while the large legacy service remains untrusted.""
  - ""Zeta works by running a small, proven correct monitor in a trusted execution environment validating responses from the service.""
  - ""As a complementary methodology for retrofitting strong, formal guarantees on existing legacy services, I will present the Zeta framework.""
  - ""In this talk, I will provide an overview of this paradigm in the context of F*, a proof-oriented programming language developed at Microsoft Research.""
  - ""Proof-oriented programming is a paradigm where programs are designed and developed along with mathematical proofs of their correctness and security.""",,"- The abstract discusses proof-oriented programming as a paradigm, which is a specific approach to programming that integrates mathematical proofs for correctness and security.
 - The mention of F* as a proof-oriented programming language suggests a focus on this paradigm rather than integration with other paradigms.
 - The Zeta framework is described as a methodology for retrofitting formal guarantees on existing legacy services, which implies a way to integrate proof-oriented programming with existing systems, but it does not explicitly describe integration between different programming paradigms.
 - The abstract does not provide specific integration mechanisms, interaction models, constraints, or novel translation techniques for integrating different programming paradigms.","- ""Proof-oriented programming is a paradigm where programs are designed and developed along with mathematical proofs of their correctness and security.""
  - ""I will provide an overview of this paradigm in the context of F*, a proof-oriented programming language developed at Microsoft Research.""
  - ""Zeta works by running a small, proven correct monitor in a trusted execution environment validating responses from the service.""
  - ""As a complementary methodology for retrofitting strong, formal guarantees on existing legacy services, I will present the Zeta framework.""
  - ""I will briefly discuss several critical software components, developed from scratch in F*.""",,"- The abstract primarily focuses on proof-oriented programming and its application in developing high-assurance systems, particularly with the F* programming language.
 - There is no mention of generic programming or abstraction mechanisms in the abstract. The focus is on proof-oriented programming and the use of F* for developing secure components.
 - The abstract discusses the Zeta framework, which is related to retrofitting legacy services with formal guarantees, but it does not address generic programming or abstraction mechanisms.
 - The abstract does not provide any information on the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""Proof-oriented programming is a paradigm where programs are designed and developed along with mathematical proofs of their correctness and security.""
  - ""In this talk, I will provide an overview of this paradigm in the context of F*, a proof-oriented programming language developed at Microsoft Research.""
  - ""As a complementary methodology for retrofitting strong, formal guarantees on existing legacy services, I will present the Zeta framework.""
  - ""Zeta works by running a small, proven correct monitor in a trusted execution environment validating responses from the service.""
  - ""The key idea is that we only need to develop the monitor using proof-oriented programming once-and-for-all, while the large legacy service remains untrusted.""
  - ""I will illustrate Zeta by sketching an example of how we can make a concurrent, high-performance, key-value store ""zero trust"" and argue that this step incurs modest software engineering effort and modest runtime overheads.""",,"- The abstract discusses the paradigm of proof-oriented programming, which is a theoretical contribution as it emphasizes the integration of mathematical proofs with programming.
 - The mention of F* as a proof-oriented programming language suggests a theoretical advancement in programming language design, as it is specifically developed for this paradigm.
 - The introduction of the Zeta framework is a novel insight, as it provides a methodology for applying proof-oriented programming to existing legacy services without requiring them to be fully trusted or rewritten.
 - The Zeta framework's approach of using a small, proven correct monitor in a trusted execution environment is a theoretical advancement, as it offers a way to ensure security and correctness without significant overhaul of existing systems.
 - The potential implications for programming language design are highlighted by the use of F* and the Zeta framework, which could influence future language development to incorporate proof-oriented programming principles."
Call-by-push-value: Decomposing call-by-value and call-by-name,P. Levy,10.1007/s10990-006-0480-6,https://doi.org/10.1007/s10990-006-0480-6,High. Order Symb. Comput.,76,2006,"1. Primitive Name: Computation Types Denoting Algebras
  Definition: Computation types in CBPV denote algebras, not just carriers of algebras.
  Orthogonality Score: High (distinct from other frameworks like Effect-PCF)
 

 2. Primitive Name: Distinction Between Computation and Thunk
  Definition: CBPV retains the distinction between a computation and its thunk.
  Orthogonality Score: High (distinct from monadic metalanguages)
 

 3. Primitive Name: CBPV Equational Theory
  Definition: The minimal congruence containing laws governing computations.
  Orthogonality Score: High (specific to CBPV)
 

 4. Primitive Name: Push/Pop Reading
  Definition: A conceptual framework explaining function and computation interaction.
  Orthogonality Score: High (unique to CBPV)","- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Equivalence to categorical semantics, Eilenberg-Moore adjunctions
 - Proof techniques used: Equational theory, categorical equivalences
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Translations from CBV and CBN to CBPV, preserving denotational semantics.
 - Interaction models between paradigms: Decomposition of function types in CBV and CBN into CBPV.
 - Constraints or challenges in paradigm integration: Preserving a wide range of semantics.
 - Novel translation or embedding techniques: Two-stage translations from CBV and CBN to CBPV, involving fine-grain versions.",Generic programming not extensively addressed,"- Introduction of the call-by-push-value (CBPV) calculus as a unified framework for call-by-value (CBV) and call-by-name (CBN) paradigms.
 - Compositional account of CBN by treating computation types as denoting algebras.
 - Explicit handling of thunking isomorphism, not visible in monadic metalanguages.
 - Simple decomposition of CBN and CBV models into CBPV.
 - Straightforward operational semantics and fully abstract translations from CBN and CBV.
 - Machine reading of CBPV through the CK-machine, explaining function types as computation types.","- ""CBPV's computation types denote algebras, not merely carriers of algebras.""
  - ""We present the call-by-push-value (CBPV) calculus, which decomposes the typed call-by-value (CBV) and typed call-by-name (CBN) paradigms into fine-grain primitives.""
  - ""The CBPV equational theory is the minimal congruence containing the laws in Fig. 11 (with R ranging over computations).""
  - ""CBPV retains the distinction between a computation and its thunk, familiar to CBV programmers but erased in monadic metalanguages.""
  - ""CBPV is closely related to Filinski's Effect-PCF (Fil96), a form of the monadic metalanguage (Mog91). However it differs from Effect-PCF in 2 respects.""",,"- The paper introduces the call-by-push-value (CBPV) calculus as a way to decompose call-by-value (CBV) and call-by-name (CBN) paradigms into fine-grain primitives.
 - The first conceptual primitive is the distinction between computation types denoting algebras, which is a key feature of CBPV that differs from other frameworks like Effect-PCF.
 - The second primitive is the retention of the distinction between a computation and its thunk, which is significant for operational semantics and differs from monadic metalanguages.
 - The CBPV equational theory provides a set of laws that govern the behavior of computations, which can be considered as another set of primitives defining the calculus.
 - The push/pop reading of CBPV is a conceptual framework that explains how functions and computations interact, which can be seen as a primitive in understanding the operational semantics of CBPV.","- ""We present the call-by-push-value (CBPV) calculus, which decomposes the typed call-by-value (CBV) and typed call-by-name (CBN) paradigms into fine-grain primitives.""
  - ""On the operational side, we give big-step semantics and a stack machine for CBPV, which leads to a straightforward push/pop reading of CBPV programs.""
  - ""On the denotational side, we model CBPV using cpos and, more generally, using algebras for a strong monad.""
  - ""We give an equational theory for CBPV, and show it equivalent to a categorical semantics using monads and algebras.""
  - ""We use this theory to formally compare CBPV to Filinski’s variant of the monadic metalanguage, as well as to Marz’s language SFPL, both of which have essentially the same type structure as CBPV.""
  - ""The CBPV equational theory is the minimal congruence containing the laws in Fig. 11 (with R ranging over computations).""
  - ""Proposition 17 Let τ be a CBPV object structure. Then the categories Directτ and RestrAlg τ are equivalent.""
  - ""The monad/algebra semantics uses an Eilenberg-Moore adjunction between C and C T (algebras and algebra homomorphisms).""
  - ""The behaviour semantics uses the adjunction between Set and Set with left adjoint S × -and right adjoint S""",,"- The paper uses a combination of operational and denotational semantics to formalize CBPV. Operational semantics are provided through big-step semantics and a stack machine, while denotational semantics are modeled using cpos and algebras for a strong monad.
 - The mathematical framework is based on category theory, as indicated by the use of monads and algebras, as well as the equivalence to a categorical semantics.
 - The paper provides an equational theory for CBPV, which is a key component of the mathematical framework, ensuring properties such as soundness and adequacy.
 - The framework involves the use of Eilenberg-Moore adjunctions, which are a specific mathematical property guaranteed by the framework.
 - The proof techniques used include the establishment of equivalences between different semantic models and the use of categorical structures to relate CBPV to other languages.
 - The limitations or constraints of the framework are not explicitly mentioned, but the paper does discuss the relationship between CBPV and other languages, indicating potential areas for further exploration.","- ""We present the call-by-push-value (CBPV) calculus, which decomposes the typed call-by-value (CBV) and typed call-by-name (CBN) paradigms into fine-grain primitives.""
  - ""We present the translations from CBN and CBV to CBPV. All these translations straightforwardly preserve denotational semantics.""
  - ""We could add ""etc."" to the list of semantics, but for the sake of precision we will stop there.""
  - ""The reason this is a desirable objective is that it is plausible that the situation found for all the semantics listed will also be true for all other CBV and CBN semantics we might wish to study.""
  - ""CBPV is closely related to Filinski's Effect-PCF (Fil96), a form of the monadic metalanguage (Mog91). However it differs from Effect-PCF in 2 respects.""
  - ""Besides Effect-PCF, and somewhat similar pointed/unpointed calculi such as (How96), there has been much work bringing CBV and CBN into a common framework.""
  - ""We therefore emphasize what, by contrast, is extraordinary about CBPV: the translations into it preserve such a wide range of semantics.""
  - ""In this paper, we introduce a calculus, call-by-push-value (CBPV), which is a solution to this problem.""
  - ""CBPV has two disjoint classes of terms: values and computations.""
  - ""The types of CBV are value types and the types of CBN are computation types.""
  - ""Operationally, this says that a CBV function is a thunk of a computation that pops an argument and returns an answer.""
  - ""It is crucial to see that all these decompositions preserve denotational semantics, both for cpos/cppos and, more generally, in the monad/algebra setting.""
  - ""The CBPV equational theory is the minimal congruence containing the laws in Fig. 11 (with R ranging over computations).""
  - ""The translation -from CBPV value (resp. computation) types to Effect-PCF value (resp. computation) types are defined by induction:""
  - ""The translations -from Effect-PCF value types to CBPV value types, and -from Effect-PCF computation types to CBPV computation types are defined by mutual induction:""",,"- The paper introduces the call-by-push-value (CBPV) calculus as a way to integrate call-by-value (CBV) and call-by-name (CBN) paradigms by decomposing them into fine-grain primitives.
 - The integration mechanism involves translating both CBV and CBN into CBPV, which preserves denotational semantics across a wide range of semantics.
 - The interaction model between paradigms is based on the decomposition of function types in CBV and CBN into CBPV, where CBV functions are seen as thunks of computations and CBN functions are decomposed into U A → B.
 - The paper highlights that CBPV is unique in preserving a wide range of semantics, which is a significant challenge in integrating different paradigms.
 - Novel translation techniques include the two-stage translations from CBV and CBN to CBPV, which involve intermediate fine-grain versions of these paradigms.
 - The paper also discusses the relationship between CBPV and other frameworks like Effect-PCF, showing how CBPV types can be translated to and from Effect-PCF types.","- ""We present the call-by-push-value (CBPV) calculus, which decomposes the typed call-by-value (CBV) and typed call-by-name (CBN) paradigms into fine-grain primitives.""
  - ""CBPV is closely related to Filinski's Effect-PCF (Fil96), a form of the monadic metalanguage (Mog91). However it differs from Effect-PCF in 2 respects.""
  - ""CBPV's computation types denote algebras, not merely carriers of algebras.""
  - ""CBPV retains the distinction between a computation and its thunk, familiar to CBV programmers but erased in monadic metalanguages.""
  - ""The CBPV equational theory is the minimal congruence containing the laws in Fig. 11 (with R ranging over computations).""
  - ""We use this theory to formally compare CBPV to Filinski’s variant of the monadic metalanguage, as well as to Marz’s language SFPL, both of which have essentially the same type structure as CBPV.""
  - ""The translation from CBN jumbo λ-calculus with any of our effects (divergence, printing or storage) to CBPV with the same effects is junk-free i.e. for each computation U A n 0 , . . . , U A n n-1 ⊢ M : B n in the target language, there is a term A 0 , . . . , A n-1 ⊢ N : B in the source language such that N n = M is provable in the CBPV theory fully abstract i.e. M CBN N iff M n N n""
  - ""The question remains whether these results hold for smaller source languages. In some cases, affirmative results can be obtained by showing that the smaller source languages provide enough connectives to define the general connectives of jumbo λcalculus.""
  - ""The simulation results Prop. 6-9 do not make any use of types, and could be transferred to an untyped setting.""
  - ""The CBPV typing rules presented in Fig. 2 allow computations to be formed by patternmatching, but not values.""
  - ""We omit the assumptions necessary to make each equation well-typed.""
  - ""we add complex values, whose syntax is displayed in Fig. 12""
  - ""The equational theory on CBPV with complex values is the least congruence containing the laws of Fig. 11 , with R ranging over all terms (values and computations).""
  - ""we define a theory on CBPV with complex values to be a substitutive congruence containing these laws.""
  - ""Proposition 14 (complex values do not affect computations)""
  - ""Proposition 15 Let Γ be a context that is tuple-free, i.e. no identifier in it has , 1, × type.""
  - ""Proposition 16 Closed values within a consistent theory have the following properties.""
  - ""Definition 5 A CBPV algebra-family consists of a distributive category C equipped with a strong monad T and a (not necessarily small) family of T -algebras {KY } Y ∈Jwe""
  - ""Definition 6 (object structures) 1. A CBPV object structure τ is a (not necessarily small) algebra for the 2-sorted signature defining CBPV types.""
  - ""Definition 7 Let τ be a CBPV object structure.""
  - ""Definition 8 Let τ be a CBPV object structure. We define a monad T on Sig τ as follows.""
  - ""Definition 9 A direct model of CBPV consists of a CBPV object structure τ together with an algebra (s, θ) for the monad T on Sig τ""
  - ""Proposition 17 Let τ be a CBPV object structure. Then the categories Directτ and RestrAlg τ are equivalent.""
  - ""The monad/algebra semantics uses an Eilenberg-Moore adjunction between C and C T (algebras and algebra homomorphisms).""
  - ""The behaviour semantics uses the adjunction between Set and Set with left adjoint S × -and right adjoint S""",,"- The paper primarily focuses on the call-by-push-value (CBPV) calculus and its relationship with call-by-value (CBV) and call-by-name (CBN) paradigms, rather than generic programming.
 - The paper discusses the decomposition of CBV and CBN into fine-grain primitives, which is more about operational semantics than generic programming.
 - The mention of ""jumbo λ-calculus"" and translations to CBPV suggests a focus on type systems and operational properties rather than genericity.
 - The paper does not explicitly address generic programming or abstraction mechanisms in terms of genericity.
 - The focus is on the equational theory, type systems, and operational semantics rather than generic programming concepts.","- ""We present the call-by-push-value (CBPV) calculus, which decomposes the typed call-by-value (CBV) and typed call-by-name (CBN) paradigms into fine-grain primitives.""
  - ""The reason this is a desirable objective is that it is plausible that the situation found for all the semantics listed will also be true for all other CBV and CBN semantics we might wish to study.""
  - ""CBPV is closely related to Filinski's Effect-PCF (Fil96), a form of the monadic metalanguage (Mog91). However it differs from Effect-PCF in 2 respects.""
  - ""Firstly, the explicit writing of U allows us to give a compositional account of CBN, because a computation type denotes an algebra.""
  - ""Secondly, CBPV makes explicit the thunking isomorphism, which is invisible from the monadic viewpoint, but apparent in the behaviour semantics of Sect. 6.2.""
  - ""Thirdly, we see a simple decomposition of CBN and CBV models for the first time.""
  - ""Fourthly, we have a straightforward operational semantics for CBPV (unlike Effect-PCF, but like MIL-lite), and the translations from CBN and CBV into it are fully abstract.""
  - ""Fifthly, we have a machine reading of CBPV (the CK-machine) that makes it clear why a function type should be regarded as a computation type, a classification that was present in Effect-PCF but not understood in a computational way.""
  - ""As stated in Sect. 1.1, this paper is an introduction to CBPV, not an exhaustive study. In particular, the relationship between CBPV and adjunctions (Lev03; Lev05) is not investigated in this paper.""",,"- The paper introduces the call-by-push-value (CBPV) calculus as a novel approach to decompose call-by-value (CBV) and call-by-name (CBN) paradigms into fine-grain primitives. This is a key theoretical contribution as it provides a unified framework for understanding these paradigms.
 - The explicit use of ""U"" in CBPV allows for a compositional account of CBN, which is a significant theoretical advancement. This is because it treats computation types as denoting algebras, which is different from existing monadic metalanguages.
 - The paper highlights the thunking isomorphism, which is not visible in monadic metalanguages but is apparent in behavior semantics. This is a novel insight into how CBPV handles computations and values.
 - The decomposition of CBN and CBV models into CBPV is a new contribution, providing a simpler understanding of these models.
 - The operational semantics of CBPV and the fully abstract translations from CBN and CBV are significant theoretical contributions. They provide a straightforward operational semantics and ensure that the translations preserve denotational semantics.
 - The machine reading of CBPV through the CK-machine is another theoretical innovation, as it explains why function types are considered computation types in a computational context.
 - The paper also mentions potential implications for programming language design, particularly in how CBPV can be used to understand and design languages with both CBV and CBN features."
Reasoning about Iteration and Recursion Uniformly based on Big-step Semantics,"Ximeng Li, Qianying Zhang, Guohui Wang, Zhiping Shi, Yong Guan",10.1007/978-3-030-91265-9_4,https://doi.org/10.1007/978-3-030-91265-9_4,"International Symposium on Software Engineering: Theories, Tools, and Applications",3,2021,Not specified (the paper focuses on a methodological approach rather than defining specific conceptual primitives),"- Type of mathematical framework: Type theory (as indicated by the use of Coq proof assistant)
 - Specific mathematical properties guaranteed: Soundness and relative completeness
 - Proof techniques used: Inductive proofs
 - Limitations or constraints of the framework: Not explicitly mentioned, but tailored for deductive program verification with big-step semantics",No specific integration approach described,"- Definition of ""concept"" used: Language-independent verification based on big-step operational semantics.
 - Mechanisms for representing generic abstractions: Application to different programming paradigms (imperative and functional).
 - Minimal type requirements identified: Language independence using big-step semantics.
 - Static checking or optimization strategies: Not explicitly addressed.","- Key novel insights: A language-independent technique for reasoning about iteration and recursion based on big-step operational semantics.
 - Theoretical advancements: Inductive proofs for soundness and relative completeness, simplification of deductive verification by avoiding explicit inductions.
 - Potential implications: Provides a common model for reasoning about unbounded behavior across different languages, simplifying programming language design.","- ""In this work, we propose a solution for the sound reasoning about iteration and recursion based on the big-step operational semantics of any programming language.""
  - ""We give inductive proofs on the soundness and relative completeness of our reasoning technique.""
  - ""We illustrate the technique at simplified programming languages of the imperative and functional paradigms, with diverse features.""
  - ""The main technical contributions of this article are:
 

 a language-independent technique simplifying the deductive verification of iterative and recursive program structures based on big-step semantics, -proofs for the soundness and relative completeness of the technique, -illustration of the technique with the verification of example programs in simplified programming languages of different paradigms, -mechanization of proofs and verification examples in the Coq proof assistant.""
  - ""We provide an infrastructure that handles the routine part of the work in reasoning about programming constructs with potentially unbounded behavior, based on a common model of big-step execution in a proof assistant.""
  - ""The technique can be applied to any programming language, as long as the big-step operational semantics of the language is formulated with an explicit characterization of the premises and conclusions of inference rules.""",,"- The paper focuses on developing a language-independent technique for reasoning about iteration and recursion using big-step operational semantics.
 - The technique is designed to be applicable to any programming language, provided its big-step operational semantics is explicitly defined.
 - The paper does not explicitly define specific conceptual primitives but rather focuses on a methodological approach to handling iteration and recursion.
 - The emphasis is on the use of big-step semantics as a foundational framework for deductive program verification, rather than on defining specific primitives.
 - The paper discusses the application of this technique to various programming paradigms but does not specify conceptual primitives for reconstructing these paradigms.","- ""We give inductive proofs on the soundness and relative completeness of our reasoning technique.""
  - ""The main technical contributions of this article are:
 

 a language-independent technique simplifying the deductive verification of iterative and recursive program structures based on big-step semantics, -proofs for the soundness and relative completeness of the technique, -illustration of the technique with the verification of example programs in simplified programming languages of different paradigms, -mechanization of proofs and verification examples in the Coq proof assistant.""
  - ""We prove the implication from verif (Φ) to infer Φ (c, r). The following lemma is a key component of this proof. Lemma 1. If verif (Φ), and deriv (c, r) holds, then infer Φ (c, r) holds.""
  - ""Theorem 1 (Soundness). If verif (Φ) can be established, then valid (Φ) holds.""
  - ""Theorem 4 (Relative Completeness). For each valid specification Φ, there exists a specification Φ ′ such that Φ Φ ′ , and verif (Φ ′ ) can be established.""
  - ""The technique admits succinct, inductive arguments for soundness and relative completeness that are verified in the Coq proof assistant along with other formal claims [8].""",,"- The paper uses inductive proofs to establish the soundness and relative completeness of their reasoning technique, indicating a reliance on inductive reasoning as a proof technique.
 - The use of the Coq proof assistant suggests that the mathematical framework is based on type theory, as Coq is a proof assistant based on the Curry-Howard correspondence, which is a fundamental principle in type theory.
 - The paper guarantees specific mathematical properties such as soundness and relative completeness, which are central to formal verification.
 - The limitations or constraints of the framework are not explicitly mentioned, but the focus on big-step semantics and the use of Coq suggest that the framework is tailored for deductive program verification with these specific characteristics.","- ""The technique can be applied to any programming language, as long as the big-step operational semantics of the language is formulated with an explicit characterization of the premises and conclusions of inference rules.""
  - ""To tackle the problem caused by the proliferation of programming languages in deductive program verification, we provide a technique to address the crosscutting concern of reasoning about language features causing unbounded behavior, including loops and recursive function calls.""
  - ""The language considered in this section is a fragment of the eager functional language as discussed in [27].""
  - ""In this section, we evaluate our technique with two further examples. In the two examples, programming languages of the imperative and functional paradigms are used, respectively, to implement the functionality of merging two sorted lists of integers into a single sorted list of integers.""
  - ""We illustrate our technique using verification tasks involving simplified imperative and functional languages.""",,"- The paper discusses the application of the proposed technique to both imperative and functional programming paradigms, indicating a focus on integrating these paradigms within the context of deductive program verification.
 - The technique is designed to be language-independent, which implies that it can be applied across different programming paradigms without requiring paradigm-specific modifications.
 - The paper does not explicitly describe specific integration mechanisms or interaction models between paradigms. Instead, it focuses on the application of the technique to different paradigms.
 - There is no mention of novel translation or embedding techniques specifically for integrating different paradigms.
 - The paper does not discuss constraints or challenges in paradigm integration explicitly, but it does address the general challenge of dealing with unbounded behavior across different languages.","- ""In language-independent program verification, common aspects of computer programs are addressed to enable sound reasoning for all languages.""
  - ""we propose a solution for the sound reasoning about iteration and recursion based on the big-step operational semantics of any programming language.""
  - ""We give inductive proofs on the soundness and relative completeness of our reasoning technique.""
  - ""We illustrate the technique at simplified programming languages of the imperative and functional paradigms, with diverse features.""
  - ""The main technical contributions of this article are:
 

 a language-independent technique simplifying the deductive verification of iterative and recursive program structures based on big-step semantics,""
  - ""We provide an infrastructure that handles the routine part of the work in reasoning about programming constructs with potentially unbounded behavior, based on a common model of big-step execution in a proof assistant.""
  - ""To combat the cumbersomeness of direct program proofs based on operational semantics, while avoiding the full complexity in the development of program logics, one could seek to establish the infrastructure necessary for reasoning about specific kinds of language features, for any languages with those features.""",,"- The paper focuses on developing a language-independent technique for deductive program verification, which implies a level of genericity in its approach.
 - The technique is based on big-step operational semantics, which is a common model that can be applied to various programming languages, indicating a form of abstraction.
 - The paper discusses the application of this technique to different programming paradigms (imperative and functional), suggesting a mechanism for representing generic abstractions.
 - The emphasis on language independence and the use of big-step semantics as a common model implies a minimal type requirement for the languages being verified.
 - The paper does not explicitly discuss static checking or optimization strategies in the context of generic programming.
 - The focus is more on the verification technique rather than specific type systems or static checking mechanisms.","- ""In this work, we propose a solution for the sound reasoning about iteration and recursion based on the big-step operational semantics of any programming language.""
  - ""We give inductive proofs on the soundness and relative completeness of our reasoning technique.""
  - ""The main technical contributions of this article are:
 

 a language-independent technique simplifying the deductive verification of iterative and recursive program structures based on big-step semantics, -proofs for the soundness and relative completeness of the technique, -illustration of the technique with the verification of example programs in simplified programming languages of different paradigms, -mechanization of proofs and verification examples in the Coq proof assistant.""
  - ""To combat the cumbersomeness of direct program proofs based on operational semantics, while avoiding the full complexity in the development of program logics, one could seek to establish the infrastructure necessary for reasoning about specific kinds of language features, for any languages with those features.""
  - ""Our technique also has a succinct, inductive argument for soundness.""
  - ""The technique can be applied to any programming language, as long as the big-step operational semantics of the language is formulated with an explicit characterization of the premises and conclusions of inference rules.""
  - ""The user of this technique need not set up inductions for the loops and recursive calls in performing a program proof, but formulates invariants and function contracts in a uniform style with a specification, and perform symbolic execution of the program with the help of this specification.""",,"- The paper introduces a novel approach to reasoning about iteration and recursion using big-step operational semantics, which is a significant theoretical contribution.
 - The technique is language-independent, meaning it can be applied to any programming language with a big-step semantics, which is a key advancement over existing approaches that are often language-specific.
 - The paper provides inductive proofs for the soundness and relative completeness of the technique, which are theoretical advancements beyond existing methods.
 - The technique simplifies deductive verification by avoiding the need for explicit inductions for loops and recursive calls, instead using a uniform style for invariants and function contracts.
 - The approach has potential implications for programming language design by providing a common model for reasoning about unbounded behavior across different languages."
D Datalog and Recursion,-,-,-,-,0,-,"1. Primitive Name: Recursion
  Definition: Addition of recursion to conjunctive queries to yield datalog
  Orthogonality Score: Not specified
 2. Primitive Name: Negation
  Definition: Combination with recursion to extend first-order queries
  Orthogonality Score: Not specified
 3. Primitive Name: Stratification
  Definition: Semantics for negation in datalog
  Orthogonality Score: Not specified
 4. Primitive Name: Well-founded Semantics
  Definition: Semantics for negation in datalog
  Orthogonality Score: Not specified",Not specified (the abstract discusses logic programming and operational semantics but does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Enriching conjunctive queries with union and difference; adding recursion to conjunctive queries to yield datalog.
 - Interaction models between paradigms: Adapting logic-programming approaches to databases; combining recursion and negation in datalog.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"- Introduction of recursion to conjunctive queries, yielding datalog.
 - Adaptation of logic-programming approaches to databases, providing an elegant notation for recursion.
 - Combination of recursion and negation in query languages, extending first-order queries.
 - Maintenance of correspondence between languages in the three paradigms in the presence of recursion.
 - Exploration of incorporating negation in datalog, inspired by logic programming, with implications for programming language design.","- ""First we add recursion to the conjunctive queries, which yields datalog.""
  - ""Datalog owes a great debt to Prolog and the logic-programming area in general.""
  - ""A fundamental contribution of the logic-programming paradigm to relational query languages is its elegant notation for expressing recursion.""
  - ""We adapt the logic-programming approach to the framework of databases.""
  - ""Chapters 14 and 15 deal with languages combining recursion and negation, which are proper extensions of first-order queries.""
  - ""The semantics of each one is defined in fundamentally operational terms, which include datalog with negation and a straightforward, fixpoint semantics.""
  - ""Several important semantics for negation are presented, including stratification and well-founded semantics.""",,"- The abstract discusses the addition of recursion to conjunctive queries, resulting in datalog, which is a conceptual primitive in the context of query languages.
 - The influence of Prolog and logic programming on datalog suggests that recursion is a fundamental primitive in this context.
 - The adaptation of logic programming to databases indicates that recursion is a key primitive in this framework.
 - The combination of recursion and negation in later chapters suggests that these are conceptual primitives for extending first-order queries.
 - The mention of specific semantics like stratification and well-founded semantics implies that these are conceptual primitives for handling negation in datalog.
 - The abstract does not provide explicit definitions or orthogonality scores for these primitives, but they are clearly identified as key concepts.","- ""We did this by enriching the conjunctive queries first with union (disjunction) and then with difference (negation).""
  - ""First we add recursion to the conjunctive queries, which yields datalog.""
  - ""Datalog owes a great debt to Prolog and the logic-programming area in general.""
  - ""A fundamental contribution of the logic-programming paradigm to relational query languages is its elegant notation for expressing recursion.""
  - ""We adapt the logic-programming approach to the framework of databases.""
  - ""We study evaluation techniques for datalog programs in Chapter 13, which covers the main optimization techniques developed for recursion in query languages, including seminaive evaluation and magic sets.""
  - ""Chapters 14 and 15 deal with languages combining recursion and negation, which are proper extensions of first-order queries.""
  - ""The semantics of each one is defined in fundamentally operational terms, which include datalog with negation and a straightforward, fixpoint semantics.""
  - ""Several important semantics for negation are presented, including stratification and well-founded semantics.""",,"- The abstract discusses the enrichment of conjunctive queries with union and difference, leading to the development of datalog, which is a form of recursion. This suggests a focus on logical and algebraic frameworks.
 - The mention of datalog and its debt to Prolog indicates a connection to logic programming, which is a mathematical framework.
 - The adaptation of logic programming to databases suggests a theoretical foundation in logic programming principles.
 - The discussion of evaluation techniques and optimization methods like seminaive evaluation and magic sets implies a focus on operational semantics.
 - The mention of fixpoint semantics and specific semantics for negation like stratification and well-founded semantics indicates a mathematical framework based on these concepts.
 - However, the abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it detail specific mathematical properties guaranteed or proof techniques used.","- ""We did this by enriching the conjunctive queries first with union (disjunction) and then with difference (negation).""
  - ""First we add recursion to the conjunctive queries, which yields datalog.""
  - ""Datalog owes a great debt to Prolog and the logic-programming area in general.""
  - ""A fundamental contribution of the logic-programming paradigm to relational query languages is its elegant notation for expressing recursion.""
  - ""The perspective of databases, however, is significantly different from that of logic programming.""
  - ""We adapt the logic-programming approach to the framework of databases.""
  - ""Chapters 14 and 15 deal with languages combining recursion and negation, which are proper extensions of first-order queries.""
  - ""Languages are presented from all three paradigms, which support both negation and recursion.""
  - ""the elegant correspondence between languages in the three paradigms is maintained in the presence of recursion.""
  - ""Chapter 15 considers approaches to incorporating negation in datalog that are closer in spirit to logic programming.""",,"- The abstract discusses the integration of different programming paradigms by enriching conjunctive queries with union and difference, which are elements from algebraic and logic paradigms.
 - The development of datalog by adding recursion to conjunctive queries is a key integration mechanism, as it combines elements from logic programming (Prolog) with relational databases.
 - The abstract mentions adapting logic-programming approaches to databases, indicating an interaction model where logic programming concepts are applied to database frameworks.
 - The integration of negation and recursion in datalog is a significant aspect, as it extends first-order queries and maintains correspondence across paradigms.
 - The abstract does not explicitly mention specific constraints or challenges in paradigm integration, nor does it detail novel translation or embedding techniques.
 - The focus is on theoretical integration strategies and comparative analysis, particularly in how datalog and its extensions relate to logic programming and database paradigms.","- ""First we add recursion to the conjunctive queries, which yields datalog.""
  - ""Datalog owes a great debt to Prolog and the logic-programming area in general.""
  - ""A fundamental contribution of the logic-programming paradigm to relational query languages is its elegant notation for expressing recursion.""
  - ""We adapt the logic-programming approach to the framework of databases.""
  - ""Chapters 14 and 15 deal with languages combining recursion and negation, which are proper extensions of first-order queries.""
  - ""Chapter 15 considers approaches to incorporating negation in datalog that are closer in spirit to logic programming.""",,"- The abstract discusses the addition of recursion to conjunctive queries, resulting in datalog, which is a key aspect of the study.
 - It mentions the influence of Prolog and logic programming on datalog, particularly in terms of recursion notation.
 - The adaptation of logic programming to databases suggests a focus on conceptual abstraction, as it involves applying logic programming principles to a different domain.
 - The abstract does not explicitly mention generic programming or type systems, which are typically associated with genericity and abstraction mechanisms.
 - The focus is on recursion and negation in query languages rather than generic programming or abstraction mechanisms.","- ""First we add recursion to the conjunctive queries, which yields datalog.""
  - ""Datalog owes a great debt to Prolog and the logic-programming area in general.""
  - ""A fundamental contribution of the logic-programming paradigm to relational query languages is its elegant notation for expressing recursion.""
  - ""We adapt the logic-programming approach to the framework of databases.""
  - ""Although datalog is of great theoretical importance, it is not adequate as a practical query language because of the lack of negation.""
  - ""Chapters 14 and 15 deal with languages combining recursion and negation, which are proper extensions of first-order queries.""
  - ""The semantics of each one is defined in fundamentally operational terms, which include datalog with negation and a straightforward, fixpoint semantics.""
  - ""As will be seen, the elegant correspondence between languages in the three paradigms is maintained in the presence of recursion.""
  - ""Chapter 15 considers approaches to incorporating negation in datalog that are closer in spirit to logic programming.""",,"- The abstract discusses the introduction of recursion to conjunctive queries, resulting in datalog, which is a novel theoretical contribution as it extends the capabilities of query languages.
 - The adaptation of logic-programming approaches to databases is highlighted as a significant theoretical advancement, as it brings an elegant notation for recursion into the database context.
 - The combination of recursion and negation in query languages is presented as a theoretical advancement beyond existing approaches, as it extends first-order queries and provides new operational semantics.
 - The maintenance of correspondence between languages in the three paradigms (algebraic, logic, deductive) in the presence of recursion is a theoretical innovation, as it ensures consistency across different paradigms.
 - The exploration of incorporating negation in datalog, inspired by logic programming, suggests potential implications for programming language design by enhancing the expressiveness of query languages."
Practical Foundations of Mathematics,P. Taylor,10.5860/choice.37-4551,https://doi.org/10.5860/choice.37-4551,Cambridge Studies in Advanced Mathematics,190,1999,"1. Primitive Name: Constructive Logic
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 2. Primitive Name: Type Theory
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 3. Primitive Name: Propositions-as-Types
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 4. Primitive Name: Intuitionistic Higher-Order Logic
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 5. Primitive Name: Categorical Mathematical Structures
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 6. Primitive Name: Sum, Product, and Function Types
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 7. Primitive Name: Structural Induction
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed","- Type of mathematical framework: Constructive logic and type theory, with elements of category theory
 - Specific mathematical properties guaranteed: Captures the essence of the axiom of Replacement in a type-theoretic framework
 - Proof techniques used: Propositions-as-types, where proofs appear as functional programs
 - Limitations or constraints of the framework: Informal use of type-theoretic language, contrasting with more syntactically inclined approaches",No specific integration approach described,Generic programming not extensively addressed (the abstract discusses type theory and abstraction mechanisms but does not explicitly address generic programming methodology or specific strategies),"- Key novel insights: Focus on constructive logic and type theory as foundations for mathematics and computer science.
 - Theoretical advancements: Use of propositions-as-types, proofs as functional programs, type-theoretic universes for the axiom of Replacement, and categorical structures for general formulations.
 - Potential implications for programming language design: Bridging logic and computation through propositions-as-types and functional programs.","- ""The book presents a very well-chosen selection of mathematical notions and techniques as they are relevant for the foundations of Mathematics and Computer Science.""
  - ""The aim rather is to exhibit and study the mathematical principles behind logic and induction as needed and used for the formalisation of (the main parts of) Mathematics and Computer Science.""
  - ""the book is based on and provides an introduction to constructive logic and type theory, the latter being much closer to mathematical practice than set theory.""
  - ""Constructive logic is also discussed from the point of view of propositions-as-types where proofs appear as sort of functional programs thus bridging the gap between logic and computation.""
  - ""The mathematical structures employed for providing a mathematical underpinning are mainly categorical in nature thus allowing for general and concise formulations.""
  - ""the underlying logic is intuitionistic higher-order logic ( a la Church, i.e. based on functions and a type of propositions)""
  - ""a thorough discussion of the set-theoretic axiom of Replacement and strong arguments in favour of type-theoretic universes as capturing the essence of the axiom of Replacement in a type theoretic framework.""",,"- The abstract discusses the use of constructive logic and type theory as foundational elements, which suggests these are conceptual primitives.
 - The mention of ""propositions-as-types"" indicates a primitive related to the representation of propositions as types, which is a fundamental concept in type theory.
 - The use of ""intuitionistic higher-order logic"" suggests a primitive related to logical reasoning based on functions and propositions.
 - The discussion of ""categorical"" mathematical structures implies a primitive related to the use of categories for general and concise formulations.
 - The mention of ""sum, product and function types"" and ""structural induction"" suggests primitives related to these specific types and induction techniques.
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality or level of abstraction in detail.","- ""The book presents a very well-chosen selection of mathematical notions and techniques as they are relevant for the foundations of Mathematics and Computer Science.""
  - ""the book is based on and provides an introduction to constructive logic and type theory, the latter being much closer to mathematical practice than set theory.""
  - ""Constructive logic is also discussed from the point of view of propositions-as-types where proofs appear as sort of functional programs thus bridging the gap between logic and computation.""
  - ""The mathematical structures employed for providing a mathematical underpinning are mainly categorical in nature thus allowing for general and concise formulations.""
  - ""Whereas till the last chapter the underlying logic is intuitionistic higher-order logic ( a la Church, i.e. based on functions and a type of propositions) in the nal chapter one nds a thorough discussion of the set-theoretic axiom of Replacement and strong arguments in favour of type-theoretic universes as capturing the essence of the axiom of Replacement in a type theoretic framework.""
  - ""As opposed to most texts on constructive type theory which are very syntactically inclined in the current book the use of type-theoretic language is much more informal which is in accordance with the informal way set theory is used in mathematics.""",,"- The abstract mentions that the book is based on ""constructive logic and type theory,"" indicating that these are the primary mathematical frameworks used.
 - The use of ""propositions-as-types"" suggests a specific approach within type theory where proofs are viewed as functional programs, which is a characteristic of the framework.
 - The mention of ""categorical in nature"" indicates that category theory is also employed, providing a general and concise formulation of mathematical structures.
 - The abstract discusses the use of ""intuitionistic higher-order logic"" and its relation to type theory, particularly in capturing the essence of the axiom of Replacement.
 - The informal use of type-theoretic language is noted, contrasting with more syntactically inclined approaches, which might be seen as a limitation or constraint in terms of formal verification.","- ""As opposed to most texts on constructive type theory which are very syntactically inclined in the current book the use of type-theoretic language is much more informal which is in accordance with the informal way set theory is used in mathematics.""
  - ""The mathematical structures employed for providing a mathematical underpinning are mainly categorical in nature thus allowing for general and concise formulations.""
  - ""Constructive logic is also discussed from the point of view of propositions-as-types where proofs appear as sort of functional programs thus bridging the gap between logic and computation.""
  - ""The aim rather is to exhibit and study the mathematical principles behind logic and induction as needed and used for the formalisation of (the main parts of) Mathematics and Computer Science.""",,"- The abstract discusses the integration of mathematical principles and logic with computer science, particularly through constructive logic and type theory.
 - The mention of ""propositions-as-types"" and ""proofs appear as sort of functional programs"" suggests a connection between logical and computational paradigms, but it does not explicitly describe a programming paradigm integration approach.
 - The use of categorical structures for mathematical underpinning implies a general framework for integration, but again, it does not specify an integration approach for programming paradigms.
 - The abstract does not mention specific integration mechanisms, interaction models, constraints, or novel translation techniques related to programming paradigms.","- ""The book presents a very well-chosen selection of mathematical notions and techniques as they are relevant for the foundations of Mathematics and Computer Science.""
  - ""The aim rather is to exhibit and study the mathematical principles behind logic and induction as needed and used for the formalisation of (the main parts of) Mathematics and Computer Science.""
  - ""the book is based on and provides an introduction to constructive logic and type theory, the latter being much closer to mathematical practice than set theory.""
  - ""Constructive logic is also discussed from the point of view of propositions-as-types where proofs appear as sort of functional programs thus bridging the gap between logic and computation.""
  - ""The mathematical structures employed for providing a mathematical underpinning are mainly categorical in nature thus allowing for general and concise formulations.""
  - ""the use of type-theoretic language is much more informal which is in accordance with the informal way set theory is used in mathematics.""
  - ""The second chapter on Types and Induction discusses sum, product and function types, the paradigm of propositions-as-types and the technique of structural induction exempli ed by natural numbers and lists.""",,"- The abstract discusses the book's focus on constructive logic and type theory, which are relevant to generic programming and abstraction mechanisms.
 - The mention of ""propositions-as-types"" and ""functional programs"" suggests a connection to generic programming, as these concepts are often used in generic programming methodologies.
 - The use of categorical structures implies a focus on abstraction mechanisms, as categories are used to represent abstract structures in mathematics and computer science.
 - The discussion of ""sum, product and function types"" and ""structural induction"" in the second chapter suggests a focus on type systems and abstraction mechanisms.
 - However, the abstract does not explicitly mention ""generic programming"" or provide detailed information on minimal type requirements, static checking, or optimization strategies.","- ""The book presents a very well-chosen selection of mathematical notions and techniques as they are relevant for the foundations of Mathematics and Computer Science.""
  - ""The aim rather is to exhibit and study the mathematical principles behind logic and induction as needed and used for the formalisation of (the main parts of) Mathematics and Computer Science.""
  - ""the book is based on and provides an introduction to constructive logic and type theory, the latter being much closer to mathematical practice than set theory.""
  - ""Constructive logic is also discussed from the point of view of propositions-as-types where proofs appear as sort of functional programs thus bridging the gap between logic and computation.""
  - ""The mathematical structures employed for providing a mathematical underpinning are mainly categorical in nature thus allowing for general and concise formulations.""
  - ""in the nal chapter one nds a thorough discussion of the set-theoretic axiom of Replacement and strong arguments in favour of type-theoretic universes as capturing the essence of the axiom of Replacement in a type theoretic framework.""
  - ""As opposed to most texts on constructive type theory which are very syntactically inclined in the current book the use of type-theoretic language is much more informal which is in accordance with the informal way set theory is used in mathematics.""",,"- The abstract highlights the book's focus on constructive logic and type theory, which is a departure from traditional foundations based on classical logic and set theory. This suggests a novel approach to understanding mathematical principles.
 - The use of propositions-as-types and the view of proofs as functional programs is a theoretical advancement that bridges logic and computation, potentially impacting programming language design.
 - The discussion of type-theoretic universes as a framework for capturing the essence of the axiom of Replacement is a theoretical contribution that offers a new perspective on foundational issues.
 - The abstract mentions the use of categorical structures for general and concise formulations, which is a theoretical advancement in providing a mathematical underpinning.
 - The informal use of type-theoretic language is a novelty compared to other texts on constructive type theory, which are often syntactically inclined."
Representing Object Identity in a Pure Functional Language,A. Ohori,10.1007/3-540-53507-1_69,https://doi.org/10.1007/3-540-53507-1_69,International Conference on Database Theory,25,1990,"1. Primitive Name: Object Identity
  Definition: Captures mutability, sharing, and cyclic structures in object-oriented databases.
  Orthogonality Score: Not discussed
 2. Primitive Name: References
  Definition: Implemented in Standard ML to capture properties of object identity.
  Orthogonality Score: Not discussed
 3. Primitive Name: Monads
  Definition: Used to interpret impure higher-order functional languages in a typed pure functional language.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory and category theory
 - Specific mathematical properties guaranteed: Precise semantics for primitive operations, preservation of data structure properties
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Mathematical model for object identity in typed pure functional languages.
 - Interaction models between paradigms: Interaction between set data types and object identity.
 - Constraints or challenges in paradigm integration: Lack of precise semantics for object identity.
 - Novel translation or embedding techniques: Interpretation of impure higher-order functional language with references in typed pure functional language using Moggi's result on monads.","- Definition of ""concept"" used: Object identity
 - Mechanisms for representing generic abstractions: References in Standard ML, interpretation using monads
 - Minimal type requirements identified: Not explicitly mentioned
 - Static checking or optimization strategies: Not explicitly mentioned","- Establishment of a mathematical model for object identity in typed pure functional languages.
 - Use of references as implemented in Standard ML to capture object identity properties.
 - Method for interpreting impure higher-order functional languages with references in typed pure functional languages using Moggi's result on monads.
 - Investigation of interaction between set data types and object identity.
 - Integration of object identity with existing data models within a type system.
 - Uniform integration of object identity and a generalized relational model in a programming language.","- ""One of the central concepts in the field of object-oriented databases is object identity, which nicely captures mutability, sharing and cyclic structures.""
  - ""This paper attempts to establish a mathematical model for object identity in a framework of typed pure functional languages.""
  - ""We argue that the properties of object identity are accurately captured by references as they are implemented in Standard ML.""
  - ""We then present a method to interpret an impure higher-order functional language with references in a typed pure functional language using Moggi's recent result on the categorical structure of monads.""
  - ""This establishes a precise semantics to the primitive operations for references and allows us to analyze various property of object identity.""
  - ""We investigate the interaction between set data types and object identity.""
  - ""Since the interpretation is shown to preserve all the properties of the existing data structures for databases, it enables us to integrate object identity with various existing data models within a type system of a programming language.""",,"- The abstract discusses the concept of ""object identity"" as a central concept in object-oriented databases, which captures mutability, sharing, and cyclic structures. This suggests that object identity is a key conceptual primitive.
 - The paper attempts to establish a mathematical model for object identity, indicating that object identity is a defined primitive within the context of the study.
 - The abstract mentions that the properties of object identity are captured by references as implemented in Standard ML, suggesting that references are a conceptual primitive related to object identity.
 - The use of Moggi's result on monads to interpret impure functional languages in a typed pure functional language implies that monads are another conceptual primitive used in the study.
 - The abstract does not provide explicit definitions for these primitives beyond their roles in capturing object identity and integrating with data models, but it does imply their importance in the theoretical framework.","- ""This paper attempts to establish a mathematical model for object identity in a framework of typed pure functional languages.""
  - ""We investigate the interaction between set data types and object identity.""
  - ""We then present a method to interpret an impure higher-order functional language with references in a typed pure functional language using Moggi's recent result on the categorical structure of monads.""
  - ""Since the interpretation is shown to preserve all the properties of the existing data structures for databases, it enables us to integrate object identity with various existing data models within a type system of a programming language.""
  - ""This establishes a precise semantics to the primitive operations for references and allows us to analyze various property of object identity.""",,"- The abstract mentions the use of a ""framework of typed pure functional languages,"" which suggests that the mathematical framework is based on type theory.
 - The reference to ""Moggi's recent result on the categorical structure of monads"" indicates that category theory is also involved in the framework, as monads are a concept from category theory.
 - The abstract discusses the establishment of a ""precise semantics to the primitive operations for references,"" which implies that the framework provides a formal verification of these operations.
 - The mention of ""preserving all the properties of the existing data structures for databases"" suggests that the framework guarantees certain properties related to data integrity and consistency.
 - The abstract does not explicitly mention specific proof techniques or limitations of the framework, but it does imply a focus on formal verification and integration with existing data models.","- ""This seems to be a major obstacle to achieve a clean integration of object-oriented databases and other paradigms of database programming in a modern type system of a programming language.""
  - ""This paper attempts to establish a mathematical model for object identity in a framework of typed pure functional languages.""
  - ""We then present a method to interpret an impure higher-order functional language with references in a typed pure functional language using Moggi's recent result on the categorical structure of monads.""
  - ""This establishes a precise semantics to the primitive operations for references and allows us to analyze various property of object identity.""
  - ""We investigate the interaction between set data types and object identity.""
  - ""it enables us to integrate object identity with various existing data models within a type system of a programming language.""
  - ""We show that object identity and a generalized relational model can be uniformly integrated in a programming language.""",,"- The abstract discusses the integration of object-oriented databases with other paradigms of database programming, indicating a focus on integrating different programming paradigms.
 - The study proposes a mathematical model for object identity in a framework of typed pure functional languages, which is a specific integration mechanism.
 - The method of interpreting an impure higher-order functional language with references in a typed pure functional language using Moggi's result on monads is a novel translation technique.
 - The interaction between set data types and object identity is an example of an interaction model between paradigms.
 - The integration of object identity with existing data models within a type system is a theoretical integration strategy.
 - The abstract mentions the challenge of achieving a clean integration due to the lack of precise semantics for object identity, which is a constraint in paradigm integration.
 - The study shows that object identity and a generalized relational model can be uniformly integrated, which is a comparative analysis section indicating successful integration.","- ""This paper attempts to establish a mathematical model for object identity in a framework of typed pure functional languages.""
  - ""We argue that the properties of object identity are accurately captured by references as they are implemented in Standard ML.""
  - ""We then present a method to interpret an impure higher-order functional language with references in a typed pure functional language using Moggi's recent result on the categorical structure of monads.""
  - ""This establishes a precise semantics to the primitive operations for references and allows us to analyze various property of object identity.""
  - ""We investigate the interaction between set data types and object identity.""
  - ""it enables us to integrate object identity with various existing data models within a type system of a programming language.""
  - ""We show that object identity and a generalized relational model can be uniformly integrated in a programming language.""",,"- The abstract discusses the establishment of a mathematical model for object identity in a typed pure functional language, which suggests a focus on conceptual abstraction related to object identity.
 - The use of references in Standard ML is highlighted as a mechanism for capturing object identity properties, which implies a form of abstraction.
 - The interpretation of an impure language in a typed pure functional language using monads suggests a mechanism for representing generic abstractions, as monads are often used for such purposes.
 - The integration of object identity with existing data models within a type system indicates a form of generic programming methodology, as it involves applying object identity concepts across different data models.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on type systems and integration with existing data models implies some level of type checking.
 - Overall, while the abstract does not explicitly use the term ""generic programming,"" it discusses mechanisms for representing generic abstractions and integrating concepts across different data models, which aligns with generic programming principles.","- ""This paper attempts to establish a mathematical model for object identity in a framework of typed pure functional languages.""
  - ""We argue that the properties of object identity are accurately captured by references as they are implemented in Standard ML.""
  - ""We then present a method to interpret an impure higher-order functional language with references in a typed pure functional language using Moggi's recent result on the categorical structure of monads.""
  - ""This establishes a precise semantics to the primitive operations for references and allows us to analyze various property of object identity.""
  - ""We investigate the interaction between set data types and object identity.""
  - ""it enables us to integrate object identity with various existing data models within a type system of a programming language.""
  - ""We show that object identity and a generalized relational model can be uniformly integrated in a programming language.""",,"- The abstract mentions the establishment of a ""mathematical model for object identity in a framework of typed pure functional languages,"" which is a novel theoretical contribution as it provides a precise framework for understanding object identity.
 - The use of references as implemented in Standard ML to capture object identity properties is a key insight, as it provides a concrete mechanism for representing object identity.
 - The method for interpreting an impure higher-order functional language with references in a typed pure functional language using Moggi's result on monads is a theoretical advancement, as it provides a way to integrate object identity into functional programming languages.
 - The investigation of the interaction between set data types and object identity is a novel contribution, as it explores how object identity can be integrated with existing data models.
 - The integration of object identity with various existing data models within a type system is a significant theoretical contribution, as it enables a unified approach to programming language design.
 - The uniform integration of object identity and a generalized relational model is a theoretical advancement, as it shows how different paradigms can be combined in a programming language."
An Inherently-Typed Formalization for Featherweight Java,"Samuel da Silva Feitosa, A. S. Mena, R. Ribeiro, A. R. D. Bois",10.1145/3355378.3355385,https://doi.org/10.1145/3355378.3355385,Brazilian Symposium on Programming Languages,1,2019,Not specified (the abstract does not mention specific conceptual primitives),"- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Type safety
 - Proof techniques used: Type checking by the host language
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of an inherently-typed approach to formalize Featherweight Java.
 - Theoretical advancements: Ensuring interpreter correctness by construction using dependent types in Agda and Coq, enhancing type safety and reducing repetitive proofs.
 - Potential implications: Improved type safety and reduced errors in programming language design through inherent typing.","- ""Featherweight Java is one of the most popular calculi which specify object-oriented programming features.""
  - ""Using this approach, the interpreter is correct by construction, since the type checker of the host language is responsible for verifying type safety, thus avoiding repetitions of proofs and error checking.""
  - ""In this paper we explore an inherently-typed approach to formalize Featherweight Java, implementing the static and dynamic semantics in Agda using dependent types, and then replicating it in Coq (the latter using the Equations plug-in).""",,"- The abstract discusses the formalization of Featherweight Java, which is a calculus for object-oriented programming features. However, it does not explicitly mention any conceptual primitives defined by the study.
 - The focus of the abstract is on the methodological approach of using an inherently-typed formalization and implementing it in Agda and Coq, rather than on defining specific conceptual primitives.
 - The abstract does not provide any specific names or definitions of conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""the interpreter is correct by construction, since the type checker of the host language is responsible for verifying type safety, thus avoiding repetitions of proofs and error checking.""
  - ""an inherently-typed approach to formalize Featherweight Java,""
  - ""implementing the static and dynamic semantics in Agda using dependent types,""
  - ""replicating it in Coq (the latter using the Equations plug-in).""",,"- The abstract mentions an ""inherently-typed approach,"" which suggests the use of type theory as the mathematical framework.
 - The implementation in Agda using ""dependent types"" further supports the use of type theory, as dependent types are a key feature of type theory.
 - The replication in Coq with the Equations plug-in indicates the use of another proof assistant, which is also based on type theory.
 - The mention of ""the interpreter is correct by construction"" implies that the framework guarantees type safety, which is a specific mathematical property.
 - The use of type checkers to verify type safety suggests a proof technique that relies on the host language's type system to ensure correctness.
 - There is no explicit mention of limitations or constraints of the framework in the abstract.","- ""Using this approach, the interpreter is correct by construction, since the type checker of the host language is responsible for verifying type safety, thus avoiding repetitions of proofs and error checking.""
  - ""In this paper we explore an inherently-typed approach to formalize Featherweight Java, implementing the static and dynamic semantics in Agda using dependent types, and then replicating it in Coq (the latter using the Equations plug-in).""
  - ""It has been used as the basis for investigating novel language functionalities, as well as to specify and understand the formal properties of existing features for languages in this paradigm.""
  - ""Featherweight Java is one of the most popular calculi which specify object-oriented programming features.""",,"- The abstract discusses Featherweight Java, which is a calculus for object-oriented programming features. This suggests a focus on object-oriented programming rather than integration of multiple paradigms.
 - The paper explores an inherently-typed approach to formalize Featherweight Java, which is about formalizing a specific paradigm rather than integrating different paradigms.
 - The abstract mentions implementing semantics in Agda and Coq, which are formal verification tools, but this is about formalizing Featherweight Java rather than integrating different programming paradigms.
 - There is no mention of specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques related to integrating different programming paradigms.","- ""Featherweight Java is one of the most popular calculi which specify object-oriented programming features.""
  - ""Using this approach, the interpreter is correct by construction, since the type checker of the host language is responsible for verifying type safety, thus avoiding repetitions of proofs and error checking.""
  - ""In this paper we explore an inherently-typed approach to formalize Featherweight Java, implementing the static and dynamic semantics in Agda using dependent types, and then replicating it in Coq (the latter using the Equations plug-in).""",,"- The abstract discusses the formalization of Featherweight Java using an inherently-typed approach, which involves implementing static and dynamic semantics in Agda and Coq. This suggests a focus on type systems and formal verification rather than generic programming.
 - The mention of ""dependent types"" in Agda and the use of the Equations plug-in in Coq indicates a focus on type systems and formal verification, but does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not provide specific details on generic programming methodology, type system discussions related to genericity, or abstraction mechanism explanations that would indicate a focus on generic programming.
 - The focus on type safety and verification suggests a strong emphasis on type systems, but this does not necessarily equate to a focus on generic programming or abstraction mechanisms.","- ""In this paper we explore an inherently-typed approach to formalize Featherweight Java, implementing the static and dynamic semantics in Agda using dependent types, and then replicating it in Coq (the latter using the Equations plug-in).""
  - ""However, when considering mechanized formalization, it is hard to find an implementation for languages with complex structures and binding mechanisms as Featherweight Java.""
  - ""Featherweight Java is one of the most popular calculi which specify object-oriented programming features.""
  - ""Using this approach, the interpreter is correct by construction, since the type checker of the host language is responsible for verifying type safety, thus avoiding repetitions of proofs and error checking.""",,"- The abstract mentions that Featherweight Java is a popular calculus for object-oriented programming features, indicating its significance in the field.
 - It highlights the challenge of mechanized formalization for languages like Featherweight Java due to their complex structures and binding mechanisms. This suggests a gap in existing approaches.
 - The paper introduces an ""inherently-typed approach"" to formalize Featherweight Java, which is a novel insight as it addresses the challenge of complex structures and binding mechanisms.
 - The use of dependent types in Agda and replication in Coq with the Equations plug-in is a theoretical advancement, as it ensures the interpreter is correct by construction, enhancing type safety and reducing the need for repetitive proofs.
 - The potential implications for programming language design include improved type safety and reduced errors, as the type checker verifies safety, which could influence future language design by emphasizing inherent typing."
"Rewriting calculi, higher-order reductions and patterns: introduction","Horatiu Cirstea, M. Fernández",10.1017/S0960129508006737,https://doi.org/10.1017/S0960129508006737,Mathematical Structures in Computer Science,0,2008,Not specified (the abstract does not explicitly define or list specific conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),"- Specific integration mechanisms proposed: Enriching first-order rewriting with higher-order capabilities or adding algebraic features to the λ-calculus.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Integration of first-order and higher-order paradigms.
 - Theoretical advancements: Development of new computation models and logical frameworks by enriching first-order rewriting with higher-order capabilities and adding algebraic features to the λ-calculus.
 - Potential implications: Addressing challenges in declarative programming languages and proof environments.","- ""It has led to the development of new computation models and new logical frameworks, which have been obtained by enriching first-order rewriting with higher-order capabilities or by adding algebraic features to the λ-calculus.""
  - ""The integration of first-order and higher-order paradigms has been one of the main challenges in the design of both declarative programming languages and proof environments.""",,"- The abstract discusses the integration of first-order and higher-order paradigms, which suggests a focus on combining different programming paradigms.
 - It mentions the development of new computation models and logical frameworks, indicating a theoretical framework for reconstructing programming paradigms.
 - The abstract refers to enriching first-order rewriting with higher-order capabilities and adding algebraic features to the λ-calculus, which implies conceptual primitives related to these processes.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It provides a general overview of the integration and development of new models rather than detailing specific primitives.","- ""It has led to the development of new computation models and new logical frameworks, which have been obtained by enriching first-order rewriting with higher-order capabilities or by adding algebraic features to the λ-calculus.""
  - ""The integration of first-order and higher-order paradigms has been one of the main challenges in the design of both declarative programming languages and proof environments.""",,"- The abstract discusses the integration of first-order and higher-order paradigms, which suggests a focus on combining different mathematical frameworks.
 - It mentions the development of new computation models and logical frameworks, indicating a focus on theoretical foundations.
 - The abstract refers to enriching first-order rewriting with higher-order capabilities and adding algebraic features to the λ-calculus, which implies a type of mathematical framework involving rewriting calculi and possibly type theory.
 - However, the abstract does not specify the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""It has led to the development of new computation models and new logical frameworks, which have been obtained by enriching first-order rewriting with higher-order capabilities or by adding algebraic features to the λ-calculus.""
  - ""The integration of first-order and higher-order paradigms has been one of the main challenges in the design of both declarative programming languages and proof environments.""",,"- The abstract mentions the integration of first-order and higher-order paradigms as a challenge, indicating that the study addresses this integration.
 - It describes the development of new computation models and logical frameworks as a result of this integration, suggesting a theoretical integration strategy.
 - The abstract specifies that this integration involves enriching first-order rewriting with higher-order capabilities or adding algebraic features to the λ-calculus, which can be seen as specific integration mechanisms.
 - However, the abstract does not provide detailed interaction models between paradigms, constraints, or novel translation techniques.
 - The focus is on the general approach of integrating first-order and higher-order paradigms through new computation models and logical frameworks.","- ""The integration of first-order and higher-order paradigms has been one of the main challenges in the design of both declarative programming languages and proof environments.""
  - ""It has led to the development of new computation models and new logical frameworks, which have been obtained by enriching first-order rewriting with higher-order capabilities or by adding algebraic features to the λ-calculus.""",,"- The abstract discusses the integration of first-order and higher-order paradigms, which is related to generic programming and abstraction mechanisms.
 - It mentions the development of new computation models and logical frameworks, which could imply mechanisms for representing generic abstractions.
 - However, the abstract does not explicitly mention generic programming, type requirements, static checking, or optimization strategies.
 - The focus seems to be on the integration of paradigms rather than specific mechanisms for genericity and abstraction.","- ""The integration of first-order and higher-order paradigms has been one of the main challenges in the design of both declarative programming languages and proof environments.""
  - ""It has led to the development of new computation models and new logical frameworks, which have been obtained by enriching first-order rewriting with higher-order capabilities or by adding algebraic features to the λ-calculus.""",,"- The abstract discusses the integration of first-order and higher-order paradigms, which is a significant challenge in programming language design and proof environments. This integration is a key theoretical contribution as it addresses a long-standing challenge.
 - The development of new computation models and logical frameworks is highlighted as a result of this integration. This indicates a theoretical advancement beyond existing approaches by enriching first-order rewriting and adding algebraic features to the λ-calculus.
 - The abstract implies that these developments have potential implications for programming language design, as they address challenges in declarative programming languages and proof environments."
Reening Multiset Transformers,"C. Hankin, Daniel Le M etayery, David Sandsz",-,-,-,0,2008,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework),"- Specific integration mechanisms proposed: Generic pipelining transformation to convert sequential compositions into parallel ones.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Generic pipelining transformation.","Generic programming not extensively addressed (the abstract mentions a generic transformation but does not provide detailed information on generic programming methodology, type systems, or abstraction mechanisms)","- Key novel insights: Introduction of Gamma as a minimal language based on local multiset rewriting with a chemical reaction metaphor.
 - Theoretical advancements: Study of reenement for parallel and sequential composition operators, derivation of programming laws, and development of a generic pipelining transformation.
 - Potential implications: Enables transformation of sequential compositions into parallel ones, improving program efficiency and scalability.","- ""The calculus thus obtained is applied in the development of a generic \pipelining""""
  - ""The virtues of this paradigm in terms of systematic program construction and design of parallel programs have been argued in previous papers.""
  - ""In this paper, we study a notion of reenement for programs involving parallel and sequential composition operators, and derive a number of programming laws.""
  - ""Gamma is a minimal language based on local multiset rewriting with an elegant chemical reaction metaphor.""",,"- The abstract mentions ""Gamma"" as a ""minimal language based on local multiset rewriting with an elegant chemical reaction metaphor."" This suggests that Gamma is a conceptual framework or paradigm rather than a specific set of primitives.
 - The abstract discusses the study of ""reenement for programs involving parallel and sequential composition operators,"" which implies that these operators are part of the conceptual framework, but it does not explicitly define them as primitives.
 - The mention of ""programming laws"" and a ""generic \pipelining"" transformation suggests that these are outcomes or applications of the Gamma paradigm rather than primitives themselves.
 - The abstract does not provide explicit definitions or names for conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""The calculus thus obtained is applied in the development of a generic \pipelining""""
  - ""The virtues of this paradigm in terms of systematic program construction and design of parallel programs have been argued in previous papers.""
  - ""In this paper, we study a notion of reenement for programs involving parallel and sequential composition operators, and derive a number of programming laws.""
  - ""Gamma is a minimal language based on local multiset rewriting with an elegant chemical reaction metaphor.""",,"- The abstract mentions that Gamma is based on ""local multiset rewriting,"" which suggests a mathematical framework related to rewriting systems. However, it does not specify the type of mathematical framework (e.g., type theory, category theory) explicitly.
 - The mention of ""programming laws"" and ""calculus"" implies some form of formal system, but again, the specific mathematical framework is not detailed.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations/constraints of the framework in the abstract.
 - The abstract does not provide explicit details about the theoretical foundations, proof methodology, or formal verification discussions related to the mathematical framework.","- ""The calculus thus obtained is applied in the development of a generic \pipelining""""
  - ""we study a notion of reenement for programs involving parallel and sequential composition operators, and derive a number of programming laws.""
  - ""Gamma can also be seen as a notation for coordinating independent programs in a larger application.""
  - ""Gamma is a minimal language based on local multiset rewriting with an elegant chemical reaction metaphor.""",,"- The abstract discusses Gamma as a language based on local multiset rewriting, which is a programming paradigm. It is described as having an ""elegant chemical reaction metaphor,"" suggesting a unique approach to program construction and design.
 - Gamma is noted for coordinating independent programs, which implies an integration mechanism where different programs can be managed within a larger application.
 - The study focuses on ""reenement"" for parallel and sequential composition operators, which suggests a theoretical integration strategy for combining different programming paradigms.
 - The development of a ""generic pipelining transformation"" indicates a specific integration mechanism that allows for the conversion of sequential compositions into parallel ones, which is a novel translation technique.
 - However, the abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration.","- ""The calculus thus obtained is applied in the development of a generic \pipelining""""
  - ""Gamma can also be seen as a notation for coordinating independent programs in a larger application.""
  - ""The virtues of this paradigm in terms of systematic program construction and design of parallel programs have been argued in previous papers.""
  - ""In this paper, we study a notion of reenement for programs involving parallel and sequential composition operators, and derive a number of programming laws.""
  - ""Gamma is a minimal language based on local multiset rewriting with an elegant chemical reaction metaphor.""",,"- The abstract mentions that Gamma is a ""minimal language based on local multiset rewriting,"" which suggests a focus on simplicity and possibly genericity in its design.
 - The mention of ""systematic program construction and design of parallel programs"" implies a structured approach to programming, which could involve generic programming principles.
 - The abstract discusses ""reenement for programs involving parallel and sequential composition operators,"" which might relate to abstraction mechanisms by allowing for the transformation of program structures.
 - The development of a ""generic \pipelining"" transformation suggests a focus on generic programming, as it enables the transformation of sequential compositions into parallel ones, which is a form of abstraction.
 - However, the abstract does not explicitly mention ""generic programming methodology,"" ""type system discussions,"" or ""abstraction mechanism explanations,"" which are key areas for detailed analysis of genericity and abstraction mechanisms.","- ""Gamma is a minimal language based on local multiset rewriting with an elegant chemical reaction metaphor.""
  - ""The calculus thus obtained is applied in the development of a generic \pipelining""""
  - ""In this paper, we study a notion of reenement for programs involving parallel and sequential composition operators, and derive a number of programming laws.""
  - ""The virtues of this paradigm in terms of systematic program construction and design of parallel programs have been argued in previous papers.""",,"- The abstract introduces Gamma as a minimal language based on local multiset rewriting, which suggests a novel approach to programming language design by leveraging a chemical reaction metaphor. This is a key novel insight as it presents a unique paradigm for systematic program construction and parallel program design.
 - The study of reenement for programs involving parallel and sequential composition operators is a theoretical advancement. This concept is new and contributes to the field by providing a framework for transforming sequential compositions into parallel ones, which is a significant theoretical contribution.
 - The derivation of programming laws and the application of these laws to develop a generic pipelining transformation are theoretical advancements. These laws and the transformation enable the reenement of sequential compositions into parallel ones, which has potential implications for improving the efficiency and scalability of programs.
 - The abstract does not explicitly mention comparative analysis with existing work, but the introduction of a new paradigm and the development of programming laws suggest that these are advancements beyond existing approaches."
"effort to develop foundations for prototype-based languages or to define a more general model , which at the same time represents both class-based and prototype-based languages","Verónica Argañaraz, G. Baum, C. Pons, María José Presso, M. Prieto, Natalia Romero",-,-,-,0,2012,"1. Primitive Name: Objects
  Definition: Basic entities in the model
  Orthogonality Score: High
 2. Primitive Name: Messages
  Definition: Means of communication between objects
  Orthogonality Score: High
 3. Primitive Name: Sharing Relationship in Object Creation
  Definition: Expressing how objects share behavior at creation
  Orthogonality Score: High
 4. Primitive Name: Changing Sharing Relationship
  Definition: Ability to modify the sharing relationship between objects
  Orthogonality Score: High
 5. Primitive Name: Referencing Donor Object
  Definition: Ability to reference the object from which behavior is borrowed
  Orthogonality Score: High","Not specified (the abstract mentions the use of the impς-calculus but does not provide details on the type of mathematical framework, specific properties guaranteed, proof techniques, or limitations)","- Specific integration mechanisms proposed: Delegation between concrete objects
 - Interaction models between paradigms: Representation of all usual constructs using only objects and messages
 - Constraints or challenges in paradigm integration: Not explicitly mentioned
 - Novel translation or embedding techniques: Translation of sharing constructs from prototype-based language into formal calculus",Generic programming not extensively addressed,"- Key novel insights: Constructing sharing schemes using a basic model with just objects and messages; expressing delegation between concrete objects in the calculus.
 - Theoretical advancements: Representing every sharing scheme possible in a prototype environment using per object delegation; defining sharing constructs for an object-based language and translating them into a formal calculus.
 - Potential implications: Developing foundations for prototype-based languages; defining a more general model that represents both class-based and prototype-based languages; enhancing the theoretical framework for object-oriented languages.","- ""There are primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""",,"- The abstract discusses the idea of constructing sharing schemes using a basic model with ""just objects and messages."" This suggests that these are fundamental primitives in their approach.
 - The mention of ""sharing constructs for an object based (prototypes) high level language"" indicates that these constructs are part of the conceptual primitives they propose.
 - The specific primitives mentioned are related to expressing the sharing relationship in object creation, changing that relationship, and referencing the donor of an object. These are explicitly defined as part of their contribution.
 - The level of abstraction is high since these primitives are intended to be foundational for both class-based and prototype-based languages.
 - Orthogonality is implied as these primitives are designed to be basic and fundamental, suggesting they are orthogonal to each other in their functionality.","- ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in Object-Oriented languages can be built using only objects and messages.""
  - ""We have built per object delegation using the calculus.""
  - ""Abadi & Cardelli describe how to build the concepts of class based languages in their formalism, but they don't represent the ability to share behavior by delegation among concrete objects present in prototype based languages.""
  - ""Martin Abadi & Luca Cardelli have defined a formal calculus of objects, the impς-calculus, which consists just of objects, object communication and object update [Abadi96].""",,"- The abstract mentions the use of a ""formal calculus of objects"" known as the ""impς-calculus,"" which is a mathematical framework developed by Abadi and Cardelli.
 - This framework is described as consisting of ""objects, object communication and object update,"" indicating its focus on object-oriented concepts.
 - The abstract does not specify the type of mathematical framework (e.g., type theory, category theory) explicitly, nor does it detail specific mathematical properties guaranteed or proof techniques used.
 - The focus is on the application of this calculus to represent delegation and sharing schemes in object-oriented languages, rather than on the theoretical foundations or proof methodology.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""Sharing of behavior is one of the most important features in the Object-Oriented paradigm.""
  - ""The two classical organisations of sharing are classes and prototypes, raising two different models and two families of object oriented languages.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""we show how to express delegation between concrete objects in the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in OO can be built using only objects and messages.""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""There are primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object.""",,"- The abstract discusses the integration of class-based and prototype-based languages within the Object-Oriented paradigm.
 - The authors propose a basic model using just objects and messages to construct sharing schemes, which is a theoretical integration strategy.
 - They provide a mechanism for expressing delegation between concrete objects, which is a specific integration mechanism.
 - The abstract mentions the translation of sharing constructs from a prototype-based language into a formal calculus, which is a novel translation technique.
 - The authors aim to represent all usual constructs found in Object-Oriented languages using only objects and messages, indicating an interaction model between paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does discuss the theoretical integration strategies and novel translation techniques.","- ""Sharing of behavior is one of the most important features in the Object-Oriented paradigm.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""Abadi and Cardelli have defined a calculus of objects which represents the basic elements.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment,""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""There are primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object.""",,"- The abstract focuses on the sharing of behavior and delegation between objects, which are fundamental concepts in object-oriented programming.
 - The study uses a calculus of objects defined by Abadi and Cardelli, which is a formal system for representing object-oriented concepts.
 - The abstract discusses the representation of delegation between concrete objects, which is a mechanism for generic abstraction.
 - The study defines sharing constructs for an object-based language and translates them into a formal calculus, indicating a focus on abstraction mechanisms.
 - However, the abstract does not explicitly mention generic programming methodology, type system discussions, or minimal type requirements, which are key aspects of genericity and abstraction mechanisms.
 - The focus is more on the representation of sharing schemes and delegation rather than generic programming or abstraction mechanisms in the context of genericity.","- ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in OO can be built using only objects and messages.""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in Object-Oriented languages can be built using only objects and messages.""
  - ""Abadi & Cardelli describe how to build the concepts of class based languages in their formalism, but they don't represent the ability to share behavior by delegation among concrete objects present in prototype based languages.""
  - ""We have built per object delegation using the calculus.""",,"- The study claims to construct sharing schemes using a basic model with just objects and messages, which is a novel insight as it simplifies the representation of object-oriented concepts.
 - The work shows how to express delegation between concrete objects in the calculus, which is a theoretical advancement beyond existing approaches that primarily focus on class-based languages.
 - The key contribution is the ability to represent every sharing scheme possible in a prototype environment using per object delegation, which completes the theoretical framework for object-oriented languages.
 - The study defines sharing constructs for an object-based language and translates them into a formal calculus, which is a theoretical advancement in representing prototype-based languages.
 - The work addresses a gap in existing research by developing foundations for prototype-based languages and defining a more general model that represents both class-based and prototype-based languages.
 - The study builds upon Abadi & Cardelli's work by adding the ability to share behavior by delegation among concrete objects, which is a significant theoretical contribution."
What is Generic Programming ?,"G. D. Reis, Jaakko Järvi",-,-,-,4,2005,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework),No specific integration approach described,"- Definition of ""concept"" used: Generic programming is equated to language mechanisms for type-safe polymorphic containers and designing reusable algorithms.
 - Mechanisms for representing generic abstractions: Type-safe polymorphic containers, polytypic and type-indexed programming.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: Analysis of core mathematical notions at the foundations of generic programming.
 - Theoretical advancements: Relating methodologies from imperative and functional programming communities to provide a unified understanding.
 - Potential implications: Establishing a base for common understanding of techniques for generic software components, which could inform programming language design.","- ""The last two decades have seen an ever-growing interest in generic programming.""
  - ""In the simplest view generic programming is equated to a set of language mechanisms for implementing type-safe polymorphic containers, such as List<T> in Java.""
  - ""The notion of generic programming that motivated the design of the Standard Template Library (STL) advocates a broader definition: a programming paradigm for designing and developing reusable and efficient collections of algorithms.""
  - ""The functional programming community uses the term as a synonym for polytypic and type-indexed programming, which involves designing functions that operate on data-types having certain algebraic structures.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""",,"- The abstract discusses various definitions and perspectives on generic programming but does not explicitly define conceptual primitives.
 - It mentions different views on generic programming, such as type-safe polymorphic containers and broader definitions involving reusable algorithms, but these are not explicitly labeled as conceptual primitives.
 - The abstract focuses on analyzing mathematical notions and relating methodologies, but it does not specify any particular conceptual primitives.
 - The paper aims to provide a base for understanding techniques, but again, no specific primitives are mentioned.","- ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""
  - ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""",,"- The abstract mentions ""core mathematical notions"" and ""foundations of rational approaches to generic programming,"" which suggests that the paper discusses mathematical frameworks. However, it does not specify the type of mathematical framework used.
 - The abstract does not provide details about specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus on ""analyzing core mathematical notions"" and providing a ""base for common understanding"" implies a theoretical approach, but the abstract lacks explicit details about the mathematical framework.","- ""The last two decades have seen an ever-growing interest in generic programming.""
  - ""As for most programming paradigms, there are several definitions of generic programming in use.""
  - ""The notion of generic programming that motivated the design of the Standard Template Library (STL) advocates a broader definition: a programming paradigm for designing and developing reusable and efficient collections of algorithms.""
  - ""The functional programming community uses the term as a synonym for polytypic and type-indexed programming, which involves designing functions that operate on data-types having certain algebraic structures.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""",,"- The abstract discusses the concept of generic programming and its various definitions across different programming paradigms.
 - It mentions the broader definition advocated by the Standard Template Library (STL), which focuses on designing reusable and efficient collections of algorithms.
 - The abstract also references the functional programming community's use of generic programming as a synonym for polytypic and type-indexed programming.
 - The paper aims to analyze core mathematical notions and relate methodologies from imperative and functional programming communities, indicating a focus on understanding and integrating different programming paradigms.
 - However, the abstract does not explicitly describe specific integration mechanisms, interaction models, constraints, or novel translation techniques.
 - The focus is on providing a common understanding of techniques rather than detailing specific integration strategies or challenges.","- ""The last two decades have seen an ever-growing interest in generic programming.""
  - ""In the simplest view generic programming is equated to a set of language mechanisms for implementing type-safe polymorphic containers, such as List<T> in Java.""
  - ""The notion of generic programming that motivated the design of the Standard Template Library (STL) advocates a broader definition: a programming paradigm for designing and developing reusable and efficient collections of algorithms.""
  - ""The functional programming community uses the term as a synonym for polytypic and type-indexed programming, which involves designing functions that operate on data-types having certain algebraic structures.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""",,"- The abstract discusses various definitions of generic programming, indicating a focus on understanding the concept of genericity.
 - The mention of ""type-safe polymorphic containers"" suggests a mechanism for representing generic abstractions, as it involves creating containers that can work with multiple types.
 - The reference to the Standard Template Library (STL) implies a broader definition of generic programming that includes designing reusable and efficient algorithms, which is a form of abstraction mechanism.
 - The functional programming community's use of ""polytypic and type-indexed programming"" indicates a focus on designing functions that operate on data-types with specific algebraic structures, which is a form of abstraction.
 - The abstract aims to analyze core mathematical notions and provide a common understanding of techniques for generic software components, which suggests an exploration of minimal type requirements and possibly static checking or optimization strategies.
 - However, the abstract does not explicitly mention minimal type requirements or specific static checking or optimization strategies, so these aspects are not directly addressed.","- ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""",,"- The abstract mentions that the paper analyzes ""core mathematical notions"" at the foundations of generic programming, which suggests a theoretical contribution by exploring the mathematical underpinnings of the field.
 - The paper relates methodologies from both imperative and functional programming communities, indicating a theoretical advancement by integrating or comparing different approaches.
 - The abstract states that the paper provides a ""base for common understanding"" of techniques for generic software components, which implies a theoretical contribution by establishing a foundational framework for understanding these techniques.
 - The focus on providing a base for common understanding and relating methodologies suggests a potential implication for programming language design by offering a more unified or comprehensive approach to generic programming."
"Concepts, Techniques, and Models of Computer Programming","P. V. Roy, Seif Haridi",-,-,-,477,2004,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Uniform framework using kernel languages
 - Interaction models between paradigms: Not explicitly mentioned
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Key novel insights: Presentation of all major programming paradigms in a uniform framework, use of kernel languages to simplify complex concepts.
 - Theoretical advancements: Definition of kernel languages in terms of a simple abstract machine, progressive introduction of kernel languages to show deep relationships between models.
 - Potential implications for programming language design: Understanding the underlying unity of programming, simplification of complex concepts through kernel languages.","- ""The book presents all major programming paradigms in a uniform framework that shows their deep relationships and how and where to use them together.""
  - ""Each model has its own set of techniques and each is included on the basis of its usefulness in practice.""
  - ""The general models include declarative programming, declarative concurrency, message-passing concurrency, explicit state, object-oriented programming, shared-state concurrency, and relational programming.""
  - ""Specialized models include graphical user interface programming, distributed programming, and constraint programming.""
  - ""Each model is based on its kernel language -- a simple core language that consists of a small number of programmer-significant elements.""
  - ""The kernel languages are introduced progressively, adding concepts one by one, thus showing the deep relationships between different models.""
  - ""The kernel languages are defined precisely in terms of a simple abstract machine.""",,"- The abstract discusses various programming paradigms and models, but it does not explicitly define specific conceptual primitives.
 - The mention of ""kernel languages"" suggests a focus on core elements, but these are not detailed as specific primitives.
 - The abstract emphasizes the relationships between models and the use of a simple abstract machine, but it does not provide explicit definitions or lists of conceptual primitives.
 - The focus is on presenting programming paradigms in a unified framework rather than defining specific primitives.","- ""The kernel languages are defined precisely in terms of a simple abstract machine.""
  - ""The book focuses on techniques of lasting value and explains them precisely in terms of a simple abstract machine.""
  - ""this approach allows programmer and student to grasp the underlying unity of programming.""",,"- The abstract mentions the use of a ""simple abstract machine"" to explain programming techniques and define kernel languages. This suggests a focus on operational semantics rather than a specific mathematical framework like type theory or category theory.
 - There is no mention of a specific mathematical framework such as type theory or category theory in the abstract.
 - The abstract does not provide details on theoretical foundations, proof methodology, or formal verification discussions, which are typically associated with a mathematical framework.
 - The focus on a ""simple abstract machine"" does not imply a specific mathematical framework or properties guaranteed by such a framework.","- ""The book presents all major programming paradigms in a uniform framework that shows their deep relationships and how and where to use them together.""
  - ""The kernel languages are defined precisely in terms of a simple abstract machine.""
  - ""The kernel languages are introduced progressively, adding concepts one by one, thus showing the deep relationships between different models.""
  - ""Each model is based on its kernel language -- a simple core language that consists of a small number of programmer-significant elements.""
  - ""Because a wide variety of languages and programming paradigms can be modeled by a small set of closely related kernel languages, this approach allows programmer and student to grasp the underlying unity of programming.""",,"- The abstract mentions that the book presents all major programming paradigms in a ""uniform framework,"" which suggests an integration approach by showing their deep relationships and how to use them together.
 - The use of ""kernel languages"" as a core concept for each paradigm indicates a specific integration mechanism, as these languages are introduced progressively to highlight relationships between models.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in integration, nor does it discuss novel translation or embedding techniques.
 - The focus on kernel languages and their definition in terms of a simple abstract machine implies a theoretical integration strategy by providing a common basis for understanding different paradigms.","- ""The book presents all major programming paradigms in a uniform framework that shows their deep relationships and how and where to use them together.""
  - ""Each model has its own set of techniques and each is included on the basis of its usefulness in practice.""
  - ""Each model is based on its kernel language -- a simple core language that consists of a small number of programmer-significant elements.""
  - ""The kernel languages are introduced progressively, adding concepts one by one, thus showing the deep relationships between different models.""
  - ""The kernel languages are defined precisely in terms of a simple abstract machine.""
  - ""Because a wide variety of languages and programming paradigms can be modeled by a small set of closely related kernel languages, this approach allows programmer and student to grasp the underlying unity of programming.""",,"- The abstract discusses the presentation of programming paradigms in a unified framework, which suggests an emphasis on abstraction and understanding relationships between different programming models.
 - The use of ""kernel languages"" and their progressive introduction indicates a focus on core concepts and their relationships, which is a form of abstraction.
 - The abstract mentions that these kernel languages are defined in terms of a ""simple abstract machine,"" which implies a mechanism for representing generic abstractions.
 - However, there is no specific mention of generic programming methodology, type system discussions, or explicit abstraction mechanisms like static checking or optimization strategies.
 - The abstract does not provide a definition of ""concept"" used in the context of generic programming or minimal type requirements.
 - Overall, while the abstract suggests an approach to abstraction and unity in programming, it does not extensively address generic programming or provide detailed mechanisms for generic abstractions.","- ""This innovative text presents computer programming as a unified discipline in a way that is both practical and scientifically sound.""
  - ""The book presents all major programming paradigms in a uniform framework that shows their deep relationships and how and where to use them together.""
  - ""Each model is based on its kernel language -- a simple core language that consists of a small number of programmer-significant elements.""
  - ""The kernel languages are introduced progressively, adding concepts one by one, thus showing the deep relationships between different models.""
  - ""The kernel languages are defined precisely in terms of a simple abstract machine.""
  - ""Because a wide variety of languages and programming paradigms can be modeled by a small set of closely related kernel languages, this approach allows programmer and student to grasp the underlying unity of programming.""",,"- The abstract describes the book as ""innovative,"" suggesting that it offers new insights or approaches to computer programming.
 - The presentation of all major programming paradigms in a ""uniform framework"" is a novel insight, as it provides a comprehensive view of how different paradigms relate to each other.
 - The use of ""kernel languages"" and their progressive introduction is a theoretical advancement, as it simplifies complex programming concepts by focusing on core elements.
 - The definition of kernel languages in terms of a ""simple abstract machine"" is a theoretical contribution, as it provides a precise and unified way to understand different programming models.
 - The approach allows for the understanding of the ""underlying unity of programming,"" which is a key theoretical contribution, as it highlights the commonalities across different programming paradigms."
Reasoning About a Service-oriented Programming Paradigm,"C. Guidi, F. Montesi",10.4204/EPTCS.2.6,https://doi.org/10.4204/EPTCS.2.6,YR-SOC,9,2009,"1. Primitive Name: Service
  Definition: A deployed service engine whose sessions animate a given service behaviour.
  Orthogonality Score: High
 

 2. Primitive Name: Behaviour
  Definition: The description of the service activities composed in a workflow.
  Orthogonality Score: High
 

 3. Primitive Name: Session
  Definition: An executing instance of a service behaviour equipped with its own local state.
  Orthogonality Score: High
 

 4. Primitive Name: Engine
  Definition: A machinery able to manage service sessions by providing session creation, state support, message routing and session execution capabilities.
  Orthogonality Score: High
 

 5. Primitive Name: Service Description
  Definition: Provides all the necessary information for interacting with a service.
  Orthogonality Score: High
 

 6. Primitive Name: Request-Response Interaction Pattern
  Definition: Plays a fundamental role when designing a service system architecture.
  Orthogonality Score: High
 

 7. Primitive Name: Slave Service Mobility
  Definition: A design pattern where slave services are moved and embedded to the master service container.
  Orthogonality Score: High
 

 8. Primitive Name: Master Service Mobility
  Definition: A design pattern where the master service is moved and embedded into the container of the slave.
  Orthogonality Score: High
 

 9. Primitive Name: SoS (Service of Services) Pattern
  Definition: A design pattern that exploits both dynamic embedding and dynamic redirecting.
  Orthogonality Score: High","- Type of mathematical framework: Process calculus
 - Specific mathematical properties guaranteed: Correlation sets for session identification, support for state and Request-Response primitives
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Formalization of Web Services technology in a process calculus (SOCK)
 - Unique session identification mechanism in SOCK
 - Explicit state support in SOCK
 - Introduction of dynamic fault handling
 - Comprehensive framework for studying service-oriented computing issues
 - Identification of key concepts: behavior, session, engine, interface, deployment, service, container, embedding, redirecting, aggregation
 - Novel design patterns: slave service mobility, master service mobility, SoS","- ""The sum of these experiences made us aware of the fact that we were facing a new way for designing, developing and studying distributed applications: the service-oriented paradigm.""
  - ""In the following we describe the basic concepts that we have extracted and we try to show how they can be considered the foundations of the service-oriented programming paradigm.""
  - ""The first thing to address is the definition of the term service. In order to provide evidence that a serviceoriented paradigm exists we need to define what a service is, as services are the most important component of the paradigm.""
  - ""The behaviour of a service is the description of the service activities composed in a workflow.""
  - ""A service session is an executing instance of a service behaviour equipped with its own local state.""
  - ""A key element of the service-oriented programming paradigm is session identification.""
  - ""An engine is a machinery able to manage service sessions by providing session creation, state support, message routing and session execution capabilities.""
  - ""A service description provides all the necessary information for interacting with a service.""
  - ""A service is a deployed service engine whose sessions animate a given service behaviour.""
  - ""The definitions of service and service composition shown so far are the key elements of the serviceoriented programming paradigm.""
  - ""The Request-Response interaction pattern plays a fundamental role when designing a service system architecture.""
  - ""Slave service mobility and Master service mobility.""
  - ""SoS: Service of services pattern.""",,"- The paper discusses the service-oriented programming paradigm and its foundational concepts.
 - The authors define several key concepts that serve as primitives for this paradigm:
  - **Service**: Defined as ""a deployed service engine whose sessions animate a given service behaviour.""
  - **Behaviour**: Described as ""the description of the service activities composed in a workflow.""
  - **Session**: Identified as ""an executing instance of a service behaviour equipped with its own local state.""
  - **Engine**: Defined as ""a machinery able to manage service sessions by providing session creation, state support, message routing and session execution capabilities.""
  - **Service Description**: Provides ""all the necessary information for interacting with a service.""
  - **Request-Response Interaction Pattern**: Plays a ""fundamental role when designing a service system architecture.""
  - **Slave Service Mobility and Master Service Mobility**: Design patterns that are part of the paradigm.
  - **SoS (Service of Services) Pattern**: Another design pattern within the paradigm.
 - These primitives are orthogonal in that they address different aspects of the service-oriented paradigm, such as service definition, behavior, session management, and interaction patterns.
 - The level of abstraction is high, as these primitives are conceptual and foundational to the paradigm.","- ""Our work started some years ago when we began to formalize the basic mechanisms of the Web Services technology in a process calculus.""
  - ""We chose such an approach because process calculi were naturally born for describing concurrent processes, as Web Services are.""
  - ""The main difference between SCC and SOCK can befound in the session identification mechanism. In SOCK we identify sessions by means of correlation sets whereas in SCC sessions are identified by freshly generated names.""
  - ""Both state and the RequestResponse primitive made SOCK close to the technologies. This fact allowed us to reason about fault handling issues which led us to propose a new way, the dynamic handling, for managing faults""
  - ""The main difference between SOCK and COWS is the fact that SOCK explicitly supports a state whereas COWS does not.""",,"- The paper discusses the use of process calculus as the mathematical framework for formalizing service-oriented computing concepts.
 - Process calculus is used to describe concurrent processes, which are inherent in Web Services.
 - The framework is specifically designed to handle communication primitives, workflow composition, session management, and service networks.
 - The paper highlights the use of correlation sets for session identification, which is a key mathematical property guaranteed by the framework.
 - The framework also supports state and Request-Response primitives, which are crucial for fault handling and dynamic management.
 - The paper does not explicitly mention type theory or category theory, nor does it detail specific proof techniques or limitations of the framework.","- ""This paper is about a new way for programming distributed applications: the service-oriented one.""
  - ""The main difference between SCC and SOCK can befound in the session identification mechanism.""
  - ""The main difference between SOCK and COWS is the fact that SOCK explicitly supports a state whereas COWS does not.""
  - ""Both state and the RequestResponse primitive made SOCK close to the technologies.""
  - ""The JOLIE language allowed us to apply the concepts studied in SOCK in real world application development, and this raised new issues and in turn made new software design patterns to emerge.""
  - ""The sum of these experiences made us aware of the fact that we were facing a new way for designing, developing and studying distributed applications: the service-oriented paradigm.""
  - ""The definitions of service and service composition shown so far are the key elements of the serviceoriented programming paradigm.""
  - ""The Request-Response interaction pattern plays a fundamental role when designing a service system architecture.""
  - ""The main difference is that in the callback configuration the service A must be aware of the fact that it has to receive the response message in a specific port.""
  - ""In the Request-Response case, it is sufficient for A to know the functional interface of B where the RequestResponse operation is declared in order to interact with it.""
  - ""the Request-Response pattern raises interesting issues from the fault handling point of view but, for the sake of brevity, we do not discuss them here and we invite the interested reader to consult [14,24].""
  - ""It is easy to model the web client-server pattern in the service-oriented programming paradigm.""
  - ""The SoS pattern exploits both dynamic embedding and dynamic redirecting.""",,"- The paper primarily focuses on the service-oriented programming paradigm and its development through the SOCK process calculus and the JOLIE programming language.
 - It discusses the integration of different programming paradigms by comparing SOCK with other process calculi like SCC and COWS, highlighting differences in session identification and state support.
 - The paper introduces interaction models such as the Request-Response pattern and its implications for fault handling and architectural design.
 - It mentions the web client-server pattern as an example of how service-oriented programming can be applied.
 - The SoS pattern is described as a way to dynamically embed and redirect services, which can be seen as a novel technique for integrating different services.
 - However, the paper does not explicitly discuss a comprehensive integration approach for different programming paradigms beyond the service-oriented paradigm.","- ""This paper is about a new way for programming distributed applications: the service-oriented one.""
  - ""Our work started some years ago when we began to formalize the basic mechanisms of the Web Services technology in a process calculus.""
  - ""The main difference between SOCK and COWS is the fact that SOCK explicitly supports a state whereas COWS does not.""
  - ""Both state and the RequestResponse primitive made SOCK close to the technologies.""
  - ""The JOLIE language allowed us to apply the concepts studied in SOCK in real world application development, and this raised new issues and in turn made new software design patterns to emerge.""
  - ""The sum of these experiences made us aware of the fact that we were facing a new way for designing, developing and studying distributed applications: the service-oriented paradigm.""
  - ""In the following we describe the basic concepts that we have extracted and we try to show how they can be considered the foundations of the service-oriented programming paradigm.""
  - ""We agree with this definition but we argue that it is too abstract because too many things could be a service.""
  - ""The behaviour of a service is the description of the service activities composed in a workflow.""
  - ""A service description provides all the necessary information for interacting with a service.""
  - ""Service interfaces contain abstract information for performing compatibility checks between services, abstracting from low-level details such as communication data protocols and transports.""
  - ""The deployment phase is in charge of binding the service interface with network locations and protocols.""
  - ""A service is a deployed service engine whose sessions animate a given service behaviour.""",,"- The paper primarily focuses on the service-oriented programming paradigm and its theoretical foundations rather than generic programming or abstraction mechanisms.
 - The authors discuss the development of SOCK and JOLIE, which are process calculi and programming languages, respectively, but these are not explicitly related to generic programming or abstraction mechanisms.
 - The paper does not mention generic programming or abstraction mechanisms in the context of type systems or static checking.
 - The focus is on service-oriented computing, service definitions, and service composition rather than genericity or abstraction in programming.
 - The paper does not provide a definition of ""concept"" or mechanisms for representing generic abstractions, nor does it discuss minimal type requirements or static checking strategies.","- ""Our work started some years ago when we began to formalize the basic mechanisms of the Web Services technology in a process calculus.""
  - ""The main difference between SCC and SOCK can befound in the session identification mechanism.""
  - ""The main difference between SOCK and COWS is the fact that SOCK explicitly supports a state whereas COWS does not.""
  - ""Both state and the RequestResponse primitive made SOCK close to the technologies.""
  - ""This fact allowed us to reason about fault handling issues which led us to propose a new way, the dynamic handling, for managing faults""
  - ""At the present, we can state that SOCK and JOLIE form a framework that offers the possibility to study service-oriented computing issues from the theoretical, architectural and practical points of view.""
  - ""It is our opinion that a service-oriented programming paradigm exists and that it is characterized by the concepts of behaviour, session, session execution, correlation set, engine, interface, deployment, service, container, embedding, redirecting and aggregation.""
  - ""Upon these key concepts we experimented some interesting design patterns from an architectural viewpoint, such as the slave service mobility, the master service mobility and the SoS.""",,"- The paper introduces a novel theoretical contribution by formalizing Web Services technology in a process calculus, specifically through the development of SOCK. This is a unique theoretical advancement as it provides a structured approach to service-oriented computing.
 - The paper highlights the differences between SOCK and other existing approaches like SCC and COWS, particularly in session identification and state support. These differences represent theoretical advancements beyond existing approaches.
 - The introduction of dynamic fault handling is a novel insight that contributes to the theoretical understanding of service-oriented computing.
 - The paper proposes a comprehensive framework for studying service-oriented computing issues, which is a significant theoretical contribution.
 - The identification of key concepts such as behavior, session, engine, and composition techniques like embedding and redirecting are theoretical innovations that contribute to the understanding of the service-oriented programming paradigm.
 - The paper discusses design patterns like slave service mobility and master service mobility, which are novel architectural viewpoints that have potential implications for programming language design."
THE CLASSIFICATION OF PROGRAMMING ENVIRONMENTS,"J. Kollár, Peter Václavík, J. Porubän",-,-,-,7,-,Not specified (the abstract does not explicitly define conceptual primitives or provide their definitions),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described (the abstract mentions integration goals and environment classification but lacks detailed mechanisms or interaction models),Generic programming not extensively addressed (the abstract focuses on environment classification and safe programming but does not explicitly discuss generic programming methodology or type systems),"- Key novel insights: Introduction of the process functional paradigm that combines functional and imperative languages without assignments.
 - Theoretical advancements: Development of PFL as a unified implementation language for von Neumann architectures; classification of environments into external and internal categories; extension to object and modular environments.
 - Potential implications: Integration of various programming languages into a single framework; enhanced safety and reliability in programming language design.","- ""A process functional paradigm prevents the use of assignments in programs, at the same time providing full power of both functional and imperative languages to a programmer.""
  - ""PFL – an experimental process functional language, originally developed as a programming language, seems to be promising to integrate the implementation requirements for any language aimed to von Neumann computer architectures.""
  - ""the formalized definitions of environments presented in this paper are useful and constructive for further development of PFL as a minimal superset of programming languages currently being used in a practice.""
  - ""we will classify the environments dividing them into two basic categories – external and internal environments, that may be defined in any scope of a program.""
  - ""we extend the notion of explicit and implicit environments to object and modular environments.""
  - ""we formulate the requirements for safe programming, which prevents the use of undefined values in programs.""",,"- The abstract discusses a ""process functional paradigm"" which suggests a conceptual framework for programming environments, but it does not explicitly define specific conceptual primitives.
 - The mention of ""PFL"" as an experimental language indicates a focus on language development rather than the definition of primitives.
 - The classification of environments into ""external and internal environments"" and the extension to ""object and modular environments"" suggests a categorization of environments rather than the definition of primitives.
 - The abstract does not provide explicit definitions or names for conceptual primitives, nor does it discuss their level of abstraction or orthogonality.
 - The focus on ""requirements for safe programming"" implies a concern with programming practices rather than the definition of primitives.","- ""A process functional paradigm prevents the use of assignments in programs, at the same time providing full power of both functional and imperative languages to a programmer.""
  - ""PFL – an experimental process functional language, originally developed as a programming language, seems to be promising to integrate the implementation requirements for any language aimed to von Neumann computer architectures.""
  - ""the formalized definitions of environments presented in this paper are useful and constructive for further development of PFL as a minimal superset of programming languages currently being used in a practice.""
  - ""we will classify the environments dividing them into two basic categories – external and internal environments, that may be defined in any scope of a program.""
  - ""we extend the notion of explicit and implicit environments to object and modular environments.""
  - ""Finally, we formulate the requirements for safe programming, which prevents the use of undefined values in programs.""",,"- The abstract discusses the process functional paradigm and the PFL language, which suggests a focus on functional programming principles.
 - The mention of ""formalized definitions of environments"" implies some level of formalization, but it does not specify a particular mathematical framework like type theory or category theory.
 - The classification of environments and extension of notions to object and modular environments suggest a structured approach, but again, no specific mathematical framework is mentioned.
 - The abstract does not provide details on proof techniques, specific mathematical properties guaranteed, or limitations of the framework.
 - The focus on safe programming and preventing undefined values suggests some level of formal verification, but the abstract does not specify the mathematical framework used for this purpose.","- ""A process functional paradigm prevents the use of assignments in programs, at the same time providing full power of both functional and imperative languages to a programmer.""
  - ""PFL – an experimental process functional language, originally developed as a programming language, seems to be promising to integrate the implementation requirements for any language aimed to von Neumann computer architectures.""
  - ""the formalized definitions of environments presented in this paper are useful and constructive for further development of PFL as a minimal superset of programming languages currently being used in a practice.""
  - ""we will classify the environments dividing them into two basic categories – external and internal environments, that may be defined in any scope of a program.""
  - ""we extend the notion of explicit and implicit environments to object and modular environments.""
  - ""we formulate the requirements for safe programming, which prevents the use of undefined values in programs.""",,"- The abstract mentions a ""process functional paradigm"" that integrates the power of both functional and imperative languages, suggesting a mechanism for integrating different programming paradigms.
 - PFL is described as an experimental language that aims to integrate implementation requirements for languages targeting von Neumann architectures, indicating a potential integration strategy.
 - The classification of environments into external and internal categories, and the extension to object and modular environments, could be part of the integration approach by providing a structured framework for different paradigms.
 - The focus on safe programming by preventing undefined values suggests a constraint or challenge in paradigm integration, ensuring that the integration does not compromise program safety.
 - However, the abstract does not explicitly describe specific integration mechanisms, interaction models, or novel translation techniques beyond the general integration aim of PFL.","- ""A process functional paradigm prevents the use of assignments in programs, at the same time providing full power of both functional and imperative languages to a programmer.""
  - ""PFL – an experimental process functional language, originally developed as a programming language, seems to be promising to integrate the implementation requirements for any language aimed to von Neumann computer architectures.""
  - ""the formalized definitions of environments presented in this paper are useful and constructive for further development of PFL as a minimal superset of programming languages currently being used in a practice.""
  - ""we will classify the environments dividing them into two basic categories – external and internal environments, that may be defined in any scope of a program.""
  - ""we extend the notion of explicit and implicit environments to object and modular environments.""
  - ""we formulate the requirements for safe programming, which prevents the use of undefined values in programs.""",,"- The abstract discusses a process functional paradigm and its potential to integrate different programming languages, which suggests a focus on abstraction mechanisms.
 - The mention of PFL as a ""minimal superset of programming languages"" implies a level of genericity in its design.
 - The classification of environments into external and internal categories, and the extension to object and modular environments, indicates a structured approach to abstraction.
 - The focus on safe programming and preventing undefined values suggests a type of static checking or optimization strategy.
 - However, the abstract does not explicitly mention generic programming methodology, type system discussions, or specific mechanisms for representing generic abstractions.","- ""A process functional paradigm prevents the use of assignments in programs, at the same time providing full power of both functional and imperative languages to a programmer.""
  - ""PFL – an experimental process functional language, originally developed as a programming language, seems to be promising to integrate the implementation requirements for any language aimed to von Neumann computer architectures.""
  - ""the formalized definitions of environments presented in this paper are useful and constructive for further development of PFL as a minimal superset of programming languages currently being used in a practice.""
  - ""we will classify the environments dividing them into two basic categories – external and internal environments, that may be defined in any scope of a program.""
  - ""we extend the notion of explicit and implicit environments to object and modular environments.""
  - ""we formulate the requirements for safe programming, which prevents the use of undefined values in programs.""",,"- The abstract introduces a novel paradigm, the ""process functional paradigm,"" which combines the strengths of functional and imperative languages without using assignments. This is a key theoretical contribution as it offers a new approach to programming language design.
 - The development of PFL as a potential unified implementation language for von Neumann architectures is a significant theoretical advancement. It suggests a way to integrate various programming languages into a single framework, which is a novel insight.
 - The classification of environments into external and internal categories, and the extension to object and modular environments, provides a new theoretical framework for understanding programming environments. This is a theoretical advancement beyond existing approaches.
 - The formulation of requirements for safe programming to prevent undefined values is a theoretical contribution that enhances programming language design by ensuring safety and reliability."
Gamma and the chemical reaction model : fteen years after ?,"J. Banâtre, Pascal Fradet",-,-,-,5,2003,"1. Primitive Name: Multiset
  Definition: A collection of individual pieces of data seen as a chemical solution.
  Orthogonality Score: Not discussed
 2. Primitive Name: Reaction Condition
  Definition: A condition that determines which elements in the multiset are replaced.
  Orthogonality Score: Not discussed
 3. Primitive Name: Action
  Definition: The replacement of elements in the multiset based on the reaction condition.
  Orthogonality Score: Not discussed
 4. Primitive Name: Locality Principle
  Definition: Individual values react together independently without global conditions.
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention a specific mathematical framework or details about proof techniques and limitations),No specific integration approach described,"- Definition of ""concept"" used: Computation as a chemical reaction on individual pieces of data.
 - Mechanisms for representing generic abstractions: Use of multisets and locality principle.
 - Minimal type requirements identified: Focus on individual interactions without global conditions.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: Elimination of artificial sequentiality, description of computation as chemical reactions.
 - Theoretical advancements: Chemical reaction model, suitability as an intermediate language for program derivation, minimal nature, locality principle.
 - Potential implications: High-level programming style, easier program correctness proof, refinement for efficiency, systematic and modest programming languages.","- ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""
  - ""The unique data structure in Gamma is the multiset which can be seen as a chemical solution.""
  - ""A simple program is a pair (Reaction condition, Action). Execution proceeds by replacing in the multiset elements satisfying the reaction condition by the products of the action.""
  - ""The essential feature of the Gamma programming style is that a data structure is no longer seen as a hierarchy that has to be walked through or decomposed by the program in order to extract atomic values.""
  - ""Atomic values are gathered into one single bag and the computation is the result of their individual interactions.""
  - ""A related notion is the \locality principle"" in Gamma: individual values may react together and produce new values in a completely independent way.""
  - ""The locality principle is crucial because it makes it easier to reason about programs and it encapsulates the intuition that there is no hidden control constraints in Gamma programs.""",,"- The abstract describes the Gamma formalism as a way to define programs without artificial sequentiality, using a chemical reaction model. This suggests that the conceptual primitives are related to this model.
 - The multiset is identified as the unique data structure, which is akin to a chemical solution. This indicates that the multiset is a fundamental primitive.
 - The program structure is defined as a pair of reaction condition and action, which are key primitives in the Gamma formalism.
 - The locality principle is highlighted as a crucial aspect, indicating that individual values interacting independently is a core primitive.
 - The abstract does not explicitly list these as ""conceptual primitives,"" but they are central to the Gamma formalism and its programming style.","- ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""
  - ""The unique data structure in Gamma is the multiset which can be seen as a chemical solution.""
  - ""Execution proceeds by replacing in the multiset elements satisfying the reaction condition by the products of the action.""
  - ""The result is obtained when a stable state is reached, that is to say when no more reactions can take place.""
  - ""The possibility of getting rid of arti cial sequentiality in Gamma confers a very high level nature to the language and allows the programmer to describe programs in a very abstract way.""
  - ""Gamma programs are easier to prove correct with respect to a speci cation and they can be re ned for the sake of e ciency in a second stage.""
  - ""The locality principle is crucial because it makes it easier to reason about programs and it encapsulates the intuition that there is no hidden control constraints in Gamma programs.""",,"- The abstract describes Gamma as a formalism that uses a chemical reaction model to describe computation, which suggests a unique mathematical framework.
 - The use of multisets as a data structure and the concept of chemical reactions imply a framework that might involve set theory or algebraic structures.
 - The mention of ""getting rid of artificial sequentiality"" and the ""locality principle"" suggests that the framework might be designed to ensure certain properties like parallelism and independence of operations.
 - The abstract mentions that Gamma programs are easier to prove correct, which implies some form of formal verification or proof methodology, but it does not specify the type of mathematical framework or proof techniques used.
 - There is no explicit mention of a specific mathematical framework like type theory or category theory, nor are there details on specific mathematical properties guaranteed or proof techniques used.
 - The abstract does not provide limitations or constraints of the framework.","- ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""
  - ""Gamma is a kernel language which can be introduced intuitively through the chemical reaction metaphor.""
  - ""The unique data structure in Gamma is the multiset which can be seen as a chemical solution.""
  - ""The essential feature of the Gamma programming style is that a data structure is no longer seen as a hierarchy that has to be walked through or decomposed by the program in order to extract atomic values.""
  - ""Atomic values are gathered into one single bag and the computation is the result of their individual interactions.""
  - ""A related notion is the \locality principle"" in Gamma: individual values may react together and produce new values in a completely independent way.""
  - ""The locality principle is crucial because it makes it easier to reason about programs and it encapsulates the intuition that there is no hidden control constraints in Gamma programs.""",,"- The abstract discusses the Gamma formalism as a programming paradigm that uses a chemical reaction model to describe computation. This model is based on the interaction of individual pieces of data in a multiset, which is seen as a chemical solution.
 - The Gamma programming style is characterized by the absence of artificial sequentiality, allowing for a high-level, abstract description of programs.
 - The locality principle in Gamma ensures that individual values interact independently, which simplifies reasoning about programs and eliminates hidden control constraints.
 - The abstract does not explicitly discuss the integration of different programming paradigms or specific mechanisms for integrating paradigms. It focuses on the unique features and programming style of Gamma rather than how it interacts with other paradigms.","- ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""
  - ""The unique data structure in Gamma is the multiset which can be seen as a chemical solution.""
  - ""A simple program is a pair (Reaction condition, Action). Execution proceeds by replacing in the multiset elements satisfying the reaction condition by the products of the action.""
  - ""The possibility of getting rid of arti cial sequentiality in Gamma confers a very high level nature to the language and allows the programmer to describe programs in a very abstract way.""
  - ""In some sense, one can say that it is possible in Gamma to express the very \idea"" of an algorithm without any unnecessary linguistic idiosyncrasy""
  - ""The essential feature of the Gamma programming style is that a data structure is no longer seen as a hierarchy that has to be walked through or decomposed by the program in order to extract atomic values.""
  - ""Atomic values are gathered into one single bag and the computation is the result of their individual interactions.""
  - ""A related notion is the \locality principle"" in Gamma: individual values may react together and produce new values in a completely independent way.""",,"- The abstract describes Gamma as a formalism that uses a chemical reaction model to describe computation, which is a high-level abstraction mechanism.
 - The use of multisets as a data structure allows for a generic representation of data, as it does not impose a specific hierarchy or structure on the data.
 - The programming style in Gamma focuses on individual interactions between atomic values, which suggests a mechanism for representing generic abstractions by not imposing artificial sequentiality or structural constraints.
 - The locality principle in Gamma ensures that reactions are independent and do not require global conditions, which supports the idea of minimal type requirements and flexibility in programming.
 - The abstract does not explicitly mention static checking or optimization strategies, but the focus on abstracting away unnecessary linguistic idiosyncrasies implies a level of abstraction that could facilitate these processes.","- ""Gamma was originally proposed in 1986 as a formalism for the de nition of programs without arti cial sequentiality.""
  - ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""
  - ""The possibility of getting rid of arti cial sequentiality in Gamma confers a very high level nature to the language and allows the programmer to describe programs in a very abstract way.""
  - ""This also makes Gamma suitable as an intermediate language in the program derivation process: Gamma programs are easier to prove correct with respect to a speci cation and they can be re ned for the sake of e ciency in a second stage.""
  - ""the very minimal nature of the original Gamma formalism is one factor which has made possible the various developments that are sketched in this paper.""
  - ""Using the chemical reaction model as a basic paradigm can have a deep e ect on our way of thinking about algorithms.""
  - ""The essential feature of the Gamma programming style is that a data structure is no longer seen as a hierarchy that has to be walked through or decomposed by the program in order to extract atomic values.""
  - ""The locality principle is crucial because it makes it easier to reason about programs and it encapsulates the intuition that there is no hidden control constraints in Gamma programs.""",,"- The abstract introduces Gamma as a formalism that eliminates artificial sequentiality, which is a novel insight in programming language design. This allows for a more abstract and high-level programming style.
 - The chemical reaction model is a theoretical advancement beyond existing approaches, as it describes computation in a unique way that focuses on individual data interactions rather than sequential execution.
 - The ability to use Gamma as an intermediate language in program derivation is a significant theoretical contribution, as it simplifies the process of proving program correctness and allows for refinement for efficiency.
 - The minimal nature of Gamma and its focus on locality are theoretical innovations that make it easier to reason about programs and eliminate hidden control constraints.
 - The abstract suggests that these innovations have implications for how we think about algorithms and programming language design, potentially leading to more systematic and modest programming languages."
A Metalanguage for Guarded Iteration,"S. Goncharov, C. Rauch, Lutz Schröder",10.1016/j.tcs.2021.04.005,https://doi.org/10.1016/j.tcs.2021.04.005,International Colloquium on Theoretical Aspects of Computing,4,2018,"1. Primitive Name: Axiomatic Guardedness
  Definition: A relation between Kleisli morphisms and summands, serving as a unifying framework for various examples from program semantics.
  Orthogonality Score: High (orthogonal to computation as a strong monad)
 2. Primitive Name: Vacuous Guardedness
  Definition: Induces trivial iteration, unfolding at most once.
  Orthogonality Score: High (distinct from total guardedness)
 3. Primitive Name: Total Guardedness
  Definition: Supported by monads equipped with a total iteration operator, specifically Elgot monads.
  Orthogonality Score: High (distinct from vacuous guardedness)
 4. Primitive Name: Strong Monad
  Definition: A notion of computation, parametrizing the metalanguage.
  Orthogonality Score: High (orthogonal to axiomatic guardedness)","- Type of mathematical framework: Category theory, specifically symmetric monoidal categories and strong monads.
 - Specific mathematical properties guaranteed: Soundness and adequacy of operational semantics, preservation of guardedness.
 - Proof techniques used: Categorical semantics, distributive laws, induction in the style of Tait.
 - Limitations or constraints of the framework: Focus on guarded iteration; may not apply to unguarded recursion.","- Specific integration mechanisms proposed: Combining guarded iteration with fine-grain call-by-value paradigm, using exception handling as a metaphor for organizing loops.
 - Interaction models between paradigms: Integration of guardedness with computational effects, exception handling with iteration.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Exception handling metaphor for organizing loops.","- Definition of ""concept"" used: Guardedness as an abstract notion for recursive definitions.
 - Mechanisms for representing generic abstractions: Use of monads, distributive laws over comonads, and custom signatures.
 - Minimal type requirements identified: Existence of Kleisli exponentials and greatest σ-algebras.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Introduction of a generic metalanguage for guarded iteration combining fine-grain call-by-value paradigm.
 - Generic categorical semantics applicable to various computational effects.
 - Integration of exception handling with guarded iteration.
 - Parametrization with axiomatic guardedness and strong monads for flexible language design.
 - Potential for developing more expressive languages handling both guarded and unguarded iteration.","- ""In recent work, we have introduced an axiomatic notion of guardedness in symmetric monoidal categories, which serves as a unifying framework for various examples from program semantics, process algebra, and beyond.""
  - ""In the present paper, we propose a generic metalanguage for guarded iteration based on combining this notion with the fine-grain call-by-value paradigm, which we intend as a unifying programming language for guarded and unguarded iteration in the presence of computational effects.""
  - ""The monad T is (abstractly) guarded if it is equipped with a notion of guardedness, i.e. with a relation between Kleisli morphisms f : X Ñ T Y and summands σ : Y 1 Y closed under the rules in Fig. 2""
  - ""The notion of (abstract) guardedness is a common generalization of various special cases occurring in practice.""
  - ""We extend this perspective by parametrizing such a language with a notion of guardedness and equipping it with guarded iteration.""
  - ""The notion of guardedness can range from vacuous guardedness (inducing trivial iteration, which unfolds at most once) to total guardedness (supported by monads equipped with a total iteration operator, specifically Elgot monads);""
  - ""Our denotational semantics is generic, and is parametrized by two orthogonal features: a notion of computation, given as a strong monad, and a notion of axiomatic guardedness, which serves to support guarded iteration.""",,"- The paper introduces an axiomatic notion of guardedness as a conceptual primitive, which is central to the metalanguage proposed for guarded iteration.
 - The notion of guardedness is defined as a relation between Kleisli morphisms and summands, which is a key conceptual primitive in the framework.
 - The paper discusses different types of guardedness, such as vacuous and total guardedness, which are conceptual primitives used to describe different scenarios of iteration.
 - The metalanguage is parametrized by two orthogonal features: a notion of computation (strong monad) and a notion of axiomatic guardedness, indicating these as conceptual primitives.
 - The paper does not explicitly list these primitives in a separate section or table but integrates them throughout the discussion of the metalanguage and its semantics.","- ""In recent work, we have introduced an axiomatic notion of guardedness in symmetric monoidal categories, which serves as a unifying framework for various examples from program semantics, process algebra, and beyond.""
  - ""We give a generic (categorical) semantics of this language over a suitable class of strong monads supporting guarded iteration, and show it to be in touch with the standard operational behaviour of iteration by giving a concrete big-step operational semantics for a certain specific instance of the metalanguage and establishing soundness and (computational) adequacy for this case.""
  - ""The developments in [20] are couched in terms of a special class of monoidal categories called guarded traced symmetric monoidal categories, equipped with a monoidal notion of guardedness and a monoidal notion of feedback allowing only such cyclic computations that are guarded in the corresponding sense.""
  - ""We use the standard language of category theory [30].""
  - ""The monad T being strong means in particular that for every W P |C|, τ yields a distributive law of the monad T over the comonad W ˆ--, which extends T from C to C / / W [7].""
  - ""The notion of (abstract) guardedness is a common generalization of various special cases occurring in practice.""
  - ""the guardedness structure on T satisfies the axiom (str).""
  - ""the notion of abstract guardedness [22,20] to a multivariable setting in the form of a metalanguage for guarded iteration, which incorporates both monad-based encapsulation of side-effects [34] and the fine-grain call-by-value paradigm [29].""
  - ""We proceed to define a variant of fine-grain call-by-value [29] following the ideas from [14] on labelled iteration.""
  - ""We prove Theorem 5 first but in fact occasionally make use of the converse statements recorded in Theorem 6 (whose proof will not depend on Theorem 5).""
  - ""The proof of the converse statements then runs as follows:""
  - ""We prove Theorem 16 analogously to [14] by showing a stronger type-indexed property used as an induction invariant in the style of Tait [43].""",,"- The paper uses category theory as the mathematical framework, specifically focusing on symmetric monoidal categories and strong monads to formalize guarded iteration.
 - The framework guarantees properties such as soundness and adequacy of the operational semantics, as well as the preservation of guardedness under certain operations.
 - The proof techniques include the use of categorical semantics, distributive laws, and induction in the style of Tait.
 - The framework is limited by its focus on guarded iteration and may not directly apply to unguarded or more general forms of recursion.","- ""In the present paper, we propose a generic metalanguage for guarded iteration based on combining this notion with the fine-grain call-by-value paradigm, which we intend as a unifying programming language for guarded and unguarded iteration in the presence of computational effects.""
  - ""We extend this perspective by parametrizing such a language with a notion of guardedness and equipping it with guarded iteration.""
  - ""A key insight we borrow from [14] is that effectful iteration can be efficiently organized via throwing and handling exceptions (also called labels in this context) in a loop, leading to a more convenient programming style in comparison to the one directly inspired by the typing of the iteration operator (1).""
  - ""We show that the exception handling metaphor seamlessly extends to the guarded case and is compatible with the axioms of guardedness.""
  - ""We proceed to define a variant of fine-grain call-by-value [29] following the ideas from [14] on labelled iteration.""
  - ""The metalanguage features two kinds of judgements:
 

 for values and computations, respectively.""
  - ""The language constructs relating to products, coproducts, and the monad structure are standard (except maybe init, which forms unique morphisms from the null type 0 into any type A)""
  - ""The key features of our metalanguage, discussed next, concern algebraic operations on the one hand, and exception-based iteration on the other hand.""
  - ""We proceed to complement our denotational semantics from Sections 4 and 5 with a big-step operational semantics.""
  - ""Our denotational semantics is generic, and is parametrized by two orthogonal features: a notion of computation, given as a strong monad, and a notion of axiomatic guardedness, which serves to support guarded iteration.""",,"- The paper proposes a metalanguage that integrates guarded iteration with the fine-grain call-by-value paradigm, indicating a specific integration mechanism.
 - The integration involves combining guardedness with computational effects, suggesting an interaction model between paradigms.
 - The use of exception handling as a metaphor for organizing loops is a novel translation technique that integrates iteration with exception handling.
 - The paper discusses theoretical integration strategies by parametrizing the language with guardedness and equipping it with guarded iteration.
 - The metalanguage features standard constructs for products, coproducts, and monad structures, indicating a structured approach to paradigm integration.
 - The denotational semantics is generic and parametrized by computation and guardedness, suggesting a flexible framework for integrating different paradigms.","- ""In the present paper, we propose a generic metalanguage for guarded iteration based on combining this notion with the fine-grain call-by-value paradigm, which we intend as a unifying programming language for guarded and unguarded iteration in the presence of computational effects.""
  - ""We extend this perspective by parametrizing such a language with a notion of guardedness and equipping it with guarded iteration.""
  - ""The developments in [20] are couched in terms of a special class of monoidal categories called guarded traced symmetric monoidal categories, equipped with a monoidal notion of guardedness and a monoidal notion of feedback allowing only such cyclic computations that are guarded in the corresponding sense.""
  - ""The monad T being strong means in particular that for every W P |C|, τ yields a distributive law of the monad T over the comonad W ˆ--, which extends T from C to C / / W [7].""
  - ""We proceed to define a variant of fine-grain call-by-value [29] following the ideas from [14] on labelled iteration. For our purposes we extend the standard setup by allowing a custom signature of operations Σ, but restrict the expressiveness of the language being defined slightly, mainly by excluding function spaces for the moment.""
  - ""The signature Σ consists of two disjoint parts: a value signature Σ v containing signature symbols of the form f : A Ñ B, and an effect signature Σ c containing signature symbols of the form f : A Ñ BrCs.""
  - ""The term language over these data is given in Fig. 4""
  - ""Assuming that greatest σ-algebras exist, we complement our metalanguage with functional types A Ñ ∆ B where the index ∆ serves to store information about (guarded) exceptions of the curried function.""
  - ""In order to interpret functional types in fine-grain call-by-value, it normally suffices to assume existence of Kleisli exponentials, i.e. objects T B A such that HompC, T B A q and HompC ˆA, T Bq are naturally isomorphic, or equivalently that all presheaves Homp--ˆA, T Bq : C op Ñ Set are representable.""
  - ""By the Yoneda lemma, this requirement is equivalent to the following.
 

 Definition 10 (Greatest σ-algebra). Given σ : A 1 A, a pair pA σ , ι σ q consisting of an object A σ P |C| and a morphism ι σ : A σ Ñ σ T A is called a greatest σ-algebra if for every f : X Ñ σ T A there is a unique f : X Ñ A σ with the property that f""
  - ""We proceed to define a variant of fine-grain call-by-value [29] following the ideas from [14] on labelled iteration.""",,"- The paper introduces a ""generic metalanguage for guarded iteration,"" which suggests a focus on generic programming by providing a unifying framework for different types of iteration.
 - The metalanguage is based on a ""fine-grain call-by-value paradigm,"" which is extended to include custom signatures and guarded iteration, indicating a mechanism for representing generic abstractions.
 - The use of monads and distributive laws over comonads suggests a mechanism for abstracting computational effects, which is a key aspect of generic programming.
 - The paper discusses the concept of ""guardedness"" as a way to abstractly define recursive definitions, which is a form of conceptual abstraction.
 - The minimal type requirements are implied by the need for Kleisli exponentials and greatest σ-algebras, which are necessary for interpreting functional types and ensuring the existence of certain algebraic structures.
 - The paper does not explicitly mention static checking or optimization strategies, but the use of categorical semantics and abstract notions like guardedness suggests a focus on theoretical foundations rather than practical implementation details.","- ""In the present paper, we propose a generic metalanguage for guarded iteration based on combining this notion with the fine-grain call-by-value paradigm, which we intend as a unifying programming language for guarded and unguarded iteration in the presence of computational effects.""
  - ""We give a generic (categorical) semantics of this language over a suitable class of strong monads supporting guarded iteration, and show it to be in touch with the standard operational behaviour of iteration by giving a concrete big-step operational semantics for a certain specific instance of the metalanguage and establishing soundness and (computational) adequacy for this case.""
  - ""Our denotational semantics is generic, and is parametrized by two orthogonal features: a notion of computation, given as a strong monad, and a notion of axiomatic guardedness, which serves to support guarded iteration.""
  - ""We extend this perspective by parametrizing such a language with a notion of guardedness and equipping it with guarded iteration.""
  - ""We show that the exception handling metaphor seamlessly extends to the guarded case and is compatible with the axioms of guardedness.""
  - ""In future research, we thus aim to use our present work for developing operational accounts of computational phenomena from their denotational models.""",,"- The paper introduces a novel metalanguage that combines guarded iteration with the fine-grain call-by-value paradigm, which is a significant theoretical contribution as it provides a unifying framework for both guarded and unguarded iteration.
 - The authors provide a generic categorical semantics for this metalanguage, which is a theoretical advancement as it offers a broad framework applicable to various computational effects.
 - The integration of exception handling with guarded iteration is a key novel insight, as it extends the exception handling metaphor to the guarded case, enhancing the language's expressiveness.
 - The paper's focus on parametrizing the language with axiomatic guardedness and strong monads is a theoretical advancement, as it allows for a flexible and modular approach to programming language design.
 - The potential implications for programming language design include the development of more expressive and flexible languages that can handle both guarded and unguarded iteration, as well as the integration of computational effects in a principled manner."
Structural Proof Theory and Logic Programming An extended abstract,D. Miller,-,-,-,0,2020,"1. Primitive Name: Proof Theory
  Definition: A framework for developing computational logic, particularly using natural deduction proofs and the Curry-Howard Correspondence.
  Orthogonality Score: Not discussed
 2. Primitive Name: Proof-Normalization
  Definition: A process related to functional programming.
  Orthogonality Score: Not discussed
 3. Primitive Name: Proof-Search
  Definition: A process related to logic programming.
  Orthogonality Score: Not discussed
 4. Primitive Name: Extension of Logical Connectives and Quantifiers
  Definition: Enhancing expressiveness in logic programs beyond first-order classical logic.
  Orthogonality Score: Not discussed",Not specified (the abstract mentions proof theory as a framework but does not specify the mathematical framework characteristics),"- Specific integration mechanisms proposed: Use of proof theory as a framework for logic programming; Curry-Howard Correspondence for functional programming.
 - Interaction models between paradigms: Functional programming as proof-normalization; logic programming as proof-search.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: The use of proof theory as a framework for computational logic, providing a different perspective from traditional model theory and SLD-resolution.
 - Theoretical advancements: Extension of logical connectives and quantifiers in logic programs, enabling more expressive programs beyond first-order classical logic.
 - Potential implications: Supports new language designs based on stable models and constraints, and provides a theoretical basis for understanding the difference between functional and logic programming paradigms.","- ""Employing proof theory as a framework for logic programming has at least two signiﬁcant beneﬁts.""
  - ""First, proof theory—mainly, the theory of natural deduction proofs—has been used to describe the foundations of functional programming (via the Curry-Howard Correspondence).""
  - ""Thus from the proof theory point-of-view, a clear difference between these paradigms appears: functional programming can be seen as proof-normalization and logic programming as proof-search""
  - ""Second, proof theory provides a framework for extending the role of logical connectives and quanti-ﬁers in logic programs, thus allowing for much more expressive logic programs than those deﬁned using ﬁrst-order classical logic.""
  - ""The theory of proof, particularly the approach developed by Gentzen in the 1930s and by Girard in the 1980s, is a different and appealing framework for developing computational logic.""",,"- The abstract discusses the use of proof theory as a framework for logic programming, which suggests that proof theory is a conceptual primitive in this context.
 - The mention of ""the theory of natural deduction proofs"" and ""the Curry-Howard Correspondence"" indicates that these are specific conceptual primitives related to functional programming.
 - The distinction between ""proof-normalization"" and ""proof-search"" suggests these are conceptual primitives for differentiating between functional and logic programming paradigms.
 - The abstract also mentions the extension of logical connectives and quantifiers, which could be considered conceptual primitives for enhancing expressiveness in logic programs.","- ""proof theory provides a framework for extending the role of logical connectives and quanti-ﬁers in logic programs, thus allowing for much more expressive logic programs than those deﬁned using ﬁrst-order classical logic.""
  - ""proof theory—mainly, the theory of natural deduction proofs—has been used to describe the foundations of functional programming (via the Curry-Howard Correspondence).""
  - ""Employing proof theory as a framework for logic programming has at least two signiﬁcant beneﬁts.""
  - ""The theory of proof, particularly the approach developed by Gentzen in the 1930s and by Girard in the 1980s, is a different and appealing framework for developing computational logic.""
  - ""The semantics of logic programming languages, particularly those based on ﬁrst-order Horn clauses, have traditionally been given a denotational semantics using model theory and an operational semantics using SLD-resolution.""",,"- The abstract mentions the use of ""model theory"" and ""SLD-resolution"" as traditional semantic frameworks for logic programming languages. However, these are not explicitly described as the mathematical framework used in the paper.
 - The abstract highlights ""proof theory"" as a framework for developing computational logic, which is a type of mathematical framework.
 - The mention of ""natural deduction proofs"" and the ""Curry-Howard Correspondence"" suggests that proof theory is used to formalize properties of functional programming, but it does not specify the mathematical properties guaranteed or the proof techniques used.
 - The abstract does not provide specific details about the mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""The semantics of logic programming languages, particularly those based on ﬁrst-order Horn clauses, have traditionally been given a denotational semantics using model theory and an operational semantics using SLD-resolution.""
  - ""Connecting these two different forms of semantic description has been satisfying, since it reassures us that the language is not ad hoc , and productive, since it supports new language designs based on, for example, stable models and constraints.""
  - ""The theory of proof, particularly the approach developed by Gentzen in the 1930s and by Girard in the 1980s, is a different and appealing framework for developing computational logic.""
  - ""Employing proof theory as a framework for logic programming has at least two signiﬁcant beneﬁts.""
  - ""First, proof theory—mainly, the theory of natural deduction proofs—has been used to describe the foundations of functional programming (via the Curry-Howard Correspondence).""
  - ""Thus from the proof theory point-of-view, a clear difference between these paradigms appears: functional programming can be seen as proof-normalization and logic programming as proof-search""
  - ""The role of cut-elimination is different in these two programming paradigms: cut-elimination can be used in functional programming to describe computation steps, while it can be used to reason about computation in logic programming.""
  - ""Second, proof theory provides a framework for extending the role of logical connectives and quanti-ﬁers in logic programs, thus allowing for much more expressive logic programs than those deﬁned using ﬁrst-order classical logic.""",,"- The abstract discusses the integration of different programming paradigms by comparing functional programming and logic programming through the lens of proof theory.
 - It highlights the use of proof theory as a framework for developing computational logic, which is a novel approach to integrating these paradigms.
 - The abstract mentions the Curry-Howard Correspondence as a mechanism that connects functional programming to proof theory, indicating a theoretical integration strategy.
 - It describes the interaction between functional and logic programming paradigms by contrasting proof-normalization in functional programming with proof-search in logic programming.
 - The role of cut-elimination is discussed as a mechanism that differs between these paradigms, suggesting a specific integration mechanism.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the theoretical framework provided by proof theory.","- ""Employing proof theory as a framework for logic programming has at least two signiﬁcant beneﬁts.""
  - ""proof theory—mainly, the theory of natural deduction proofs—has been used to describe the foundations of functional programming (via the Curry-Howard Correspondence).""
  - ""proof theory provides a framework for extending the role of logical connectives and quanti-ﬁers in logic programs, thus allowing for much more expressive logic programs than those deﬁned using ﬁrst-order classical logic.""
  - ""The theory of proof, particularly the approach developed by Gentzen in the 1930s and by Girard in the 1980s, is a different and appealing framework for developing computational logic.""",,"- The abstract discusses the use of proof theory as a framework for logic programming, which is related to the foundations of functional programming through the Curry-Howard Correspondence.
 - It mentions that proof theory allows for extending the role of logical connectives and quantifiers, making logic programs more expressive.
 - However, there is no specific mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract.
 - The focus is on the application of proof theory to logic programming rather than generic programming or abstraction mechanisms.","- ""Thus from the proof theory point-of-view, a clear difference between these paradigms appears: functional programming can be seen as proof-normalization and logic programming as proof-search""
  - ""First, proof theory—mainly, the theory of natural deduction proofs—has been used to describe the foundations of functional programming (via the Curry-Howard Correspondence).""
  - ""The theory of proof, particularly the approach developed by Gentzen in the 1930s and by Girard in the 1980s, is a different and appealing framework for developing computational logic.""
  - ""Connecting these two different forms of semantic description has been satisfying, since it reassures us that the language is not ad hoc , and productive, since it supports new language designs based on, for example, stable models and constraints.""",,"- The abstract discusses the connection between denotational and operational semantics in logic programming, which is a traditional approach. However, it highlights the novelty of using proof theory as a framework for computational logic, which is a different and appealing approach.
 - The first significant benefit of using proof theory is its application in describing the foundations of functional programming through the Curry-Howard Correspondence. This provides a theoretical basis for understanding the difference between functional and logic programming paradigms.
 - The second benefit is the extension of logical connectives and quantifiers in logic programs, allowing for more expressive programs beyond first-order classical logic. This is a theoretical advancement as it enables more complex and expressive logic programs.
 - The abstract implies that these benefits have potential implications for programming language design, particularly in creating new language designs based on stable models and constraints."
Attribute grammar paradigms—a high-level methodology in language implementation,J. Paakki,10.1145/210376.197409,https://doi.org/10.1145/210376.197409,CSUR,395,1995,Not specified (the abstract does not provide explicit definitions or detailed descriptions of the conceptual primitives),Not specified (the abstract does not mention a specific mathematical framework or its characteristics),No specific integration approach described (the abstract discusses classification and taxonomy but does not detail specific integration mechanisms or techniques),Generic programming not extensively addressed,"- Key novel insights: Integration of attribute grammars with established programming paradigms.
 - Theoretical advancements: Classification of paradigms into structured, modular, object-oriented, logic, and functional attribute grammars; introduction of implicit parallel or incremental attribute evaluation paradigms.
 - Potential implications: Improved efficiency or flexibility in programming language design through novel attribute evaluation paradigms.","- ""The modern advanced specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms.""
  - ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""Attribute grammars are a formalism for specifying programming languages.""",,"- The abstract mentions that attribute grammars are used for specifying programming languages, indicating a focus on formalism and methodology.
 - It states that modern specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms. This suggests that the primitives are derived from these paradigms.
 - The abstract discusses the classification of paradigms into structured, modular, object-oriented, logic, and functional attribute grammars. These could be considered as conceptual primitives or categories within the framework of attribute grammars.
 - The mention of ""implicit parallel or incremental attribute evaluation paradigm"" suggests additional approaches or primitives related to evaluation methods.
 - However, the abstract does not provide explicit definitions or detailed descriptions of these primitives, nor does it specify their level of abstraction or orthogonality.","- ""The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""Attribute grammars are a formalism for specifying programming languages.""
  - ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The presentation is founded on mapping elements of attribute grammars to their counterparts in programming languages.""",,"- The abstract discusses attribute grammars as a formalism for specifying programming languages, which implies a theoretical foundation.
 - However, there is no mention of a specific mathematical framework such as type theory or category theory.
 - The abstract focuses on the classification and integration of attribute grammar paradigms rather than detailing a mathematical framework.
 - There is no discussion of proof methodology, formal verification, or specific mathematical properties guaranteed by the framework.
 - The abstract does not mention any limitations or constraints of a mathematical framework.","- ""The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.""
  - ""The modern advanced specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""",,"- The abstract mentions that modern specification languages extend the core attribute grammar model with concepts from established programming paradigms, indicating an integration of these paradigms into attribute grammars.
 - The classification of paradigms into structured, modular, object-oriented, logic, and functional attribute grammars suggests a theoretical integration strategy where different programming paradigms are integrated into attribute grammars.
 - The mention of a methodology integrating two problem-solving disciplines implies a focus on how attribute grammars and programming paradigms are brought together.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques, but it does suggest a classification and taxonomy approach to integration.","- ""Attribute grammars are a formalism for specifying programming languages.""
  - ""The modern advanced specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms.""
  - ""The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.""
  - ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""",,"- The abstract discusses attribute grammars as a formalism for specifying programming languages, which implies a focus on language implementation rather than generic programming.
 - The mention of ""concepts and primitives from established programming paradigms"" suggests that the study may touch upon genericity and abstraction, but it does not explicitly address these topics.
 - The classification of paradigms into structured, modular, object-oriented, logic, and functional attribute grammars indicates a focus on different programming paradigms, but it does not specify how these relate to generic programming or abstraction mechanisms.
 - There is no explicit mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract.
 - The abstract does not provide definitions of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements identified, or static checking or optimization strategies related to generic programming.","- ""Attribute grammars are a formalism for specifying programming languages.""
  - ""The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.""
  - ""The modern advanced specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""The presentation is founded on mapping elements of attribute grammars to their counterparts in programming languages.""
  - ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.""",,"- The abstract discusses the use of attribute grammars as a formalism for specifying programming languages, which is a foundational concept rather than a novel insight.
 - The classification of systems and specification languages based on application support, linguistic characteristics, and automation degree suggests a systematic approach but does not explicitly mention a novel theoretical contribution.
 - The extension of the core attribute grammar model with concepts from established programming paradigms indicates an advancement in integrating different programming paradigms with attribute grammars, which could be considered a theoretical contribution.
 - The mapping of attribute grammar elements to programming languages and the classification of paradigms into structured, modular, object-oriented, logic, and functional attribute grammars represent a theoretical advancement in integrating different problem-solving disciplines.
 - The introduction of implicit parallel or incremental attribute evaluation paradigms suggests a novel approach to attribute evaluation, which could have implications for programming language design by potentially improving efficiency or flexibility."
Advanced Seminar on Foundations of Innovative Software Development II and Colloquium on Functional and Logic Programming and Specifications (CFLP),"H. Ehrig, Colloquium on Functional, Specifications",-,-,-,2,1987,Not specified (the abstract does not explicitly define conceptual primitives or provide a methodology/theoretical framework section),"- Type of mathematical framework: Linear logic, formal semantics, algebraic specifications, type theory, category theory
 - Specific mathematical properties guaranteed: Equality properties, resource-sensitive reasoning, type safety, polymorphism
 - Proof techniques used: Inductive assertion method, higher order generalization
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Retractions (functional paradigm for logic programming), implementing algebraically specified abstract data types in an imperative language.
 - Interaction models between paradigms: Or-parallel execution models of Prolog.
 - Constraints or challenges in paradigm integration: Extensional models for polymorphism, type discipline for program modules.
 - Novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"" used: Not explicitly mentioned.
 - Mechanisms for representing generic abstractions: Compositive abstraction algorithm for combinatory logic; Implementing algebraically specified abstract data types.
 - Minimal type requirements identified: A type discipline for program modules.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novel insights: Models and equality for logical programming, compositive abstraction algorithm for combinatory logic, linear logic and lazy computation, natural dynamic semantics of mini-Standard ML, intensional negation of logic programs, inductive assertion method for logic programs, higher order generalization in program derivation.
 - Theoretical advancements: Implementing algebraically specified abstract data types in an imperative programming language, declarative environment for concurrent logic programming, retraction as a functional paradigm for logic programming, refined strategies for semantic unification, extensional models for polymorphism, type discipline for program modules, theory and practice of canonical term functors in abstract data type specifications.
 - Potential implications for programming language design: Integration of abstract data types into imperative languages, new frameworks for concurrent and functional programming, advancements in semantic unification and polymorphism, improved module typing.","- ""Models and equality for logical programming.-""
  - ""A compositive abstraction algorithm for combinatory logic.-""
  - ""Linear logic and lazy computation.-""
  - ""The natural dynamic semantics of mini-Standard ML.-""
  - ""Listlog - A PROLOG extension for list processing.-""
  - ""Intensional negation of logic programs: Examples and implementation techniques.-""
  - ""Improving the execution speed of compiled Prolog with modes, clause selection, and determinism.-""
  - ""Simulation results of a multiprocessor PROLOG architecture based on a distributed and/or graph.-""
  - ""Generating efficient code from strictness annotations.-""
  - ""Hoisting: Lazy evaluation in a cold climate.-""
  - ""Inductive assertion method for logic programs.-""
  - ""Higher order generalization in program derivation.-""
  - ""Implementing algebraically specified abstract data types in an imperative programming language.-""
  - ""A declarative environment for concurrent logic programming.-""
  - ""Or-parallel execution models of Prolog.-""
  - ""Retractions: A functional paradigm for logic programming.-""
  - ""Refined strategies for semantic unification.-""
  - ""Extensional models for polymorphism.-""
  - ""A type discipline for program modules.-""
  - ""Theory and practice of canonical term functors in abstract data type specifications.""",,"- The abstract lists various topics related to programming paradigms, such as logical programming, combinatory logic, linear logic, and lazy computation. These are areas of focus rather than specific conceptual primitives.
 - There is no explicit mention of ""conceptual primitives"" or any specific definitions of primitives in the abstract.
 - The abstract discusses various techniques and models, such as ""compositive abstraction algorithm,"" ""intensional negation,"" and ""inductive assertion method,"" but these are not explicitly defined as conceptual primitives.
 - The abstract does not provide a clear methodology or theoretical framework section where conceptual primitives might be defined.
 - The level of abstraction and orthogonality of any primitives are not discussed in the abstract.","- ""Models and equality for logical programming.-""
  - ""Linear logic and lazy computation.-""
  - ""The natural dynamic semantics of mini-Standard ML.-""
  - ""Inductive assertion method for logic programs.-""
  - ""Higher order generalization in program derivation.-""
  - ""Implementing algebraically specified abstract data types in an imperative programming language.-""
  - ""Extensional models for polymorphism.-""
  - ""A type discipline for program modules.-""
  - ""Theory and practice of canonical term functors in abstract data type specifications.""",,"- The abstract mentions several topics related to mathematical frameworks, such as ""Models and equality for logical programming,"" which suggests a focus on formal models and equality properties.
 - ""Linear logic and lazy computation"" indicates the use of linear logic, a mathematical framework that deals with resource-sensitive reasoning.
 - ""The natural dynamic semantics of mini-Standard ML"" suggests a focus on formal semantics, which is a mathematical framework for describing the meaning of programming languages.
 - ""Inductive assertion method for logic programs"" and ""Higher order generalization in program derivation"" imply the use of proof techniques related to induction and generalization.
 - ""Implementing algebraically specified abstract data types in an imperative programming language"" suggests the use of algebraic specifications, a mathematical framework for defining abstract data types.
 - ""Extensional models for polymorphism"" and ""A type discipline for program modules"" indicate a focus on type theory, which is a mathematical framework for ensuring type safety and polymorphism.
 - ""Theory and practice of canonical term functors in abstract data type specifications"" suggests the use of category theory, which is a mathematical framework for abstracting and generalizing mathematical structures.","- ""Retractions: A functional paradigm for logic programming.-""
  - ""Implementing algebraically specified abstract data types in an imperative programming language.-""
  - ""A declarative environment for concurrent logic programming.-""
  - ""Or-parallel execution models of Prolog.-""
  - ""Extensional models for polymorphism.-""
  - ""A type discipline for program modules.-""",,"- The abstract mentions several topics related to different programming paradigms, such as functional, logic, and imperative programming.
 - The mention of ""Retractions: A functional paradigm for logic programming"" suggests an integration mechanism where functional programming concepts are applied to logic programming.
 - ""Implementing algebraically specified abstract data types in an imperative programming language"" indicates an integration approach where abstract data types from algebraic specifications are implemented in an imperative language, showing a blend of paradigms.
 - ""A declarative environment for concurrent logic programming"" implies an integration of declarative programming (often associated with functional programming) with concurrent logic programming.
 - ""Or-parallel execution models of Prolog"" suggests an interaction model between different execution models within the logic programming paradigm.
 - ""Extensional models for polymorphism"" and ""A type discipline for program modules"" could relate to constraints or challenges in integrating paradigms, as they deal with polymorphism and module organization, which are crucial in multi-paradigm integration.
 - The abstract does not explicitly mention novel translation or embedding techniques, but the integration of different paradigms is implied through the topics listed.","- ""Theory and practice of canonical term functors in abstract data type specifications.""
  - ""A type discipline for program modules.-""
  - ""Implementing algebraically specified abstract data types in an imperative programming language.-""
  - ""A compositive abstraction algorithm for combinatory logic.-""",,"- The abstract mentions ""A compositive abstraction algorithm for combinatory logic,"" which suggests a focus on abstraction mechanisms, particularly in the context of combinatory logic. This could relate to generic programming methodologies.
 - The mention of ""Implementing algebraically specified abstract data types in an imperative programming language"" indicates a focus on abstraction mechanisms for data types, which is relevant to generic programming.
 - The phrase ""A type discipline for program modules"" suggests discussions about type systems, which are crucial for generic programming and abstraction mechanisms.
 - The reference to ""Theory and practice of canonical term functors in abstract data type specifications"" implies a focus on abstraction mechanisms and type systems, which are key components of generic programming.","- ""Models and equality for logical programming.-""
  - ""A compositive abstraction algorithm for combinatory logic.-""
  - ""Linear logic and lazy computation.-""
  - ""The natural dynamic semantics of mini-Standard ML.-""
  - ""Intensional negation of logic programs: Examples and implementation techniques.-""
  - ""Inductive assertion method for logic programs.-""
  - ""Higher order generalization in program derivation.-""
  - ""Implementing algebraically specified abstract data types in an imperative programming language.-""
  - ""A declarative environment for concurrent logic programming.-""
  - ""Retractions: A functional paradigm for logic programming.-""
  - ""Refined strategies for semantic unification.-""
  - ""Extensional models for polymorphism.-""
  - ""A type discipline for program modules.-""
  - ""Theory and practice of canonical term functors in abstract data type specifications.""",,"- The abstract mentions several topics that suggest novel insights and theoretical contributions, such as ""Models and equality for logical programming,"" which could imply new theoretical frameworks for logical programming.
 - The mention of ""A compositive abstraction algorithm for combinatory logic"" suggests a new algorithmic approach, which is a theoretical advancement.
 - ""Linear logic and lazy computation"" indicates a focus on theoretical aspects of logic and computation, potentially offering new insights into how these concepts can be applied.
 - ""The natural dynamic semantics of mini-Standard ML"" suggests a theoretical contribution to the understanding of programming language semantics.
 - ""Intensional negation of logic programs"" and ""Inductive assertion method for logic programs"" imply new theoretical methods for handling negation and assertions in logic programming.
 - ""Higher order generalization in program derivation"" suggests a theoretical advancement in program derivation techniques.
 - ""Implementing algebraically specified abstract data types in an imperative programming language"" indicates a theoretical contribution to integrating abstract data types into imperative languages.
 - ""A declarative environment for concurrent logic programming"" and ""Retractions: A functional paradigm for logic programming"" suggest new theoretical frameworks for concurrent and functional programming paradigms.
 - ""Refined strategies for semantic unification"" and ""Extensional models for polymorphism"" imply theoretical advancements in semantic unification and polymorphism.
 - ""A type discipline for program modules"" suggests a theoretical contribution to module typing, which is crucial for programming language design.
 - ""Theory and practice of canonical term functors in abstract data type specifications"" indicates a theoretical contribution to abstract data type specifications."
Semantics of Alan,Francesco Pagliarecci,-,-,Starting AI Researchers' Symposium,1,2006,Not specified (the abstract does not explicitly define any conceptual primitives),"- Type of mathematical framework: Rewriting logic language Maude
 - Specific mathematical properties guaranteed: Formal modeling and reasoning, model checking, proving properties
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","No specific integration approach described (the abstract mentions integration of agent-oriented and object-oriented paradigms but does not provide specific mechanisms or details on interaction models, constraints, or novel techniques)",Generic programming not extensively addressed,"- Key novel insights: Integration of agent-oriented and object-oriented programming paradigms in Alan.
 - Theoretical advancements: Formal definition of Alan in Maude, enabling model checking and property proving.
 - Potential implications: New approaches to programming language design through formal modeling and reasoning.","- ""We define the formal specification of Alan in the rewriting logic language Maude.""
  - ""Alan is a programming language that aims to integrate both the agent-oriented and the object-oriented programming.""
  - ""This paper presents a formal definition of Alan.""",,"- The abstract discusses the formal definition of the Alan programming language, which integrates agent-oriented and object-oriented programming paradigms.
 - The formal specification is defined using the rewriting logic language Maude, which suggests a focus on operational semantics.
 - The abstract does not explicitly mention any conceptual primitives or their definitions.
 - The focus is on the integration of programming paradigms and the use of Maude for formal modeling and reasoning, rather than on specific conceptual primitives.
 - There is no mention of specific primitives, their definitions, or their orthogonality.","- ""We define the formal specification of Alan in the rewriting logic language Maude.""
  - ""This paper presents a formal definition of Alan.""",,"- The abstract mentions that the formal definition of Alan is defined using the ""rewriting logic language Maude."" This indicates that the mathematical framework used is based on rewriting logic, which is a type of mathematical framework.
 - The use of Maude suggests that the framework is capable of formal modeling and reasoning, which includes model checking and proving properties. This implies that the framework supports these specific mathematical properties.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used beyond the general capabilities of Maude.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""We define the formal specification of Alan in the rewriting logic language Maude.""
  - ""Alan is a programming language that aims to integrate both the agent-oriented and the object-oriented programming.""
  - ""The end is to take advantages from both the paradigms.""",,"- The abstract mentions that Alan integrates both agent-oriented and object-oriented programming paradigms, indicating an integration approach.
 - The use of Maude for formal specification suggests a theoretical integration strategy, as Maude is a rewriting logic language that can support formal modeling and reasoning.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques. It focuses on the goal of integration and the use of Maude for formal specification.
 - The abstract does not provide detailed information on how the paradigms interact or any specific challenges in integration.","- ""Alan is a programming language that aims to integrate both the agent-oriented and the object-oriented programming.""
  - ""We define the formal specification of Alan in the rewriting logic language Maude.""
  - ""This paper presents a formal definition of Alan.""",,"- The abstract focuses on the formal definition of the Alan programming language and its integration of agent-oriented and object-oriented programming paradigms.
 - It mentions the use of Maude for formal specification, which is relevant to formal modeling and reasoning but does not specifically address generic programming or abstraction mechanisms.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.","- ""Alan is a programming language that aims to integrate both the agent-oriented and the object-oriented programming.""
  - ""This paper presents a formal definition of Alan.""
  - ""We define the formal specification of Alan in the rewriting logic language Maude.""",,"- The abstract introduces Alan as a programming language that integrates both agent-oriented and object-oriented programming paradigms, which is a novel approach as it combines two distinct programming methodologies.
 - The formal definition of Alan in the rewriting logic language Maude is a theoretical contribution, as it provides a rigorous framework for understanding and analyzing the language.
 - The use of Maude for formal specification allows for advanced formal modeling and reasoning techniques such as model checking and property proving, which are significant theoretical advancements.
 - The integration of these paradigms and the use of Maude for formal specification have potential implications for programming language design, as they offer new ways to analyze and verify programs."
Foundations for Partial Evaluation of Functional Languages with Computational Eeects 1 Partial Evaluation of Programs with Computational Eeects,John Hatclii,-,-,-,0,-,Not specified (the abstract does not explicitly define conceptual primitives beyond the mention of monads),"- Type of mathematical framework: Category theory (monads)
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described (the abstract discusses the use of Moggi's computational metalanguage for handling computational effects but does not detail specific integration mechanisms or interaction models),Generic programming not extensively addressed,"- Key novel insights: Use of Moggi's computational metalanguage to handle computational effects in functional languages.
 - Theoretical advancements: Parameterization of the metalanguage on various effects using monads, providing a rigorous semantics and conceptual clarity.
 - Potential implications: Enhancing programming languages by reusing existing partial evaluation technology to handle computational effects more effectively.","- ""By relying only on the abstract laws governing the behavior of monads, one can reason about the metalanguage independently of the particular""",,"- The abstract discusses the use of Moggi's computational metalanguage as a foundation for partial evaluation in functional languages with computational effects.
 - It mentions that this metalanguage is based on ""computational monads,"" which are a type of categorical structure.
 - The abstract does not explicitly list or define specific conceptual primitives beyond the mention of monads and their role in parameterizing computational effects.
 - The focus is on the theoretical framework provided by Moggi's theory rather than on specific primitives for reconstructing programming paradigms.
 - The abstract does not provide a detailed list of primitives or their definitions, nor does it discuss their orthogonality or level of abstraction.","- ""By relying only on the abstract laws governing the behavior of monads, one can reason about the metalanguage independently of the particular""",,"- The abstract mentions ""Moggi's theory of computational monads"" and ""his computational metalanguage,"" which suggests that the mathematical framework used is based on category theory, specifically monads.
 - The use of monads indicates that the framework is designed to handle computational effects in a structured way, which is a key aspect of category theory.
 - The abstract states that the framework allows for reasoning about the metalanguage independently of specific effects, which implies that it provides a level of abstraction and generality.
 - The mention of ""abstract laws governing the behavior of monads"" suggests that the framework guarantees certain mathematical properties related to these laws.
 - There is no explicit mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.","- ""The computational metalanguage can be parameterized on various computational eeects, provided that each eeect can be expressed in terms of a categorical structure called a monad.""
  - ""One would like to build partial evaluation technology for languages with eeects on a formal framework that (a) provides a rigorous semantics for eeects, (b) brings conceptual clarity to the often confuscated treatment of eeects in specializers, and (c) provides organizing principles while imposing a particular discipline for manipulating eeects so as to avoid ad-hoc solutions.""
  - ""Until recently, partial evaluators for functional languages have treated program components containing these computational eeects very conservatively | usually by completely avoiding specialization of program constructs that generate eeects.""
  - ""Clearly, the pure functional paradigm is unable to support modern real-world applications which generally are reactive in nature rather than batch-oriented.""
  - ""The simple semantics of pure functional programs (which do not include computational eeects such as state modiication, input/output, and rst-class exceptions) makes it easier to perform the basic actions of partial evaluation such as static analysis, function unfolding (inlining), and symbolic execution.""
  - ""Research on partial evaluation has ourished in the context of pure functional languages, yet modern functional languages include many notions of computation that partial evaluation technology has only recently been able to handle.""",,"- The abstract discusses the integration of different programming paradigms by addressing the limitations of pure functional languages in handling computational effects such as state modification, input/output, and exceptions.
 - It mentions that modern functional languages like ML and Haskell provide features for computation with state or persistence, input/output, and robust handling of exceptional events, indicating an integration of paradigms.
 - The use of Moggi's computational metalanguage as an intermediate language provides a foundation for handling these computational effects, suggesting a theoretical integration strategy.
 - The abstract does not explicitly describe specific integration mechanisms, interaction models, or novel translation techniques but implies a framework for integrating paradigms through the use of monads.
 - The focus is on providing a rigorous semantics for effects and conceptual clarity, which are constraints or challenges in paradigm integration.","- ""By relying only on the abstract laws governing the behavior of monads, one can reason about the metalanguage independently of the particular""
  - ""We summarize how using Moggi's computational metalanguage as intermediate language provides a foundation for this recent advance in technology.""",,"- The abstract discusses the use of Moggi's computational metalanguage as a foundation for handling computational effects in functional languages. This suggests a focus on abstraction mechanisms related to computational effects rather than generic programming.
 - The mention of parameterizing the computational metalanguage on various computational effects and using monads indicates a mechanism for representing abstractions related to these effects.
 - The abstract does not explicitly mention generic programming, type systems, or minimal type requirements, which are key components of genericity and abstraction mechanisms.
 - The focus is on the use of monads as a conceptual abstraction mechanism for handling computational effects, rather than generic programming.","- ""We summarize how using Moggi's computational metalanguage as intermediate language provides a foundation for this recent advance in technology.""
  - ""By relying only on the abstract laws governing the behavior of monads, one can reason about the metalanguage independently of the particular""
  - ""Ideally, the framework should allow one to re-use existing partial evaluation technology as much as possible.""",,"- The abstract discusses the use of Moggi's computational metalanguage as a foundation for advancing partial evaluation technology in functional languages with computational effects. This suggests a novel insight into how to handle computational effects in a more rigorous and systematic way.
 - The parameterization of the computational metalanguage on various computational effects using monads is a theoretical advancement. It provides a structured approach to handling different types of effects, which is a significant contribution beyond existing approaches that may have treated these effects conservatively or avoided them.
 - The abstract highlights the need for a formal framework that provides rigorous semantics for effects, conceptual clarity, and organizing principles. This indicates a theoretical contribution towards establishing a more systematic and disciplined approach to handling computational effects in partial evaluation.
 - The potential implications for programming language design include the ability to reuse existing partial evaluation technology, which suggests that the framework could be integrated into existing programming languages to enhance their capabilities."
Modularity in Logic Programming,"M. Bugliesi, E. Lamma, P. Mello",10.1016/0743-1066(94)90032-9,https://doi.org/10.1016/0743-1066(94)90032-9,The Journal of Logic Programming,183,1994,"1. Primitive Name: Compositional Operators
  Definition: Used to build programs as combinations of separate and independent components.
  Orthogonality Score: Not specified
 2. Primitive Name: Scoping and Abstraction Mechanisms
  Definition: Modeled in terms of logical connectives of extended logic languages.
  Orthogonality Score: Not specified",Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Module systems with compositional operators for programming-in-the-large; abstraction and scoping mechanisms for programming-in-the-small.
 - Interaction models between paradigms: Mapping object-level logical connectives onto compositional operators.
 - Constraints or challenges in paradigm integration: Different issues arise in programming-in-the-large and programming-in-the-small approaches.
 - Novel translation or embedding techniques: Uniform reconstruction of approaches; mapping logical connectives onto compositional operators.",Generic programming not extensively addressed,"- Key novel insights: Uniform reconstruction of modular logic programming approaches.
 - Theoretical advancements: Integration of programming-in-the-large and programming-in-the-small approaches; mapping object-level logical connectives onto compositional operators.
 - Potential implications: Advancements in modularity and flexibility for programming languages.","- ""The research on modular logic programming has evolved along two different directions during the past decade.""
  - ""Various papers have focused primarily on the problems of programming-in-the-large.""
  - ""They have proposed module systems equipped with compositional operators for building programs as combinations of separate and independent components.""
  - ""Other proposals have instead concentrated on the problem of programming-in-the-small in an attempt to enrich logic programming with abstraction and scoping mechanisms available in other programming paradigms.""
  - ""The compositional operators of the former allow one to structure programs without any need to extend the theory of Horn clauses.""
  - ""The scoping and abstraction mechanisms of the latter are modeled in terms of the logical connectives of extended logic languages.""
  - ""In this paper we provide a uniform reconstruction of the above approaches and we show, wherever this is possible, how the object-level logical connectives of the latter can be mapped onto the compositional operators of the former.""",,"- The abstract discusses two main directions in modular logic programming: programming-in-the-large and programming-in-the-small.
 - For programming-in-the-large, the conceptual primitives are ""compositional operators"" used to build programs from separate components.
 - For programming-in-the-small, the primitives are ""scoping and abstraction mechanisms"" modeled using logical connectives of extended logic languages.
 - The abstract does not provide explicit definitions for these primitives but describes their roles and how they are used.
 - The level of abstraction is high as these primitives are used to structure programs and enrich logic programming.
 - Orthogonality is not explicitly discussed in the abstract.","- ""The research on modular logic programming has evolved along two different directions during the past decade.""
  - ""They have proposed module systems equipped with compositional operators for building programs as combinations of separate and independent components.""
  - ""Other proposals have instead concentrated on the problem of programming-in-the-small in an attempt to enrich logic programming with abstraction and scoping mechanisms available in other programming paradigms.""
  - ""The compositional operators of the former allow one to structure programs without any need to extend the theory of Horn clauses.""
  - ""The scoping and abstraction mechanisms of the latter are modeled in terms of the logical connectives of extended logic languages.""
  - ""In this paper we provide a uniform reconstruction of the above approaches and we show, wherever this is possible, how the object-level logical connectives of the latter can be mapped onto the compositional operators of the former.""",,"- The abstract discusses two approaches to modular logic programming: one focusing on programming-in-the-large with compositional operators, and the other on programming-in-the-small with abstraction and scoping mechanisms.
 - It mentions that the compositional operators do not require extending the theory of Horn clauses, which suggests a foundation in logic programming principles.
 - The scoping and abstraction mechanisms are modeled using logical connectives of extended logic languages, indicating a connection to logical frameworks.
 - The abstract does not explicitly mention a specific mathematical framework like type theory or category theory.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the conceptual reconstruction and mapping between different approaches rather than on a detailed mathematical framework.","- ""The research on modular logic programming has evolved along two different directions during the past decade.""
  - ""Various papers have focused primarily on the problems of programming-in-the-large.""
  - ""They have proposed module systems equipped with compositional operators for building programs as combinations of separate and independent components.""
  - ""Other proposals have instead concentrated on the problem of programming-in-the-small in an attempt to enrich logic programming with abstraction and scoping mechanisms available in other programming paradigms.""
  - ""The issues that arise in the two approaches are substantially different.""
  - ""The compositional operators of the former allow one to structure programs without any need to extend the theory of Horn clauses.""
  - ""The scoping and abstraction mechanisms of the latter are modeled in terms of the logical connectives of extended logic languages.""
  - ""In this paper we provide a uniform reconstruction of the above approaches and we show, wherever this is possible, how the object-level logical connectives of the latter can be mapped onto the compositional operators of the former.""",,"- The abstract discusses two main directions in modular logic programming research: programming-in-the-large and programming-in-the-small. This suggests a focus on integrating different aspects of programming paradigms.
 - The ""programming-in-the-large"" approach involves module systems with compositional operators, which can be seen as a mechanism for integrating separate components.
 - The ""programming-in-the-small"" approach aims to enrich logic programming with abstraction and scoping mechanisms from other paradigms, indicating an integration of different paradigm features.
 - The abstract mentions that the issues in these approaches are different, suggesting challenges in integrating these paradigms.
 - The paper provides a ""uniform reconstruction"" of these approaches, which implies a theoretical integration strategy.
 - The mapping of logical connectives onto compositional operators suggests a novel translation technique for integrating these paradigms.","- ""The research on modular logic programming has evolved along two different directions during the past decade.""
  - ""They have proposed module systems equipped with compositional operators for building programs as combinations of separate and independent components.""
  - ""Other proposals have instead concentrated on the problem of programming-in-the-small in an attempt to enrich logic programming with abstraction and scoping mechanisms available in other programming paradigms.""
  - ""In this paper we provide a uniform reconstruction of the above approaches and we show, wherever this is possible, how the object-level logical connectives of the latter can be mapped onto the compositional operators of the former.""
  - ""The scoping and abstraction mechanisms of the latter are modeled in terms of the logical connectives of extended logic languages.""",,"- The abstract discusses two main directions in modular logic programming: one focusing on programming-in-the-large with compositional operators, and the other on programming-in-the-small with abstraction and scoping mechanisms.
 - The mention of ""abstraction and scoping mechanisms"" suggests a focus on conceptual abstraction, but it does not provide specific details on generic programming or type requirements.
 - The abstract does not explicitly mention generic programming or type systems, nor does it discuss static checking or optimization strategies.
 - The focus is more on the integration of different approaches rather than detailing specific mechanisms for generic abstractions or type requirements.","- ""The research on modular logic programming has evolved along two different directions during the past decade.""
  - ""Various papers have focused primarily on the problems of programming-in-the-large.""
  - ""Other proposals have instead concentrated on the problem of programming-in-the-small""
  - ""The issues that arise in the two approaches are substantially different.""
  - ""The compositional operators of the former allow one to structure programs without any need to extend the theory of Horn clauses.""
  - ""The scoping and abstraction mechanisms of the latter are modeled in terms of the logical connectives of extended logic languages.""
  - ""In this paper we provide a uniform reconstruction of the above approaches""
  - ""we show, wherever this is possible, how the object-level logical connectives of the latter can be mapped onto the compositional operators of the former.""",,"- The abstract discusses two main directions in modular logic programming research: programming-in-the-large and programming-in-the-small. This indicates a comprehensive review of existing approaches.
 - The paper provides a ""uniform reconstruction"" of these approaches, suggesting a novel integration or synthesis of existing methods.
 - The abstract mentions mapping object-level logical connectives onto compositional operators, which implies a theoretical advancement in how these concepts are related and applied.
 - The focus on providing a uniform reconstruction and mapping between different approaches suggests a theoretical contribution by integrating disparate elements into a cohesive framework.
 - The abstract does not explicitly mention potential implications for programming language design, but the integration of different approaches could imply advancements in modularity and flexibility for programming languages."
An Approach to Class Reasoning in Symbolic Computation,"G. Cioni, A. Colagrossi, M. Temperini",10.1007/3-540-61697-7_25,https://doi.org/10.1007/3-540-61697-7_25,Design and Implementation of Symbolic Computation Systems,2,1996,"1. Primitive Name: Class Construct
  Definition: Allows for expressing properties of mathematical structures
  Orthogonality Score: Not specified
 2. Primitive Name: Inheritance
  Definition: Part of the programming language defined in the methodology
  Orthogonality Score: Not specified
 3. Primitive Name: Class Reasoning
  Definition: Method for evaluating logical relations among mathematical structures
  Orthogonality Score: Not specified",Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),No specific integration approach described,"Generic programming not extensively addressed (the abstract focuses on class reasoning and object-oriented paradigm but lacks specific details on generic programming methodologies, type systems, or optimization strategies)","- Key novel insights: Integration of object-oriented paradigm with mathematical modeling through axiomatization; expression of mathematical structure properties using class constructs.
 - Theoretical advancements: Definition of a programming language in terms of class construct and inheritance; application of class reasoning to evaluate logical relations and modify hierarchies of mathematical structures.
 - Potential implications for programming language design: Structured representation of mathematical structures and their properties; dynamic management and analysis of complex mathematical relationships.","- ""A suitable programming language is defined in terms of its class construct and inheritance.""
  - ""The class construct allows for expressing also the properties of the structure represented by the class.""
  - ""By reasoning about the properties defined in classes (class reasoning) logical relations among the related mathematical structures can be evaluated.""
  - ""We show how class reasoning can be applied in order to rearrange and/or modify a hierarchy of (classes representing) mathematical structures.""
  - ""A methodology, following the object-oriented paradigm, for modeling mathematical structure by axiomatization is presented.""",,"- The abstract discusses a methodology that follows the object-oriented paradigm, which suggests that the conceptual primitives are related to object-oriented programming (OOP) concepts.
 - The mention of ""class construct and inheritance"" indicates that these are key primitives in the methodology, as they are fundamental to OOP.
 - The ""class construct"" is described as allowing for the expression of properties of mathematical structures, which implies that it is a primitive for representing these structures.
 - ""Class reasoning"" is highlighted as a method for evaluating logical relations among mathematical structures, suggesting that it is a primitive for reasoning about these structures.
 - The abstract does not provide explicit definitions or orthogonality scores for these primitives, nor does it mention any other specific primitives.","- ""A methodology, following the object-oriented paradigm, for modeling mathematical structure by axiomatization is presented.""
  - ""A suitable programming language is defined in terms of its class construct and inheritance.""
  - ""We show how class reasoning can be applied in order to rearrange and/or modify a hierarchy of (classes representing) mathematical structures.""
  - ""By reasoning about the properties defined in classes (class reasoning) logical relations among the related mathematical structures can be evaluated.""
  - ""The class construct allows for expressing also the properties of the structure represented by the class.""",,"- The abstract mentions an ""object-oriented paradigm"" and ""axiomatization,"" which suggests a structured approach to modeling mathematical structures. However, it does not specify a particular type of mathematical framework like type theory or category theory.
 - The use of ""class construct and inheritance"" indicates a focus on object-oriented programming principles, but this does not directly translate to a specific mathematical framework.
 - The abstract discusses ""class reasoning"" and evaluating ""logical relations among the related mathematical structures,"" which implies some form of logical analysis, but again, no specific mathematical framework is named.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations/constraints of the framework in the abstract.","- ""We show how class reasoning can be applied in order to rearrange and/or modify a hierarchy of (classes representing) mathematical structures.""
  - ""By reasoning about the properties defined in classes (class reasoning) logical relations among the related mathematical structures can be evaluated.""
  - ""The class construct allows for expressing also the properties of the structure represented by the class.""
  - ""A suitable programming language is defined in terms of its class construct and inheritance.""
  - ""A methodology, following the object-oriented paradigm, for modeling mathematical structure by axiomatization is presented.""",,"- The abstract mentions the use of the ""object-oriented paradigm,"" which is a specific programming paradigm.
 - It discusses the use of a ""class construct and inheritance,"" which are typical features of object-oriented programming.
 - The abstract does not mention any integration of different programming paradigms; it only focuses on the object-oriented paradigm.
 - There is no discussion of interaction models between different paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.
 - The focus is on using object-oriented programming for modeling mathematical structures, not on integrating multiple paradigms.","- ""A suitable programming language is defined in terms of its class construct and inheritance.""
  - ""We show how class reasoning can be applied in order to rearrange and/or modify a hierarchy of (classes representing) mathematical structures.""
  - ""By reasoning about the properties defined in classes (class reasoning) logical relations among the related mathematical structures can be evaluated.""
  - ""The class construct allows for expressing also the properties of the structure represented by the class.""
  - ""A methodology, following the object-oriented paradigm, for modeling mathematical structure by axiomatization is presented.""",,"- The abstract discusses a methodology that follows the object-oriented paradigm, which is relevant to generic programming and abstraction.
 - The mention of a ""class construct and inheritance"" suggests mechanisms for representing generic abstractions, as these are fundamental components of object-oriented programming that allow for genericity and abstraction.
 - The ability to ""express properties of the structure represented by the class"" implies a form of conceptual abstraction, as it allows for the representation of abstract concepts through classes.
 - The abstract does not explicitly mention ""minimal type requirements,"" ""static checking,"" or ""optimization strategies,"" which are typically discussed in the context of generic programming methodologies.
 - The focus on ""class reasoning"" and the manipulation of class hierarchies suggests a mechanism for abstraction, but the abstract does not provide detailed information on generic programming methodologies or type system discussions.","- ""A methodology, following the object-oriented paradigm, for modeling mathematical structure by axiomatization is presented.""
  - ""We show how class reasoning can be applied in order to rearrange and/or modify a hierarchy of (classes representing) mathematical structures.""
  - ""A suitable programming language is defined in terms of its class construct and inheritance.""
  - ""The class construct allows for expressing also the properties of the structure represented by the class.""
  - ""By reasoning about the properties defined in classes (class reasoning) logical relations among the related mathematical structures can be evaluated.""",,"- The abstract presents a methodology that follows the object-oriented paradigm for modeling mathematical structures through axiomatization. This suggests a novel approach to integrating object-oriented programming principles with mathematical modeling.
 - The definition of a programming language in terms of its class construct and inheritance is a key theoretical contribution. It implies a structured way to represent mathematical structures and their properties within a programming context.
 - The ability to express properties of mathematical structures using the class construct is a significant theoretical advancement. It allows for the evaluation of logical relations among related structures, which is a novel insight into how mathematical structures can be analyzed and manipulated.
 - The application of class reasoning to rearrange or modify hierarchies of mathematical structures is a theoretical contribution. It suggests a new way to dynamically manage and analyze complex mathematical relationships.
 - The abstract does not explicitly mention comparisons with existing work or specific implications for programming language design. However, the methodology and class reasoning approach imply potential implications for designing programming languages that can effectively model and manipulate mathematical structures."
Compositional theories for host-core languages,"D. Trotta, M. Zorzi",-,-,-,0,2020,"1. Primitive Name: Host Language (H)
  Definition: Part of the syntax representing the host language in the host-core type theory.
  Orthogonality Score: Not specified
 2. Primitive Name: Core Language (C)
  Definition: Part of the syntax representing the core language embedded in the host language.
  Orthogonality Score: Not specified
 3. Primitive Name: Typed Calculus HC
  Definition: A minimal and flexible host-core system capturing common properties of host-core languages.
  Orthogonality Score: Not specified","- Type of mathematical framework: Linear type theory, category theory
 - Specific mathematical properties guaranteed: Extra properties making the system better behaved, strong correspondence between syntax and semantics
 - Proof techniques used: Proving extra properties, establishing strong correspondence
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Embedding of core language C in host language H.
 - Interaction models between paradigms: Flexible management of data linearity for non-classical computational paradigms.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Extension of Benton's Linear-Non-Linear type theory with improved properties; introduction of host-core type theory for flexible data linearity management.
 - Theoretical advancements: Splitting syntax into host and core languages; denotational model and strong correspondence between syntax and semantics.
 - Potential implications: Simplified multi-language programming; framework for heterogeneous programming language design.","- ""Linear type theories, of various types and kinds, are of fundamental importance in most programming language research nowadays.""
  - ""we describe an extension of Benton's Linear-Non-Linear type theory and model for which we can prove some extra properties that make the system better behaved as far as its theory is concerned.""
  - ""We call this system the host-core type theory.""
  - ""The syntax of a host-core language is split into two parts, representing respectively a host language H and a core language C, embedded in H.""
  - ""This idea, derived from Benton's Linear-Non-Linear formulation of Linear Logic, allows a flexible management of data linearity, which is particularly useful in non-classical computational paradigms.""
  - ""The host-core style can be viewed as a simplified notion of multi-language programming, the process of software development in a heterogeneous programming language.""
  - ""we present the typed calculus HC, a minimal and flexible host-core system that captures and standardizes common properties of an ideal class of host-core languages.""
  - ""We provide a denotational model in terms of enriched categories and we state a strong correspondence between syntax and semantics through the notion of internal language.""",,"- The abstract discusses the extension of Benton's Linear-Non-Linear type theory, which is a conceptual framework for managing data linearity in programming languages.
 - The ""host-core type theory"" is introduced as a system that splits the syntax into two parts: a host language (H) and a core language (C), which are conceptual primitives for managing data linearity and multi-language programming.
 - The ""typed calculus HC"" is presented as a minimal and flexible system that standardizes properties of host-core languages, suggesting it is a conceptual primitive for capturing these properties.
 - The use of ""enriched categories"" and ""internal language"" indicates a theoretical framework for understanding the semantics of these primitives.
 - The abstract does not explicitly define these primitives with precise definitions or discuss their orthogonality, but they are implied as fundamental concepts in the host-core type theory.","- ""an extension of Benton's Linear-Non-Linear type theory and model for which we can prove some extra properties that make the system better behaved as far as its theory is concerned.""
  - ""Linear type theories, of various types and kinds, are of fundamental importance in most programming language research nowadays.""
  - ""We provide a denotational model in terms of enriched categories and we state a strong correspondence between syntax and semantics through the notion of internal language.""
  - ""The latter result provides some useful characterizations of host-core style, otherwise difficult to obtain.""
  - ""The syntax of a host-core language is split into two parts, representing respectively a host language H and a core language C, embedded in H.""",,"- The abstract mentions ""Linear type theories"" as a fundamental component, indicating that the mathematical framework is based on type theory.
 - The extension of Benton's Linear-Non-Linear type theory suggests that this is a specific type of mathematical framework used.
 - The mention of ""enriched categories"" indicates the use of category theory in the denotational model.
 - The abstract states that they ""prove some extra properties"" and establish a ""strong correspondence between syntax and semantics,"" which implies the use of proof techniques to guarantee these properties.
 - The abstract does not explicitly mention limitations or constraints of the framework.","- ""The syntax of a host-core language is split into two parts, representing respectively a host language H and a core language C, embedded in H.""
  - ""The host-core style can be viewed as a simplified notion of multi-language programming, the process of software development in a heterogeneous programming language.""
  - ""we present the typed calculus HC, a minimal and flexible host-core system that captures and standardizes common properties of an ideal class of host-core languages.""
  - ""We provide a denotational model in terms of enriched categories and we state a strong correspondence between syntax and semantics through the notion of internal language.""
  - ""This idea, derived from Benton's Linear-Non-Linear formulation of Linear Logic, allows a flexible management of data linearity, which is particularly useful in non-classical computational paradigms.""",,"- The abstract discusses the ""host-core type theory"" as an extension of Benton's Linear-Non-Linear type theory, which suggests a theoretical integration strategy.
 - The syntax is split into two parts, a host language and a core language, indicating a specific integration mechanism where one language is embedded in another.
 - The mention of ""flexible management of data linearity"" and its utility in ""non-classical computational paradigms"" implies an interaction model that accommodates different paradigms.
 - The ""host-core style"" is described as a simplified form of multi-language programming, which suggests a theoretical integration strategy for heterogeneous programming languages.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it detail novel translation or embedding techniques beyond the general concept of embedding one language in another.","- ""Linear type theories, of various types and kinds, are of fundamental importance in most programming language research nowadays.""
  - ""we describe an extension of Benton's Linear-Non-Linear type theory and model for which we can prove some extra properties that make the system better behaved as far as its theory is concerned.""
  - ""The syntax of a host-core language is split into two parts, representing respectively a host language H and a core language C, embedded in H.""
  - ""This idea, derived from Benton's Linear-Non-Linear formulation of Linear Logic, allows a flexible management of data linearity, which is particularly useful in non-classical computational paradigms.""
  - ""The host-core style can be viewed as a simplified notion of multi-language programming, the process of software development in a heterogeneous programming language.""
  - ""we present the typed calculus HC, a minimal and flexible host-core system that captures and standardizes common properties of an ideal class of host-core languages.""
  - ""We provide a denotational model in terms of enriched categories and we state a strong correspondence between syntax and semantics through the notion of internal language.""
  - ""We also discuss some concrete instances, extensions and specializations of the system HC.""",,"- The abstract discusses the extension of Benton's Linear-Non-Linear type theory, which is a type theory framework. This suggests a focus on type systems rather than generic programming.
 - The mention of ""flexible management of data linearity"" and ""non-classical computational paradigms"" indicates a focus on type theory and its applications rather than generic programming.
 - The abstract describes the host-core style as a ""simplified notion of multi-language programming,"" which might imply some form of abstraction, but it does not explicitly address generic programming or abstraction mechanisms.
 - The presentation of a ""typed calculus HC"" and a ""denotational model in terms of enriched categories"" suggests a focus on type systems and semantics rather than generic programming.
 - The abstract does not mention any specific mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""In this paper we describe an extension of Benton's Linear-Non-Linear type theory and model for which we can prove some extra properties that make the system better behaved as far as its theory is concerned.""
  - ""We call this system the host-core type theory.""
  - ""The syntax of a host-core language is split into two parts, representing respectively a host language H and a core language C, embedded in H.""
  - ""This idea, derived from Benton's Linear-Non-Linear formulation of Linear Logic, allows a flexible management of data linearity, which is particularly useful in non-classical computational paradigms.""
  - ""The host-core style can be viewed as a simplified notion of multi-language programming, the process of software development in a heterogeneous programming language.""
  - ""we present the typed calculus HC, a minimal and flexible host-core system that captures and standardizes common properties of an ideal class of host-core languages.""
  - ""We provide a denotational model in terms of enriched categories and we state a strong correspondence between syntax and semantics through the notion of internal language.""
  - ""The latter result provides some useful characterizations of host-core style, otherwise difficult to obtain.""
  - ""We also discuss some concrete instances, extensions and specializations of the system HC.""",,"- The abstract describes an extension of Benton's Linear-Non-Linear type theory, which is a novel contribution as it introduces new properties that improve the system's theoretical behavior.
 - The introduction of the ""host-core type theory"" is a key novel insight, as it represents a new approach to managing data linearity in programming languages.
 - The splitting of the syntax into host and core languages is a theoretical advancement, as it simplifies multi-language programming and allows for flexible data linearity management.
 - The provision of a denotational model and the establishment of a strong correspondence between syntax and semantics are significant theoretical contributions, as they provide a solid foundation for understanding the host-core style.
 - The discussion of concrete instances, extensions, and specializations of the system HC suggests potential implications for programming language design, as it offers a framework for developing heterogeneous programming languages."
Inclusional Theories in Declarative Programming,"Marco Schorlemmer, J. Agustí-Cullell",-,-,APPIA-GULP-PRODE,2,1996,"1. Primitive Name: Partial Order Relations
  Definition: Basis for specification frameworks
  Orthogonality Score: Not discussed
 2. Primitive Name: Inclusions
  Definition: Basis for several different specification frameworks
  Orthogonality Score: Not discussed
 3. Primitive Name: Term Rewriting
  Definition: Suitable technique for theorem proving with inclusional theories
  Orthogonality Score: Not discussed
 4. Primitive Name: Restrictions on Inclusional Theories
  Definition: To improve inference mechanism and define efficient deduction strategies
  Orthogonality Score: Not discussed
 5. Primitive Name: Lattices
  Definition: Specific algebraic structure for inclusional theories
  Orthogonality Score: Not discussed
 6. Primitive Name: Sort Checking
  Definition: Replaces evaluation of functional expressions by reduction to normal forms
  Orthogonality Score: Not discussed","- Type of mathematical framework: Partial order relations and inclusions
 - Specific mathematical properties guaranteed: Not explicitly mentioned
 - Proof techniques used: Term rewriting
 - Limitations or constraints of the framework: Impracticality of term rewriting in general; need for restrictions on inclusional theories","- Specific integration mechanisms proposed: Term rewriting for theorem proving with inclusional theories.
 - Interaction models between paradigms: Integration of logic programming with inclusional theories.
 - Constraints or challenges in paradigm integration: Need for restrictions to improve inference mechanisms and deduction strategies.
 - Novel translation or embedding techniques: Replacement of evaluating functional expressions with sort checking of sort expressions.",Generic programming not extensively addressed (the abstract focuses on inclusional theories and algebraic structures but does not provide detailed mechanisms for generic programming or conceptual abstraction),"- Novel insight: Shift from equality relations to partial order relations and inclusions in logic programming languages.
 - Theoretical advancement: Proposal for a logic programming language that efficiently handles inclusions.
 - Theoretical contribution: Restricting inclusional theories to specific algebraic structures like lattices to improve inference mechanisms.
 - Theoretical innovation: Replacing evaluation of functional expressions by reduction to normal forms with sort checking of sort expressions.","- ""Term rewriting appears to be a suitable technique for theorem proving with inclusional theories""",,"- The abstract discusses the focus on ""partial order relations"" and ""inclusions"" as conceptual primitives for developing a logic programming language. This suggests that these are foundational concepts in the study.
 - The mention of ""term rewriting"" as a technique for theorem proving with inclusional theories implies that this is a methodological primitive for handling these relations.
 - The need for ""restrictions"" on inclusional theories to improve inference mechanisms suggests that these restrictions are part of the conceptual framework.
 - The reference to ""lattices"" as a promising approach indicates that this is a specific algebraic structure considered as a conceptual primitive.
 - The shift from evaluating functional expressions to ""sort checking"" suggests a change in how expressions are evaluated, which could be considered a conceptual primitive in terms of programming paradigm.","- ""Term rewriting appears to be a suitable technique for theorem proving with inclusional theories , since it naturally applies to arbitrary (possibly non-symmetric) transitive relations, but turns out to be impractical in general.""",,"- The abstract mentions the use of ""partial order relations"" and ""inclusions"" as a basis for specification frameworks, indicating a focus on these mathematical concepts.
 - Term rewriting is identified as a technique for theorem proving with inclusional theories, suggesting its use as a proof technique.
 - The need for restrictions on inclusional theories to improve inference mechanisms implies limitations or constraints in the framework.
 - The mention of ""specific algebraic structures, like lattices"" suggests that these structures are part of the mathematical framework.
 - The replacement of evaluating functional expressions with sort checking indicates a shift in the approach to formal verification.","- ""Term rewriting appears to be a suitable technique for theorem proving with inclusional theories , since it naturally applies to arbitrary (possibly non-symmetric) transitive relations, but turns out to be impractical in general.""",,"- The abstract discusses the development of a logic programming language that efficiently handles inclusions, which could be useful for rapid prototyping. This suggests an integration of logic programming with inclusional theories.
 - Term rewriting is mentioned as a technique for theorem proving with inclusional theories, indicating a potential integration mechanism.
 - The abstract notes that restrictions are needed to improve inference mechanisms and deduction strategies, which could be seen as constraints or challenges in integrating inclusional theories into a programming language.
 - The mention of restricting to specific algebraic structures like lattices suggests a theoretical integration strategy.
 - The replacement of evaluating functional expressions with sort checking indicates a novel translation or embedding technique.",,,"- The abstract discusses the focus on partial order relations and inclusions as a basis for specification frameworks, which suggests a conceptual abstraction mechanism.
 - The mention of working towards a logic programming language that efficiently deals with inclusions implies a generic programming approach, as it aims to create a versatile tool.
 - The need for restrictions on inclusional theories to improve inference mechanisms suggests a mechanism for representing generic abstractions by limiting the scope to specific algebraic structures like lattices.
 - The replacement of evaluating functional expressions with sort checking indicates a type system discussion, which is relevant to minimal type requirements and static checking strategies.
 - However, the abstract does not explicitly define a ""concept"" or provide detailed mechanisms for generic programming or abstraction beyond the focus on inclusions and algebraic structures.","- ""Term rewriting appears to be a suitable technique for theorem proving with inclusional theories , since it naturally applies to arbitrary (possibly non-symmetric) transitive relations, but turns out to be impractical in general.""",,"- The abstract highlights a shift in focus from equality relations to partial order relations and inclusions, which is a novel insight in the context of logic programming languages.
 - The proposal to develop a logic programming language that efficiently handles inclusions is a theoretical advancement, as it addresses a gap in current programming languages.
 - The use of term rewriting for theorem proving with inclusional theories is noted, but the abstract also acknowledges its impracticality, suggesting a need for new strategies.
 - The suggestion to restrict inclusional theories to specific algebraic structures like lattices is a theoretical contribution, as it offers a promising approach to improve inference mechanisms.
 - The replacement of evaluating functional expressions by reduction to normal forms with sort checking is a theoretical innovation, as it adapts the programming paradigm to better suit inclusional theories."
The Multi-Paradigm Synchronous Programming Language,"L. Holenderski, A. Poigné",-,-,-,4,1998,Not specified (the abstract does not explicitly define any conceptual primitives),Not specified (the abstract does not provide details about the mathematical framework characteristics),"- Specific integration mechanisms proposed: Uniform translation rules to a common intermediate format called Boolean automata.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Uniform translation to Boolean automata for multi-paradigm integration.",Generic programming not extensively addressed,"- Key novel insights: Uniform translation rules for Lustre, Esterel, and Argos into Boolean automata.
 - Theoretical advancements: Integration of different programming languages into a multi-paradigm language.
 - Potential implications: Enhanced flexibility and efficiency in programming synchronous reactive systems through the creation of a multi-paradigm language.","- ""Such a uniform translation allows to smoothly combine the languages into one multi-paradigm language for programming synchronous reactive systems.""
  - ""We present uniform translation rules for three synchronous programming languages Lustre, Esterel and Argos, to a common intermediate format called Boolean automata.""",,"- The abstract discusses the translation of three synchronous programming languages (Lustre, Esterel, and Argos) into a common intermediate format called Boolean automata. This suggests that the conceptual primitives might be related to this translation process.
 - However, the abstract does not explicitly define any conceptual primitives. It mentions the use of Boolean automata as a common format but does not detail what specific primitives are involved in this process.
 - The focus of the abstract is on the uniform translation and the creation of a multi-paradigm language, rather than on defining specific conceptual primitives.
 - There is no mention of the level of abstraction or orthogonality of any primitives, as none are explicitly defined.","- ""Such a uniform translation allows to smoothly combine the languages into one multi-paradigm language for programming synchronous reactive systems.""
  - ""We present uniform translation rules for three synchronous programming languages Lustre, Esterel and Argos, to a common intermediate format called Boolean automata.""",,"- The abstract mentions the use of ""Boolean automata"" as a common intermediate format for translating three synchronous programming languages. This suggests a mathematical framework based on automata theory.
 - The abstract does not provide specific details about the type of mathematical framework, such as type theory or category theory, nor does it mention specific mathematical properties guaranteed or proof techniques used.
 - There is no mention of limitations or constraints of the framework in the abstract.
 - The abstract focuses on the translation and combination of languages rather than detailing the mathematical framework's characteristics.","- ""We present uniform translation rules for three synchronous programming languages Lustre, Esterel and Argos, to a common intermediate format called Boolean automata.""
  - ""Such a uniform translation allows to smoothly combine the languages into one multi-paradigm language for programming synchronous reactive systems.""",,"- The abstract mentions the use of ""uniform translation rules"" to translate three different synchronous programming languages (Lustre, Esterel, and Argos) into a common intermediate format called Boolean automata. This suggests a specific integration mechanism where different languages are translated into a common format to facilitate integration.
 - The phrase ""smoothly combine the languages into one multi-paradigm language"" indicates that the integration approach involves creating a single language that can encompass multiple paradigms, which is a novel translation technique.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration, but it does imply a theoretical integration strategy by using a common intermediate format.
 - The abstract does not provide a comparative analysis or detailed discussion of paradigm interactions, but it does highlight the integration of different languages into a single multi-paradigm language.","- ""Such a uniform translation allows to smoothly combine the languages into one multi-paradigm language for programming synchronous reactive systems.""
  - ""We present uniform translation rules for three synchronous programming languages Lustre, Esterel and Argos, to a common intermediate format called Boolean automata.""",,"- The abstract discusses the translation of three synchronous programming languages into a common intermediate format, which suggests a focus on integration and compatibility rather than generic programming or abstraction mechanisms.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract.
 - The focus is on combining languages rather than on genericity or abstraction, indicating that these aspects are not extensively addressed in the study.","- ""We present uniform translation rules for three synchronous programming languages Lustre, Esterel and Argos, to a common intermediate format called Boolean automata.""
  - ""Such a uniform translation allows to smoothly combine the languages into one multi-paradigm language for programming synchronous reactive systems.""",,"- The abstract mentions the development of ""uniform translation rules"" for three synchronous programming languages (Lustre, Esterel, and Argos) into a common intermediate format called Boolean automata. This is a novel insight as it suggests a new way to integrate different programming languages.
 - The ability to translate these languages into a common format implies a theoretical advancement beyond existing approaches, as it enables the creation of a multi-paradigm language. This is a significant contribution because it allows for the combination of different programming paradigms, which can enhance flexibility and efficiency in programming synchronous reactive systems.
 - The potential implications for programming language design are significant. By creating a multi-paradigm language, the study contributes to the theoretical foundations of programming language design by showing how different languages can be integrated, potentially leading to more versatile and powerful programming tools."
"Domains and Denotational Semantics: History, Accomplishments and Open Problems Classical Domain Theory Axiomatic Domain Theory","Achim Jung, Marcelo P Fiore, Eugenio Moggi, Peter O 'hearn, Jon Riecke, G. Rosolini, Ian Stark, Marcelo P Fiore, D. Ww, D ? W-D ? W ( I E",-,-,-,2,1996,Not specified (the abstract does not explicitly define conceptual primitives or their orthogonality),"- Type of mathematical framework: Domain Theory (Scott-domains), Axiomatic and Synthetic Approaches
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,Not mentioned (the abstract does not explicitly mention any unique theoretical contributions or advancements beyond existing approaches),"- ""In this collection we try to give an overview of some selected topics in Domain Theory and Denotational Semantics.""
  - ""The emphasis is on those ordered structures which have been introduced by Dana Scott in 1969 and which gure under the name (Scott-) domains.""
  - ""After surveying developments in the concrete theory of domains we describe two newer developments, the axiomatic and the synthetic approach.""
  - ""In the second part we look at three computational phenomena in detail, namely, sequential computation, polymorphism, and mutable state, and at the challenges that these pose for a mathematical model.""
  - ""Denotational semantics has traditionally been described as the theory of true meanings for programs, or, to put it more poignantly, as the theory of what programs denote.""
  - ""By translating from one formalism into another one expects to gain new insight into the object at hand.""
  - ""the purpose of denotational semantics is threefold: to bring out subtle issues in language design, to derive new reasoning principles, and to develop an intuitive""",,"- The abstract discusses the use of Scott-domains as a fundamental structure in denotational semantics, which could be considered a conceptual primitive.
 - The mention of axiomatic and synthetic approaches suggests these might be conceptual primitives in the context of domain theory.
 - The abstract highlights three computational phenomena: sequential computation, polymorphism, and mutable state. These could be seen as conceptual primitives in the context of computational models.
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality.
 - The abstract focuses on the overview and purposes of denotational semantics rather than detailing specific conceptual primitives.","- ""In this collection we try to give an overview of some selected topics in Domain Theory and Denotational Semantics.""
  - ""The emphasis is on those ordered structures which have been introduced by Dana Scott in 1969 and which gure under the name (Scott-) domains.""
  - ""After surveying developments in the concrete theory of domains we describe two newer developments, the axiomatic and the synthetic approach.""
  - ""Denotational semantics has traditionally been described as the theory of true meanings for programs, or, to put it more poignantly, as the theory of what programs denote.""
  - ""In many cases, denotations have been built with the help of functions in some mathematical universe and so this position presupposes that the ontological status of sets and functions is rmly established.""
  - ""This second position has become more and more popular over the last years, following the rapid progress on the programming language side which results in ever new and successful computational paradigms and which can hardly be ascribed merely to the desire to nd syntactical descriptions of already existing mathematical objects.""",,"- The abstract discusses Domain Theory and Denotational Semantics, which are mathematical frameworks used to formalize and guarantee properties of conceptual primitives in programming languages.
 - The mention of ""Scott-domains"" indicates a specific type of mathematical framework related to domain theory, which is a branch of mathematics used to model computational phenomena.
 - The abstract also refers to ""axiomatic and synthetic approaches,"" which are methodologies within domain theory that provide a structured way to analyze and reason about programs.
 - The use of ""functions in some mathematical universe"" suggests that the framework involves mathematical functions and possibly type theory, as these are common tools in denotational semantics.
 - The abstract does not explicitly mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework, but it implies that these frameworks are used to provide a theoretical foundation for understanding programs.","- ""This presentation does by no means exhaust the various approaches to denotational semantics and it certainly does not describe all possible mathematical techniques which have been used to describe various aspects of programs.""
  - ""the purpose of denotational semantics is threefold: to bring out subtle issues in language design, to derive new reasoning principles, and to develop an intuitive""
  - ""By translating from one formalism into another one expects to gain new insight into the object at hand.""
  - ""However, the pragmatics of denotational semantics is essentially unaaected by the foundational stance one takes; the aims, hopes and concrete uses are the same.""
  - ""In the second part we look at three computational phenomena in detail, namely, sequential computation, polymorphism, and mutable state, and at the challenges that these pose for a mathematical model.""",,"- The abstract discusses computational phenomena such as sequential computation, polymorphism, and mutable state, which are related to different programming paradigms. However, it does not explicitly mention how these paradigms are integrated.
 - The abstract notes that the presentation does not exhaust all approaches to denotational semantics, suggesting that there might be other works or sections that address integration, but this is not detailed in the abstract.
 - The abstract focuses on the general purpose and aims of denotational semantics rather than specific integration mechanisms or challenges.
 - There is no mention of specific integration mechanisms, interaction models, constraints, or novel translation techniques related to programming paradigm integration.","- ""In this collection we try to give an overview of some selected topics in Domain Theory and Denotational Semantics.""
  - ""The emphasis is on those ordered structures which have been introduced by Dana Scott in 1969 and which gure under the name (Scott-) domains.""
  - ""After surveying developments in the concrete theory of domains we describe two newer developments, the axiomatic and the synthetic approach.""
  - ""In the second part we look at three computational phenomena in detail, namely, sequential computation, polymorphism, and mutable state, and at the challenges that these pose for a mathematical model.""
  - ""Denotational semantics has traditionally been described as the theory of true meanings for programs, or, to put it more poignantly, as the theory of what programs denote.""
  - ""In many cases, denotations have been built with the help of functions in some mathematical universe and so this position presupposes that the ontological status of sets and functions is rmly established.""
  - ""This second position has become more and more popular over the last years, following the rapid progress on the programming language side which results in ever new and successful computational paradigms and which can hardly be ascribed merely to the desire to nd syntactical descriptions of already existing mathematical objects.""
  - ""the pragmatics of denotational semantics is essentially unaaected by the foundational stance one takes; the aims, hopes and concrete uses are the same.""
  - ""By translating from one formalism into another one expects to gain new insight into the object at hand.""
  - ""the purpose of denotational semantics is threefold: to bring out subtle issues in language design, to derive new reasoning principles, and to develop an intuitive""",,"- The abstract primarily focuses on domain theory and denotational semantics, with an emphasis on mathematical structures and their applications in programming.
 - The mention of ""polymorphism"" suggests a connection to generic programming, as polymorphism is a key concept in genericity.
 - However, the abstract does not provide specific details on generic programming methodology, type system discussions, or abstraction mechanism explanations.
 - There is no explicit mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The abstract does not delve into the specifics of generic programming or conceptual abstraction mechanisms, indicating that these topics are not extensively addressed.","- ""In this collection we try to give an overview of some selected topics in Domain Theory and Denotational Semantics.""
  - ""The emphasis is on those ordered structures which have been introduced by Dana Scott in 1969 and which gure under the name (Scott-) domains.""
  - ""After surveying developments in the concrete theory of domains we describe two newer developments, the axiomatic and the synthetic approach.""
  - ""In the second part we look at three computational phenomena in detail, namely, sequential computation, polymorphism, and mutable state, and at the challenges that these pose for a mathematical model.""
  - ""This presentation does by no means exhaust the various approaches to denotational semantics and it certainly does not describe all possible mathematical techniques which have been used to describe various aspects of programs.""
  - ""We hope that, nevertheless, it illustrates how a particular challenge (namely the modelling of recursive deenitions) has given rise to an immensely rich theory, both in its general parts and in its applications.""
  - ""Denotational semantics has traditionally been described as the theory of true meanings for programs, or, to put it more poignantly, as the theory of what programs denote.""
  - ""But there has always been an alternative viewpoint in which denotational semantics is seen as a translation from one formal system to another.""
  - ""This second position has become more and more popular over the last years, following the rapid progress on the programming language side which results in ever new and successful computational paradigms and which can hardly be ascribed merely to the desire to nd syntactical descriptions of already existing mathematical objects.""
  - ""the pragmatics of denotational semantics is essentially unaaected by the foundational stance one takes; the aims, hopes and concrete uses are the same.""
  - ""By translating from one formalism into another one expects to gain new insight into the object at hand.""
  - ""Elaborating slightly on this, we can say that the purpose of denotational semantics is threefold: to bring out subtle issues in language design, to derive new reasoning principles, and to develop an intuitive""",,"- The abstract discusses the overview of Domain Theory and Denotational Semantics, indicating a comprehensive review rather than a novel contribution.
 - The mention of Scott-domains and newer developments like axiomatic and synthetic approaches suggests a focus on existing theories rather than new theoretical contributions.
 - The discussion of computational phenomena and challenges for mathematical models implies an analysis of existing issues rather than introducing new theoretical frameworks.
 - The abstract highlights the traditional view of denotational semantics and an alternative viewpoint, but does not explicitly introduce new theoretical contributions.
 - The purpose of denotational semantics is described as gaining new insights, deriving reasoning principles, and developing intuition, which are general goals rather than specific novel contributions.
 - The abstract does not explicitly mention any unique theoretical contributions or advancements beyond existing approaches."
A domain-theoretic approach to functional and logic programming,"F. Silbermann, B. Jayaraman",10.1017/S095679680000040X,https://doi.org/10.1017/S095679680000040X,Journal of functional programming,14,1992,"1. Primitive Name: Set Abstraction
  Definition: Provided via Zermelo-Frankel set notation
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Herbrand Universe
  Definition: Used as a set abstraction generator
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Domain-Theoretic Constructions
  Definition: Used to define the language
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Lower (or Angelic) Powerdomain
  Definition: Used to model set abstraction facility
  Orthogonality Score: Not discussed","- Type of mathematical framework: Domain theory
 - Specific mathematical properties guaranteed: Referential transparency, use of lower (or angelic) powerdomain for set abstraction
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Domain theory as a common basis, set abstraction using Zermelo-Frankel set notation, Herbrand universe as a set abstraction generator, lower powerdomain to model set abstraction.
 - Interaction models between paradigms: Treating enumeration parameter as a logical variable for efficiency.
 - Constraints or challenges in paradigm integration: Maintaining referential transparency, achieving implicitly correct operational semantics.
 - Novel translation or embedding techniques: Using domain theory as a common basis, employing lower powerdomain for set abstraction.",Generic programming not extensively addressed,"- Key novel insights: Use of domain theory as a common basis for functional and logic programming; integration of logic programming through set abstraction using Zermelo-Frankel set notation and the Herbrand universe.
 - Theoretical advancements: Definition of the language in terms of domain-theoretic constructions and primitives; use of the lower powerdomain to model set abstraction; maintenance of referential transparency; implicitly correct operational semantics through direct execution of denotational semantics.
 - Potential implications: Provides a simple, elegant, and purely declarative language combining key features of functional and logic programming; requires parallel evaluation for operational semantics completeness.","- ""The language is defined in terms of (computable) domain-theoretic constructions and primitives, using the lower (or angelic) powerdomain to model the set abstraction facility.""
  - ""The logic programming capability is provided by set abstraction (via Zermelo-Frankel set notation), using the Herbrand universe as a set abstraction generator,""
  - ""Our integrated language remains essentially within the functional paradigm.""",,"- The abstract mentions that the integrated language is based on the functional paradigm, indicating that functional programming concepts are foundational.
 - The logic programming capability is introduced through ""set abstraction (via Zermelo-Frankel set notation),"" which suggests that set abstraction is a conceptual primitive.
 - The use of the ""Herbrand universe as a set abstraction generator"" implies that this is another primitive, as it is used to generate sets for abstraction.
 - The mention of ""(computable) domain-theoretic constructions and primitives"" indicates that these are also conceptual primitives, as they are used to define the language.
 - The ""lower (or angelic) powerdomain"" is specifically mentioned as a primitive used to model set abstraction, suggesting it is a key conceptual primitive.","- ""domain theory as a common basis for functional and logic programming.""
  - ""The language is defined in terms of (computable) domain-theoretic constructions and primitives,""
  - ""Referential transparency with respect to the underlying mathematical model is maintained throughout.""
  - ""An implicitly correct operational semantics is obtained by direct execution of the denotational semantic definition,""
  - ""using the lower (or angelic) powerdomain to model the set abstraction facility.""",,"- The abstract mentions ""domain theory as a common basis for functional and logic programming,"" indicating that the mathematical framework used is domain theory.
 - The language is defined using ""computable domain-theoretic constructions and primitives,"" which suggests that the framework is based on domain theory.
 - The use of ""the lower (or angelic) powerdomain to model the set abstraction facility"" is a specific mathematical property guaranteed by this framework, as it relates to how set abstraction is handled.
 - ""Referential transparency with respect to the underlying mathematical model is maintained throughout"" implies that the framework ensures referential transparency, a specific mathematical property.
 - The abstract does not explicitly mention proof techniques or limitations of the framework, but it does mention ""an implicitly correct operational semantics,"" which suggests a focus on ensuring correctness through the framework.","- ""The integration of functional and logic programming languages has been a topic of great interest in the last decade.""
  - ""This paper addresses these shortcomings via a new approach: domain theory as a common basis for functional and logic programming.""
  - ""Our integrated language remains essentially within the functional paradigm.""
  - ""The logic programming capability is provided by set abstraction (via Zermelo-Frankel set notation), using the Herbrand universe as a set abstraction generator, but for efficiency reasons our proposed evaluation procedure treats this generator's enumeration parameter as a logical variable.""
  - ""The language is defined in terms of (computable) domain-theoretic constructions and primitives, using the lower (or angelic) powerdomain to model the set abstraction facility.""
  - ""The result is a simple, elegant and purely declarative language that successfully combines the most important features of both pure functional programming and pure Horn logic programming.""
  - ""Referential transparency with respect to the underlying mathematical model is maintained throughout.""
  - ""An implicitly correct operational semantics is obtained by direct execution of the denotational semantic definition, modified suitably to permit logical variables whenever the Herbrand universe is being generated within a set abstraction.""",,"- The abstract discusses the integration of functional and logic programming languages, indicating a focus on combining these two paradigms.
 - The integration approach is based on domain theory, which serves as a common basis for both functional and logic programming.
 - The language remains within the functional paradigm but incorporates logic programming capabilities through set abstraction using Zermelo-Frankel set notation and the Herbrand universe.
 - The use of the lower powerdomain to model set abstraction is a specific integration mechanism.
 - The interaction model involves treating the enumeration parameter as a logical variable for efficiency, which is a novel translation technique.
 - The abstract mentions that the language maintains referential transparency and achieves an implicitly correct operational semantics, which are constraints or challenges addressed in the integration.
 - The integration approach is novel in that it uses domain theory as a common basis and employs specific mathematical constructs like the lower powerdomain to combine the paradigms.","- ""The integration of functional and logic programming languages has been a topic of great interest in the last decade.""
  - ""This paper addresses these shortcomings via a new approach: domain theory as a common basis for functional and logic programming.""
  - ""Our integrated language remains essentially within the functional paradigm.""
  - ""The logic programming capability is provided by set abstraction (via Zermelo-Frankel set notation), using the Herbrand universe as a set abstraction generator,""
  - ""The language is defined in terms of (computable) domain-theoretic constructions and primitives, using the lower (or angelic) powerdomain to model the set abstraction facility.""
  - ""The result is a simple, elegant and purely declarative language that successfully combines the most important features of both pure functional programming and pure Horn logic programming.""
  - ""Referential transparency with respect to the underlying mathematical model is maintained throughout.""",,"- The abstract discusses the integration of functional and logic programming languages, which implies a focus on combining different programming paradigms rather than generic programming.
 - The approach uses domain theory as a common basis, which is more about providing a theoretical foundation for the integration rather than addressing generic programming.
 - The mention of set abstraction and the use of Zermelo-Frankel set notation suggests a mechanism for representing abstractions, but it is not explicitly related to generic programming.
 - There is no mention of minimal type requirements, static checking, or optimization strategies, which are typical components of generic programming.
 - The abstract does not explicitly address generic programming methodology or type system discussions, which are key areas for genericity and abstraction mechanisms.","- ""The integration of functional and logic programming languages has been a topic of great interest in the last decade. Many proposals have been made, yet none is completely satisfactory especially in the context of higher order functions and lazy evaluation.""
  - ""This paper addresses these shortcomings via a new approach: domain theory as a common basis for functional and logic programming.""
  - ""Our integrated language remains essentially within the functional paradigm.""
  - ""The logic programming capability is provided by set abstraction (via Zermelo-Frankel set notation), using the Herbrand universe as a set abstraction generator, but for efficiency reasons our proposed evaluation procedure treats this generator's enumeration parameter as a logical variable.""
  - ""The language is defined in terms of (computable) domain-theoretic constructions and primitives, using the lower (or angelic) powerdomain to model the set abstraction facility.""
  - ""The result is a simple, elegant and purely declarative language that successfully combines the most important features of both pure functional programming and pure Horn logic programming.""
  - ""Referential transparency with respect to the underlying mathematical model is maintained throughout.""
  - ""An implicitly correct operational semantics is obtained by direct execution of the denotational semantic definition, modified suitably to permit logical variables whenever the Herbrand universe is being generated within a set abstraction.""
  - ""Completeness of the operational semantics requires a form of parallel evaluation, rather than the more familiar left-most rule.""",,"- The abstract highlights that previous attempts at integrating functional and logic programming have been unsatisfactory, particularly with higher-order functions and lazy evaluation. This sets the stage for the novelty of the approach.
 - The use of domain theory as a common basis for both paradigms is identified as a new approach, which is a key theoretical contribution.
 - The integration of logic programming capabilities through set abstraction using Zermelo-Frankel set notation and the Herbrand universe is a novel insight, as it provides a way to incorporate logic programming within a functional paradigm.
 - The language's definition in terms of domain-theoretic constructions and primitives, specifically using the lower powerdomain, is a theoretical advancement beyond existing approaches.
 - The maintenance of referential transparency and the development of an implicitly correct operational semantics are significant theoretical contributions, as they ensure the language's mathematical integrity.
 - The requirement for parallel evaluation for completeness of operational semantics is a theoretical innovation, diverging from traditional left-most rule evaluation."
Logic + control revisited: an abstract interpreter for GO¨DEL programs,E. Börger,-,-,-,7,1995,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: Evolving algebras
 - Specific mathematical properties guaranteed: Provably correct stepwise refinements
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Clean interface between logical and control components
 - Interaction models between paradigms: Concurrency
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned","- Definition of ""concept"" used: Abstract terms and abstract search spaces
 - Mechanisms for representing generic abstractions: Gure-vich's notion of evolving algebras
 - Minimal type requirements identified: Not explicitly mentioned
 - Static checking or optimization strategies: Provably correct stepwise reenements","- Key novel insights: Development of a simple interpreter for GG odel programs, clean interface between logical and control components, formalization at the level of abstract search spaces, modular approach.
 - Theoretical advancements: Use of abstract terms covering the general logic programming paradigm, allowance for concurrency, application of Gure-vich's notion of evolving algebras for machine and proof system independent description and analysis.
 - Potential implications: Tool for mathematical description and analysis of design decisions, ground for provably correct stepwise refinements in programming language design.","- ""The construction is given in abstract terms which cover the general logic programming paradigm and allow for concurrency.""
  - ""The formalization directly reeects the intuitive procedural understanding of programs, but is formulated at the level of abstract search spaces and proceeds in a modular fashion.""
  - ""The deenition provides a clean interface between logical and control components for execution of GG odel programs.""
  - ""This combination of procedural and abstract features, made possible by use of Gure-vich's notion of evolving algebras, provides a tool for mathematical| machine and proof system independent|description and analysis of design decisions for logic programming languages; it also lays the ground for provably correct stepwise reenements, through a hierarchy of speciications at lower levels, down to implementations.""",,"- The abstract mentions the use of ""Gure-vich's notion of evolving algebras,"" which suggests a theoretical framework but does not explicitly define conceptual primitives.
 - The abstract discusses the ""clean interface between logical and control components"" and ""abstract terms"" that cover the ""general logic programming paradigm,"" but these are not explicitly defined as conceptual primitives.
 - The mention of ""procedural and abstract features"" and ""abstract search spaces"" indicates a level of abstraction but does not specify particular primitives.
 - The abstract does not provide explicit definitions or names for conceptual primitives, nor does it discuss their orthogonality.","- ""This combination of procedural and abstract features, made possible by use of Gure-vich's notion of evolving algebras, provides a tool for mathematical| machine and proof system independent|description and analysis of design decisions for logic programming languages; it also lays the ground for provably correct stepwise reenements, through a hierarchy of speciications at lower levels, down to implementations.""
  - ""The formalization directly reeects the intuitive procedural understanding of programs, but is formulated at the level of abstract search spaces and proceeds in a modular fashion.""
  - ""The construction is given in abstract terms which cover the general logic programming paradigm and allow for concurrency.""",,"- The abstract mentions the use of ""Gure-vich's notion of evolving algebras,"" which suggests that the mathematical framework involves evolving algebras. This is a specific type of mathematical framework.
 - The abstract describes the formalization as being ""at the level of abstract search spaces"" and ""proceeds in a modular fashion,"" indicating that the framework is abstract and modular.
 - The mention of ""provably correct stepwise reenements"" suggests that the framework is used for formal verification and guarantees certain properties, such as correctness.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, nor does it discuss limitations or constraints of the framework.","- ""The deenition provides a clean interface between logical and control components for execution of GG odel programs.""
  - ""The construction is given in abstract terms which cover the general logic programming paradigm and allow for concurrency.""
  - ""This combination of procedural and abstract features, made possible by use of Gure-vich's notion of evolving algebras, provides a tool for mathematical| machine and proof system independent|description and analysis of design decisions for logic programming languages;""",,"- The abstract mentions the provision of a ""clean interface between logical and control components,"" which suggests an integration mechanism between these two components.
 - The use of ""abstract terms"" and ""Gure-vich's notion of evolving algebras"" indicates a theoretical integration strategy that allows for concurrency, which is a form of interaction model between paradigms.
 - The abstract does not explicitly mention specific constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.
 - The focus is on providing a tool for description and analysis of design decisions, which implies a theoretical integration approach rather than a detailed practical integration strategy.","- ""The formalization directly reeects the intuitive procedural understanding of programs, but is formulated at the level of abstract search spaces and proceeds in a modular fashion.""
  - ""The construction is given in abstract terms which cover the general logic programming paradigm and allow for concurrency.""
  - ""This combination of procedural and abstract features, made possible by use of Gure-vich's notion of evolving algebras, provides a tool for mathematical| machine and proof system independent|description and analysis of design decisions for logic programming languages; it also lays the ground for provably correct stepwise reenements, through a hierarchy of speciications at lower levels, down to implementations.""
  - ""The deenition provides a clean interface between logical and control components for execution of GG odel programs.""",,"- The abstract discusses the development of an interpreter for GG odel programs, focusing on the interface between logical and control components. This suggests a level of abstraction in the design.
 - The use of ""abstract terms"" and ""abstract search spaces"" indicates a focus on conceptual abstraction, allowing for a general approach to logic programming.
 - The mention of ""Gure-vich's notion of evolving algebras"" implies a mechanism for representing generic abstractions, as evolving algebras are a mathematical framework for describing dynamic systems.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does suggest a modular approach, which could imply some form of type system or optimization.
 - The focus on ""provably correct stepwise reenements"" suggests a method for ensuring correctness, which could be related to static checking or optimization strategies.","- ""We develop a simple interpreter for programs of the new logic programming language GG odel.""
  - ""The deenition provides a clean interface between logical and control components for execution of GG odel programs.""
  - ""This combination of procedural and abstract features, made possible by use of Gure-vich's notion of evolving algebras, provides a tool for mathematical| machine and proof system independent|description and analysis of design decisions for logic programming languages; it also lays the ground for provably correct stepwise reenements, through a hierarchy of speciications at lower levels, down to implementations.""
  - ""The formalization directly reeects the intuitive procedural understanding of programs, but is formulated at the level of abstract search spaces and proceeds in a modular fashion.""
  - ""The construction is given in abstract terms which cover the general logic programming paradigm and allow for concurrency.""",,"- The abstract introduces a ""simple interpreter for programs of the new logic programming language GG odel,"" which suggests a novel development in the field of logic programming.
 - The ""clean interface between logical and control components"" is highlighted as a key feature, indicating an advancement in how these components are integrated.
 - The use of ""abstract terms"" and the allowance for ""concurrency"" suggest theoretical contributions to the general logic programming paradigm.
 - The formalization at the ""level of abstract search spaces"" and the modular approach are novel insights that reflect a procedural understanding of programs.
 - The use of ""Gure-vich's notion of evolving algebras"" provides a theoretical framework that is machine and proof system independent, which is a significant theoretical advancement.
 - The potential implications include providing a tool for the description and analysis of design decisions and enabling provably correct stepwise refinements, which are significant contributions to programming language design."
Syntactic finitism in the metatheory of programming languages,"C. Schürmann, Jeffrey Sarnat",-,-,-,4,2010,"1. Primitive Name: Case Analysis
  Definition: Part of syntactic finitism, viewed as a priori justified
  Orthogonality Score: Not specified
 2. Primitive Name: Structural Induction on Abstract Syntax
  Definition: Part of syntactic finitism, viewed as a priori justified
  Orthogonality Score: Not specified
 3. Primitive Name: Well-founded Induction on the Lexicographic Path Ordering
  Definition: Alternative/complementary principle within syntactic finitism
  Orthogonality Score: Not specified","- Type of mathematical framework: Syntactic finitism, proof theory
 - Specific mathematical properties guaranteed: Soundness of modular termination-analysis
 - Proof techniques used: Case analysis, structural induction, well-founded induction on lexicographic path ordering
 - Limitations or constraints of the framework: Not explicitly mentioned",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Proposal of ""syntactic finitism"" as a philosophical viewpoint that views certain principles as a priori justified.
 - Theoretical advancements: Exploration of what can be done with these principles using proof theory; syntactically finitary account of proofs by logical relations; investigation of replacing structural induction with well-founded induction on the lexicographic path ordering; formalization of syntactically finitary proofs in the proofs as logic programs paradigm.
 - Potential implications for programming language design: Development of more reliable and automated formal methods for specifying and reasoning about program behavior.","- ""we propose an answer to the former by describing a philosophical viewpoint we refer to as syntactic finitism, in which the principles of case analysis and structural induction on abstract syntax are viewed as being a priori justified.""
  - ""Finally, we argue that syntactically finitary proofs can be formalized in the proofs as logic programs paradigm popularized by the proof assistant Twelf; we prove the soundness of a modular termination-analysis that is central to the validity of this interpretation.""
  - ""We explore the latter question using some of the ideas and results from proof theory; along the way, we provide a syntactically finitary account of proofs by logical relations, and investigate the consequences of replacing structural induction with well-founded induction on the lexicographic path ordering from term rewriting theory.""
  - ""We posit the following questions: (1) what are these principles and (2) how much can we do with them?""",,"- The abstract discusses the concept of ""syntactic finitism"" as a philosophical viewpoint that justifies certain principles a priori.
 - The principles mentioned are ""case analysis"" and ""structural induction on abstract syntax,"" which are considered fundamental to syntactic finitism.
 - The abstract also mentions the exploration of these principles in the context of proof theory and their application in formalizing proofs as logic programs.
 - The mention of ""well-founded induction on the lexicographic path ordering from term rewriting theory"" suggests an alternative or complementary principle within the framework of syntactic finitism.
 - The abstract does not provide explicit definitions for these principles beyond their mention as part of syntactic finitism, nor does it discuss their orthogonality or level of abstraction in detail.","- ""One of the central goals of programming-language research is to develop mathematically sound formal methods for precisely specifying and reasoning about the behavior of programs.""
  - ""research into the development of logical systems that provide an automated means to apply—and verify the application of—trusted reasoning principles to concrete proofs.""
  - ""We posit the following questions: (1) what are these principles and (2) how much can we do with them?""
  - ""we propose an answer to the former by describing a philosophical viewpoint we refer to as syntactic finitism, in which the principles of case analysis and structural induction on abstract syntax are viewed as being a priori justified.""
  - ""We explore the latter question using some of the ideas and results from proof theory; along the way, we provide a syntactically finitary account of proofs by logical relations, and investigate the consequences of replacing structural induction with well-founded induction on the lexicographic path ordering from term rewriting theory.""
  - ""Finally, we argue that syntactically finitary proofs can be formalized in the proofs as logic programs paradigm popularized by the proof assistant Twelf; we prove the soundness of a modular termination-analysis that is central to the validity of this interpretation.""",,"- The abstract discusses the development of ""mathematically sound formal methods"" and ""logical systems"" for verifying proofs, indicating a focus on formal verification.
 - The concept of ""syntactic finitism"" is introduced as a philosophical viewpoint that justifies certain principles like case analysis and structural induction, suggesting a type of mathematical framework.
 - The mention of ""proof theory"" and ""proofs by logical relations"" indicates the use of specific mathematical properties and proof techniques.
 - The exploration of replacing structural induction with well-founded induction on the lexicographic path ordering suggests a focus on specific mathematical properties and techniques.
 - The formalization of proofs in the ""proofs as logic programs paradigm"" and the use of the Twelf proof assistant imply a type of mathematical framework.
 - The proof of ""soundness of a modular termination-analysis"" suggests a specific mathematical property guaranteed by the framework.","- ""One of the central goals of programming-language research is to develop mathematically sound formal methods for precisely specifying and reasoning about the behavior of programs.""
  - ""The boundary between trusted and untrusted reasoning principles is inherently blurry, and different researchers draw the line in different places.""
  - ""We posit the following questions: (1) what are these principles and (2) how much can we do with them?""
  - ""we propose an answer to the former by describing a philosophical viewpoint we refer to as syntactic finitism, in which the principles of case analysis and structural induction on abstract syntax are viewed as being a priori justified.""
  - ""We explore the latter question using some of the ideas and results from proof theory; along the way, we provide a syntactically finitary account of proofs by logical relations, and investigate the consequences of replacing structural induction with well-founded induction on the lexicographic path ordering from term rewriting theory.""
  - ""Finally, we argue that syntactically finitary proofs can be formalized in the proofs as logic programs paradigm popularized by the proof assistant Twelf; we prove the soundness of a modular termination-analysis that is central to the validity of this interpretation.""",,"- The abstract discusses the development of formal methods for specifying and reasoning about program behavior, which is a broad goal in programming language research.
 - It introduces the concept of ""syntactic finitism"" as a philosophical viewpoint that justifies certain principles like case analysis and structural induction.
 - The abstract mentions the exploration of these principles using proof theory and the investigation of replacing structural induction with well-founded induction.
 - It also discusses the formalization of syntactically finitary proofs in the context of logic programs and the proof assistant Twelf.
 - However, there is no explicit mention of integrating different programming paradigms, specific integration mechanisms, interaction models, constraints, or novel translation techniques related to paradigm integration.","- ""One of the central goals of programming-language research is to develop mathematically sound formal methods for precisely specifying and reasoning about the behavior of programs.""
  - ""The boundary between trusted and untrusted reasoning principles is inherently blurry, and different researchers draw the line in different places.""
  - ""We posit the following questions: (1) what are these principles and (2) how much can we do with them?""
  - ""we propose an answer to the former by describing a philosophical viewpoint we refer to as syntactic finitism, in which the principles of case analysis and structural induction on abstract syntax are viewed as being a priori justified.""
  - ""We explore the latter question using some of the ideas and results from proof theory; along the way, we provide a syntactically finitary account of proofs by logical relations, and investigate the consequences of replacing structural induction with well-founded induction on the lexicographic path ordering from term rewriting theory.""
  - ""Finally, we argue that syntactically finitary proofs can be formalized in the proofs as logic programs paradigm popularized by the proof assistant Twelf; we prove the soundness of a modular termination-analysis that is central to the validity of this interpretation.""",,"- The abstract discusses the development of formal methods for programming languages, focusing on mathematical soundness and reasoning about program behavior. However, it does not explicitly mention generic programming or abstraction mechanisms.
 - The concept of ""syntactic finitism"" is introduced, which involves principles like case analysis and structural induction on abstract syntax. This could be related to abstraction mechanisms, but it is not explicitly linked to generic programming.
 - The abstract mentions the use of proof theory and logical relations, which might relate to type systems and abstraction, but again, there is no direct mention of generic programming or specific mechanisms for representing generic abstractions.
 - There is no mention of minimal type requirements or static checking/optimization strategies related to generic programming.
 - The focus of the abstract is on syntactic finitism and its application to proof theory, rather than on generic programming or abstraction mechanisms.","- ""Although neither has an uncontroversial answer, in this dissertation we propose an answer to the former by describing a philosophical viewpoint we refer to as syntactic finitism, in which the principles of case analysis and structural induction on abstract syntax are viewed as being a priori justified.""
  - ""Finally, we argue that syntactically finitary proofs can be formalized in the proofs as logic programs paradigm popularized by the proof assistant Twelf; we prove the soundness of a modular termination-analysis that is central to the validity of this interpretation.""
  - ""We explore the latter question using some of the ideas and results from proof theory; along the way, we provide a syntactically finitary account of proofs by logical relations, and investigate the consequences of replacing structural induction with well-founded induction on the lexicographic path ordering from term rewriting theory.""
  - ""This phenomenon has motivated a great deal of research into the development of logical systems that provide an automated means to apply—and verify the application of—trusted reasoning principles to concrete proofs.""
  - ""One of the central goals of programming-language research is to develop mathematically sound formal methods for precisely specifying and reasoning about the behavior of programs.""
  - ""We posit the following questions: (1) what are these principles and (2) how much can we do with them?""",,"- The abstract discusses the central goal of developing mathematically sound formal methods for programming languages, which is a broad context for the study.
 - It highlights the need for automated means to apply and verify trusted reasoning principles, indicating a gap in current methods that the study aims to address.
 - The study proposes a philosophical viewpoint called ""syntactic finitism,"" which is a novel insight as it views certain principles as a priori justified, providing a new perspective on trusted reasoning principles.
 - The exploration of what can be done with these principles involves using proof theory and providing a syntactically finitary account of proofs by logical relations, which is a theoretical advancement beyond existing approaches.
 - The investigation of replacing structural induction with well-founded induction on the lexicographic path ordering is another theoretical contribution, as it explores new methods for proof verification.
 - The formalization of syntactically finitary proofs in the proofs as logic programs paradigm is a significant theoretical contribution, as it provides a new framework for formalizing proofs.
 - The soundness proof of a modular termination-analysis is a theoretical advancement that supports the validity of this new framework."
Foreword,J. Lapp,10.1889/1.1844655,https://doi.org/10.1889/1.1844655,IEEE International Conference on Robotics and Automation,0,2001,Not specified (the abstract does not provide explicit definitions or a list of conceptual primitives),"Not specified (the abstract mentions proof-theoretic approach, linear logic, and algebraic frameworks but does not provide specific details on mathematical properties, proof techniques, or limitations)",No specific integration approach described (the abstract implies integration through the use of different logical systems and frameworks but does not provide explicit details),Generic programming not extensively addressed,"- Key novel insights: Application of proof-theoretic approach to object-based concurrent systems, use of actor model for open distributed systems, linear logic for concurrent object-oriented programming.
 - Theoretical advancements: Proof-theoretic foundations for actor systems, linear logic for specifying concurrent programming concepts, hidden sorted algebra as an evolution of Algebraic Specification.
 - Potential implications: New theoretical foundations and frameworks for concurrent and object-oriented programming language design.","- ""The use of logic for system development concerns both the specification step and the study of the operational aspects (through proof analysis and construction) of such development.""
  - ""we have to identify and to study, on the one hand, the role and the treatment of objects (representation, inheritance, modularity, communication, and so on) in this context, and, on the other hand, the interaction of work on proofs and concurrency with the Object-Oriented Programming paradigm.""
  - ""The papers selected for this Special Issue address some of the topics discussed in the workshop. They present different alternative frameworks that are effectively based on a proof-theoretic approach.""
  - ""The paper entitled Proof-theoretic foundations for the design of actor systems shows that the actor model can also be used as a basis for the rigorous design of open distributed systems.""
  - ""The paper entitled A specification logic for concurrent object-oriented programming focuses on the use of linear logic as a language for specifying advanced concepts of programming – in particular the salient aspects of concurrent object-oriented programming.""
  - ""Another proposal for such a framework to deal with concurrent object-oriented features for software development can be based on algebra, mainly hidden sorted algebra, which can be seen as an evolution of Algebraic Specification to handle such features.""",,"- The abstract discusses the use of logic for system development, focusing on specification and operational aspects, which suggests a theoretical framework involving logical systems.
 - It mentions the study of objects and their treatment in the context of concurrency and object-oriented programming, indicating that these are conceptual primitives being considered.
 - The abstract references different frameworks based on a proof-theoretic approach, which implies that these frameworks might define specific conceptual primitives.
 - The mention of the actor model and linear logic suggests that these could be conceptual primitives used in the study.
 - The abstract does not provide explicit definitions or a list of conceptual primitives, nor does it discuss their orthogonality or level of abstraction.","- ""The use of logic for system development concerns both the specification step and the study of the operational aspects (through proof analysis and construction) of such development.""
  - ""The proof-theoretic approach is particularly well suited for describing not only how parts of a system perform computations but also properties that the whole system is required to fulfil, which is very important for designers and programmers.""
  - ""The paper entitled Proof-theoretic foundations for the design of actor systems shows that the actor model can also be used as a basis for the rigorous design of open distributed systems.""
  - ""The paper entitled A specification logic for concurrent object-oriented programming focuses on the use of linear logic as a language for specifying advanced concepts of programming – in particular the salient aspects of concurrent object-oriented programming.""
  - ""From a refined sequent calculus based on a proof-theoretical characterization of linear logic programming, an accurate encoding of traditional features of concurrent object-oriented programming (with encapsulation as the cornerstone) is proposed and analysed.""
  - ""Another proposal for such a framework to deal with concurrent object-oriented features for software development can be based on algebra, mainly hidden sorted algebra, which can be seen as an evolution of Algebraic Specification to handle such features.""",,"- The abstract discusses the use of logic for system development, specifically mentioning the ""proof-theoretic approach"" as a method for describing system properties. This suggests a focus on proof theory as a mathematical framework.
 - The mention of ""linear logic"" as a language for specifying programming concepts indicates that linear logic is a type of mathematical framework used in this context.
 - The abstract also refers to ""algebra, mainly hidden sorted algebra,"" as another framework for dealing with concurrent object-oriented features, indicating an algebraic approach.
 - The abstract does not specify particular mathematical properties guaranteed by these frameworks, nor does it detail specific proof techniques or limitations.
 - The abstract does not provide explicit details on the type of mathematical framework, specific properties guaranteed, proof techniques used, or limitations, which are required for a comprehensive answer.","- ""The papers selected for this Special Issue address some of the topics discussed in the workshop. They present different alternative frameworks that are effectively based on a proof-theoretic approach.""
  - ""The paper entitled A specification logic for concurrent object-oriented programming focuses on the use of linear logic as a language for specifying advanced concepts of programming – in particular the salient aspects of concurrent object-oriented programming.""
  - ""Another proposal for such a framework to deal with concurrent object-oriented features for software development can be based on algebra, mainly hidden sorted algebra, which can be seen as an evolution of Algebraic Specification to handle such features.""
  - ""The paper entitled Proof-theoretic foundations for the design of actor systems shows that the actor model can also be used as a basis for the rigorous design of open distributed systems.""
  - ""the interaction of work on proofs and concurrency with the Object-Oriented Programming paradigm.""",,"- The abstract discusses the interaction between proof theory, concurrency, and object-oriented programming, indicating a focus on integrating these paradigms.
 - The mention of ""different alternative frameworks"" suggests that various integration mechanisms are proposed, although specific details are not provided in the abstract.
 - The use of linear logic and algebra (hidden sorted algebra) as frameworks for specifying concurrent object-oriented programming suggests novel translation or embedding techniques.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, or constraints/challenges in paradigm integration, but it implies that these are addressed through the use of different logical systems and frameworks.","- ""The use of logic for system development concerns both the specification step and the study of the operational aspects (through proof analysis and construction) of such development.""
  - ""The papers selected for this Special Issue address some of the topics discussed in the workshop.""
  - ""They present different alternative frameworks that are effectively based on a proof-theoretic approach.""
  - ""The paper entitled Proof-theoretic foundations for the design of actor systems shows that the actor model can also be used as a basis for the rigorous design of open distributed systems.""
  - ""The proof-theoretic approach is particularly well suited for describing not only how parts of a system perform computations but also properties that the whole system is required to fulfil, which is very important for designers and programmers.""
  - ""The paper entitled A specification logic for concurrent object-oriented programming focuses on the use of linear logic as a language for specifying advanced concepts of programming – in particular the salient aspects of concurrent object-oriented programming.""
  - ""From a refined sequent calculus based on a proof-theoretical characterization of linear logic programming, an accurate encoding of traditional features of concurrent object-oriented programming (with encapsulation as the cornerstone) is proposed and analysed.""
  - ""Another proposal for such a framework to deal with concurrent object-oriented features for software development can be based on algebra, mainly hidden sorted algebra, which can be seen as an evolution of Algebraic Specification to handle such features.""",,"- The abstract discusses the use of logic for system development, which includes specification and operational aspects. This suggests a focus on formal methods rather than generic programming.
 - The mention of ""different alternative frameworks"" and ""proof-theoretic approach"" indicates a focus on theoretical foundations rather than generic programming methodologies.
 - The abstract does not explicitly mention generic programming or abstraction mechanisms related to genericity.
 - The focus on ""proof-theoretic foundations"" and ""specification logic"" suggests a theoretical approach rather than practical generic programming techniques.
 - The abstract does not provide any information on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.","- ""The papers selected for this Special Issue address some of the topics discussed in the workshop. They present different alternative frameworks that are effectively based on a proof-theoretic approach.""
  - ""They illustrate, from different points of view, the interest, potentialities and difficulties of dealing with such an approach in the design of object-based concurrent systems.""
  - ""The paper entitled Proof-theoretic foundations for the design of actor systems shows that the actor model can also be used as a basis for the rigorous design of open distributed systems.""
  - ""The proof-theoretic approach is particularly well suited for describing not only how parts of a system perform computations but also properties that the whole system is required to fulfil, which is very important for designers and programmers.""
  - ""The paper entitled A specification logic for concurrent object-oriented programming focuses on the use of linear logic as a language for specifying advanced concepts of programming – in particular the salient aspects of concurrent object-oriented programming.""
  - ""From a refined sequent calculus based on a proof-theoretical characterization of linear logic programming, an accurate encoding of traditional features of concurrent object-oriented programming (with encapsulation as the cornerstone) is proposed and analysed.""
  - ""Another proposal for such a framework to deal with concurrent object-oriented features for software development can be based on algebra, mainly hidden sorted algebra, which can be seen as an evolution of Algebraic Specification to handle such features.""",,"- The abstract discusses the use of a proof-theoretic approach in the design of object-based concurrent systems, which is a novel insight as it applies theoretical foundations to practical system design.
 - The application of the actor model for the rigorous design of open distributed systems is highlighted as a theoretical contribution, as it provides a new basis for system design.
 - The use of linear logic for specifying concurrent object-oriented programming concepts is another theoretical advancement, as it offers a new language for programming specifications.
 - The proposal of using hidden sorted algebra as an evolution of Algebraic Specification to handle concurrent features is a theoretical innovation, as it provides a new framework for software development.
 - These contributions have potential implications for programming language design by providing new theoretical foundations and frameworks for concurrent and object-oriented programming."
of Logic,-,-,-,-,3,2022,Not specified (the abstract discusses theoretical framework and semantics but does not explicitly define conceptual primitives for reconstructing programming paradigms),"- Type of mathematical framework: Predicate calculus
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described (the abstract focuses on theoretical underpinnings and semantics rather than practical integration strategies),"Generic programming not extensively addressed (the abstract focuses on logic programming and predicate calculus, but does not explicitly address generic programming methodologies or type systems)","- Key novel insights: The logic programming paradigm's ability to produce multiple answers and allow selection between them.
 - Theoretical advancements: Shallow embedding into the predicate calculus to define semantics; atomic commands as predicates and operators as transformations on these predicates.
 - Potential implications: Simplification of impure features like negation and cut in Prolog; structured understanding and manipulation of programming language elements.","- ""A theory of programming is intended to support the practice of programming by relating each program to the specification of what it is intended to achieve.""
  - ""A distinctive characteristic of the logic programming paradigm is that each execution of a program produces not just a single answer but a collection of answers, allowing the later parts of the program to select between them.""
  - ""A specification of such a program is therefore just a predicate describing the size, content, and other properties of the set of options offered.""
  - ""The actual behaviour of a particular program is also described by a predicate, namely the strongest specification that it is certain to satisfy.""
  - ""The program is correct if this behavioural predicate logically implies its specification.""
  - ""The semantics of the programming language is given by a shallow embedding into the predicate calculus.""
  - ""Atomic commands are predicates, and the operators of a programming language are defined as transformations on these predicates.""
  - ""The familiar and and or of logic programming are specified to combine their offer sets by intersection or union, so as to permit parallel implementation.""",,"- The abstract discusses the theoretical framework of logic programming, focusing on how programs relate to their specifications and the use of predicates to describe program behavior.
 - It mentions that each program execution produces a collection of answers, which is a key characteristic of the logic programming paradigm.
 - The abstract defines the specification and behavior of programs using predicates, which are fundamental to the logic programming paradigm.
 - The semantics of the programming language are described using a shallow embedding into predicate calculus, indicating that predicates are a core conceptual primitive.
 - Atomic commands are defined as predicates, and operators are transformations on these predicates, suggesting that predicates are a basic building block.
 - The abstract does not explicitly list conceptual primitives or provide a detailed definition of them in the context of reconstructing programming paradigms.
 - The focus is on the theoretical framework and semantics rather than explicitly defining conceptual primitives for reconstructing paradigms.","- ""The semantics of the programming language is given by a shallow embedding into the predicate calculus.""
  - ""Atomic commands are predicates, and the operators of a programming language are defined as transformations on these predicates.""
  - ""The familiar and and or of logic programming are specified to combine their offer sets by intersection or union, so as to permit parallel implementation.""",,"- The abstract mentions that the semantics of the programming language is given by a ""shallow embedding into the predicate calculus."" This indicates that the mathematical framework used is based on predicate calculus, which is a branch of mathematical logic.
 - The use of predicate calculus suggests that the framework is likely based on first-order logic or a similar logical system, as these are common foundations for predicate calculus.
 - The abstract describes atomic commands as predicates and operators as transformations on these predicates, which aligns with the formalism of predicate calculus.
 - The mention of combining offer sets by intersection or union suggests the use of set theory, which is often integrated with predicate calculus in formal verification.
 - There is no explicit mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.","- ""A theory of programming is intended to support the practice of programming by relating each program to the specification of what it is intended to achieve.""
  - ""An unifying theory is one that is applicable to a general paradigm of computing, supporting the classification of many programming languages as correct instances of the paradigm.""
  - ""A distinctive characteristic of the logic programming paradigm is that each execution of a program produces not just a single answer but a collection of answers, allowing the later parts of the program to select between them.""
  - ""The semantics of the programming language is given by a shallow embedding into the predicate calculus.""
  - ""Atomic commands are predicates, and the operators of a programming language are defined as transformations on these predicates.""
  - ""The familiar and and or of logic programming are specified to combine their offer sets by intersection or union, so as to permit parallel implementation.""",,"- The abstract discusses the concept of a unifying theory that applies to a general paradigm of computing, which suggests a broad approach to integrating different programming paradigms by classifying them under a common framework.
 - The focus on logic programming and its characteristics indicates that the integration approach might involve using logic programming principles to unify other paradigms.
 - The mention of ""shallow embedding into the predicate calculus"" suggests a novel translation or embedding technique, as it involves integrating programming languages into a logical framework.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models between paradigms, or constraints/challenges in paradigm integration. It focuses more on the theoretical underpinnings and semantics rather than practical integration strategies.","- ""A theory of programming is intended to support the practice of programming by relating each program to the specification of what it is intended to achieve.""
  - ""An unifying theory is one that is applicable to a general paradigm of computing, supporting the classification of many programming languages as correct instances of the paradigm.""
  - ""A distinctive characteristic of the logic programming paradigm is that each execution of a program produces not just a single answer but a collection of answers, allowing the later parts of the program to select between them.""
  - ""The semantics of the programming language is given by a shallow embedding into the predicate calculus.""
  - ""Atomic commands are predicates, and the operators of a programming language are defined as transformations on these predicates.""
  - ""Explicit mention of the complete set of answers simplifies definition of so-called impure features, such as the negation and the cut of Prolog.""",,"- The abstract discusses a theory of programming and its application to a general paradigm of computing, which suggests a focus on abstraction mechanisms.
 - The mention of a ""unifying theory"" implies a level of genericity in the approach, as it applies to multiple programming languages.
 - The use of ""predicate calculus"" and ""predicates"" as atomic commands indicates a mechanism for representing abstractions, as predicates can be seen as abstract representations of program behavior.
 - The abstract does not explicitly mention ""minimal type requirements"" or ""static checking or optimization strategies,"" which are typically associated with generic programming methodologies.
 - The focus on logic programming and predicate calculus suggests a conceptual abstraction mechanism, but it does not explicitly address generic programming in terms of type systems or static checking.","- ""A distinctive characteristic of the logic programming paradigm is that each execution of a program produces not just a single answer but a collection of answers, allowing the later parts of the program to select between them.""
  - ""A theory of programming is intended to support the practice of programming by relating each program to the specification of what it is intended to achieve.""
  - ""The semantics of the programming language is given by a shallow embedding into the predicate calculus.""
  - ""Atomic commands are predicates, and the operators of a programming language are defined as transformations on these predicates.""
  - ""Explicit mention of the complete set of answers simplifies definition of so-called impure features, such as the negation and the cut of Prolog.""",,"- The abstract discusses a theory of programming that relates programs to their specifications, which is a foundational contribution to understanding how programming languages are structured and validated.
 - The logic programming paradigm's ability to produce multiple answers and allow selection between them is highlighted as a distinctive characteristic, which suggests a novel insight into how programming languages can be designed to handle multiple outcomes.
 - The use of a shallow embedding into the predicate calculus to define the semantics of the programming language is a theoretical advancement, as it provides a formal framework for understanding the language's behavior.
 - The definition of atomic commands as predicates and operators as transformations on these predicates is a theoretical contribution, as it provides a structured way to understand and manipulate programming language elements.
 - The simplification of impure features like negation and cut in Prolog through explicit mention of complete answer sets is a theoretical innovation, as it addresses a complex aspect of programming language design."
Multiparty Languages: The Choreographic and 1 Multitier Cases 2,"Saverio Giallorenzo, F. Montesi, Marco Peressotti, David Richter, G. Salvaneschi, P. Weisenburger, Guida Salvaneschi",-,-,-,11,-,Not specified (the abstract does not provide explicit definitions or names of the conceptual primitives),"- Type of mathematical framework: Process calculi and lambda calculus
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Algorithms to translate one paradigm into the other.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Algorithms for translating one paradigm into the other.",Generic programming not extensively addressed,"- Key novel insights: The surprising similarity between choreographic and multitier languages.
 - Theoretical advancements: Identification of core abstractions that differentiate the two approaches and development of algorithms to translate between them.
 - Potential implications: Facilitating joint research and cross-fertilization between communities, potentially leading to more integrated or flexible programming models.",,,"- The abstract mentions that choreographic languages provide primitives for expressing multiparty communication protocols, but it does not specify what these primitives are.
 - Similarly, multitier languages are described as supporting primitives for changing the location of execution, but again, no specific primitives are listed.
 - The abstract discusses the isolation of core abstractions and algorithms for translation between the two paradigms, but it does not provide explicit definitions or names of these primitives.
 - The level of abstraction and orthogonality of the primitives are not discussed in the abstract.",,,"- The abstract mentions that choreographic languages and multitier languages are rooted in different theoretical underpinnings: process calculi and lambda calculus. This suggests that these are the mathematical frameworks used to formalize and guarantee properties of the conceptual primitives.
 - Process calculi are a type of mathematical framework used to model concurrent systems and interactions, which aligns with the focus on multiparty communication protocols in choreographic languages.
 - Lambda calculus is a mathematical framework used to formalize computation and is relevant to multitier languages that enable programming across different tiers of a distributed system.
 - The abstract does not provide specific details about the mathematical properties guaranteed, proof techniques used, or limitations of these frameworks. It only mentions the theoretical underpinnings and the translation algorithms between the two paradigms.",,,"- The abstract discusses two programming paradigms: choreographic languages and multitier languages. Choreographic languages focus on multiparty communication protocols, while multitier languages focus on computation across different tiers of a distributed system.
 - The abstract mentions that these paradigms have been investigated independently with different theoretical underpinnings (process calculi and lambda calculus), indicating a historical separation between the two.
 - The study claims to show that these two paradigms are surprisingly similar, suggesting a potential for integration.
 - The abstract mentions isolating core abstractions and providing algorithms to translate one paradigm into the other, which implies a specific integration mechanism.
 - The mention of algorithms for translation suggests a novel translation technique.
 - The abstract does not explicitly mention interaction models or constraints/challenges in paradigm integration, but it does imply a theoretical integration strategy by highlighting the similarity and potential for cross-fertilization between the two paradigms.",,,"- The abstract discusses choreographic and multitier languages, focusing on their ability to express multiparty communication protocols and computation across distributed systems.
 - It mentions the theoretical underpinnings of these languages, such as process calculi and lambda calculus, which are relevant to abstraction mechanisms.
 - The abstract highlights the similarity between choreographic and multitier languages and the isolation of core abstractions, which suggests some level of abstraction mechanism discussion.
 - However, there is no explicit mention of generic programming methodology, type system discussions, or specific mechanisms for representing generic abstractions.
 - The abstract does not provide details on minimal type requirements or static checking/optimization strategies related to generic programming.",,,"- The abstract highlights the primary focus on choreographic and multitier languages, which are two distinct paradigms in programming language design.
 - It notes that these paradigms have been studied independently with different theoretical foundations (process calculi and lambda calculus), indicating a gap in understanding their relationship.
 - The novelty lies in the discovery of a surprising similarity between these two languages, which challenges the existing independent research trajectories.
 - The theoretical contribution is the identification of core abstractions that differentiate these languages and the development of algorithms to translate between them, which is a new insight.
 - This work has potential implications for programming language design by suggesting a path for integrating or aligning these paradigms, which could lead to more efficient or flexible programming models.
 - The abstract suggests that this work could facilitate joint research and cross-fertilization between the communities studying these paradigms, which is a significant theoretical advancement."
A logical theory of concurrent objects and its realization in the Maude language,J. Meseguer,10.7551/mitpress/2087.003.0017,https://doi.org/10.7551/mitpress/2087.003.0017,-,304,1993,"1. Primitive Name: Rewriting Logic
  Definition: A simple logic where concurrent object-oriented computation corresponds to logical deduction.
  Orthogonality Score: High
 

 2. Primitive Name: Axiomatization of Objects and Classes
  Definition: Axiomatization of objects, classes, and concurrent computations in terms of rewriting logic.
  Orthogonality Score: High
 

 3. Primitive Name: Object Representation
  Definition: Representation of objects as terms with identifiers, classes, attribute identifiers, and values.
  Orthogonality Score: High
 

 4. Primitive Name: ACI-Operator
  Definition: Structuring the distributed state as a multiset using the ACI-operator.
  Orthogonality Score: High
 

 5. Primitive Name: Initial Models
  Definition: Mathematical semantics based on initial models that correspond to concurrent systems.
  Orthogonality Score: High","- Type of mathematical framework: Rewriting logic, category theory
 - Specific mathematical properties guaranteed: Soundness, completeness, initial models
 - Proof techniques used: Initial models, reflection functors, initial machines
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Use of rewriting logic as a unifying framework; mappings between logics to relate syntax, sentences, entailments, and models.
 - Interaction models between paradigms: Mappings between logics facilitate interaction and translation between different paradigms.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Prolog programs can be viewed as MaudeLog programs after a simple translation.","Maude supports generic programming through parameterized modules and views, with minimal type requirements defined by trivial theories like TRIV. The type system uses order-sorted structures and sort constraints to enhance abstraction, and the semantics are based on initial order-sorted algebras for static checking and optimization.","- Introduction of a new theory of concurrent objects based on rewriting logic.
 - Use of rewriting logic as a semantic framework for concurrent object-oriented programming.
 - Unification of functional, relational, and concurrent object-oriented programming paradigms through rewriting logic.
 - Development of a model theory for rewriting logic and its application to Maude modules.
 - Generalization of equational logic to rewriting logic for broader applications in concurrent systems programming.","- ""A new theory of concurrent objects is presented.""
  - ""The theory has the important advantage of being based directly on a simple logic called rewriting logic in which concurrent object-oriented computation exactly corresponds to logical deduction.""
  - ""This axiomatization of objects, classes, and concurrent object-oriented computations in terms of rewriting logic is proposed as a general semantic framework for object-oriented programming.""
  - ""A direct fruit of this theory is a new language, called Maude, that can be used to program concurrent object-oriented systems in an entirely declarative way using rewriting logic.""
  - ""Rewriting logic is defined, and concurrent rewriting is formalized as deduction in such a logic.""
  - ""The key idea is to conceptualize the distributed state of a concurrent object-oriented system-called a configuration-as a multiset of objects and messages that evolves by concurrent ACI -rewriting using rules that describe the effects of communication events between some objects and messages.""
  - ""An object in a given state is represented as a term
 

 where O is the object's name or identifier, C is its class, the a i 's are the names of the object's attribute identifiers, and the v i 's are the corresponding values.""
  - ""The ACI -operator plays a role entirely similar to that played by the operator with the same syntax used for Petri nets, namely that of structuring the distributed state as a multiset.""
  - ""Rewriting logic is sound and complete and has initial models.""
  - ""The mathematical semantics of Maude modules is based on such initial models which intuitively correspond to concurrent systems2""",,"- The paper introduces a new theory of concurrent objects based on rewriting logic, which is a conceptual primitive for reconstructing programming paradigms.
 - Rewriting logic is defined as a simple logic where concurrent object-oriented computation corresponds to logical deduction, serving as a foundational primitive.
 - The axiomatization of objects, classes, and concurrent computations in rewriting logic is a key conceptual primitive for object-oriented programming.
 - The representation of objects as terms with identifiers, classes, attribute identifiers, and values is another primitive.
 - The use of the ACI-operator to structure the distributed state as a multiset is a primitive for handling concurrency.
 - The soundness and completeness of rewriting logic, along with its initial models, provide a mathematical foundation for these primitives.","- ""A new theory of concurrent objects is presented. The theory has the important advantage of being based directly on a simple logic called rewriting logic in which concurrent object-oriented computation exactly corresponds to logical deduction.""
  - ""Rewriting logic is sound and complete and has initial models.""
  - ""The mathematical semantics of Maude modules is based on such initial models which intuitively correspond to concurrent systems2""
  - ""A precise account of the model theory of rewriting logic, giving rise to an initial model semantics for Maude modules and fully consistent with the above system-oriented interpretation, is given in Section 8.""
  - ""the rules of rewriting logic are rules to reason about change in a concurrent system""
  - ""the models of a rewrite theory are systems. By a ""system"" we of course mean a machine-like entity that can be in a variety of states, and that can change its state by performing certain transitions.""
  - ""The general notion of model, called an R-system, is defined as follows:
 

 Given a rewrite theory R = (Σ, E, L, R), an R-system S is a category S together with:
 

 • a (Σ, E)-algebra structure given by a family of functors""
  - ""The category T R (X) is just one among many models that can be assigned to the rewrite theory R.""
  - ""The table of Figure 12 summarizes our present discussion.""
  - ""The reflection functor associated with the inclusion R-Preord ⊆ R-Sys sends T R (X) to the familiar R-rewriting relation30 → R(X) on E-equivalence classes of terms with variables in X.""
  - ""the semantics of a system module mod R endm not having any functional submodules, we propose the initial machine in R-Mach/R-Preord""",,"- The paper introduces rewriting logic as the mathematical framework used to formalize concurrent object-oriented computation. This framework is based on logical deduction.
 - Rewriting logic is described as sound and complete, with initial models, which are used to provide mathematical semantics for Maude modules.
 - The model theory of rewriting logic is discussed, with an emphasis on initial model semantics for Maude modules.
 - The framework involves category theory, as indicated by the use of terms like ""category"" and ""functors"" in describing the models of rewrite theories.
 - The paper mentions the use of initial models and preorder, poset, and algebra models, which are specific mathematical properties guaranteed by the framework.
 - The framework is used to reason about change in concurrent systems, indicating a focus on dynamic behavior.
 - The paper discusses the use of reflection functors and initial machines in providing semantics for Maude modules, which are part of the proof techniques used.
 - The framework is designed to handle concurrency and object-oriented programming, but there is no explicit mention of limitations or constraints.","- ""A direct fruit of this theory is a new language, called Maude, that can be used to program concurrent object-oriented systems in an entirely declarative way using rewriting logic.""
  - ""Maude naturally unifies the functional programming paradigm with concurrent objectoriented programming and contains (a slight linguistic variant of) the OBJ language [45,53] as its functional sublanguage.""
  - ""An extension of Maude called MaudeLog [73]-also based entirely on rewriting logic-unifies the three paradigms of functional, relational, and concurrent object-oriented programming.""
  - ""For designing multiparadigm logic programming languages, a key technical tool is the use of mappings between logics that relate the syntax, sentences, entailments, and models of two different logics by appropriate translations.""
  - ""In the case of Maude and MaudeLog, what is done is to define a new logic-rewriting logicin which concurrent computations-and in particular concurrent object-oriented computationscan be expressed in a natural way, and then to formally relate this logic to the logics of the functional and relational paradigms, i.e., to equational logic and to Horn logic, by means of maps of logics that provide a simple and rigorous unification of paradigms.""
  - ""The details of this map of logics are discussed in Appendix B of [73]. At the programming language level, such a map corresponds to the inclusion of Maude's functional modules (essentially identical to OBJ3 modules) within the language.""
  - ""The difference between Maude and MaudeLog does not consist in any change in the underlying logic; indeed, both languages are based on rewriting logic, and both have rewrite theories as programs.""
  - ""The above map of logics means that, after a simple translation, we can view a (pure) Prolog program as a MaudeLog program.""",,"- The paper discusses the integration of different programming paradigms through the use of rewriting logic as a unifying framework. This is evident from the introduction of Maude and MaudeLog, which are designed to integrate functional, relational, and concurrent object-oriented programming paradigms.
 - The integration mechanism involves defining a new logic, rewriting logic, which can naturally express concurrent computations and then relating this logic to other paradigms through mappings. This is a key technical tool for achieving multiparadigm integration.
 - The interaction model between paradigms is facilitated by these mappings, which allow for the translation of syntax, sentences, entailments, and models between different logics. This enables a seamless integration of different programming styles within a single framework.
 - The paper does not explicitly mention specific constraints or challenges in paradigm integration, but it does highlight the simplicity and rigor of the integration approach through rewriting logic.
 - A novel translation technique is mentioned where a Prolog program can be viewed as a MaudeLog program after a simple translation, indicating a flexible embedding of relational programming within the MaudeLog framework.","- ""the parameter theory is the trivial theory TRIV.""
  - ""Maude supports a highly modular and parameterized programming style, contains OBJ3 as a functional sublanguage, and provides a simple and semantically rigorous unification of functional programming and concurrent object-oriented programming.""
  - ""The set of elements is a parameter that can be instantiated to any set; therefore, as in the previous example, the parameter theory is the trivial theory TRIV.""
  - ""The expressiveness of the order-sorted type structure can be further increased by the declaration of axioms called sort constraints""",,"- The paper discusses Maude's support for a modular and parameterized programming style, which is a key aspect of generic programming. This indicates that Maude allows for the creation of generic abstractions through parameterized modules.
 - Parameterized modules in Maude can be instantiated with specific data types or structures, which is a mechanism for representing generic abstractions. This is achieved through the use of ""views"" that map parameter sorts to actual sorts in the module.
 - The concept of ""trivial theory TRIV"" is mentioned as a minimal type requirement, which only requires a set of elements. This suggests that Maude's type system allows for minimal type requirements to enable generic programming.
 - The use of order-sorted type structures and sort constraints in Maude enhances the expressiveness of the type system, allowing for more flexible and abstract representations of data types.
 - The mathematical semantics of Maude modules is based on initial order-sorted algebras, which provide a rigorous foundation for static checking and optimization strategies.","- ""A new theory of concurrent objects is presented. The theory has the important advantage of being based directly on a simple logic called rewriting logic in which concurrent object-oriented computation exactly corresponds to logical deduction.""
  - ""Rewriting logic provides not only a semantic framework, but also a computational model for concurrent object-oriented programming.""
  - ""Maude naturally unifies the functional programming paradigm with concurrent objectoriented programming and contains (a slight linguistic variant of) the OBJ language [45,53] as its functional sublanguage.""
  - ""The main difficulty has to do with logic, because the logics on which functional and relational programming are based-namely, equational logic (in either a first-order or a higher-order version) and first-order Horn logic, respectively-describe unchanging Platonic structures such as sets, functions and relations as it is fitting for logics originally introduced to develop logical foundations for mathematics.""
  - ""Rewriting logic is sound and complete and has initial models.""
  - ""The model theory of rewriting logic and an initial model semantics for Maude modules are also discussed.""
  - ""The paper discusses in more detail all the aspects just mentioned about rewriting logic as a semantic framework for concurrent object-oriented programming and about the Maude language, and illustrates many of the ideas with examples.""
  - ""The same high standards of mathematical rigor enjoyed by equational logic can be maintained in giving semantics to a language like Maude in the broader context of rewriting logic.""
  - ""This paper has presented a general semantic framework for object-oriented programming based on rewriting logic that is intrinsically concurrent and provides a simple and rigorous account of key concepts such as objects, classes and class inheritance, concurrent object-oriented synchronous and asynchronous communication, autonomous objects, and object creation and deletion.""",,"- The paper introduces a new theory of concurrent objects based on rewriting logic, which is a significant theoretical contribution. This theory provides a semantic framework for concurrent object-oriented programming that is intrinsically concurrent.
 - The use of rewriting logic as a basis for concurrent object-oriented programming is novel because it directly corresponds to logical deduction, providing a rigorous and simple framework.
 - The paper advances beyond existing approaches by unifying functional, relational, and concurrent object-oriented programming paradigms through rewriting logic, which is a significant theoretical advancement.
 - The development of Maude and MaudeLog languages based on rewriting logic provides a practical implementation of these theoretical contributions, but the focus here is on the theoretical innovations.
 - The paper discusses the model theory of rewriting logic and its application to Maude modules, which is a theoretical contribution to the field of programming language design.
 - The generalization of equational logic to rewriting logic expands the field of applications for rewrite rule programming, particularly for concurrent systems, which is a theoretical advancement."
"Choreographies, Computationally","L. Cruz-Filipe, F. Montesi",-,-,arXiv.org,4,2015,Not specified (the abstract does not explicitly define or list specific conceptual primitives),"Not specified (the abstract does not explicitly mention the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework)",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of Choreographic Programming for deadlock-free concurrent programs; Minimal Choreographies (MC) as a minimal language for Turing completeness.
 - Theoretical advancements: MC is minimal wrt Turing completeness; methodology provides a natural notion of computation for choreographies.
 - Potential implications: Automatic generation of concurrent implementations; projection of MC to a deadlock-free and Turing complete process calculus.","- ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""
  - ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""
  - ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""
  - ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""MC is minimal wrt Turing completeness: it implements all computable functions, and restricting its syntax breaks this property.""",,"- The abstract introduces ""Minimal Choreographies (MC)"" as a language that includes ""only the essential primitives of the paradigm."" This suggests that MC is a foundational element in defining the conceptual primitives for Choreographic Programming.
 - The abstract does not explicitly list or define specific conceptual primitives. Instead, it focuses on the properties of MC, such as being minimal with respect to Turing completeness and its ability to generate concurrent implementations.
 - The mention of MC being ""minimal wrt Turing completeness"" implies that the primitives are fundamental to achieving Turing completeness, but the abstract does not specify what these primitives are.
 - The abstract discusses the methodology and results related to MC, but it does not provide explicit definitions or names of the conceptual primitives.","- ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""
  - ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""
  - ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""
  - ""MC is minimal wrt Turing completeness: it implements all computable functions, and restricting its syntax breaks this property.""",,"- The abstract discusses the foundations of Choreographic Programming, which suggests a focus on theoretical foundations.
 - The introduction of Minimal Choreographies (MC) as a language with essential primitives indicates a formal approach to defining the paradigm.
 - The mention of MC being minimal with respect to Turing completeness implies a focus on computational properties, specifically ensuring that the language can implement all computable functions.
 - The methodology leading to a natural notion of computation and automatic generation of concurrent implementations suggests a formal verification process.
 - The projection of a Turing complete fragment of MC to a process calculus indicates a synthesis process, which is a common technique in formal verification.
 - However, the abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) used, nor does it specify the proof techniques or limitations of the framework.","- ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""
  - ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""
  - ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""",,"- The abstract discusses the introduction of Minimal Choreographies (MC) as a language that includes the essential primitives for Choreographic Programming. This suggests a focus on developing a specific paradigm rather than integrating multiple paradigms.
 - The mention of generating concurrent implementations of independent computations automatically implies a focus on the internal workings of the Choreographic Programming paradigm rather than integration with other paradigms.
 - The projection of a Turing complete fragment of MC to a process calculus is a synthesis step, which could be interpreted as a form of integration. However, this is more about translating one paradigm into another rather than integrating multiple paradigms.
 - There is no explicit mention of specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques related to integrating different programming paradigms.","- ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""
  - ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""
  - ""MC is minimal wrt Turing completeness: it implements all computable functions, and restricting its syntax breaks this property.""
  - ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""",,"- The abstract discusses the introduction of Minimal Choreographies (MC) as a language that includes only the essential primitives of Choreographic Programming. This suggests a focus on foundational elements rather than generic programming or abstraction mechanisms.
 - The mention of MC being ""minimal wrt Turing completeness"" indicates a focus on computational completeness rather than genericity or abstraction.
 - The abstract does not explicitly mention generic programming, type systems, or abstraction mechanisms, which are key components of genericity and abstraction.
 - The focus is on the methodology for generating concurrent implementations and the projection to a process calculus, which does not directly relate to generic programming or abstraction mechanisms.","- ""We investigate the foundations of Choreographic Programming, a paradigm for writing concurrent programs that are deadlock free by construction, guided by the notion of computation.""
  - ""Finally, we show that a Turing complete fragment of MC can be correctly projected to a process calculus (synthesis), which is thus both deadlock free and Turing complete.""
  - ""Our methodology yields a natural notion of computation for choreographies, which can be used to generate concurrent implementations of independent computations automatically.""
  - ""We start by introducing Minimal Choreographies (MC), a language that includes only the essential primitives of the paradigm.""
  - ""MC is minimal wrt Turing completeness: it implements all computable functions, and restricting its syntax breaks this property.""",,"- The abstract introduces Choreographic Programming as a paradigm for writing deadlock-free concurrent programs, which is a novel approach to ensuring concurrency without deadlocks.
 - The introduction of Minimal Choreographies (MC) as a language with only essential primitives suggests a theoretical contribution in defining a minimal set of operations necessary for Turing completeness.
 - The fact that MC is minimal with respect to Turing completeness indicates a theoretical advancement in understanding the fundamental requirements for computability in choreographies.
 - The methodology providing a natural notion of computation for choreographies is a key novel insight, as it enables automatic generation of concurrent implementations.
 - The projection of a Turing complete fragment of MC to a process calculus that is both deadlock-free and Turing complete is a significant theoretical contribution, as it bridges the gap between theoretical foundations and practical implementation."
Considerations on genericity for programming language design,H. Gast,-,-,-,1,1999,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described,"- Definition of ""concept"" used: Not mentioned
 - Mechanisms for representing generic abstractions: Describing programming language constructs using calculus, including overload resolution, higher-order functions, and type constructors with contravariant argument positions
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Automatic instantiation of generic algorithms with bounded type variables (type classes)","- Key novel insights: Proposal of a general approach to the design and implementation of a type system.
 - Theoretical advancements: Description of programming language constructs using calculus, including overload resolution, higher-order functions, and type constructors with contravariant argument positions.
 - Potential implications: General approach to type system design and detailed framework for programming language constructs.","- ""In this essay we propose a general approach to the design and implementation of a type system.""
  - ""The generic programming paradigm has received considerable attention since the publication of the C STL library [20].""
  - ""The speci cation of capabilities, which a programming language must provide to support generic programming, has been examined in detail in [26] and [31].""
  - ""We then discuss how programming language constructs can be described by means of the calculus, including overload resolution, higher-order functions and type constructors with contravariant argument positions together with automatic instantiation of generic algorithms with bounded type variables (type classes).""",,"- The abstract mentions the generic programming paradigm and its requirements, but it does not explicitly define conceptual primitives.
 - The mention of a ""general approach to the design and implementation of a type system"" suggests a focus on type systems, but no specific primitives are listed.
 - The discussion of programming language constructs such as ""overload resolution, higher-order functions and type constructors with contravariant argument positions"" and ""automatic instantiation of generic algorithms with bounded type variables (type classes)"" indicates topics related to generic programming, but these are not explicitly defined as conceptual primitives.
 - The abstract does not provide precise definitions or orthogonality scores for any conceptual primitives.","- ""In this essay we propose a general approach to the design and implementation of a type system.""
  - ""The speci cation of capabilities, which a programming language must provide to support generic programming, has been examined in detail in [26] and [31].""
  - ""The generic programming paradigm has received considerable attention since the publication of the C STL library [20].""
  - ""We then discuss how programming language constructs can be described by means of the calculus, including overload resolution, higher-order functions and type constructors with contravariant argument positions together with automatic instantiation of generic algorithms with bounded type variables (type classes).""",,"- The abstract mentions the generic programming paradigm and the specification of capabilities for supporting it, but it does not explicitly mention a mathematical framework.
 - The mention of ""a general approach to the design and implementation of a type system"" suggests a focus on type theory, but this is not explicitly stated as a mathematical framework.
 - The abstract discusses programming language constructs being described by means of ""the calculus,"" which could imply a mathematical framework, but it does not specify the type of calculus or its mathematical properties.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.
 - Overall, the abstract does not provide explicit details about a mathematical framework used to formalize and guarantee properties of the conceptual primitives.","- ""we propose a general approach to the design and implementation of a type system.""
  - ""We then discuss how programming language constructs can be described by means of the calculus, including overload resolution, higher-order functions and type constructors with contravariant argument positions together with automatic instantiation of generic algorithms with bounded type variables (type classes).""
  - ""The speci cation of capabilities, which a programming language must provide to support generic programming, has been examined in detail in [26] and [31].""
  - ""The generic programming paradigm has received considerable attention since the publication of the C STL library [20].""",,"- The abstract mentions the generic programming paradigm, which suggests a focus on this paradigm rather than integration of multiple paradigms.
 - The discussion of a ""general approach to the design and implementation of a type system"" and the description of programming language constructs using calculus does not explicitly address the integration of different programming paradigms.
 - There is no mention of specific integration mechanisms, interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.
 - The abstract does not provide any information on how different programming paradigms are integrated or interact with each other.","- ""In this essay we propose a general approach to the design and implementation of a type system.""
  - ""The generic programming paradigm has received considerable attention since the publication of the C STL library [20].""
  - ""The speci cation of capabilities, which a programming language must provide to support generic programming, has been examined in detail in [26] and [31].""
  - ""We then discuss how programming language constructs can be described by means of the calculus, including overload resolution, higher-order functions and type constructors with contravariant argument positions together with automatic instantiation of generic algorithms with bounded type variables (type classes).""",,"- The abstract mentions the generic programming paradigm and its increasing attention, indicating that genericity is a focus of the study.
 - The specification of capabilities for supporting generic programming is referenced, suggesting that the study examines the requirements for generic programming.
 - The proposal of a general approach to the design and implementation of a type system implies that the study addresses type system discussions, which are crucial for generic programming.
 - The mention of describing programming language constructs using calculus, including overload resolution, higher-order functions, and type constructors, indicates mechanisms for representing generic abstractions.
 - The reference to automatic instantiation of generic algorithms with bounded type variables (type classes) suggests a mechanism for static checking or optimization strategies.
 - The abstract does not explicitly define a ""concept"" used or list minimal type requirements, but it does discuss type system implementation and mechanisms for generic abstractions.","- ""In this essay we propose a general approach to the design and implementation of a type system.""
  - ""We then discuss how programming language constructs can be described by means of the calculus, including overload resolution, higher-order functions and type constructors with contravariant argument positions together with automatic instantiation of generic algorithms with bounded type variables (type classes).""
  - ""The speci cation of capabilities, which a programming language must provide to support generic programming, has been examined in detail in [26] and [31].""
  - ""The generic programming paradigm has received considerable attention since the publication of the C STL library [20].""",,"- The abstract mentions that the generic programming paradigm has received considerable attention, indicating a context where existing work has already been done, but it does not specify what is novel about the current study.
 - The mention of previous examinations in [26] and [31] suggests that there is existing literature on the capabilities required for generic programming, but again, it does not highlight what is new or unique in this study.
 - The proposal of a ""general approach to the design and implementation of a type system"" suggests a potential novelty, as it implies a new or comprehensive method for type system design.
 - The discussion of describing programming language constructs using calculus, including specific features like overload resolution and type constructors, indicates a theoretical contribution by providing a detailed framework for these constructs.
 - The abstract does not explicitly mention any comparative analysis with existing work or specific implications for programming language design beyond the general approach proposed."
PhD Abstracts,Graham Hutton,-,-,-,0,2017,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: Type theory and category theory
 - Specific mathematical properties guaranteed: Establishment of initial objects in categories of algebras
 - Proof techniques used: Colimit construction, coequalisers
 - Limitations or constraints of the framework: Described as a first approximation towards a theory of higher inductive types","- Specific integration mechanisms proposed: Development of GUMSMP combining shared and distributed memory mechanisms; AugurV2 for probabilistic modeling with parallel comprehensions.
 - Interaction models between paradigms: Combination of scalable distributed memory parallelism with low-overhead shared memory parallelism; integration of type checking and model checking.
 - Constraints or challenges in paradigm integration: Need for a specialized RTS for hierarchical architectures; focus on efficient design choices.
 - Novel translation or embedding techniques: Use of a virtual shared heap; parallel comprehensions in AugurV2.",Generic programming not extensively addressed,"- Development of GUMSMP, a new parallel Haskell RTS that combines shared and distributed memory mechanisms for hierarchical architectures.
 - Introduction of a theory of quotient inductive-inductive definitions, unifying and generalizing previous treatments.
 - Advancements in probabilistic programming languages, including the use of computable distributions and the design of AugurV2.
 - Integration of type checking and model checking into a single platform for software verification.
 - Development of modeling languages ATS/PML and ATS/Veri with advanced type systems.","- ""Key design objectives in realising this system are to prefer local work, and to exploit mostly passive load distribution with pre-fetching.""
  - ""A categorical characterisation of the induction principle is given and is shown to coincide with the property of being an initial object in the categories of algebras.""
  - ""The probabilistic programming paradigm for Bayesian machine learning proposes that we (1) use a programming language to express probabilistic models and (2) leverage the language implementation to perform statistical inference.""
  - ""In this dissertation, I study probabilistic programming languages, i.e., programming languages designed for probabilistic modeling.""
  - ""One motivation for using computable distributions, as opposed to more generally measures, is so that we can think of a Turing-complete probabilistic programming language as expressing computable distributions.""
  - ""I design, implement, and evaluate a language called AugurV2, which proposes probabilistic modeling with parallel comprehensions for composable Markov Chain Monte Carlo (MCMC) inference.""",,"- The abstract discusses several conceptual frameworks and methodologies related to parallel programming, probabilistic programming, and software verification. However, it does not explicitly define ""conceptual primitives"" as requested by the question.
 - The closest to conceptual primitives are the design objectives and mechanisms mentioned for the GUMSMP RTS, such as preferring local work and exploiting passive load distribution with pre-fetching. However, these are not explicitly labeled as conceptual primitives.
 - The theory of quotient inductive-inductive definitions and the probabilistic programming paradigm are theoretical frameworks rather than specific primitives.
 - The abstract does not provide explicit definitions or lists of conceptual primitives as requested by the question.","- ""In this thesis we present a theory of quotient inductive-inductive deﬁnitions, which are inductive-inductive deﬁnitions extended with constructors for equations.""
  - ""The resulting theory is an improvement over previous treatments of inductive-inductive and indexed inductive deﬁnitions in that it uniﬁes and generalises these into a single framework.""
  - ""The framework can also be seen as a ﬁrst approximation towards a theory of higher inductive types, but done in a set truncated setting.""
  - ""We give the type of speciﬁcations of quotient inductive-inductive deﬁnitions mutu-ally with its interpretation as categories of algebras.""
  - ""A categorical characterisation of the induction principle is given and is shown to coincide with the property of being an initial object in the categories of algebras.""
  - ""The existence of initial objects in the categories of algebras associated to quotient inductive-inductive deﬁnitions is established for a class of deﬁnitions.""
  - ""This is done by a colimit construction that can be carried out in type theory itself in the presence of natural numbers, sum types and quotients or equivalently, coequalisers.""",,"- The abstract mentions the development of a ""theory of quotient inductive-inductive deﬁnitions,"" which suggests a mathematical framework related to type theory.
 - The framework is described as an improvement over previous treatments, indicating a focus on unifying and generalizing existing concepts within type theory.
 - The mention of ""categories of algebras"" and ""categorical characterisation of the induction principle"" suggests the use of category theory as part of the framework.
 - The abstract discusses the establishment of initial objects in categories of algebras, which is a specific mathematical property guaranteed by the framework.
 - The use of ""colimit construction"" and ""coequalisers"" indicates specific proof techniques used within the framework.
 - The framework is described as a ""first approximation towards a theory of higher inductive types,"" which might imply limitations or constraints in its current form.","- ""Key design objectives in realising this system are to prefer local work, and to exploit mostly passive load distribution with pre-fetching.""
  - ""The probabilistic programming paradigm for Bayesian machine learning proposes that we (1) use a programming language to express probabilistic models and (2) leverage the language implementation to perform statistical inference.""
  - ""I design, implement, and evaluate a language called AugurV2, which proposes probabilistic modeling with parallel comprehensions for composable Markov Chain Monte Carlo (MCMC) inference.""
  - ""In this dissertation, I study probabilistic programming languages, i.e., programming languages designed for probabilistic modeling.""
  - ""A specialised RTS for the ubiquitous hierarchical architectures is lacking.""",,"- The abstract discusses the integration of different programming paradigms, particularly focusing on parallel Haskell implementations and probabilistic programming languages.
 - The development of GUMSMP is a specific integration mechanism that combines shared and distributed memory mechanisms to exploit hierarchical architectures.
 - The interaction model between paradigms is evident in the combination of scalable distributed memory parallelism with low-overhead shared memory parallelism.
 - Constraints or challenges are implied by the need for a specialized RTS for hierarchical architectures and the focus on efficient design choices.
 - Novel translation or embedding techniques are suggested by the use of a virtual shared heap and parallel comprehensions in AugurV2.
 - The abstract also mentions the integration of type checking and model checking, which is another example of paradigm integration.","- ""A categorical characterisation of the induction principle is given and is shown to coincide with the property of being an initial object in the categories of algebras.""
  - ""Key design objectives in realising this system are to prefer local work, and to exploit mostly passive load distribution with pre-fetching.""
  - ""A specialised RTS for the ubiquitous hierarchical architectures is lacking.""",,"- The abstract discusses the Glasgow Haskell Compiler (GHC) and its parallel implementations, which suggests a focus on parallel programming rather than generic programming.
 - The mention of a new parallel Haskell RTS (GUMSMP) and its design objectives indicates a focus on parallelism rather than genericity.
 - The theory of quotient inductive-inductive definitions and its framework for higher inductive types suggests a focus on type theory and categorical characterizations rather than generic programming.
 - There is no explicit mention of generic programming methodology, type system discussions related to genericity, or abstraction mechanisms specifically for generic programming.
 - The abstract does not provide any information on minimal type requirements or static checking/optimization strategies related to generic programming.","- ""I design, implement, and evaluate a language called AugurV2, which proposes probabilistic modeling with parallel comprehensions for composable Markov Chain Monte Carlo (MCMC) inference.""
  - ""One motivation for using computable distributions, as opposed to more generally measures, is so that we can think of a Turing-complete probabilistic programming language as expressing computable distributions.""
  - ""This thesis describes two modeling languages ATS/PML and ATS/Veri that inherit the advanced type system from an existing programming language ATS, in which both dependent types of Dependent ML style and linear types are supported.""
  - ""In this dissertation, I study probabilistic programming languages, i.e., programming languages designed for probabilistic modeling.""",,"- The abstract discusses several novel contributions, including the development of a new parallel Haskell RTS called GUMSMP, which combines shared and distributed memory mechanisms. This is a key theoretical contribution as it addresses the need for efficient parallelism in hierarchical architectures.
 - The introduction of a theory of quotient inductive-inductive definitions is a significant theoretical advancement. It unifies and generalizes previous treatments of inductive-inductive and indexed inductive definitions, providing a new framework for understanding these concepts.
 - The work on probabilistic programming languages, particularly the use of computable distributions and the design of AugurV2, represents a theoretical contribution by enhancing the efficiency and scalability of probabilistic modeling.
 - The integration of type checking and model checking into a single platform for software verification is another theoretical contribution, as it synergistically combines two important verification techniques.
 - The development of modeling languages ATS/PML and ATS/Veri with advanced type systems is a theoretical contribution, as it facilitates the creation of correct models for software designs."
Functional Programming and Metamodeling frameworks for System Design,D. Mathaikutty,-,-,-,5,2005,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Functional programming framework (SML-Sys) with denotational semantics
 - Specific mathematical properties guaranteed: Semantic preservation during refinement
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Functional programming framework SML-Sys based on function-based semantic definitions of MoCs; semantics preserving transformation library.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Translation of models into XML-based IML, which can then be translated into Standard ML or Haskell models.","- Definition of ""concept"" used: Function-based semantic definitions of MoCs
 - Mechanisms for representing generic abstractions: SML-Sys framework, refinement methodology, semantics preserving transformation library
 - Minimal type requirements identified: Not explicitly mentioned
 - Static checking or optimization strategies: Automatic design-time syntactic and semantic checks","- Key novel insights: Introduction of a functional programming framework (SML-Sys) based on function-based semantic definitions of MoCs, addressing dependence on specific programming languages and lack of formal semantics.
 - Theoretical advancements: Development of a refinement methodology with semantics-preserving transformation library, and introduction of EWD for customizable MoC-specific visual modeling syntax.
 - Potential implications for programming language design: More formal and customizable framework for system design, enabling formal reasoning and automatic syntactic and semantic checks.","- ""we follow Axel Jantsch’s paradigm of function-based semantic definitions of MoCs and formulate a functional programming framework called SML-Sys.""
  - ""Our framework provides for formal reasoning due to its formal semantic underpinning inherited from SML’s precise denotational semantics.""
  - ""we propose a refinement methodology and provide a semantics preserving transformation library within our framework.""
  - ""we have developed EWD, which allows users to customize MoC-specific visual modeling syntax defined as a metamodel.""
  - ""EWD is developed using a metamodeling framework GME (Generic Modeling Environment).""
  - ""Modeling in EWD facilitates saving the model in an XML-based interoperability language (IML) we defined for this purpose.""",,"- The abstract discusses the development of a functional programming framework called SML-Sys, which is based on Axel Jantsch’s paradigm of function-based semantic definitions of MoCs. This suggests that the conceptual primitives are related to functional programming and semantic definitions.
 - The framework provides formal reasoning due to its formal semantic underpinning inherited from SML’s precise denotational semantics. This indicates that the primitives are defined with a focus on formal semantics.
 - The abstract mentions a refinement methodology and a semantics preserving transformation library, which implies that the primitives are designed to support refinement and transformation processes.
 - The development of EWD and its use of a metamodeling framework (GME) suggests that the primitives are also related to metamodeling and visual modeling syntax.
 - The abstract does not explicitly list specific conceptual primitives or provide detailed definitions for them. Therefore, the primitives are not explicitly defined in the abstract.","- ""we follow Axel Jantsch’s paradigm of function-based semantic definitions of MoCs and formulate a functional programming framework called SML-Sys.""
  - ""Our framework provides for formal reasoning due to its formal semantic underpinning inherited from SML’s precise denotational semantics.""
  - ""we propose a refinement methodology and provide a semantics preserving transformation library within our framework.""
  - ""EWD is developed using a metamodeling framework GME (Generic Modeling Environment).""
  - ""It allows for automatic design-time syntactic and semantic checks on the models for conformance to their metamodel.""
  - ""The IML format is in turn automatically translated into Standard ML, or Haskell models.""
  - ""We also generate SMV-based template from the XML representation to obtain verification models.""",,"- The abstract mentions the use of a ""functional programming framework called SML-Sys,"" which suggests a type of mathematical framework based on functional programming principles.
 - The framework is described as having ""formal semantic underpinning inherited from SML’s precise denotational semantics,"" indicating that the mathematical framework is grounded in denotational semantics, a branch of mathematical logic.
 - The mention of ""semantics preserving transformation library"" implies that the framework ensures certain mathematical properties related to semantic preservation during refinement.
 - The use of ""metamodeling framework GME"" and ""automatic design-time syntactic and semantic checks"" suggests a focus on formal verification and model checking.
 - The translation into ""Standard ML, or Haskell models"" and generation of ""SMV-based template"" for verification models indicates the use of formal verification techniques.
 - However, the abstract does not explicitly mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""System-on-Chip (SoC) and other complex distributed hardware/software systems contain heterogeneous components whose behavior are best captured by different models of computations (MoCs).""
  - ""any system design framework for such systems requires the capability to express heterogeneous MoCs.""
  - ""we follow Axel Jantsch’s paradigm of function-based semantic definitions of MoCs and formulate a functional programming framework called SML-Sys.""
  - ""Our framework provides for formal reasoning due to its formal semantic underpinning inherited from SML’s precise denotational semantics.""
  - ""we propose a refinement methodology and provide a semantics preserving transformation library within our framework.""
  - ""we have developed EWD, which allows users to customize MoC-specific visual modeling syntax defined as a metamodel.""
  - ""Modeling in EWD facilitates saving the model in an XML-based interoperability language (IML) we defined for this purpose.""
  - ""The IML format is in turn automatically translated into Standard ML, or Haskell models.""",,"- The abstract discusses the need for a system design framework that can express heterogeneous models of computation (MoCs), which implies the integration of different programming paradigms.
 - The study proposes a functional programming framework called SML-Sys, which is based on function-based semantic definitions of MoCs. This suggests a specific integration mechanism by using a common semantic foundation.
 - The framework provides for formal reasoning and semantics preserving transformation, which are key aspects of integrating different paradigms by ensuring consistency and correctness across transformations.
 - The use of EWD for customizing MoC-specific visual modeling syntax and the translation of models into XML-based IML, which can then be translated into Standard ML or Haskell models, indicates a novel translation technique for integrating different paradigms.
 - The abstract does not explicitly mention interaction models between paradigms or specific constraints or challenges in paradigm integration, but it does highlight the importance of formal semantics and transformation libraries in addressing these issues.","- ""we follow Axel Jantsch’s paradigm of function-based semantic definitions of MoCs and formulate a functional programming framework called SML-Sys.""
  - ""Our framework provides for formal reasoning due to its formal semantic underpinning inherited from SML’s precise denotational semantics.""
  - ""we propose a refinement methodology and provide a semantics preserving transformation library within our framework.""
  - ""we have developed EWD, which allows users to customize MoC-specific visual modeling syntax defined as a metamodel.""
  - ""EWD is developed using a metamodeling framework GME (Generic Modeling Environment).""
  - ""It allows for automatic design-time syntactic and semantic checks on the models for conformance to their metamodel.""
  - ""Modeling in EWD facilitates saving the model in an XML-based interoperability language (IML) we defined for this purpose.""
  - ""The IML format is in turn automatically translated into Standard ML, or Haskell models.""",,"- The abstract discusses the use of a functional programming framework called SML-Sys, which is based on Axel Jantsch’s paradigm of function-based semantic definitions of MoCs. This suggests a focus on functional programming as a mechanism for representing generic abstractions.
 - The framework provides formal reasoning capabilities due to its formal semantic underpinning, which implies a level of abstraction and genericity in its design.
 - The mention of a refinement methodology and a semantics preserving transformation library indicates mechanisms for representing generic abstractions and ensuring correctness.
 - The use of EWD and the metamodeling framework GME suggests a focus on conceptual abstraction through visual modeling syntax and metamodels.
 - The automatic design-time syntactic and semantic checks imply static checking strategies to ensure conformance to metamodels.
 - The translation of models into Standard ML or Haskell models suggests a level of genericity in the programming methodology.","- ""Although a number of system level design languages (SLDL)s and frameworks have proliferated over the last few years, most of them are lacking in multiple ways.""
  - ""First, their dependence on specific programming language artifacts (Java or C/C++) make them less amenable to formal analysis.""
  - ""Second, the refinement strategies proposed in the design flows based on these languages lack formal semantics underpinnings making it difficult to prove that refinements preserve correctness, and third, none of the available SLDLs are easily customizable by users.""
  - ""To alleviate the first problem, we follow Axel Jantsch’s paradigm of function-based semantic definitions of MoCs and formulate a functional programming framework called SML-Sys.""
  - ""Our framework provides for formal reasoning due to its formal semantic underpinning inherited from SML’s precise denotational semantics.""
  - ""To handle the second problem and apply refinement strategies at a higher-level, we propose a refinement methodology and provide a semantics preserving transformation library within our framework.""
  - ""To address the third shortcoming, we have developed EWD, which allows users to customize MoC-specific visual modeling syntax defined as a metamodel.""
  - ""EWD is developed using a metamodeling framework GME (Generic Modeling Environment).""
  - ""It allows for automatic design-time syntactic and semantic checks on the models for conformance to their metamodel.""
  - ""Modeling in EWD facilitates saving the model in an XML-based interoperability language (IML) we defined for this purpose.""",,"- The abstract identifies three main shortcomings in existing system level design languages (SLDLs): dependence on specific programming languages, lack of formal semantics in refinement strategies, and lack of customizability.
 - The study addresses these shortcomings by introducing a functional programming framework called SML-Sys, which is based on function-based semantic definitions of models of computation (MoCs). This provides a formal semantic underpinning, enabling formal reasoning.
 - The introduction of a refinement methodology with a semantics-preserving transformation library addresses the issue of refinement strategies lacking formal semantics.
 - The development of EWD, which allows for customization of MoC-specific visual modeling syntax, addresses the issue of customizability.
 - The use of a metamodeling framework (GME) and an XML-based interoperability language (IML) for automatic syntactic and semantic checks and model translation to executable languages (Standard ML or Haskell) are significant theoretical contributions.
 - These contributions imply potential advancements in programming language design by providing a more formal and customizable framework for system design."
Implementation and manipulation of formal objects: an object-oriented view,"Mauro Regio, M. Temperini",10.1145/99412.99496,https://doi.org/10.1145/99412.99496,Symposium on Small Systems,1,1990,Not specified (the abstract does not explicitly define or list conceptual primitives),Not specified (the abstract does not provide details on the mathematical framework characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Integration of specification formal language and implementation programming language under a unified conceptual modeling framework.
 - Theoretical advancements: Use of Object-Oriented methodology as a conceptual framework for formal objects definition and implementation.
 - Potential implications: Exploration of Algorithmic Logic, Loglan, and Eiffel as innovative tools for programming language design.","- ""Characteristics are considered, from the point of view both of specification formal language, and of implementation programming language; indeed programming and specifying are considered as actions to be uniformed under the same general conceptual modeling.""
  - ""This conceptual modeling is given by the Object-Oriented methodology; in this paradigm, some features are discussed which are considered of main interest for our aims.""
  - ""This work is intended as a first introductive step in studying a set of characteristics for the development of a Formal Objects Definition and Implementation System.""
  - ""Argument of interest are Algorithmic Logic, as a logic specification language, and Loglan and Eiffel as innovative Object-Oriented programming languages.""",,"- The abstract discusses the development of a Formal Objects Definition and Implementation System, which suggests a focus on conceptual primitives related to object-oriented methodology.
 - It mentions the integration of specification formal language and implementation programming language under a unified conceptual modeling framework, which is object-oriented.
 - The abstract highlights Algorithmic Logic, Loglan, and Eiffel as key elements, but it does not explicitly define these as conceptual primitives or provide their precise definitions.
 - The abstract does not explicitly list or define specific conceptual primitives or their level of abstraction and orthogonality.","- ""Characteristics are considered, from the point of view both of specification formal language, and of implementation programming language; indeed programming and specifying are considered as actions to be uniformed under the same general conceptual modeling.""
  - ""This work is intended as a first introductive step in studying a set of characteristics for the development of a Formal Objects Definition and Implementation System.""
  - ""This conceptual modeling is given by the Object-Oriented methodology; in this paradigm, some features are discussed which are considered of main interest for our aims.""
  - ""Argument of interest are Algorithmic Logic, as a logic specification language, and Loglan and Eiffel as innovative Object-Oriented programming languages.""",,"- The abstract discusses the development of a Formal Objects Definition and Implementation System, which implies a focus on formalizing and implementing conceptual primitives.
 - It mentions the use of ""specification formal language"" and ""implementation programming language,"" suggesting a focus on formal languages.
 - The abstract highlights the Object-Oriented methodology as the conceptual modeling framework, which is a programming paradigm rather than a mathematical framework.
 - Algorithmic Logic is mentioned as a ""logic specification language,"" which could be part of a mathematical framework, but there is no explicit mention of its role in formalizing or guaranteeing properties.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.","- ""Argument of interest are Algorithmic Logic, as a logic specification language, and Loglan and Eiffel as innovative Object-Oriented programming languages.""
  - ""Characteristics are considered, from the point of view both of specification formal language, and of implementation programming language; indeed programming and specifying are considered as actions to be uniformed under the same general conceptual modeling.""
  - ""This conceptual modeling is given by the Object-Oriented methodology; in this paradigm, some features are discussed which are considered of main interest for our aims.""
  - ""This work is intended as a first introductive step in studying a set of characteristics for the development of a Formal Objects Definition and Implementation System.""",,"- The abstract discusses the integration of programming and specifying under a unified conceptual modeling framework, which is object-oriented.
 - It mentions the use of Algorithmic Logic as a specification language and Loglan and Eiffel as object-oriented programming languages, indicating a focus on these specific paradigms.
 - However, there is no explicit mention of specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques.
 - The abstract does not provide details on how these paradigms are integrated or any challenges faced in their integration.","- ""Characteristics are considered, from the point of view both of specification formal language, and of implementation programming language; indeed programming and specifying are considered as actions to be uniformed under the same general conceptual modeling.""
  - ""Argument of interest are Algorithmic Logic, as a logic specification language, and Loglan and Eiffel as innovative Object-Oriented programming languages.""
  - ""This conceptual modeling is given by the Object-Oriented methodology; in this paradigm, some features are discussed which are considered of main interest for our aims.""
  - ""This work is intended as a first introductive step in studying a set of characteristics for the development of a Formal Objects Definition and Implementation System.""",,"- The abstract discusses the development of a Formal Objects Definition and Implementation System, which suggests a focus on conceptual modeling and object-oriented methodology.
 - The mention of ""conceptual modeling"" and ""Object-Oriented methodology"" implies a focus on abstraction mechanisms, as these are core aspects of object-oriented programming.
 - The abstract mentions ""Algorithmic Logic"" and ""Loglan and Eiffel"" as languages of interest, which are known for their support of object-oriented programming and potentially generic programming concepts.
 - However, the abstract does not explicitly mention ""genericity and abstraction mechanisms"" or provide specific details on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus seems to be on the conceptual framework and languages rather than specific mechanisms for generic programming.","- ""Characteristics are considered, from the point of view both of specification formal language, and of implementation programming language; indeed programming and specifying are considered as actions to be uniformed under the same general conceptual modeling.""
  - ""Argument of interest are Algorithmic Logic, as a logic specification language, and Loglan and Eiffel as innovative Object-Oriented programming languages.""
  - ""This work is intended as a first introductive step in studying a set of characteristics for the development of a Formal Objects Definition and Implementation System.""
  - ""This conceptual modeling is given by the Object-Oriented methodology; in this paradigm, some features are discussed which are considered of main interest for our aims.""",,"- The abstract suggests that the study is a ""first introductive step"" in developing a Formal Objects Definition and Implementation System, which implies a novel approach or contribution to the field.
 - The integration of specification formal language and implementation programming language under a unified conceptual modeling framework is highlighted, which could be a theoretical advancement beyond existing approaches.
 - The use of the Object-Oriented methodology as a conceptual framework is emphasized, indicating a focus on theoretical contributions related to this paradigm.
 - The mention of Algorithmic Logic, Loglan, and Eiffel as innovative languages suggests an exploration of new theoretical tools or approaches in programming language design.
 - The abstract does not provide explicit conclusions or comparative analyses with existing work, but it implies that the study contributes to the theoretical understanding of formal objects and their implementation through an object-oriented lens."
Concept-based optimization,"Xiaolong Tang, Jaakko Järvi",10.1145/1512762.1512772,https://doi.org/10.1145/1512762.1512772,LCSD '07,24,2007,Not specified (the abstract does not provide explicit names or definitions for the conceptual primitives),Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Concept-based optimizations using ConceptGCC and concept maps.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"": Concepts describe the syntactic and semantic properties of classes of types, for which generic semantics-preserving transformations can be defined.
 - Mechanisms for representing generic abstractions: Concept maps establish memberships to these classes, enabling the generic optimizations for specific user-defined types.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: High-level optimizations can yield greater benefits than traditional methods; current compilers lack support for high-level transformations.
 - Theoretical advancements: Framework for ""concept-based optimizations"" using algebraic properties and concept maps to enable generic optimizations for user-defined types.
 - Potential implications: Influence on future compiler design to support high-level optimizations and user-defined types.","- ""Concept maps establish memberships to these classes, enabling the generic optimizations for specific user-defined types.""
  - ""Concepts describe the syntactic and semantic properties of classes of types, for which generic semantics-preserving transformations can be defined.""
  - ""The framework is based on careful categorization, applying the generic programming paradigm, of the algebraic properties that justify particular optimizing transformations.""",,"- The abstract mentions ""algebraic properties"" as a basis for the framework, which suggests these are conceptual primitives used to justify optimizing transformations.
 - ""Concepts"" are described as describing syntactic and semantic properties of classes of types, which implies they are conceptual primitives for defining these properties.
 - ""Concept maps"" are mentioned as establishing memberships to these classes, which suggests they are a type of conceptual primitive for enabling generic optimizations.
 - The abstract does not provide explicit names or definitions for these primitives beyond their roles in the framework.
 - The level of abstraction is high, as these primitives are related to algebraic properties and semantic descriptions.
 - Orthogonality is not explicitly discussed in the abstract.","- ""Concept maps establish memberships to these classes, enabling the generic optimizations for specific user-defined types.""
  - ""The framework is based on careful categorization, applying the generic programming paradigm, of the algebraic properties that justify particular optimizing transformations.""
  - ""Concepts describe the syntactic and semantic properties of classes of types, for which generic semantics-preserving transformations can be defined.""",,"- The abstract mentions the use of ""algebraic properties"" and ""generic programming paradigm,"" which suggests a mathematical framework related to type theory and possibly category theory, as these are common areas where algebraic properties are formalized.
 - The mention of ""concepts"" and ""concept maps"" indicates a framework that involves categorization and membership, which aligns with concepts from category theory.
 - The abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it detail specific mathematical properties guaranteed or proof techniques used.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""Transformations at higher levels of abstraction, on operations of types defined in libraries or by the user, are typically not supported.""
  - ""Built-in compiler optimizations can in principle apply to user-defined types, if those types possess properties that guarantee that the optimizing transformations preserve the meaning of the program.""
  - ""The problem is conveying this information to the compiler in a non-disruptive manner.""
  - ""This article describes a framework for specifying and implementing generic ""concept-based optimizations.""""
  - ""The framework is based on careful categorization, applying the generic programming paradigm, of the algebraic properties that justify particular optimizing transformations.""
  - ""Our framework is built on top of ConceptGCC, a compiler implementing the new language features concept and concept map of the forthcoming standard C++.""
  - ""Concepts describe the syntactic and semantic properties of classes of types, for which generic semantics-preserving transformations can be defined.""
  - ""Concept maps establish memberships to these classes, enabling the generic optimizations for specific user-defined types.""",,"- The abstract discusses the integration of generic programming paradigms with compiler optimizations, specifically focusing on ""concept-based optimizations.""
 - The framework proposed integrates generic programming with compiler optimizations by categorizing algebraic properties that justify optimizing transformations.
 - The use of ""ConceptGCC"" and ""concept maps"" suggests a mechanism for integrating user-defined types with built-in compiler optimizations.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration.
 - There is no mention of novel translation or embedding techniques beyond the use of concepts and concept maps.","- ""Transformations at higher levels of abstraction, on operations of types defined in libraries or by the user, are typically not supported.""
  - ""Built-in compiler optimizations can in principle apply to user-defined types, if those types possess properties that guarantee that the optimizing transformations preserve the meaning of the program.""
  - ""This article describes a framework for specifying and implementing generic ""concept-based optimizations.""""
  - ""The framework is based on careful categorization, applying the generic programming paradigm, of the algebraic properties that justify particular optimizing transformations.""
  - ""Our framework is built on top of ConceptGCC, a compiler implementing the new language features concept and concept map of the forthcoming standard C++.""
  - ""Concepts describe the syntactic and semantic properties of classes of types, for which generic semantics-preserving transformations can be defined.""
  - ""Concept maps establish memberships to these classes, enabling the generic optimizations for specific user-defined types.""",,"- The abstract discusses the limitation of current compiler optimizations, which typically operate at low abstraction levels, and the potential for higher-level optimizations.
 - It introduces a framework for ""concept-based optimizations,"" which is based on the generic programming paradigm. This suggests a focus on genericity and abstraction mechanisms.
 - The definition of ""concept"" is provided as describing the syntactic and semantic properties of classes of types, which allows for generic semantics-preserving transformations.
 - The mechanism for representing generic abstractions is through ""concept maps,"" which establish memberships to these classes, enabling optimizations for specific user-defined types.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it implies that concepts and concept maps are used to ensure semantics-preserving transformations.
 - The focus on generic programming and conceptual abstraction is evident throughout the abstract, indicating that genericity is extensively addressed.","- ""Production compilers' optimizers typically operate at low abstraction levels, transformation rules enacting on operations on built-in types only.""
  - ""Transformations at higher levels of abstraction, on operations of types defined in libraries or by the user, are typically not supported.""
  - ""Such high-level optimizations could, however, yield greater benefits than first lowering the abstractions and subjecting the result to low-level transformations.""
  - ""Built-in compiler optimizations can in principle apply to user-defined types, if those types possess properties that guarantee that the optimizing transformations preserve the meaning of the program.""
  - ""The problem is conveying this information to the compiler in a non-disruptive manner.""
  - ""This article describes a framework for specifying and implementing generic ""concept-based optimizations.""""
  - ""The framework is based on careful categorization, applying the generic programming paradigm, of the algebraic properties that justify particular optimizing transformations.""
  - ""Our framework is built on top of ConceptGCC, a compiler implementing the new language features concept and concept map of the forthcoming standard C++.""
  - ""Concepts describe the syntactic and semantic properties of classes of types, for which generic semantics-preserving transformations can be defined.""
  - ""Concept maps establish memberships to these classes, enabling the generic optimizations for specific user-defined types.""",,"- The abstract highlights a limitation in current compiler optimizers, which typically operate at low abstraction levels and do not support transformations at higher levels of abstraction. This is a key insight into the current state of compiler optimization.
 - The authors propose a novel approach by suggesting that high-level optimizations could yield greater benefits than traditional methods. This is a key novel insight as it challenges the conventional approach to compiler optimization.
 - The abstract introduces a framework for ""concept-based optimizations,"" which is a theoretical advancement beyond existing approaches. This framework is based on categorizing algebraic properties to justify optimizing transformations, which is a new theoretical contribution.
 - The use of concepts and concept maps to describe syntactic and semantic properties of types and enable generic optimizations is a theoretical innovation. It provides a way to convey information about user-defined types to the compiler in a non-disruptive manner, which is a significant theoretical contribution.
 - The potential implications for programming language design are significant, as this framework could influence how future compilers are designed to handle user-defined types and high-level optimizations."
Investigations Into Abstraction And Concurrency,R. Jagadeesan,-,-,-,1,1991,Not specified (the abstract discusses theoretical frameworks and models but does not explicitly define specific conceptual primitives),"- Type of mathematical framework: Domain theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Integration of functional programming with logic variables, dynamic changes in dataflow networks.
 - Interaction models between paradigms: Combination of functional language with process calculus and concurrent logic programming.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Generalization of static dataflow to concurrent logic programming with indeterminacy and dynamic communication changes.",Generic programming not extensively addressed,"- Key novel insights: Introduction of dynamic changes in dataflow networks and generalization of static dataflow models to include indeterminacy and dynamic communication changes.
 - Theoretical advancements: New powerdomain construction for process calculus and extension of static dataflow models to be more expressive.
 - Potential implications: More expressive and flexible models for interactive programming systems, which can influence programming language design.","- ""Abstract semantics hides operational detail and presents a simpler view of program execution to the user.""
  - ""Domain theory has been successful in serving as a mathematical formalism powerful enough to specify abstract semantics for transformational programs:""
  - ""The language offers the ability to share and incrementally define data-structures and is expressive enough to allow dynamic(runtime) changes in the connections of the underlying dataflow network.""
  - ""The semantic description of this chapter extends the equation-solving paradigm that underlies Kahn semantics for dataflow networks to a more expressive setting in which processes manipulate shared memory locations.""
  - ""The model is constructed domain-theoretically and is based on viewing the communication ability of processes as the basic observable.""
  - ""The main contribution of this section of the thesis is a new powerdomain construction.""
  - ""Concurrent logic programming generalizes Kahn's model of static dataflow by admitting indeterminacy through OR-parallelism, and by allowing the communication abilities of processes to change dynamically.""",,"- The abstract discusses the use of domain theory as a mathematical formalism for specifying abstract semantics, which suggests a focus on theoretical frameworks rather than specific conceptual primitives.
 - The first section describes a declarative semantics for a functional language with logic variables, which involves shared data structures and dynamic changes in dataflow networks. This could be seen as a conceptual primitive related to data sharing and dynamic network changes.
 - The second section constructs a model for process calculus with processes as first-class values, focusing on communication abilities as observables. This could be interpreted as a conceptual primitive related to process communication.
 - The third section combines these tools for concurrent logic programming, which generalizes static dataflow by introducing indeterminacy and dynamic communication changes. This suggests a conceptual primitive related to indeterminacy and dynamic communication.
 - However, the abstract does not explicitly list or define specific conceptual primitives. Instead, it describes theoretical frameworks and models that could be considered as conceptual primitives in a broader sense.","- ""Domain theory has been successful in serving as a mathematical formalism powerful enough to specify abstract semantics for transformational programs:""
  - ""The model is constructed domain-theoretically and is based on viewing the communication ability of processes as the basic observable.""
  - ""The main contribution of this section of the thesis is a new powerdomain construction.""",,"- The abstract mentions that ""Domain theory has been successful in serving as a mathematical formalism"" for specifying abstract semantics. This indicates that domain theory is the type of mathematical framework used.
 - The second section of the thesis is described as being ""constructed domain-theoretically,"" which further confirms the use of domain theory as the mathematical framework.
 - The mention of a ""new powerdomain construction"" suggests a specific mathematical property or technique used within this framework, as powerdomains are a concept within domain theory used to model non-determinism.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, nor does it discuss limitations or constraints of the framework.","- ""The language offers the ability to share and incrementally define data-structures and is expressive enough to allow dynamic(runtime) changes in the connections of the underlying dataflow network.""
  - ""The semantic description of this chapter extends the equation-solving paradigm that underlies Kahn semantics for dataflow networks to a more expressive setting in which processes manipulate shared memory locations.""
  - ""Concurrent logic programming generalizes Kahn's model of static dataflow by admitting indeterminacy through OR-parallelism, and by allowing the communication abilities of processes to change dynamically.""
  - ""The model is constructed domain-theoretically and is based on viewing the communication ability of processes as the basic observable.""",,"- The abstract discusses the integration of different programming paradigms by combining elements from functional programming, process calculus, and concurrent logic programming.
 - The first section integrates functional programming with logic variables, allowing for dynamic changes in dataflow networks, which is a mechanism for integrating functional and dataflow paradigms.
 - The second section constructs a model for process calculus, which is integrated with the functional language in the first section, indicating an interaction model between these paradigms.
 - The third section combines these elements to describe an abstract semantics for concurrent logic programming, which generalizes static dataflow by introducing indeterminacy and dynamic communication changes, suggesting a novel translation or embedding technique.
 - The abstract does not explicitly mention specific constraints or challenges in paradigm integration, but it implies that the integration involves extending existing models to more expressive settings.","- ""Abstract semantics hides operational detail and presents a simpler view of program execution to the user.""
  - ""Domain theory has been successful in serving as a mathematical formalism powerful enough to specify abstract semantics for transformational programs:""
  - ""The model is constructed domain-theoretically and is based on viewing the communication ability of processes as the basic observable.""
  - ""The semantic description of this chapter extends the equation-solving paradigm that underlies Kahn semantics for dataflow networks to a more expressive setting in which processes manipulate shared memory locations.""
  - ""The language offers the ability to share and incrementally define data-structures and is expressive enough to allow dynamic(runtime) changes in the connections of the underlying dataflow network.""",,"- The abstract discusses abstract semantics and its application to various programming models, but it does not explicitly mention generic programming or abstraction mechanisms in the context of genericity.
 - The focus is on abstract semantics for different programming paradigms, such as functional languages and process calculi, rather than on generic programming methodologies.
 - There is no mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.
 - The abstract does not provide a definition of ""concept"" used in the context of generic programming or discuss type systems in relation to genericity.","- ""The situation is not as clear for interactive programming systems: systems built out of processes communicate with the environment and/or other processes while computing.""
  - ""Static, determinate dataflow is the prime example of a model of interactive systems that is amenable to extensional treatment. However, the model is not expressive enough.""
  - ""This thesis investigates abstract models for some elaborations of the model of static dataflow.""
  - ""The language offers the ability to share and incrementally define data-structures and is expressive enough to allow dynamic(runtime) changes in the connections of the underlying dataflow network.""
  - ""The main contribution of this section of the thesis is a new powerdomain construction.""
  - ""Concurrent logic programming generalizes Kahn's model of static dataflow by admitting indeterminacy through OR-parallelism, and by allowing the communication abilities of processes to change dynamically.""",,"- The abstract highlights the limitations of existing models for interactive programming systems, particularly the lack of expressiveness in static, determinate dataflow models.
 - The thesis addresses these limitations by investigating abstract models that extend the static dataflow model, indicating a theoretical contribution towards making these models more expressive.
 - The first section introduces a declarative semantics for a functional language with logic variables, which allows for dynamic changes in dataflow networks, a novel insight into handling dynamic configurations.
 - The second section presents a new powerdomain construction for process calculus, which is a theoretical advancement in modeling processes as first-class values.
 - The third section combines these tools to provide an abstract semantics for concurrent logic programming, which generalizes existing models by incorporating indeterminacy and dynamic communication changes, a significant theoretical contribution.
 - These contributions have potential implications for programming language design by providing more expressive and flexible models for interactive systems."
"Research on sets, constraints, and preferences",B. Jayaraman,10.1145/340855.340963,https://doi.org/10.1145/340855.340963,SOEN,0,2000,"1. Primitive Name: Subset clauses
  Definition: Part of the SURE programming language for set-oriented problems
  Orthogonality Score: Not specified
 

 2. Primitive Name: Relational clauses
  Definition: Part of the SURE programming language for set-oriented problems
  Orthogonality Score: Not specified
 

 3. Primitive Name: Equational clauses
  Definition: Part of the SURE programming language for set-oriented problems
  Orthogonality Score: Not specified
 

 4. Primitive Name: Dynamic programming and heuristics
  Definition: Declarative paradigm for constraints and preferences
  Orthogonality Score: Not specified
 

 5. Primitive Name: Preference grammars
  Definition: Declarative paradigm for constraints and preferences
  Orthogonality Score: Not specified
 

 6. Primitive Name: Constraint hierarchies
  Definition: Declarative paradigm for constraints and preferences
  Orthogonality Score: Not specified
 

 7. Primitive Name: Preference relaxation
  Definition: Declarative paradigm for constraints and preferences
  Orthogonality Score: Not specified",Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Development of the SURE language incorporating Subset, Relational, and Equational clauses.
 - Interaction models between paradigms: Four declarative paradigms for using constraints and preferences.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Integration of constraints and preferences into a declarative variant of object-oriented programming.",Generic programming not extensively addressed,"- Development of the SURE programming language with novel program clauses (Subset, Relational, Equational) for enhanced declarative programming.
 - Integration of preferences into declarative programming for expressing criteria for optimal solutions.
 - Exploration of four declarative paradigms for constraints and preferences (dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation).
 - Introduction of a declarative variant of object-oriented programming focusing on constrained objects with support for constraints and preferences.","- ""We are exploring two closely related language paradigms: (i) set-oriented languages , and (ii) constraints and preferences.""
  - ""We have developed a novel programming language, called SURE, incorporating three kinds of program clauses: Subset, Relational, and Equational clauses.""
  - ""Using these clauses, we can program clear, concise, and declarative solutions to a broad range of problems requiring the use of transitive closures, monotonic aggregation, and incremental and lazy enumeration of sets.""
  - ""SuRE supports matching and unification of sets, as well as meta-programming facilities.""
  - ""In a related project, we are exploring the use of preferences and constraints in declarative programming.""
  - ""We have shown four declarative paradigms of use of constraints and preferences: dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation.""
  - ""Our modeling paradigm supports constraints as well as preferences, and the computational model provides constraint satisfaction, optimization , and relaxation techniques.""",,"- The abstract discusses two main language paradigms: set-oriented languages and constraints and preferences. These are conceptual frameworks rather than specific primitives.
 - The novel programming language SURE is mentioned, which includes three types of program clauses: Subset, Relational, and Equational clauses. These can be considered as conceptual primitives as they are fundamental components of the language.
 - The abstract also mentions the use of constraints and preferences, which are explored in four declarative paradigms. These paradigms (dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation) can be seen as conceptual primitives for reconstructing programming paradigms related to constraints and preferences.
 - The level of abstraction is high as these primitives are foundational elements of programming languages and paradigms.
 - Orthogonality is not explicitly discussed in the abstract, but the primitives seem to be distinct and serve different purposes within the programming paradigms.","- ""This research is on the theory, design, implementation, and application of declarative programming languages.""
  - ""We are exploring two closely related language paradigms: (i) set-oriented languages , and (ii) constraints and preferences.""
  - ""We have developed a novel programming language, called SURE, incorporating three kinds of program clauses: Subset, Relational, and Equational clauses.""
  - ""Using these clauses, we can program clear, concise, and declarative solutions to a broad range of problems requiring the use of transitive closures, monotonic aggregation, and incremental and lazy enumeration of sets.""
  - ""SuRE supports matching and unification of sets, as well as meta-programming facilities.""
  - ""We have implemented the paradigm using a variant of the Warren Abstract Machine for Prolog, and shown that the language has good performance for set-oriented problems.""
  - ""In a related project, we are exploring the use of preferences and constraints in declarative programming.""
  - ""We have shown four declarative paradigms of use of constraints and preferences: dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation.""
  - ""Our modeling paradigm supports constraints as well as preferences, and the computational model provides constraint satisfaction, optimization , and relaxation techniques.""",,"- The abstract discusses the development of a novel programming language called SURE, which is based on set-oriented languages and constraints/preferences.
 - It mentions the use of specific program clauses (Subset, Relational, Equational) and their application in solving problems related to transitive closures, aggregation, and set enumeration.
 - The implementation is based on a variant of the Warren Abstract Machine for Prolog, indicating a connection to logic programming.
 - The abstract does not explicitly mention a specific mathematical framework like type theory or category theory.
 - There is no mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract.
 - The focus is on the design and implementation of the language rather than the mathematical framework used to formalize and guarantee properties.","- ""We are exploring two closely related language paradigms: (i) set-oriented languages , and (ii) constraints and preferences.""
  - ""We have developed a novel programming language, called SURE, incorporating three kinds of program clauses: Subset, Relational, and Equational clauses.""
  - ""In a related project, we are exploring the use of preferences and constraints in declarative programming.""
  - ""We have shown four declarative paradigms of use of constraints and preferences: dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation.""
  - ""Currently, we are examining a declarative variant of object-oriented programming motivated by problems in modeling the structure and behavior of complex engineering artifacts.""
  - ""Our modeling paradigm supports constraints as well as preferences, and the computational model provides constraint satisfaction, optimization , and relaxation techniques.""",,"- The abstract discusses the exploration of two closely related language paradigms: set-oriented languages and constraints and preferences. This suggests an integration of these paradigms within the context of declarative programming.
 - The development of the SURE language, which incorporates Subset, Relational, and Equational clauses, indicates a specific integration mechanism by combining different types of program clauses.
 - The mention of four declarative paradigms for using constraints and preferences (dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation) implies interaction models between these paradigms.
 - The integration of constraints and preferences into a declarative variant of object-oriented programming suggests a novel approach to modeling complex engineering artifacts, which could be considered a novel translation or embedding technique.
 - The abstract does not explicitly mention specific constraints or challenges in paradigm integration, nor does it detail any specific interaction models or novel translation techniques beyond the integration within the SURE language and the declarative variant of object-oriented programming.","- ""This research is on the theory, design, implementation, and application of declarative programming languages.""
  - ""We are exploring two closely related language paradigms: (i) set-oriented languages , and (ii) constraints and preferences.""
  - ""We have developed a novel programming language, called SURE, incorporating three kinds of program clauses: Subset, Relational, and Equational clauses.""
  - ""Using these clauses, we can program clear, concise, and declarative solutions to a broad range of problems requiring the use of transitive closures, monotonic aggregation, and incremental and lazy enumeration of sets.""
  - ""SuRE supports matching and unification of sets, as well as meta-programming facilities.""
  - ""In a related project, we are exploring the use of preferences and constraints in declarative programming.""
  - ""We have shown four declarative paradigms of use of constraints and preferences: dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation.""
  - ""Currently, we are examining a declarative variant of object-oriented programming motivated by problems in modeling the structure and behavior of complex engineering artifacts.""
  - ""Our modeling paradigm supports constraints as well as preferences, and the computational model provides constraint satisfaction, optimization , and relaxation techniques.""",,"- The abstract discusses the development of a novel programming language called SURE, which incorporates set-oriented languages and constraints/preferences. This suggests a focus on declarative programming rather than generic programming.
 - The language SURE is designed to handle set operations and constraints, which are more related to declarative programming than generic programming.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanism explanations that are typically associated with generic programming.
 - The abstract does not provide any information on minimal type requirements or static checking/optimization strategies related to generic programming.
 - The focus on declarative programming and constraints/preferences does not align with the typical concerns of generic programming.","- ""We have developed a novel programming language, called SURE, incorporating three kinds of program clauses: Subset, Relational, and Equational clauses.""
  - ""While constraint logic programming is well-known in the literature, preferences are a novel addition and serve as a declarative expression of the criteria for determining optimal solutions.""
  - ""SuRE supports matching and unification of sets, as well as meta-programming facilities.""
  - ""In a related project, we are exploring the use of preferences and constraints in declarative programming.""
  - ""Using these clauses, we can program clear, concise, and declarative solutions to a broad range of problems requiring the use of transitive closures, monotonic aggregation, and incremental and lazy enumeration of sets.""
  - ""Our modeling paradigm supports constraints as well as preferences, and the computational model provides constraint satisfaction, optimization , and relaxation techniques.""
  - ""Currently, we are examining a declarative variant of object-oriented programming motivated by problems in modeling the structure and behavior of complex engineering artifacts.""
  - ""We have shown four declarative paradigms of use of constraints and preferences: dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation.""",,"- The development of the SURE programming language is a key novelty, as it introduces new program clauses (Subset, Relational, Equational) that enhance declarative programming capabilities.
 - The support for set operations like transitive closures, monotonic aggregation, and incremental and lazy enumeration of sets is a theoretical advancement, as it addresses complex problems in a concise manner.
 - The integration of preferences into declarative programming is a novel theoretical contribution, as it provides a new way to express criteria for optimal solutions.
 - The exploration of four declarative paradigms for constraints and preferences (dynamic programming and heuristics, preference grammars, constraint hierarchies, and preference relaxation) represents a theoretical advancement in handling complex optimization problems.
 - The introduction of a declarative variant of object-oriented programming, focusing on constrained objects, is a theoretical innovation that aligns with the need for more natural modeling of complex engineering artifacts.
 - The support for constraints and preferences in this paradigm, along with constraint satisfaction, optimization, and relaxation techniques, has potential implications for programming language design by offering more flexible and expressive modeling capabilities."
"Defining, analyzing, and transforming program constructs","Jingke Le, M. Wolfe",10.1109/88.281872,https://doi.org/10.1109/88.281872,IEEE Parallel & Distributed Technology Systems & Applications,5,1994,Not specified (the abstract does not explicitly define or list specific conceptual primitives),"Not specified (the abstract does not provide details on the type of mathematical framework, specific mathematical properties, proof techniques, or limitations)","- Specific integration mechanisms proposed: Framework for analyzing and transforming program constructs, nesting of sequential and parallel control constructs.
 - Interaction models between paradigms: Designers can define interactions between new features and existing language features.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Compiler can transform and optimize programs for different architectures.",Generic programming not extensively addressed,"- Key novel insights: A framework for analyzing sequential and parallel control constructs with general nesting capabilities.
 - Theoretical advancements: A simple yet powerful scheme for defining data access order and semantic structure for nested constructs; determining critical behavior for preservation during optimization.
 - Potential implications: Enhancements to programming language design for flexibility and adaptability across different architectures.","- ""Instead of being confined to a single programming paradigm, programmers can use the most appropriate constructs for the application, and the compiler can transform and optimize the program for different parallel or sequential architectures.<<ETX>>""
  - ""A simple yet powerful scheme defines the order of data accesses in a program, and provides a well-founded semantic structure for nested constructs.""
  - ""We have developed a framework for analyzing the behavior and relations of various sequential and parallel control constructs, which we can nest in a very general way.""
  - ""Because our approach is based on well-known dependence analysis techniques, it is practical for compiler implementation.""",,"- The abstract mentions a ""framework for analyzing the behavior and relations of various sequential and parallel control constructs,"" which suggests that the study involves conceptual primitives related to these constructs.
 - The ""simple yet powerful scheme"" that defines the order of data accesses and provides a semantic structure for nested constructs could be considered a conceptual primitive, as it is a fundamental element in the framework.
 - The abstract does not explicitly list or define specific conceptual primitives, nor does it provide a precise definition or orthogonality score for any primitives.
 - The focus on dependence analysis techniques and compiler implementation suggests that the primitives might be related to these areas, but again, no explicit primitives are defined in the abstract.","- ""Because our approach is based on well-known dependence analysis techniques, it is practical for compiler implementation.""
  - ""A simple yet powerful scheme defines the order of data accesses in a program, and provides a well-founded semantic structure for nested constructs.""
  - ""We have developed a framework for analyzing the behavior and relations of various sequential and parallel control constructs, which we can nest in a very general way.""
  - ""It determines which behavior the compiler and system must preserve while allowing aggressive automatic optimization.""",,"- The abstract mentions a ""framework for analyzing the behavior and relations of various sequential and parallel control constructs,"" which suggests a structured approach to understanding program constructs. However, it does not specify the type of mathematical framework used (e.g., type theory, category theory).
 - The mention of a ""simple yet powerful scheme"" and ""well-founded semantic structure"" implies some form of mathematical underpinning, but the abstract does not provide details on the specific mathematical properties guaranteed or the proof techniques used.
 - The reference to ""well-known dependence analysis techniques"" suggests a basis in established methods, but again, no specific mathematical framework or properties are detailed.
 - The abstract does not discuss any limitations or constraints of the framework.","- ""We have developed a framework for analyzing the behavior and relations of various sequential and parallel control constructs, which we can nest in a very general way.""
  - ""programmers can use the most appropriate constructs for the application, and the compiler can transform and optimize the program for different parallel or sequential architectures.<<ETX>>""
  - ""A simple yet powerful scheme defines the order of data accesses in a program, and provides a well-founded semantic structure for nested constructs.""
  - ""designers can use this framework to define how each new feature interacts with the language's other features.""",,"- The abstract discusses a framework for analyzing and transforming program constructs, which includes both sequential and parallel control constructs. This suggests a mechanism for integrating different programming paradigms by allowing nesting and interaction between these constructs.
 - The mention of a ""simple yet powerful scheme"" for defining data access order and providing a semantic structure for nested constructs implies a theoretical integration strategy that facilitates paradigm interaction.
 - The abstract notes that designers can use the framework to define interactions between new features and existing language features, which suggests an interaction model between paradigms.
 - The ability for programmers to use appropriate constructs for their application and for the compiler to transform and optimize for different architectures indicates a novel translation or embedding technique that supports paradigm integration.
 - However, the abstract does not explicitly detail specific integration mechanisms, constraints, or challenges in paradigm integration beyond these general statements.","- ""We have developed a framework for analyzing the behavior and relations of various sequential and parallel control constructs, which we can nest in a very general way.""
  - ""A simple yet powerful scheme defines the order of data accesses in a program, and provides a well-founded semantic structure for nested constructs.""
  - ""When defining parallel languages or extensions to current languages, designers can use this framework to define how each new feature interacts with the language's other features.""
  - ""Because our approach is based on well-known dependence analysis techniques, it is practical for compiler implementation.""
  - ""It determines which behavior the compiler and system must preserve while allowing aggressive automatic optimization.""
  - ""Instead of being confined to a single programming paradigm, programmers can use the most appropriate constructs for the application, and the compiler can transform and optimize the program for different parallel or sequential architectures.<<ETX>>""",,"- The abstract discusses a framework for analyzing and transforming program constructs, which suggests a focus on abstraction mechanisms.
 - The mention of a ""simple yet powerful scheme"" for defining data access order and providing a semantic structure for nested constructs implies a mechanism for representing generic abstractions.
 - The framework allows for the interaction of new features with existing language features, which could relate to minimal type requirements, although this is not explicitly stated.
 - The use of dependence analysis techniques suggests a strategy for static checking or optimization.
 - However, the abstract does not explicitly mention generic programming or type system discussions, which are key components of genericity and abstraction mechanisms.","- ""We have developed a framework for analyzing the behavior and relations of various sequential and parallel control constructs, which we can nest in a very general way.""
  - ""A simple yet powerful scheme defines the order of data accesses in a program, and provides a well-founded semantic structure for nested constructs.""
  - ""When defining parallel languages or extensions to current languages, designers can use this framework to define how each new feature interacts with the language's other features.""
  - ""Because our approach is based on well-known dependence analysis techniques, it is practical for compiler implementation.""
  - ""It determines which behavior the compiler and system must preserve while allowing aggressive automatic optimization.""
  - ""Instead of being confined to a single programming paradigm, programmers can use the most appropriate constructs for the application, and the compiler can transform and optimize the program for different parallel or sequential architectures.<<ETX>>""",,"- The abstract introduces a novel framework for analyzing the behavior and relations of sequential and parallel control constructs, which is a key theoretical contribution. This framework allows for a general nesting of these constructs, which is a significant advancement.
 - The mention of a ""simple yet powerful scheme"" that defines data access order and provides a semantic structure for nested constructs suggests a theoretical innovation in how these constructs are understood and managed.
 - The framework's applicability to defining interactions between new features in parallel languages or extensions indicates a theoretical contribution to programming language design.
 - The use of well-known dependence analysis techniques makes the approach practical for compiler implementation, but this is more of an implementation detail rather than a theoretical innovation.
 - The ability to determine which behavior must be preserved while allowing for aggressive optimization is a theoretical advancement in terms of understanding what aspects of program behavior are critical.
 - The flexibility for programmers to use appropriate constructs for different applications and architectures suggests a theoretical contribution to the flexibility and adaptability of programming languages."
Systematic Parallel Programming,Juergen Dingel,-,-,-,9,2000,"1. Primitive Name: Fair Parallelism
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 2. Primitive Name: Shared-Variable Concurrency
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 3. Primitive Name: Message-Passing Concurrency
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 4. Primitive Name: Local Variables
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 5. Primitive Name: Channels
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 6. Primitive Name: Compositional Trace Semantics
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 7. Primitive Name: Refinement Relation
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 8. Primitive Name: Syntax-Directed Refinement Rules
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed","- Type of mathematical framework: Refinement calculus
 - Specific mathematical properties guaranteed: Correctness by construction, compositional trace semantics, context-sensitive trace inclusion
 - Proof techniques used: Stepwise formal derivation, syntax-directed refinement rules
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Refinement calculus, compositional trace semantics, refinement relation combining trace inclusion and assumption-commitment reasoning.
 - Interaction models between paradigms: Uniform treatment of shared-variable and message-passing concurrency.
 - Constraints or challenges in paradigm integration: Complexity and variety of parallel architectures.
 - Novel translation or embedding techniques: Syntax-directed refinement rules.",Generic programming not extensively addressed,"- Key novel insights: Development of a refinement calculus for parallel programming; isolation of machine-dependent features for increased portability; facilitation of discovering new efficient solutions; programs correct by construction.
 - Theoretical advancements: Formal basis for parallel program design; compositional trace semantics treating shared-variable and message-passing concurrency uniformly; context-sensitive trace inclusion and assumption-commitment reasoning.
 - Potential implications for programming language design: Enhanced portability and reusability; structured development process; support for fair parallelism and various concurrency models.","- ""Our programming/specification notation supports fair parallelism, shared-variable and message-passing concurrency, local variables and channels.""
  - ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""",,"- The abstract discusses a refinement calculus that is used for the design of parallel programs. This suggests that the conceptual primitives are related to the components of this calculus.
 - The mention of ""fair parallelism, shared-variable and message-passing concurrency, local variables and channels"" indicates these are key concepts or primitives in the programming/specification notation.
 - The ""compositional trace semantics"" and ""refinement relation"" are theoretical frameworks that underpin the calculus, suggesting they are part of the conceptual primitives.
 - The ""syntax-directed refinement rules"" imply that these rules are also fundamental to the framework, acting as primitives in the development process.
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality or level of abstraction in detail.","- ""This thesis addresses some of these problems by developing a formal basis for the design of parallel programs in form of a refinement calculus.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""
  - ""The calculus thus helps structuring and documenting the development process.""
  - ""Portability is increased, because the introduction of a machine-dependent feature can be located in the refinement tree.""
  - ""Development efforts above this point in the tree are independent of that feature and are thus reusable.""
  - ""Moreover, the discovery of new, possibly more efficient solutions is facilitated.""
  - ""Last but not least, programs are correct by construction, which obviates the need for difficult debugging.""
  - ""Our programming/specification notation supports fair parallelism, shared-variable and message-passing concurrency, local variables and channels.""
  - ""It allows the development of reactive systems, that is, possibly non-terminating programs designed to interact persistently with their environment.""
  - ""Moreover the specification of liveness properties such as termination or eventual entry is supported by our methodology.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""
  - ""The calculus straddles both concurrency paradigms.""",,"- The abstract mentions the development of a ""refinement calculus"" as the mathematical framework, which is used to formalize the design of parallel programs.
 - The refinement calculus allows for the stepwise formal derivation of implementations from specifications, indicating a focus on formal verification and proof techniques.
 - The framework is described as helping with structuring and documenting the development process, which suggests it provides a structured approach to program development.
 - The mention of ""correct by construction"" implies that the framework guarantees certain properties, such as correctness, through its design.
 - The framework supports various concurrency models and reactive systems, indicating its flexibility and applicability to different programming paradigms.
 - The use of ""compositional trace semantics"" and ""context-sensitive notion of trace inclusion"" suggests specific mathematical properties related to concurrency and compositionality.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it specify a type of mathematical framework like type theory or category theory.","- ""Parallelism adds a level of complexity to the programming task that makes it very error-prone.""
  - ""a large variety of very different parallel architectures exists.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""
  - ""Portability is increased, because the introduction of a machine-dependent feature can be located in the refinement tree.""
  - ""Our programming/specification notation supports fair parallelism, shared-variable and message-passing concurrency, local variables and channels.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""
  - ""The calculus straddles both concurrency paradigms.""",,"- The abstract discusses the complexity and variety of parallel architectures, which implies a need for integration across different paradigms.
 - The refinement calculus is proposed as a mechanism to integrate different programming paradigms by allowing the derivation of low-level implementations from high-level specifications.
 - The notation supports both shared-variable and message-passing concurrency, indicating an integration of these paradigms.
 - The calculus uses a compositional trace semantics to treat these concurrency paradigms uniformly, suggesting a theoretical integration strategy.
 - The refinement relation combines trace inclusion and assumption-commitment reasoning, which are specific integration mechanisms.
 - The syntax-directed refinement rules suggest a structured approach to integrating different language constructs.
 - The abstract mentions that the calculus ""straddles both concurrency paradigms,"" indicating an integration approach that bridges different paradigms.","- ""This thesis addresses some of these problems by developing a formal basis for the design of parallel programs in form of a refinement calculus.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""
  - ""The calculus thus helps structuring and documenting the development process.""
  - ""Portability is increased, because the introduction of a machine-dependent feature can be located in the refinement tree.""
  - ""Development efforts above this point in the tree are independent of that feature and are thus reusable.""
  - ""Our programming/specification notation supports fair parallelism, shared-variable and message-passing concurrency, local variables and channels.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""",,"- The abstract discusses the development of a refinement calculus as a formal basis for designing parallel programs. This suggests a focus on abstraction mechanisms through the use of a calculus that allows for stepwise derivation from high-level specifications to low-level implementations.
 - The mention of ""structuring and documenting the development process"" implies that the calculus provides a structured approach to abstraction, which is a key aspect of generic programming.
 - The increase in portability due to the ability to locate machine-dependent features in the refinement tree suggests a mechanism for representing generic abstractions that are independent of specific machine features.
 - The support for various concurrency models (fair parallelism, shared-variable, message-passing) and the use of a compositional trace semantics indicate a focus on abstraction mechanisms that can handle different types of concurrency.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, which are typically discussed in the context of generic programming.
 - The focus on refinement rules being syntax-directed suggests a structured approach to abstraction, but it does not explicitly address generic programming methodologies or type system discussions.","- ""This thesis addresses some of these problems by developing a formal basis for the design of parallel programs in form of a refinement calculus.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""
  - ""The calculus thus helps structuring and documenting the development process.""
  - ""Portability is increased, because the introduction of a machine-dependent feature can be located in the refinement tree.""
  - ""Development efforts above this point in the tree are independent of that feature and are thus reusable.""
  - ""Moreover, the discovery of new, possibly more efficient solutions is facilitated.""
  - ""programs are correct by construction, which obviates the need for difficult debugging.""
  - ""Our programming/specification notation supports fair parallelism, shared-variable and message-passing concurrency, local variables and channels.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""
  - ""The calculus straddles both concurrency paradigms.""",,"- The abstract introduces a ""formal basis for the design of parallel programs"" in the form of a ""refinement calculus,"" which is a novel theoretical contribution. This calculus provides a structured approach to deriving low-level implementations from high-level specifications.
 - The refinement calculus enhances portability by isolating machine-dependent features within the refinement tree, making development efforts above this point reusable. This is a significant theoretical advancement as it addresses a major challenge in parallel programming.
 - The calculus facilitates the discovery of new, possibly more efficient solutions, which is a key novel insight. It also ensures programs are correct by construction, reducing the need for debugging.
 - The programming notation supports various concurrency models and treats them uniformly, which is a theoretical advancement beyond existing approaches.
 - The use of compositional trace semantics and context-sensitive trace inclusion with assumption-commitment reasoning is a unique theoretical contribution, as it achieves compositionality and straddles both concurrency paradigms."
A Constructive Semantics for Basic Aspect Constructs,Christiano Braga,10.1007/978-3-642-04164-8_6,https://doi.org/10.1007/978-3-642-04164-8_6,Semantics and Algebraic Specification,0,2009,Not specified (the abstract does not provide explicit definitions or details about the conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),"- Specific integration mechanisms proposed: Extending the library of reusable semantic components with new constructs to support new paradigms.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.","Generic programming not extensively addressed (the abstract focuses on constructive semantics and aspect-oriented programming, but does not provide detailed information on generic programming methodology, type system discussions, or abstraction mechanisms specific to genericity)","- Key novel insights: Proposal of constructs for basic aspect-oriented programming concepts with Modular SOS semantics.
 - Theoretical advancements: Emphasis on reuse and modularity in constructive semantics.
 - Potential implications: Enhanced flexibility and adaptability in programming language design through extensible semantic components.","- ""Basic notions of structural operational semantics are assumed.""
  - ""I propose constructs to support basic aspect-oriented programming concepts together with their Modular SOS semantics.""",,"- The abstract mentions that the author proposes ""constructs to support basic aspect-oriented programming concepts,"" which suggests that these constructs are conceptual primitives.
 - The abstract does not provide explicit names or definitions for these constructs, nor does it specify their level of abstraction or orthogonality.
 - The mention of ""Modular SOS semantics"" indicates a focus on structural operational semantics, but again, no specific primitives are defined or detailed in the abstract.
 - The abstract does not provide enough information to extract specific conceptual primitives, their definitions, or their level of abstraction and orthogonality.","- ""I focus on his constructive approach to the semantics of programming languages.""
  - ""Constructive Semantics is an approach to the specification of programming language semantics that focuses on reuse.""
  - ""Basic notions of structural operational semantics are assumed.""
  - ""I propose constructs to support basic aspect-oriented programming concepts together with their Modular SOS semantics.""",,"- The abstract mentions a ""constructive approach"" to semantics, which suggests a focus on constructive mathematics or type theory, but it does not explicitly state the type of mathematical framework used.
 - The mention of ""Modular SOS semantics"" indicates the use of structural operational semantics (SOS), which is a mathematical framework for specifying the semantics of programming languages. However, SOS is more of a methodology than a specific mathematical framework like type theory or category theory.
 - The abstract does not provide specific details about mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - There is no explicit mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract.","- ""I propose constructs to support basic aspect-oriented programming concepts together with their Modular SOS semantics.""
  - ""Constructive Semantics is an approach to the specification of programming language semantics that focuses on reuse.""
  - ""As new programming paradigms are developed, the library of reusable parts of semantic components provided by the constructive approach may be extended with new constructs to support the new paradigm.""",,"- The abstract discusses the ""Constructive Semantics"" approach, which is focused on reuse. This suggests a mechanism for integrating different programming paradigms by extending the library of semantic components with new constructs.
 - The mention of extending the library with new constructs to support new paradigms implies a strategy for integrating different paradigms by adding new components to the existing framework.
 - The proposal of constructs for aspect-oriented programming and their Modular SOS semantics indicates a specific integration mechanism, as it involves integrating aspect-oriented concepts into the semantics framework.
 - There is no explicit mention of interaction models between paradigms, constraints, or novel translation techniques in the abstract.","- ""I propose constructs to support basic aspect-oriented programming concepts together with their Modular SOS semantics.""
  - ""Constructive Semantics is an approach to the specification of programming language semantics that focuses on reuse.""
  - ""the library of reusable parts of semantic components provided by the constructive approach may be extended with new constructs to support the new paradigm.""",,"- The abstract discusses ""Constructive Semantics,"" which is described as focusing on ""reuse."" This suggests a form of genericity where components can be reused across different programming paradigms.
 - The mention of extending the library of reusable parts with new constructs implies a mechanism for representing generic abstractions, as it allows for the adaptation of existing components to new programming paradigms.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, which are typically discussed in the context of generic programming.
 - The focus on ""constructs to support basic aspect-oriented programming concepts"" and ""Modular SOS semantics"" indicates an emphasis on abstraction mechanisms, particularly in the context of aspect-oriented programming.
 - The abstract does not provide a detailed definition of ""concept"" used in the context of generic programming or type system discussions.","- ""I propose constructs to support basic aspect-oriented programming concepts together with their Modular SOS semantics.""
  - ""Constructive Semantics is an approach to the specification of programming language semantics that focuses on reuse.""
  - ""the library of reusable parts of semantic components provided by the constructive approach may be extended with new constructs to support the new paradigm.""",,"- The abstract mentions the proposal of ""constructs to support basic aspect-oriented programming concepts together with their Modular SOS semantics."" This suggests a novel insight into how aspect-oriented programming can be integrated into the constructive semantics framework, which is a theoretical contribution.
 - The focus on ""reuse"" in the constructive semantics approach is highlighted, indicating a theoretical advancement beyond existing approaches by emphasizing modularity and extensibility.
 - The potential for extending the library of semantic components with new constructs to support new paradigms implies a theoretical contribution towards flexibility and adaptability in programming language design.
 - The abstract does not explicitly mention a comparative analysis with existing work or specific implications for programming language design, but the focus on reuse and modularity suggests potential implications for more efficient and adaptable language design."
Structural Recursion as a Query Language,V. Tannen,-,-,-,0,2015,Not specified (the abstract does not explicitly define or name conceptual primitives),"- Type of mathematical framework: Type theory (lambda calculus)
 - Specific mathematical properties guaranteed: Relation transformers are total maps taking finite relations to finite relations
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Structural recursion on sets
 - Interaction models between paradigms: Scaling up to handle complex-object models
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Novel insight: Combining semantic simplicity of relational algebra with expressive power of unrestricted programming languages.
 - Theoretical advancement: Structural recursion on sets as the main computational engine.
 - Theoretical contribution: Restricted class of programs with structural recursion has the same expressive power as relational algebra.
 - Theoretical advancement: Scalability to complex-object models.
 - Potential implication: Finer grain programming for better optimization in programming language design.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a ""nicely"" typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""",,"- The abstract discusses a programming paradigm that combines the simplicity of relational algebra with the expressiveness of unrestricted programming languages. This suggests a focus on structural recursion as a key conceptual primitive.
 - The mention of ""structural recursion on sets"" indicates that this is a fundamental primitive in the proposed paradigm.
 - The use of a ""nicely"" typed lambda calculus suggests another primitive related to typing, which is crucial for the paradigm's structure.
 - The emphasis on how queries are implemented implies that the method of implementation is a conceptual primitive, focusing on the process rather than just the outcome.
 - The abstract does not provide explicit definitions or names for these primitives, nor does it discuss their orthogonality or level of abstraction in detail.","- ""All programming is done within a ""nicely"" typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""As in relational algebra, the meaning of any relation transformer is guaranteed to be a total map taking finite relations to finite relations.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""",,"- The abstract mentions that programming is done within a ""nicely"" typed lambda calculus, which suggests that the mathematical framework is based on type theory.
 - The mention of ""structural recursion"" indicates a focus on recursive functions, which is a common technique in type theory and functional programming.
 - The guarantee that relation transformers are total maps taking finite relations to finite relations suggests a property of the framework related to relational algebra.
 - The abstract does not explicitly mention specific proof techniques or limitations of the framework, but it does highlight the expressive power and optimization potential.
 - There is no explicit mention of category theory or other mathematical frameworks beyond type theory and lambda calculus.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a ""nicely"" typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The same programming paradigm scales up, yielding query languages for the complex-object model [AB89].""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""",,"- The abstract discusses a programming paradigm that integrates elements from relational algebra and unrestricted programming languages, aiming for both simplicity and expressive power.
 - The main integration mechanism is structural recursion on sets, which is used as the computational engine.
 - The use of a ""nicely"" typed lambda calculus suggests a theoretical integration strategy that ensures type consistency across different programming paradigms.
 - The paradigm scales up to handle complex-object models, indicating an interaction model between different paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.
 - The focus on how queries are implemented suggests an emphasis on practical integration, but specific mechanisms or challenges are not detailed.","- ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a ""nicely"" typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""
  - ""Therefore we expect that lower-level and therefore better optimizations will be feasible.""",,"- The abstract mentions the use of ""structural recursion on sets"" as the main computational engine, which suggests a focus on recursive programming rather than generic programming.
 - The mention of ""nicely typed lambda calculus"" indicates a structured approach to programming, but it does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not provide a definition of ""concept"" or discuss mechanisms for representing generic abstractions.
 - There is no mention of minimal type requirements or static checking strategies related to generic programming.
 - The focus on structural recursion and lambda calculus suggests a structured programming approach, but it does not extensively address generic programming or abstraction mechanisms.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The same programming paradigm scales up, yielding query languages for the complex-object model""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""",,"- The abstract introduces a new programming paradigm that combines the simplicity of relational algebra with the expressiveness of unrestricted programming languages, which is a novel insight.
 - The use of structural recursion on sets as the main computational engine is a theoretical advancement, as it provides a new way to approach programming.
 - The fact that a restricted class of programs using structural recursion has the same expressive power as relational algebra is a significant theoretical contribution, as it bridges two different programming paradigms.
 - The scalability of this paradigm to complex-object models is another theoretical advancement, as it expands the applicability of structural recursion.
 - The mention of finer grain programming suggests potential implications for optimization, which could lead to better performance in programming language design.
 - The abstract does not provide specific implementation details but focuses on theoretical innovations, aligning with the request to focus on theoretical contributions."
Under Consideration for Publication in Theory and Practice of Logic Programming Integration of Declarative and Constraint Programming,"P. Hofstedt, Peter Pepper",-,-,-,0,2006,Not specified (the abstract does not mention specific conceptual primitives),Not specified (the abstract does not mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Combining existing constraint solvers into an integrated system.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Integration of different language paradigms into a unified framework.
 - Theoretical advancements: Study of syntactic, semantic, and operational impacts for the amalgamation of declarative and constraint programming.
 - Potential implications: Influence on future programming language design by providing a theoretical basis for combining different paradigms.","- ""we study the syntactic, semantic and operational impacts of this idea for the amalgamation of declarative and constraint programming.""
  - ""this approach can also be used to integrate different language paradigms into a unified framework.""
  - ""Combining a set of existing constraint solvers into an integrated system of cooperating solvers is a useful and economic principle to solve hybrid constraint problems.""",,"- The abstract discusses the integration of constraint solvers and language paradigms, but it does not explicitly mention any conceptual primitives.
 - The focus is on the integration approach and its impacts on declarative and constraint programming, rather than defining specific primitives.
 - The abstract does not provide any specific names or definitions of conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""In this paper we show that this approach can also be used to integrate different language paradigms into a unified framework.""
  - ""Furthermore, we study the syntactic, semantic and operational impacts of this idea for the amalgamation of declarative and constraint programming.""
  - ""Combining a set of existing constraint solvers into an integrated system of cooperating solvers is a useful and economic principle to solve hybrid constraint problems.""",,"- The abstract discusses the integration of constraint solvers and language paradigms, which suggests a focus on the conceptual and operational aspects rather than a specific mathematical framework.
 - There is no mention of a specific type of mathematical framework such as type theory or category theory.
 - The abstract does not provide details on specific mathematical properties guaranteed or proof techniques used.
 - The focus is on the integration and impacts on declarative and constraint programming, but it does not specify any mathematical framework or its limitations.","- ""this approach can also be used to integrate different language paradigms into a unified framework.""
  - ""Combining a set of existing constraint solvers into an integrated system of cooperating solvers is a useful and economic principle to solve hybrid constraint problems.""
  - ""we study the syntactic, semantic and operational impacts of this idea for the amalgamation of declarative and constraint programming.""",,"- The abstract mentions the integration of different language paradigms into a unified framework, which suggests a focus on integrating declarative and constraint programming paradigms.
 - The approach involves combining existing constraint solvers into an integrated system, which implies a mechanism for integrating different paradigms.
 - The study examines the syntactic, semantic, and operational impacts, indicating a theoretical integration strategy that considers these aspects.
 - However, the abstract does not provide specific details on interaction models, constraints, or novel translation techniques, nor does it explicitly mention any comparative analysis.","- ""Furthermore, we study the syntactic, semantic and operational impacts of this idea for the amalgamation of declarative and constraint programming.""
  - ""In this paper we show that this approach can also be used to integrate different language paradigms into a unified framework.""
  - ""Combining a set of existing constraint solvers into an integrated system of cooperating solvers is a useful and economic principle to solve hybrid constraint problems.""",,"- The abstract discusses the integration of constraint solvers and language paradigms, which suggests a focus on combining different systems rather than generic programming or abstraction mechanisms.
 - There is no mention of generic programming, abstraction mechanisms, or type systems in the abstract.
 - The focus is on integrating different paradigms and studying their impacts, which does not directly relate to genericity or abstraction mechanisms.
 - The abstract does not provide any information on the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.","- ""this approach can also be used to integrate different language paradigms into a unified framework.""
  - ""Combining a set of existing constraint solvers into an integrated system of cooperating solvers is a useful and economic principle to solve hybrid constraint problems.""
  - ""we study the syntactic, semantic and operational impacts of this idea for the amalgamation of declarative and constraint programming.""",,"- The abstract suggests a novel approach by integrating different language paradigms into a unified framework, which is a key novel insight. This integration is not just about combining solvers but also about merging different programming paradigms.
 - The theoretical advancement lies in the study of syntactic, semantic, and operational impacts of integrating declarative and constraint programming. This indicates a deep analysis of how these paradigms can be theoretically combined, which is beyond existing approaches that might focus on practical implementation rather than theoretical foundations.
 - The potential implications for programming language design are significant because the integration of declarative and constraint programming could lead to more versatile and powerful programming languages. This unified framework could influence future language design by providing a theoretical basis for combining different paradigms."
Practical Idiomatic Considerations for Checkable Meta-Logic in Experimental Functional Programming,"B. T. Widemann, M. Lepper",10.1007/978-3-030-75333-7_2,https://doi.org/10.1007/978-3-030-75333-7_2,Workshop on Functional and Constraint Logic Programming,0,2020,"1. Primitive Name: Meta-language marking
  Definition: Explicitly marking parts of the codebase as meta-logical vocabulary to improve readability and clarity.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Nominal axiomatics
  Definition: Organizing meta-logical propositions attached to a program part clearly and accountably, often using type classes or ad-hoc polymorphic operations.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Constructive existentials
  Definition: Treating existential quantification as distinct by providing a witness in an effectively computable fashion, ensuring that properties can be checked constructively.
  Orthogonality Score: Not specified","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Properties encoded as dependent types, constructive semantics
 - Proof techniques used: Heuristic testing, constructive logic
 - Limitations or constraints of the framework: Empirical approach, reliance on heuristic testing rather than formal proof",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of meta-level marking, nominal axiomatics, and constructive existentials for offline checking.
 - Theoretical advancements: Explicit meta-level marking improves readability and serves as an anchor for meta-programming; constructive existentials provide a controlled approach to existential quantification.
 - Potential implications: Enhancing expressivity of offline checking languages; reifying algebraic concepts in functional programming.","- ""we propose several novel idioms to enhance the practical expressivity of checking, namely meta-language marking, nominal axiomatics, and constructive existentials.""
  - ""We have proposed three advanced features of meta-logical language for offline checking of functional programs, namely meta-level marking, nominal axiomatics and constructive existentials.""
  - ""The contribution of the present paper is a collection of three novel and experimental idioms for offline checking.""",,"- The paper explicitly mentions three conceptual primitives or idioms for enhancing the practical expressivity of checking in functional programming: meta-language marking, nominal axiomatics, and constructive existentials.
 - These primitives are defined as follows:
  - Meta-language marking: This involves explicitly marking parts of the codebase as meta-logical vocabulary to improve readability and clarity.
  - Nominal axiomatics: This involves organizing meta-logical propositions attached to a program part clearly and accountably, often using type classes or ad-hoc polymorphic operations.
  - Constructive existentials: This involves treating existential quantification as distinct by providing a witness in an effectively computable fashion, ensuring that properties can be checked constructively.
 - The paper does not provide a specific orthogonality score for these primitives, but they are presented as distinct and complementary features for enhancing offline checking.","- ""Purely functional programming has arguably a friendlier relationship to metalogic, the discipline of formal reasoning about program properties, than conventional state-based paradigms""
  - ""The principle of types as propositions in a functional programming language is a two-sided coin.""
  - ""In a types-as-propositions approach to meta-logic of functional programs, a property of interest is encoded as a dependent type, and holds if the type can be demonstrated to be inhabited in a constructive semantics.""
  - ""checking approaches are empirical : Properties of interest are tested by computable functions, and thus collapse to the result type Bool , of which only the value True is accepted.""
  - ""The natural logical reading of the type operator (→) is universal quantification.""
  - ""Therefore we propose to treat existential quantification as entirely distinct, and in the true spirit of constructive logic, by effective Skolemization.""
  - ""The adequacy of the semantics can be stated concisely in terms of two propositions for soundness and full abstraction, respectively.""
  - ""The correctness and completeness of these constructions are universally quantified properties again, which can be checked heuristically.""
  - ""The concept of constructive existentials is an explicitly controlled counterpart to implicit search strategies provided by the logical programming paradigm.""",,"- The paper discusses the use of a ""types-as-propositions"" approach, which is a characteristic of type theory. This suggests that the mathematical framework is based on type theory.
 - The paper mentions ""constructive semantics,"" which aligns with the principles of constructive type theory.
 - The use of ""dependent types"" to encode properties and the focus on ""constructive logic"" further supports the use of type theory as the mathematical framework.
 - The paper discusses ""universal quantification"" and ""existential quantification,"" which are common concepts in type theory and logic.
 - The framework is described as ""empirical,"" indicating that properties are tested through computable functions, which is a limitation of the framework as it relies on heuristic testing rather than formal proof.
 - The paper does not explicitly mention category theory or other mathematical frameworks, so it is not clear if these are also part of the framework.","- ""Purely functional programming has arguably a friendlier relationship to metalogic, the discipline of formal reasoning about program properties, than conventional state-based paradigms""
  - ""The principle of types as propositions in a functional programming language is a two-sided coin.""
  - ""Offline checking fills the same role as conventional unit testing procedures, although the focus is a bit different: checking purely functional programs is commonly both simpler in control, due to the lack of state of the unit under test that needs to be set up and observed, and more complex in data, due to the pervasiveness of higher-order functions.""
  - ""The checking idioms to be proposed in the following have been developed in the context of an experimental checking framework, PureCheck, implemented as a plain Haskell library.""
  - ""The contribution of the present paper is a collection of three novel and experimental idioms for offline checking.""
  - ""The natural logical reading of the type operator (→) is universal quantification.""
  - ""The concept of constructive existentials is an explicitly controlled counterpart to implicit search strategies provided by the logical programming paradigm.""
  - ""Unlike SmartCheck, where constructive existentials are dismissed for often being hard to find in practice, we contend that in a (self-)educational context such as executable modeling, the understanding gained by implementing the construction witnesses for existential meta-logical properties of interest is rewarding rather than onerous.""
  - ""Furthermore foresee interesting potential in the transfer of our ideas to a functional-logic language such as Curry [8] with builtin encapsulated search capabilities, but leave the exploration for future work.""",,"- The paper discusses the integration of functional programming with meta-logic, focusing on the use of types as propositions and the role of offline checking.
 - It highlights the friendlier relationship between purely functional programming and meta-logic compared to state-based paradigms.
 - The paper introduces novel idioms for offline checking within the context of a Haskell library called PureCheck, which is a functional programming paradigm.
 - The discussion on types as propositions and the use of offline checking suggests an integration approach that leverages the logical power of functional programming for theorem proving and testing.
 - The mention of constructive existentials and their potential application in a functional-logic language like Curry indicates a future direction for integrating functional and logical programming paradigms.
 - However, the paper does not explicitly describe a comprehensive integration approach or specific mechanisms for integrating different programming paradigms beyond the context of functional programming and meta-logic.","- ""The principle of types as propositions in a functional programming language is a two-sided coin. On the upside, the internal logical language is automatically consistent with the language semantics, and quite expressive. On the downside, the expressive power of advanced abstractions such as higher-order functions and polymorphism is a bit too much for the logical needs of the average user.""
  - ""Unrestrained use can make the meta-logical aspects of the codebase overwhelmingly hard to both write and read.""
  - ""The contribution of the present paper is a collection of three novel and experimental idioms for offline checking.""
  - ""Theory Type Classes A substantial part of model-ish functional programs is about the algebra of data structures. For structures organized in the idiomatic Haskell way as type classes, the associated meta-logic can conveniently be organized as a companion type class with default implementations.""
  - ""Type-Level Ad-Hoc Programming For more ad-hoc data structures, where operations are not organized as methods of a type class, but rather passed explicitly to higher-order functions, or where extra laws are assumed locally, a likewise looser style of meta-logic appears more adequate.""
  - ""A type class can be used to map symbolic names of laws, defined as constructors of ad-hoc datatypes, to their logical content.""
  - ""The natural logical reading of the type operator (→) is universal quantification.""
  - ""The concept of constructive existentials is an explicitly controlled counterpart to implicit search strategies provided by the logical programming paradigm.""",,"- The paper discusses the use of types as propositions in functional programming, which is a key aspect of generic programming. However, it highlights the complexity and expressiveness of these abstractions, which can be overwhelming.
 - The authors propose delimiting meta-logical vocabulary explicitly to improve readability and usability, which is a mechanism for representing generic abstractions.
 - The paper uses type classes to organize meta-logic for data structures, which is a mechanism for generic programming.
 - Type-level ad-hoc programming is mentioned as a way to handle more ad-hoc data structures, indicating flexibility in abstraction mechanisms.
 - The paper does not explicitly define a ""concept"" in the context of generic programming, nor does it specify minimal type requirements or static checking strategies.
 - The focus is more on meta-logical annotations and checking idioms rather than generic programming methodologies.","- ""We have proposed three advanced features of meta-logical language for offline checking of functional programs, namely meta-level marking, nominal axiomatics and constructive existentials.""
  - ""Marking the Meta level explicitly has not only the demonstrated advantages for the human reader, but may also serve as an anchor for meta-programming procedures, such as automatic test suite extraction without magic names.""
  - ""The contribution of the present paper is a collection of three novel and experimental idioms for offline checking.""
  - ""Unlike SmartCheck, where constructive existentials are dismissed for often being hard to find in practice, we contend that in a (self-)educational context such as executable modeling, the understanding gained by implementing the construction witnesses for existential meta-logical properties of interest is rewarding rather than onerous.""
  - ""The concept of constructive existentials is an explicitly controlled counterpart to implicit search strategies provided by the logical programming paradigm.""
  - ""Expressive offline checking language is an important step towards the reification of the algebraic concepts that pervade functional program design; consider the ubiquitous informal equational theory associated with Haskell type classes.""",,"- The paper introduces three novel idioms for offline checking: meta-level marking, nominal axiomatics, and constructive existentials. These are identified as the main theoretical contributions.
 - Meta-level marking is a new approach to explicitly delimiting meta-logical vocabulary in code, which improves readability and can serve as an anchor for meta-programming.
 - Nominal axiomatics and constructive existentials are advanced features that enhance the expressivity of offline checking by providing a structured way to organize and validate meta-logical properties.
 - The concept of constructive existentials is particularly innovative as it provides a controlled approach to handling existential quantification, contrasting with implicit search strategies in other frameworks like SmartCheck.
 - The paper suggests that these contributions have potential implications for programming language design, particularly in enhancing the expressivity of offline checking languages and reifying algebraic concepts in functional programming."
Algebraic Specification with Functionals in Program Development by Transformation,B. Krieg-Brückner,10.1007/978-94-009-1063-8_25,https://doi.org/10.1007/978-94-009-1063-8_25,-,3,1989,Not specified (the abstract does not provide explicit definitions or details about the conceptual primitives),Not specified (the abstract does not explicitly mention the type of mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Use of higher order functions and homomorphic extension functionals.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.","- Definition of ""concept"" used: Not explicitly defined, but implied through the use of higher-order functions and homomorphic extension functionals.
 - Mechanisms for representing generic abstractions: Higher-order functions and homomorphic extension functionals.
 - Minimal type requirements identified: Not mentioned.
 - Static checking or optimization strategies: Implied through ""direct optimisation transformations.""","- Key novel insights: The methodology of program development by specification and transformation, and the use of higher-order functions in algebraic specification.
 - Theoretical advancements: The combination of algebraic specification with functional programming for correctness and optimization, and the use of homomorphic extension functionals for efficiency.
 - Potential implications: Enhanced abstraction and efficiency in programming language design through the use of higher-order functions and homomorphic extension functionals.","- ""The combination with algebraic specification not only allows reasoning about correctness but also permits direct optimisation transformations.""
  - ""The functional programming paradigm leads to a considerably higher degree of abstraction and avoids much repetitive development effort, in particular through the use of homomorphic extension functionals.""
  - ""The methodology of PROgram development by SPECification and TRAnsformation is described.""
  - ""The algebraic specification language is then described, focussing on its extension by higher order functions.""",,"- The abstract discusses the methodology of program development by specification and transformation, which suggests a focus on conceptual primitives related to these processes.
 - The mention of ""algebraic specification language"" and its extension by ""higher order functions"" indicates that these are key components of the methodology, potentially serving as conceptual primitives.
 - The use of ""homomorphic extension functionals"" is highlighted as a means to achieve higher abstraction and reduce repetitive effort, suggesting it is a conceptual primitive.
 - The abstract does not provide explicit definitions for these primitives, nor does it mention their orthogonality or level of abstraction beyond the general statement about higher abstraction.","- ""The functional programming paradigm leads to a considerably higher degree of abstraction and avoids much repetitive development effort, in particular through the use of homomorphic extension functionals.""
  - ""The methodology of PROgram development by SPECification and TRAnsformation is described.""
  - ""The algebraic specification language is then described, focussing on its extension by higher order functions.""
  - ""The combination with algebraic specification not only allows reasoning about correctness but also permits direct optimisation transformations.""
  - ""Formal requirement specifications are the basis for constructing correct and efficient programs by gradual transformation.""",,"- The abstract mentions the use of ""algebraic specification language"" and ""higher order functions,"" which suggests a mathematical framework based on algebraic specifications and functional programming.
 - The mention of ""reasoning about correctness"" and ""direct optimisation transformations"" implies that the framework is used for formal verification and optimization.
 - However, the abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no mention of proof techniques or limitations/constraints of the framework in the abstract.
 - The abstract focuses on the methodology and paradigm rather than detailing the mathematical framework's characteristics.","- ""The methodology of PROgram development by SPECification and TRAnsformation is described.""
  - ""The algebraic specification language is then described, focussing on its extension by higher order functions.""
  - ""The combination with algebraic specification not only allows reasoning about correctness but also permits direct optimisation transformations.""
  - ""The functional programming paradigm leads to a considerably higher degree of abstraction and avoids much repetitive development effort, in particular through the use of homomorphic extension functionals.""",,"- The abstract discusses the integration of the functional programming paradigm with algebraic specification, which suggests a form of paradigm integration.
 - The mention of ""higher order functions"" and ""homomorphic extension functionals"" indicates specific mechanisms used in this integration, as these are functional programming concepts applied within an algebraic specification framework.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.
 - The focus is on how the functional programming paradigm enhances abstraction and efficiency within the context of algebraic specification, rather than detailing a broader integration approach across multiple paradigms.","- ""The functional programming paradigm leads to a considerably higher degree of abstraction and avoids much repetitive development effort, in particular through the use of homomorphic extension functionals.""
  - ""The algebraic specification language is then described, focussing on its extension by higher order functions.""
  - ""The methodology of PROgram development by SPECification and TRAnsformation is described.""
  - ""The combination with algebraic specification not only allows reasoning about correctness but also permits direct optimisation transformations.""",,"- The abstract discusses the methodology of program development by specification and transformation, which implies a focus on abstraction and genericity.
 - The mention of ""higher order functions"" suggests a mechanism for representing generic abstractions, as higher-order functions are a common way to achieve genericity in programming.
 - The use of ""homomorphic extension functionals"" indicates a specific mechanism for abstraction, as these functionals can apply transformations across different types, promoting genericity.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does imply optimization transformations, which could be related to static checking or optimization strategies.
 - The focus on ""a considerably higher degree of abstraction"" and the avoidance of ""repetitive development effort"" suggests that genericity and abstraction are significant aspects of the methodology.","- ""The methodology of PROgram development by SPECification and TRAnsformation is described.""
  - ""The power of compact development methods using the transformational approach, as supported by the PROSPECTRA system, is illustrated by an example.""
  - ""The combination with algebraic specification not only allows reasoning about correctness but also permits direct optimisation transformations.""
  - ""The functional programming paradigm leads to a considerably higher degree of abstraction and avoids much repetitive development effort, in particular through the use of homomorphic extension functionals.""
  - ""The algebraic specification language is then described, focussing on its extension by higher order functions.""",,"- The abstract describes a methodology for program development that involves specification and transformation, which suggests a novel approach to program development.
 - The use of higher-order functions in the algebraic specification language is highlighted, indicating a theoretical advancement in terms of abstraction and efficiency.
 - The mention of homomorphic extension functionals suggests a unique theoretical contribution by providing a way to avoid repetitive development effort.
 - The combination of algebraic specification with functional programming allows for reasoning about correctness and direct optimization transformations, which is a theoretical advancement beyond existing approaches.
 - The abstract implies that this methodology and the use of higher-order functions could have implications for programming language design by enhancing abstraction and efficiency."
Towards Requirements for Enactment Mechanisms,"M. Dowson, Christer Fernström",10.1007/3-540-57739-4_13,https://doi.org/10.1007/3-540-57739-4_13,European Workshop on Software Process Technology,86,1994,Not specified (the abstract does not explicitly define or list conceptual primitives),Not specified (the abstract does not provide details about a specific mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Theoretical implications for designing formalisms and enactment mechanisms; independence of process variables from specific paradigms.
 - Theoretical advancements beyond existing approaches: Interdependence of formalism design and enactment mechanism design.
 - Potential implications for programming language design: Integration of process variables into various formalisms.","- ""The issues we have discussed above have a number of implications for the design of formalisms or languages for constructing enactable process definitions, and for the design of process definition enactment mechanisms that would form part of process centered environments.""
  - ""Constructs that corresponded to our notion of process variables could be included in a wide variety of new formalisms, or introduced as extensions to various existing formalisms, such as the programming language-like formalism of APPLA/A [8], the extended Petri net notations used in Archipel [5] or Process WEAVER""
  - ""The design of a process definition formalism is, of course, intimately related to the design of an enactment mechanism for that formalism (which must implement the operational semantics of the formalism as well as providing run time services to users and other environment components).""
  - ""our discussion of process variables is, as far as possible, independent of any particular process definition paradigm.""",,"- The abstract discusses implications for designing formalisms and enactment mechanisms, which suggests a focus on conceptual primitives related to process definitions and enactment.
 - The mention of ""process variables"" indicates a conceptual primitive, but the abstract does not provide a precise definition or list of primitives.
 - The abstract notes that these constructs could be part of various formalisms, suggesting a level of abstraction and potential orthogonality, but again, no explicit primitives are defined.
 - The abstract does not explicitly list or define any conceptual primitives, nor does it provide a detailed explanation of their orthogonality or level of abstraction.","- ""The issues we have discussed above have a number of implications for the design of formalisms or languages for constructing enactable process definitions, and for the design of process definition enactment mechanisms that would form part of process centered environments.""
  - ""Constructs that corresponded to our notion of process variables could be included in a wide variety of new formalisms, or introduced as extensions to various existing formalisms, such as the programming language-like formalism of APPLA/A [8], the extended Petri net notations used in Archipel [5] or Process WEAVER""
  - ""At this stage, it would be premature to regard these implications as requirements, even in an informal sense, but we believe that they can provide a starting point for developing a systematic set of requirements in the near future.""
  - ""The design of a process definition formalism is, of course, intimately related to the design of an enactment mechanism for that formalism (which must implement the operational semantics of the formalism as well as providing run time services to users and other environment components).""
  - ""We have also attempted to avoid making premature design decisions.""",,"- The abstract discusses implications for designing formalisms and enactment mechanisms but does not specify any mathematical framework.
 - It mentions avoiding premature design decisions, which suggests that specific mathematical frameworks or properties are not detailed in the abstract.
 - The abstract refers to various existing formalisms like APPLA/A and extended Petri net notations, but it does not specify a particular mathematical framework or its characteristics.
 - There is no mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract.","- ""In what follows, these two issues are discussed separately, but it is important to recognize that design decisions about definition formalisms cannot be made independently of decisions about enactment mechanisms.""
  - ""The design of a process definition formalism is, of course, intimately related to the design of an enactment mechanism for that formalism (which must implement the operational semantics of the formalism as well as providing run time services to users and other environment components).""
  - ""Constructs that corresponded to our notion of process variables could be included in a wide variety of new formalisms, or introduced as extensions to various existing formalisms, such as the programming language-like formalism of APPLA/A [8], the extended Petri net notations used in Archipel [5] or Process WEAVER""",,"- The abstract mentions the inclusion of process variables in various formalisms, which suggests a potential for integration across different programming paradigms. However, it does not explicitly describe a specific integration approach or mechanisms.
 - The mention of different formalisms like APPLA/A and extended Petri net notations indicates a consideration of multiple paradigms, but there is no detailed discussion of how these are integrated.
 - The abstract emphasizes the relationship between formalism design and enactment mechanisms, but this does not directly address the integration of programming paradigms.
 - There is no mention of specific integration mechanisms, interaction models, constraints, or novel translation techniques related to programming paradigm integration.","- ""The issues we have discussed above have a number of implications for the design of formalisms or languages for constructing enactable process definitions, and for the design of process definition enactment mechanisms that would form part of process centered environments.""
  - ""At this stage, it would be premature to regard these implications as requirements, even in an informal sense, but we believe that they can provide a starting point for developing a systematic set of requirements in the near future.""
  - ""We have also attempted to avoid making premature design decisions.""
  - ""For example, our discussion of process variables is, as far as possible, independent of any particular process definition paradigm.""
  - ""Constructs that corresponded to our notion of process variables could be included in a wide variety of new formalisms, or introduced as extensions to various existing formalisms, such as the programming language-like formalism of APPLA/A [8], the extended Petri net notations used in Archipel [5] or Process WEAVER""
  - ""The design of a process definition formalism is, of course, intimately related to the design of an enactment mechanism for that formalism (which must implement the operational semantics of the formalism as well as providing run time services to users and other environment components).""
  - ""In what follows, these two issues are discussed separately, but it is important to recognize that design decisions about definition formalisms cannot be made independently of decisions about enactment mechanisms.""",,"- The abstract discusses the design of formalisms and enactment mechanisms for process definitions, which implies a focus on process modeling rather than generic programming.
 - The mention of avoiding premature design decisions and keeping discussions independent of specific paradigms suggests a broad approach but does not specifically address generic programming or abstraction mechanisms.
 - The abstract does not provide a definition of ""concept"" used in the context of generic programming or abstraction.
 - There is no mention of mechanisms for representing generic abstractions or minimal type requirements.
 - The abstract does not discuss static checking or optimization strategies related to generic programming.
 - The focus is on process definition formalisms and enactment mechanisms rather than generic programming or abstraction mechanisms.","- ""The issues we have discussed above have a number of implications for the design of formalisms or languages for constructing enactable process definitions, and for the design of process definition enactment mechanisms that would form part of process centered environments.""
  - ""The design of a process definition formalism is, of course, intimately related to the design of an enactment mechanism for that formalism (which must implement the operational semantics of the formalism as well as providing run time services to users and other environment components).""
  - ""In what follows, these two issues are discussed separately, but it is important to recognize that design decisions about definition formalisms cannot be made independently of decisions about enactment mechanisms.""
  - ""Constructs that corresponded to our notion of process variables could be included in a wide variety of new formalisms, or introduced as extensions to various existing formalisms,""
  - ""At this stage, it would be premature to regard these implications as requirements, even in an informal sense, but we believe that they can provide a starting point for developing a systematic set of requirements in the near future.""
  - ""We have also attempted to avoid making premature design decisions.""",,"- The abstract discusses implications for the design of formalisms and enactment mechanisms, suggesting a focus on theoretical contributions related to these areas.
 - The mention of developing a ""systematic set of requirements"" implies a theoretical contribution towards establishing a framework or guidelines for future work in process definition formalisms and enactment mechanisms.
 - The abstract highlights the independence of process variables from specific paradigms, indicating a novel insight into the flexibility and adaptability of these constructs across different formalisms.
 - The interdependence of formalism design and enactment mechanism design is emphasized, which is a theoretical advancement as it suggests a holistic approach to these components.
 - The abstract does not explicitly mention specific theoretical advancements beyond existing approaches or direct implications for programming language design, but it implies a contribution by discussing the integration of process variables into various formalisms."
Object management support for the construction of complex applications,"P. Tarr, L. Clarke",-,-,-,1,1996,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Elimination of dichotomy between ""programming language"" and ""database"" objects; creation of a ""database programming language"" that applies both language and database capabilities equally to all objects.
 - Interaction models between paradigms: Integration of programming language and database object management capabilities; expansion of language and database semantics to accommodate each other's capabilities.
 - Constraints or challenges in paradigm integration: Historically different goals of programming languages and databases; need to address integration problems arising from inconsistent semantic models.
 - Any novel translation or embedding techniques: Not explicitly mentioned; focus on creating a unified framework rather than specific translation techniques.",Generic programming not extensively addressed,"- Key novel insights: Elimination of the dichotomy between programming language and database objects.
 - Theoretical advancements: Integration of programming language and database capabilities into a ""database programming language,"" formal definition of semantic models, and exploration of interactions between these models.
 - Potential implications for programming language design: Reduced complexity, improved maintainability, and more rapid development of software.","- ""The object management capabilities can be applied to any kinds of objects these systems may need to define, including non-traditional objects like threads and procedures.""
  - ""In this research, we formally define some of these semantic models, and explore and attempt to address the set of interactions via a prototype implementation and experimental evaluation.""
  - ""The database programming language approach thus reduces the burden on application developers and minimizes application complexity, resulting in more rapid development of more maintainable software.""
  - ""This approach eliminates the dichotomy between ""programming language"" and ""database"" objects, thus allowing the full set of language and database capabilities to be applied equally to all objects.""
  - ""The definition and long-term management of data in complex systems requires extensive support, including-high-level type and behavior modeling, persistence, query-based and navigational access, consistency management, and concurrency control.""",,"- The abstract discusses the need for extensive support in managing data in complex systems, including high-level type and behavior modeling, persistence, query-based and navigational access, consistency management, and concurrency control. These are not explicitly defined as conceptual primitives but are mentioned as necessary capabilities.
 - The approach described eliminates the distinction between programming language and database objects, suggesting a unified framework for object management. However, this is not explicitly listed as a conceptual primitive.
 - The abstract mentions that the object management capabilities can be applied to various types of objects, including non-traditional ones like threads and procedures. This indicates a broad applicability but does not specify these as conceptual primitives.
 - The abstract states that the research formally defines some semantic models and explores interactions via a prototype implementation. However, it does not specify what these semantic models are or define them as conceptual primitives.
 - Overall, the abstract does not explicitly list or define specific conceptual primitives for reconstructing programming paradigms.","- ""The definition and long-term management of data in complex systems requires extensive support, including-high-level type and behavior modeling, persistence, query-based and navigational access, consistency management, and concurrency control.""
  - ""We have developed a different approach to addressing the object management needs of complex applications.""
  - ""The resulting object management capabilities are provided in a programming language-like manner, sometimes referred to as a ""database programming language.""""
  - ""The database programming language approach thus reduces the burden on application developers and minimizes application complexity, resulting in more rapid development of more maintainable software.""
  - ""The database programming language approach raises several challenges, arising in part from the historically different goals of programming languages and databases.""
  - ""In this research, we formally define some of these semantic models, and explore and attempt to address the set of interactions via a prototype implementation and experimental evaluation.""",,"- The abstract discusses the need for extensive support in managing data in complex systems, including type and behavior modeling, persistence, and concurrency control. However, it does not specify any mathematical framework used to formalize these concepts.
 - The mention of a ""database programming language"" suggests a focus on programming language-like capabilities, but there is no explicit mention of a mathematical framework such as type theory or category theory.
 - The abstract mentions that the researchers ""formally define some of these semantic models,"" which implies some level of formalization, but it does not specify the type of mathematical framework used for this formalization.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.","- ""The definition and long-term management of data in complex systems requires extensive support, including-high-level type and behavior modeling, persistence, query-based and navigational access, consistency management, and concurrency control.""
  - ""Traditionally, some of these capabilities have been provided by programming languages (e.g., semantically rich type and behavior models and navigational access), while others have been provided by database management systems (e.g., persistence, queries, and concurrency control).""
  - ""No language or database has provided the full set of required capabilities, however.""
  - ""This has typically required developers to program in multiple paradigms, translating explicity between ""programming language"" and ""database"" models as necessary to use their respective capabilities.""
  - ""The object-oriented database approach has sought to reduce this impedance mismatch in certain areas, but discrepancies still remain.""
  - ""We have developed a different approach to addressing the object management needs of complex applications.""
  - ""This approach eliminates the dichotomy between ""programming language"" and ""database"" objects, thus allowing the full set of language and database capabilities to be applied equally to all objects.""
  - ""The resulting object management capabilities are provided in a programming language-like manner, sometimes referred to as a ""database programming language.""""
  - ""The database programming language approach thus reduces the burden on application developers and minimizes application complexity, resulting in more rapid development of more maintainable software.""
  - ""The database programming language approach raises several challenges, arising in part from the historically different goals of programming languages and databases.""
  - ""Languages are general-purpose and flexible, to support a wide variety of application semantics, while databases impose semantic restrictions to improve performance.""
  - ""Thus, fully integrating programming language and database object management capabilities requires expanding language and database semantics to accommodate capabilities from the other domain.""
  - ""It also requires addressing numerous integration problems that arise when these new semantic models are inconsistent with each other.""
  - ""In this research, we formally define some of these semantic models, and explore and attempt to address the set of interactions via a prototype implementation and experimental evaluation.""",,"- The abstract discusses the integration of programming languages and database management systems to provide a comprehensive set of capabilities for complex applications.
 - It highlights the traditional separation between programming languages and databases, which has required developers to work in multiple paradigms and translate between them.
 - The proposed approach is to eliminate this dichotomy by creating a ""database programming language"" that applies both language and database capabilities equally to all objects.
 - This approach aims to reduce the burden on developers and minimize application complexity by providing a unified framework.
 - The abstract mentions challenges in integrating these paradigms due to their historically different goals and the need to expand semantics to accommodate each other's capabilities.
 - It also notes the need to address integration problems arising from inconsistent semantic models.
 - The study involves formally defining semantic models and exploring interactions through a prototype implementation and experimental evaluation.","- ""The definition and long-term management of data in complex systems requires extensive support, including-high-level type and behavior modeling, persistence, query-based and navigational access, consistency management, and concurrency control.""
  - ""This approach eliminates the dichotomy between ""programming language"" and ""database"" objects, thus allowing the full set of language and database capabilities to be applied equally to all objects.""
  - ""The resulting object management capabilities are provided in a programming language-like manner, sometimes referred to as a ""database programming language.""""
  - ""This allows software developers to define objects, their interrelationships, and their behavioral semantics in the same programming language in which they build the systems that manipulate these objects.""
  - ""The object management capabilities can be applied to any kinds of objects these systems may need to define, including non-traditional objects like threads and procedures.""
  - ""The database programming language approach thus reduces the burden on application developers and minimizes application complexity, resulting in more rapid development of more maintainable software.""
  - ""The database programming language approach raises several challenges, arising in part from the historically different goals of programming languages and databases.""
  - ""Thus, fully integrating programming language and database object management capabilities requires expanding language and database semantics to accommodate capabilities from the other domain.""",,"- The abstract discusses the integration of programming language and database capabilities, which suggests a focus on genericity and abstraction by eliminating the dichotomy between these two domains.
 - The mention of ""high-level type and behavior modeling"" implies a focus on abstraction mechanisms, as it involves defining objects and their behaviors in a unified manner.
 - The ""database programming language"" approach allows for the application of language and database capabilities to all objects, which suggests a mechanism for representing generic abstractions.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, which are typically discussed in the context of generic programming.
 - The focus is more on the integration of programming language and database capabilities rather than specific generic programming methodologies or type system discussions.","- ""We have developed a different approach to addressing the object management needs of complex applications.""
  - ""This approach eliminates the dichotomy between ""programming language"" and ""database"" objects, thus allowing the full set of language and database capabilities to be applied equally to all objects.""
  - ""The resulting object management capabilities are provided in a programming language-like manner, sometimes referred to as a ""database programming language.""""
  - ""The database programming language approach thus reduces the burden on application developers and minimizes application complexity, resulting in more rapid development of more maintainable software.""
  - ""The database programming language approach raises several challenges, arising in part from the historically different goals of programming languages and databases.""
  - ""fully integrating programming language and database object management capabilities requires expanding language and database semantics to accommodate capabilities from the other domain.""
  - ""In this research, we formally define some of these semantic models, and explore and attempt to address the set of interactions via a prototype implementation and experimental evaluation.""",,"- The abstract introduces a novel approach to object management by eliminating the distinction between programming language and database objects. This is a key theoretical contribution as it integrates capabilities that were previously separate.
 - The concept of a ""database programming language"" is highlighted as a theoretical advancement, allowing for a unified approach to object management.
 - The integration of programming language and database capabilities is noted as a challenge due to their historically different goals, indicating a theoretical contribution in reconciling these differences.
 - The abstract mentions the formal definition of semantic models and the exploration of interactions between these models, which is a theoretical advancement in understanding how to integrate programming languages and databases.
 - The potential implications for programming language design are significant, as the approach aims to reduce complexity and improve maintainability, which are theoretical contributions to the field."
A survey of constraint-based programming paradigms,"M. Buscemi, U. Montanari",10.1016/j.cosrev.2008.10.001,https://doi.org/10.1016/j.cosrev.2008.10.001,Computer Science Review,16,2008,"1. Primitive Name: Constraints
  Definition: Constraints do not specify computing operations, but rather the properties of a solution to be found.
  Orthogonality Score: Not specified
 2. Primitive Name: Constraint Satisfaction Problems
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not specified
 3. Primitive Name: Constraint Logic Programming
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not specified
 4. Primitive Name: Concurrent Constraint Programming
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not specified",Not specified (the abstract does not provide details about the mathematical framework used to formalize and guarantee properties of the conceptual primitives),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Constraints support a programming style with declarative description and focus on solution properties rather than computing operations.
 - Theoretical advancements: Survey of main formalisms (Constraint Satisfaction Problems, Constraint Logic Programming, Concurrent Constraint Programming) and discussion of recent extensions and ongoing trends.
 - Potential implications for programming language design: Emphasis on declarative descriptions and solution properties could influence language design.","- ""Unlike basic primitives of other programming languages, constraints do not specify computing operations, but rather the properties of a solution to be found.""
  - ""Constraints support a programming style featuring declarative description and effective solving of several classes of problems.""
  - ""In this paper, we give a survey of the main formalisms based on constraints: Constraint Satisfaction Problems, Constraint Logic Programming and Concurrent Constraint Programming.""",,"- The abstract discusses constraints as a programming style that focuses on declarative description and solving problems, which implies that constraints are a key conceptual primitive.
 - It explicitly states that constraints do not specify computing operations but rather the properties of a solution, which is a definition of how constraints function as primitives.
 - The abstract mentions three main formalisms based on constraints: Constraint Satisfaction Problems, Constraint Logic Programming, and Concurrent Constraint Programming. These are likely the conceptual primitives being discussed, as they are central to the survey.
 - The abstract does not provide a detailed definition or orthogonality score for these primitives, nor does it explicitly list them as ""conceptual primitives."" However, they are implied to be fundamental to the programming paradigms discussed.","- ""constraints do not specify computing operations, but rather the properties of a solution to be found.""
  - ""we give a survey of the main formalisms based on constraints: Constraint Satisfaction Problems, Constraint Logic Programming and Concurrent Constraint Programming.""
  - ""We outline recent extensions of these approaches and we discuss ongoing trends of research.""
  - ""Constraints support a programming style featuring declarative description and effective solving of several classes of problems.""",,"- The abstract discusses the use of constraints in programming, which implies a focus on declarative programming and problem-solving.
 - It mentions the main formalisms based on constraints, such as Constraint Satisfaction Problems, Constraint Logic Programming, and Concurrent Constraint Programming, but does not specify the mathematical framework used to formalize these concepts.
 - The abstract does not provide details about the theoretical foundations, proof methodology, or formal verification discussions related to these formalisms.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""We outline recent extensions of these approaches and we discuss ongoing trends of research.""
  - ""In this paper, we give a survey of the main formalisms based on constraints: Constraint Satisfaction Problems, Constraint Logic Programming and Concurrent Constraint Programming.""
  - ""Constraints support a programming style featuring declarative description and effective solving of several classes of problems.""",,"- The abstract mentions a survey of main formalisms based on constraints, which includes Constraint Satisfaction Problems, Constraint Logic Programming, and Concurrent Constraint Programming. This suggests a focus on different programming paradigms related to constraints.
 - The abstract does not explicitly mention any specific integration mechanisms, interaction models, constraints, or challenges in integrating these paradigms.
 - There is no mention of novel translation or embedding techniques for integrating different programming paradigms.
 - The abstract focuses on surveying and discussing trends rather than detailing specific integration strategies or mechanisms.","- ""Unlike basic primitives of other programming languages, constraints do not specify computing operations, but rather the properties of a solution to be found.""
  - ""We outline recent extensions of these approaches and we discuss ongoing trends of research.""
  - ""Constraints support a programming style featuring declarative description and effective solving of several classes of problems.""
  - ""In this paper, we give a survey of the main formalisms based on constraints: Constraint Satisfaction Problems, Constraint Logic Programming and Concurrent Constraint Programming.""",,"- The abstract discusses the use of constraints in programming, which is a declarative approach focusing on problem properties rather than operations. This suggests a level of abstraction, as constraints define what needs to be solved rather than how to solve it.
 - The mention of ""Constraint Satisfaction Problems, Constraint Logic Programming and Concurrent Constraint Programming"" indicates that the paper surveys various formalisms related to constraints, which could involve generic programming concepts.
 - However, the abstract does not explicitly mention ""generic programming"" or ""abstraction mechanisms"" in terms of type systems, static checking, or optimization strategies.
 - The focus appears to be on the survey of constraint-based programming paradigms rather than specific mechanisms for generic programming or abstraction.","- ""Constraints support a programming style featuring declarative description and effective solving of several classes of problems.""
  - ""constraints do not specify computing operations, but rather the properties of a solution to be found.""
  - ""we give a survey of the main formalisms based on constraints: Constraint Satisfaction Problems, Constraint Logic Programming and Concurrent Constraint Programming.""
  - ""We outline recent extensions of these approaches and we discuss ongoing trends of research.""",,"- The abstract mentions that constraints support a programming style with declarative description and effective problem-solving, which is a key insight into how constraints are used in programming.
 - It highlights that constraints focus on the properties of a solution rather than computing operations, which is a theoretical contribution to understanding the role of constraints in programming.
 - The survey of main formalisms (Constraint Satisfaction Problems, Constraint Logic Programming, and Concurrent Constraint Programming) suggests a comprehensive overview of existing approaches, which is a theoretical contribution by providing a structured framework for understanding these paradigms.
 - The mention of ""recent extensions"" and ""ongoing trends of research"" implies that the paper discusses advancements beyond existing approaches, although specific details are not provided in the abstract.
 - The abstract does not explicitly mention potential implications for programming language design, but the discussion of constraints and their role in programming paradigms could imply theoretical contributions to language design by highlighting the importance of declarative descriptions and solution properties."
Conditional rewriting,"N. Dershowitz, D. Plaisted",10.1145/1012497.1012518,https://doi.org/10.1145/1012497.1012518,SOEN,9,1985,Not specified (the abstract does not provide explicit definitions or names for conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework),"- Specific integration mechanisms proposed: Use of conditional equations to combine logic programming and applicative/functional programming paradigms.
 - Interaction models between paradigms: Combination of syntax and semantics for a uniform computational paradigm.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Integration of logic programming and applicative/functional programming paradigms.
 - Theoretical advancements: Unified approach simplifying programming and verification by reducing disparity between specification and programming languages.
 - Potential implications: Streamlined verification processes and more convenient languages for specifying verifier components.","- ""Programming styles such as this impact verification in two ways: by reducing the disparity between specification and programming languages and by provided a potentially convenient language in which to spe:-cify, if not implement, verifier components.""
  - ""conditional (directed) equations provide a paradigm of computat.ion that combines the clean syntax and semantics of both the logic programming and applicative/functional programming paradigms in one, uniform manner.""",,"- The abstract discusses the use of ""conditional (directed) equations"" as a paradigm that integrates elements from logic programming and applicative/functional programming. This suggests that conditional equations are a key conceptual primitive in the study.
 - The abstract does not provide explicit definitions for these primitives beyond their role in combining programming paradigms.
 - There is no mention of specific names or detailed definitions for these primitives in the abstract.
 - The abstract does not discuss the level of abstraction or orthogonality of these primitives.","- ""conditional (directed) equations provide a paradigm of computat.ion that combines the clean syntax and semantics of both the logic programming and applicative/functional programming paradigms in one, uniform manner.""
  - ""Programming styles such as this impact verification in two ways: by reducing the disparity between specification and programming languages and by provided a potentially convenient language in which to spe:-cify, if not implement, verifier components.""",,"- The abstract discusses the use of ""conditional (directed) equations"" as a paradigm that combines elements of logic programming and applicative/functional programming. This suggests a focus on the use of equations as a mathematical framework, but it does not specify the type of mathematical framework (e.g., type theory, category theory) explicitly.
 - The abstract mentions the impact on verification, indicating that the framework might be related to formal verification, but it does not provide specific details about the mathematical properties guaranteed or the proof techniques used.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework in the abstract.
 - The abstract does not provide explicit details about the mathematical framework used to formalize and guarantee properties of the conceptual primitives.","- ""Programming styles such as this impact verification in two ways: by reducing the disparity between specification and programming languages and by provided a potentially convenient language in which to spe:-cify, if not implement, verifier components.""
  - ""conditional (directed) equations provide a paradigm of computat.ion that combines the clean syntax and semantics of both the logic programming and applicative/functional programming paradigms in one, uniform manner.""",,"- The abstract mentions that conditional equations combine the syntax and semantics of logic programming and applicative/functional programming paradigms. This suggests a theoretical integration strategy where these paradigms are unified under a single framework.
 - The integration mechanism proposed is the use of conditional equations, which provides a uniform manner of combining these paradigms.
 - The interaction model between paradigms is implied by the combination of their syntax and semantics, suggesting a harmonious interaction where both paradigms are integrated into a single computational paradigm.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.
 - The focus is on reducing disparity between specification and programming languages, which implies a comparative analysis of how these paradigms can be integrated to improve verification processes.","- ""Programming styles such as this impact verification in two ways: by reducing the disparity between specification and programming languages and by provided a potentially convenient language in which to spe:-cify, if not implement, verifier components.""
  - ""conditional (directed) equations provide a paradigm of computat.ion that combines the clean syntax and semantics of both the logic programming and applicative/functional programming paradigms in one, uniform manner.""",,"- The abstract discusses the use of conditional equations as a paradigm that combines elements of logic and functional programming. This suggests a focus on integrating different programming styles rather than explicitly addressing generic programming or abstraction mechanisms.
 - There is no mention of generic programming methodology, type systems, or abstraction mechanisms in the abstract. The focus is on the integration of programming paradigms and its impact on verification.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The abstract does not indicate that generic programming is a focus of the study.","- ""conditional (directed) equations provide a paradigm of computat.ion that combines the clean syntax and semantics of both the logic programming and applicative/functional programming paradigms in one, uniform manner.""
  - ""Programming styles such as this impact verification in two ways: by reducing the disparity between specification and programming languages and by provided a potentially convenient language in which to spe:-cify, if not implement, verifier components.""",,"- The abstract introduces a novel paradigm that integrates the syntax and semantics of logic programming and applicative/functional programming paradigms. This is a key novel insight as it suggests a unified approach that could simplify programming and verification processes.
 - The integration of these paradigms is a theoretical advancement beyond existing approaches, as it addresses the disparity between specification and programming languages. This is a significant theoretical contribution as it could lead to more cohesive and efficient programming practices.
 - The potential implications for programming language design are highlighted by the reduction in disparity between specification and programming languages. This could lead to more streamlined verification processes and potentially more convenient languages for specifying verifier components."
Towards a semiotic framework for programming languages,"Valle Andrea, Mazzei Alessandro",-,-,-,0,2013,Not specified (the abstract does not explicitly define conceptual primitives or provide their definitions),Not specified (the abstract does not provide details on a specific mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The balance between formal correctness and natural language variety in high-level languages; the connection to the Sapir-Whorf hypothesis in programming language expression.
 - Theoretical advancements: Analysis of persona, time, and space in imperative, functional, and object-oriented paradigms using enunciation theory.
 - Potential implications: Understanding semiotics and the Sapir-Whorf hypothesis could lead to more effective programming language design.","- ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""",,"- The abstract mentions the analysis of ""concepts of persona, time, and space"" in different programming paradigms. These could be considered as conceptual primitives since they are fundamental concepts being analyzed within the context of programming languages.
 - The abstract does not provide explicit definitions for these primitives, nor does it mention their level of abstraction or orthogonality.
 - The study seems to focus on a semiotic framework and the analysis of these concepts within different paradigms, but it does not specify these as conceptual primitives with detailed definitions or characteristics.","- ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""
  - ""A programming language is ”an artiﬁcial formalism in which algorithms can be expressed.""
  - ""All programming languages are Turing-complete.""",,"- The abstract discusses the semiotic framework and the Von Neumann machine, which are related to the theoretical foundations of programming languages.
 - The mention of Turing-completeness indicates a focus on the computational capabilities of programming languages.
 - However, there is no explicit mention of a specific mathematical framework such as type theory or category theory.
 - The abstract does not provide details on specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is more on the semiotic and theoretical aspects rather than mathematical formalization or verification.","- ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""
  - ""All programming languages are Turing-complete.""",,"- The abstract discusses the integration of different programming paradigms by mentioning the analysis of concepts like ""persona, time, and space"" in various paradigms (imperative, functional, and object-oriented). This suggests a theoretical integration strategy by examining these concepts across paradigms.
 - The mention of ""osmosis between human and machine semiotics"" implies a balance between formal correctness and natural language variety, which could relate to interaction models between paradigms.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques. It focuses more on the theoretical analysis of paradigms rather than practical integration strategies.
 - The abstract does not provide explicit details on how these paradigms are integrated or any specific integration approach.","- ""All programming languages are Turing-complete.""
  - ""A programming language is ”an artiﬁcial formalism in which algorithms can be expressed.""
  - ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""
  - ""In high-level languages, in which the abstraction allows for the introduction of a ”structured” form of linguistic representation based on the notion of ”control ﬂow” by means of conditionals and loop, there is an osmosis between human and machine semiotics,""",,"- The abstract discusses the semiotic framework of programming languages and their relationship with human and machine semiotics, but it does not explicitly mention generic programming or abstraction mechanisms.
 - The mention of ""abstraction"" in the context of high-level languages refers to the structured form of linguistic representation, but it does not delve into specific mechanisms for generic abstractions.
 - The abstract does not provide a definition of ""concept"" used in the context of generic programming or abstraction.
 - There is no mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The focus of the abstract is on the semiotic framework and the analysis of paradigms rather than on generic programming or abstraction mechanisms.","- ""In high-level languages, in which the abstraction allows for the introduction of a ”structured” form of linguistic representation based on the notion of ”control ﬂow” by means of conditionals and loop, there is an osmosis between human and machine semiotics, where the strict formal correctness of the machine side is balanced by the variety typical of natural languages.""
  - ""In other words, there is obviously a connection to the Sapir-Whorf hypothesis in the relationship between programming language and what it can express.""
  - ""A programming language is ”an artiﬁcial formalism in which algorithms can be expressed. For all its artiﬁciality, though, this formalism remains a language”.""
  - ""All programming languages are Turing-complete. This means that all languages are able to express the same ”things”, but the variety of languages (thousands of languages in ﬁfty years) demonstrates the need to express some of these ”things” better (more easily, more eﬃciently) than others.""
  - ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""",,"- The abstract discusses the semiotic framework of programming languages, highlighting the balance between formal correctness and natural language variety. This suggests a novel insight into how programming languages can be viewed as a form of language that interacts with human semiotics.
 - The mention of the Sapir-Whorf hypothesis indicates a theoretical contribution by exploring the relationship between programming languages and their expressive capabilities, which is a new perspective on how languages influence thought and expression.
 - The analysis of concepts like persona, time, and space in different programming paradigms (imperative, functional, object-oriented) suggests a theoretical advancement by applying enunciation theory to these paradigms, which could provide new insights into programming language design.
 - The abstract does not explicitly mention potential implications for programming language design, but the analysis of semiotics and the Sapir-Whorf hypothesis implies that understanding these aspects could lead to more effective language design."
6.2 Multi-way Merge with Constant Delay 6 Controlling Reactive Computations And(x = 4) : True)) 5.2 Local Execution 5 Controlling Nondeterminism 5.1 Finite Domain Constraint Techniques 4.2.4 Independent-and Style Translation 4.2.3 Andorra Principle Style Translation 4.2.2 Translating Deenitions with,V. Saraswat,-,-,-,0,2007,Not specified (the abstract does not provide explicit definitions or details about the conceptual primitives),Not specified (the abstract does not mention any mathematical framework or theoretical foundations),"- Specific integration mechanisms proposed: Means to structure search more powerful than plain backtracking; encapsulation of search in concurrent reactive processes; multi-way merger with constant delay.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Introduction of the Andorra Kernel Language (AKL) that combines Prolog and GHC paradigms.
 - Theoretical advancements: Provides capabilities beyond Prolog and GHC, including structured search more powerful than backtracking, encapsulation of search in concurrent reactive processes, and multi-way merger with constant delay.
 - Potential implications: Offers a refined and simplified framework for programming language design, enhancing search capabilities and concurrency.","- ""It is shown how AKL provides the programming paradigms of both Prolog and GHC.""
  - ""The Andorra Kernel Language (AKL) is introduced.""
  - ""It is also possible to write a multi-way merger with constant delay.""
  - ""It is possible to encapsulate search in concurrent reactive processes.""
  - ""There are means to structure search, more powerful than plain backtracking.""",,"- The abstract introduces the Andorra Kernel Language (AKL) and its ability to provide programming paradigms similar to Prolog and GHC. This suggests that AKL is a framework that integrates elements from these paradigms.
 - The abstract mentions ""means to structure search, more powerful than plain backtracking,"" which implies a conceptual primitive related to search structuring.
 - The ability to ""encapsulate search in concurrent reactive processes"" suggests another primitive related to concurrency and reactivity.
 - The mention of a ""multi-way merger with constant delay"" indicates a primitive related to merging processes with constant delay.
 - However, the abstract does not explicitly define these primitives or provide detailed definitions. It only mentions their existence and capabilities.
 - There is no mention of the level of abstraction or orthogonality of these primitives in the abstract.","- ""The Andorra Kernel Language (AKL) is introduced.""
  - ""It is shown how AKL provides the programming paradigms of both Prolog and GHC.""
  - ""There are means to structure search, more powerful than plain backtracking.""
  - ""It is possible to encapsulate search in concurrent reactive processes.""
  - ""It is also possible to write a multi-way merger with constant delay.""
  - ""Although AKL is an instance of our previously introduced Kernel Andorra Prolog framework, this exposition contains important extensions, and a considerable amount of unnecessary formal overhead has been stripped away.""",,"- The abstract introduces the Andorra Kernel Language (AKL) and its capabilities, but it does not explicitly mention any mathematical framework used to formalize or guarantee properties of the conceptual primitives.
 - There is no mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract.
 - The abstract focuses on the programming paradigms and capabilities of AKL rather than its mathematical underpinnings.
 - The mention of ""important extensions"" and ""unnecessary formal overhead has been stripped away"" suggests that there might be some theoretical or formal aspects, but these are not detailed in the abstract.","- ""The Andorra Kernel Language (AKL) is introduced.""
  - ""It is shown how AKL provides the programming paradigms of both Prolog and GHC.""
  - ""There are means to structure search, more powerful than plain backtracking.""
  - ""It is possible to encapsulate search in concurrent reactive processes.""
  - ""It is also possible to write a multi-way merger with constant delay.""
  - ""Although AKL is an instance of our previously introduced Kernel Andorra Prolog framework, this exposition contains important extensions, and a considerable amount of unnecessary formal overhead has been stripped away.""",,"- The abstract introduces the Andorra Kernel Language (AKL) as a platform that integrates the programming paradigms of both Prolog and GHC. This suggests that AKL is designed to combine these paradigms.
 - The mention of ""means to structure search, more powerful than plain backtracking"" and the ability to ""encapsulate search in concurrent reactive processes"" implies novel mechanisms for integrating these paradigms, particularly in terms of search and concurrency.
 - The ability to ""write a multi-way merger with constant delay"" suggests a specific integration mechanism related to data merging.
 - The abstract does not explicitly mention interaction models between paradigms or specific constraints or challenges in paradigm integration.
 - There is no mention of novel translation or embedding techniques beyond the general integration of Prolog and GHC paradigms.","- ""The Andorra Kernel Language (AKL) is introduced. It is shown how AKL provides the programming paradigms of both Prolog and GHC. This is the original goal of the design. However, it has also been possible to provide capabilities beyond that of Prolog and GHC. There are means to structure search, more powerful than plain backtracking. It is possible to encapsulate search in concurrent reactive processes. It is also possible to write a multi-way merger with constant delay.""",,"- The abstract introduces the Andorra Kernel Language (AKL) and its ability to provide programming paradigms similar to Prolog and GHC, indicating a focus on integrating different programming styles.
 - It mentions capabilities beyond Prolog and GHC, such as structuring search and encapsulating search in concurrent reactive processes, which suggests advanced abstraction mechanisms.
 - The abstract does not explicitly mention generic programming, type systems, or static checking strategies, which are key components of genericity and abstraction mechanisms.
 - The focus seems to be on the integration of programming paradigms and advanced search capabilities rather than generic programming or abstraction mechanisms.","- ""The Andorra Kernel Language (AKL) is introduced.""
  - ""It is shown how AKL provides the programming paradigms of both Prolog and GHC.""
  - ""However, it has also been possible to provide capabilities beyond that of Prolog and GHC.""
  - ""There are means to structure search, more powerful than plain backtracking.""
  - ""It is possible to encapsulate search in concurrent reactive processes.""
  - ""It is also possible to write a multi-way merger with constant delay.""
  - ""In these respects AKL is quite original.""
  - ""Although AKL is an instance of our previously introduced Kernel Andorra Prolog framework, this exposition contains important extensions, and a considerable amount of unnecessary formal overhead has been stripped away.""",,"- The abstract introduces the Andorra Kernel Language (AKL), which is a novel contribution as it combines the programming paradigms of both Prolog and GHC.
 - AKL provides capabilities beyond those of Prolog and GHC, indicating theoretical advancements beyond existing approaches.
 - The language offers means to structure search more powerfully than plain backtracking, which is a theoretical innovation.
 - The ability to encapsulate search in concurrent reactive processes is another unique theoretical contribution.
 - The possibility of writing a multi-way merger with constant delay is highlighted as an original feature.
 - The abstract mentions that AKL is ""quite original"" in these respects, emphasizing its novelty.
 - The removal of unnecessary formal overhead suggests a theoretical refinement and simplification of existing frameworks."
Behavioral Types in Programming Languages,"D. Ancona, V. Bono, M. Bravetti, Joana Campos, Giuseppe Castagna, Pierre-Malo Deniélou, S. Gay, N. Gesbert, Elena Giachino, Raymond Hu, E. Johnsen, F. Martins, V. Mascardi, F. Montesi, R. Neykova, Nicholas Ng, L. Padovani, V. Vasconcelos, N. Yoshida",10.1561/2500000031,https://doi.org/10.1561/2500000031,Found. Trends Program. Lang.,151,2016,"1. Primitive Name: Interfaces
  Definition: Part of behavioral type theory for describing software entities in terms of sequences of operations.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Communication Protocols
  Definition: Part of behavioral type theory for specifying sequences of messages exchanged between entities.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Contracts
  Definition: Part of behavioral type theory for ensuring correctness properties in communication.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Choreography
  Definition: Part of behavioral type theory for describing the overall coordination of a system.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Session Types
  Definition: A way to integrate communication protocols into object-oriented languages.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Amalgamated Sessions/Methods
  Definition: A construct in Stoop that unifies sessions and methods for concurrent execution.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Generic Types
  Definition: A way to ensure uniform behavior across different types using variables instead of actual types.
  Orthogonality Score: Not discussed
 

 8. Primitive Name: Scribble Language
  Definition: A platform-independent description language for asynchronous, multiparty message passing protocols.
  Orthogonality Score: Not discussed
 

 9. Primitive Name: Scribble Conversation API
  Definition: Provides local communication operations for implementing endpoint programs.
  Orthogonality Score: Not discussed
 

 10. Primitive Name: Scribble Runtime
  Definition: A local platform library for executing Scribble endpoint programs.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Safety, reliability, soundness of weight for function types
 - Proof techniques used: Behavioral type checking, communicating finite state automata for dynamic verification
 - Limitations or constraints of the framework: Not explicitly mentioned, but challenges in applying session types to practice are discussed","The study addresses integration of programming paradigms by extending object-oriented languages with session-based communication primitives and amalgamating methods and sessions into a unified construct, as seen in languages like Moose and Stoop. These approaches involve specific constructs for session communication and compile-time checking of dual session types, reflecting the shared features of sessions and methods.","- Definition of ""concept"" used: Genericity is discussed in terms of bounded polymorphism and generic types for session-centered communications.
 - Mechanisms for representing generic abstractions: Using variables instead of actual types, parameterized classes and methods.
 - Minimal type requirements identified: Bounded polymorphism (e.g., X <: Image).
 - Static checking or optimization strategies: Not explicitly mentioned.","The paper's novelty lies in providing a comprehensive overview of the state of the art in behavioral types, focusing on their integration with programming constructs and their application in preventing system errors like memory leaks. It highlights the practical implications of these theoretical advancements in real-world systems, such as the Ocean Observatories Initiative and Sing#. The paper synthesizes existing knowledge and applies it to new contexts, contributing to the field by demonstrating the practical utility of behavioral types.","- ""The successful application of behavioral types requires a solid understanding of several practical aspects, from their representation in a concrete programming language, to their integration with other programming constructs such as methods and functions, to design and monitoring methodologies that take behaviors into account.""
  - ""Behavioral type theory encompasses concepts such as interfaces, communication protocols, contracts, and choreography.""
  - ""The key idea of a behavioral type theory is to enrich the expressiveness of types so that it becomes possible to formally describe the sequences of messages (informally depicted in Figure 1 .1) that are expected to be exchanged along the communication channel s that connects Customer and Agency.""
  - ""The integration of session types into the object-oriented paradigms can be pursued:
 

 • by extending standard object-oriented languages with adhoc primitives for session-based communication, as in languages Moose [Dezani-Ciancaglini et al., 2005 , 2006 , 2009],
 

 Moose <: [Dezani-Ciancaglini et al., 2007], and AMoose [Coppo et al., 2007].""
  - ""The notion of communication is already implied in the objectoriented paradigm and, from this point of view, sessions do not introduce any innovation: the immediate encoding of methods through sessions, that could be seen simply as a generalization of methods, will be a confirmation of this.""
  - ""Sessions are invoked on threads in a manner similar to Ada's rendezvous, and execution starts when two threads reach a certain point in their execution, where they can ""serve"" the session.""
  - ""Stoop proposes ""amalgamated"" sessions/methods, which, for brevity, we shall call sessions from now on. Invocation takes place on an object, for instance a customer asks to withdraw money from a particular ATM machine, and execution of the corresponding session takes place immediately and concurrently with the requesting thread.""
  - ""The type system guarantees that the class of the exchanged object is one of the C i""
  - ""the integration of polymorphism and session types has been studied.""
  - ""The use of generic types allows the code to be typed ""generically"", using variables instead of actual types, guaranteeing uniform behavior on a range of types.""
  - ""The notion of weight extends to type variables: when α occurs in a constraint α t, the weight of α is approximated to the weight of t.""
  - ""The Scribble language is a platform-independent description language for the specification of asynchronous, multiparty message passing protocols""
  - ""The Scribble Conversation API provides the local communication operations for implementing the endpoint programs for each role natively in various mainstream languages.""
  - ""The Scribble Runtime is a local platform library for executing Scribble endpoint programs written using the Conversation API.""","- ""(Page 23, Table 1) |  | ""traditional"" session | ""traditional"" method | ""amalgamated"" session/method |
 \n|-------------------------|-----------------------|----------------------|------------------------------|
 \n| request on | a thread | an object | an object |""","- The paper discusses various conceptual primitives related to behavioral types, particularly in the context of programming languages and communication protocols.
 - Behavioral type theory is described as encompassing interfaces, communication protocols, contracts, and choreography, which are fundamental primitives in this context.
 - The integration of session types into object-oriented languages is highlighted, with specific languages like Moose and Stoop being mentioned as examples of how these primitives are applied.
 - The paper discusses the amalgamation of sessions and methods in Stoop, which represents a conceptual primitive in terms of how communication is handled.
 - The use of generic types and polymorphism is mentioned as a way to ensure uniform behavior across different types, which is another conceptual primitive.
 - The Scribble framework is introduced as a platform for specifying asynchronous, multiparty message passing protocols, which includes primitives for protocol specification and endpoint implementation.
 - The table on page 23 provides a comparison of traditional sessions, traditional methods, and amalgamated session/methods, which suggests a set of conceptual primitives related to how sessions and methods are invoked and executed.","- ""A recent trend in current research is to use behavioral type theory as the basis for new foundations, programming languages, and software development methods for communication-intensive distributed systems.""
  - ""The key idea of a behavioral type theory is to enrich the expressiveness of types so that it becomes possible to formally describe the sequences of messages (informally depicted in Figure 1 .1) that are expected to be exchanged along the communication channel s that connects Customer and Agency.""
  - ""The successful application of behavioral types to the development of reliable, large-scale software requires both the study of formal type theories but also understanding and addressing more practical aspects, including the representation of behavioral types such as T and S in a concrete programming language, the integration of behavioral type checking with other programming constructs like methods and functions, and also design methodologies that take behaviors into account.""
  - ""The survey is structured as a series of chapters, each covering a particular programming paradigm or methodology.""
  - ""The formal investigation of behavioral types in this setting has led to the discovery of un-forseen system configurations that yield memory leaks and to the development of refined behavioral type theories preventing them.""
  - ""The technique based on weights mentioned above does not work directly in a language with first-class functions. The problem is that function types only describe the function input and output, but not which other (heap-allocated) objects the function may use: this information is fundamental for defining a sound notion of weight for (linear) arrow types.""
  - ""The solution is to equip linear arrow types with an explicit annotation providing an upper bound to the weight of the types of all endpoints present in the function body.""
  - ""the weight approximates the length of chains of pointers in the heap: it is safe to send a function value over an endpoint only if its weight is bounded.""
  - ""The Scribble framework combines these elements to promote the MPST-based methodology for distributed software development depicted in Figure 8 .1.""
  - ""The Scribble language is a platform-independent description language for the specification of asynchronous, multiparty message passing protocols [Honda et al., 2014[Honda et al., , 2011]].""
  - ""The Scribble Conversation API provides the local communication operations for implementing the endpoint programs for each role natively in various mainstream languages.""
  - ""The Scribble Runtime is a local platform library for executing Scribble endpoint programs written using the Conversation API.""
  - ""the Scribble framework, differently from the above session languages, is designed to focus on dynamic verification of endpoint behavior [Hu et al., 2013].""
  - ""Endpoint monitoring by the local Conversation Runtime is performed by converting local protocols to communicating finite state automata, for which the accepted languages correspond to the I/O action traces permitted by the protocol.""",,"- The paper discusses the use of ""behavioral type theory"" as a mathematical framework for ensuring correctness properties in distributed systems. This indicates that type theory is a central mathematical framework used in the paper.
 - The paper mentions the use of ""formal type theories"" and ""behavioral type checking,"" which suggests that type theory is used to formalize and guarantee properties of the conceptual primitives.
 - The paper discusses the integration of behavioral types with programming constructs and design methodologies, indicating that type theory is used to ensure properties such as safety and reliability.
 - The paper mentions the use of ""weights"" and ""linear arrow types"" to define sound notions of weight for function types, which are specific mathematical properties guaranteed by the framework.
 - The paper discusses the use of ""communicating finite state automata"" for dynamic verification, which is a proof technique used in the framework.
 - The paper does not explicitly mention limitations or constraints of the framework, but it does discuss challenges in applying session types to practice and the need for further extensions.","- ""The integration of session types into the object-oriented paradigms can be pursued:
 

 • by extending standard object-oriented languages with adhoc primitives for session-based communication, as in languages Moose [Dezani-Ciancaglini et al., 2005 , 2006 , 2009],
 

 Moose <: [Dezani-Ciancaglini et al., 2007], and AMoose [Coppo et al., 2007].""
  - ""The rationale of the method-session amalgamation The fundamental idea at the basis of the Stoop language is to amalgamate sessions and methods in one construct and it arises mostly from two observations:
 

 1. sessions and methods share similar features; and 2. the integration of sessions and methods reflects well the intuition of a service.""
  - ""In Stoop session invocations have a body that will be executed in parallel with the body of the session requested. The two bodies must have dual session types. This is checked at compile time, not at runtime as in Moose.""",,"- The paper discusses the integration of session types into object-oriented programming paradigms through two main approaches: extending languages with session-based communication primitives and amalgamating methods and sessions into a single construct.
 - The first approach involves adding specific constructs to existing object-oriented languages to support session-based communication, as seen in languages like Moose and its variants.
 - The second approach, exemplified by the Stoop language, involves combining methods and sessions into a unified construct, leveraging their shared features and aligning with the concept of services.
 - The amalgamation approach in Stoop allows for parallel execution of session bodies and requires compile-time checking of dual session types, which is a novel aspect compared to runtime checks in other systems like Moose.
 - These integration strategies highlight the challenges of combining different paradigms, such as ensuring type safety and managing concurrent execution, while also proposing novel techniques like compile-time dual type checking.","- ""The natural course was to study bounded polymorphism for object-oriented sessions, by following the steps of Gay [2008], where bounded polymorphism is included into π-calculus sessions.""
  - ""In Capecchi et al. [2009] the adoption of generic types for session-centered communications is formalized for SAM g , a core objectoriented language based on the Stoop approach.""
  - ""The use of generic types allows the code to be typed ""generically"", using variables instead of actual types, guaranteeing uniform behavior on a range of types.""
  - ""In an object-oriented language this corresponds to having parameterized classes and methods.""
  - ""For instance, let reconsider the bounded polymorphism example shown before. We had a service with a behavior ?(X <: Image).!X that could interact with a client behaving as prescribed by !JPG.?JPG or with a client following the protocol represented by the type !GIF.?GIF.""
  - ""In the language with generic types we can implement this two clients with a single parameterized class Customer X extends Image , and then instantiate two objects of class Customer JPG and class Customer GIF""
  - ""the integration of polymorphism and session types has been studied. In Capecchi et al. [2009] the adoption of generic types for session-centered communications is formalized for SAM g , a core objectoriented language based on the Stoop approach.""",,"- The paper discusses the concept of genericity in the context of session types and object-oriented programming. It mentions the use of bounded polymorphism and generic types to represent generic abstractions.
 - The mechanism for representing generic abstractions involves using variables instead of actual types, allowing for uniform behavior across different types. This is achieved through parameterized classes and methods.
 - The minimal type requirements identified include the use of bounded polymorphism, where a type variable is constrained to be a subtype of a specific type (e.g., X <: Image).
 - The paper does not explicitly mention static checking or optimization strategies related to generic programming, but it implies that these mechanisms are part of the type system discussions.","- ""The successful application of behavioral types requires a solid understanding of several practical aspects, from their representation in a concrete programming language, to their integration with other programming constructs such as methods and functions, to design and monitoring methodologies that take behaviors into account.""
  - ""The aim of this survey is to provide a first comprehensive overview of the state of the art of these aspects, which we may summarize as the pragmatics of behavioral types.""
  - ""the survey provides substantial evidence that behavioral types have sprinkled a remarkable interest in the research community concerned with programming languages.""
  - ""The adoption of behavioral types beside the academic context proceeds more slowly, but nonetheless there are encouraging signals.""
  - ""The survey also contains pointers to industrial projects in which behavioral types already play a key role: the Ocean Observatories Initiative, which aims at the realization of a planetary-scale network for the trasmission of environmental data ( §8.2), and the programming language Sing # , developed by Microsoft, which offers behavioral types as a native and key feature (Chapter 6).""
  - ""The formal investigation of behavioral types in this setting has led to the discovery of un-forseen system configurations that yield memory leaks and to the development of refined behavioral type theories preventing them.""",,"- The paper provides a comprehensive overview of the state of the art in behavioral types, focusing on their practical application in programming languages. This suggests a novel synthesis of existing knowledge rather than a single new theoretical contribution.
 - The paper emphasizes the integration of behavioral types with other programming constructs, which is a key area of theoretical advancement. This integration is crucial for the practical application of behavioral types in real-world programming languages.
 - The paper highlights the role of behavioral types in preventing system errors such as memory leaks, indicating a theoretical contribution to the understanding and prevention of such issues.
 - The discussion of industrial applications, such as the Ocean Observatories Initiative and Sing#, suggests that the theoretical contributions have practical implications and are beginning to influence real-world systems.
 - The paper does not introduce a new theoretical framework but rather consolidates and applies existing theories to new contexts, which is a significant contribution to the field."
Towards a Generic Framework for Trustworthy Program Refactoring,"Dániel Horpácsi, Judit Köszegi, D. J. Németh",10.14232/ACTACYB.284349,https://doi.org/10.14232/ACTACYB.284349,Acta Cybernetica,2,2021,"1. Primitive Name: Conditional Term Rewrite Rules
  Definition: Consist of two patterns and a condition expression, using first-order terms with metavariables.
 2. Primitive Name: Semantic Conditions
  Definition: Logic formulae over a predicate set characterizing the abstractions of the object language.
 3. Primitive Name: Refactoring Schemes
  Definition: Special strategies combining conditional rewrite rules with semantic predicates.
 4. Primitive Name: Micro-Refactorings
  Definition: Smallest units of transformation, carrying out the least possible amount of transformation steps.","- Type of mathematical framework: Term rewriting and predicate logic
 - Specific mathematical properties guaranteed: Semantics preservation and consistency
 - Proof techniques used: Axiomatic definition of semantic predicates, dynamic semantics
 - Limitations or constraints of the framework: Verification of pattern equivalence is not decidable","- Specific integration mechanisms proposed: Language-parametric architecture, use of language-specific artefacts and language-independent components.
 - Interaction models between paradigms: Not explicitly described.
 - Constraints or challenges in paradigm integration: Not explicitly described.
 - Novel translation or embedding techniques: Schemes may stem from shared concepts among languages.","- Definition of ""concept"" used: Generic design for a refactoring framework that supports multiple languages and enables semi-automatic formal verification.
 - Mechanisms for representing generic abstractions: Refactoring specification formalism independent of the object language; language-specific semantic predicates and refactoring schemes.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novel framework for refactoring that is generic and adaptable to multiple programming paradigms.
 - Use of language-specific semantic predicates and refactoring schemes for trustworthiness and genericity.
 - Language-parametric framework with language-specific artefacts and language-independent components.
 - High-level abstractions for fine-grained separation of components.
 - Iterative methods for scheme construction (top-down and bottom-up).
 - Focus on dependency chains in programs for extensive transformations.","- ""Our aim with this paper is to outline a generic design for a refactoring framework that has all the above-mentioned features: it uses executable and extensible definitions, supports multiple languages and enables semi-automatic formal verification.""
  - ""We propose a specification formalism and a generic framework for its processing, which claims to allow semi-automatic execution and formal verification, as well as to be adaptable to multiple paradigms.""
  - ""The main contributions of this paper are:
 

 • Design of a generic refactoring approach that supports executable and semiautomatically verifiable transformations via language-specific semantic predicates and refactoring schemes;""
  - ""We structure the rest of the paper as follows. First, we survey related work in Section 2, focusing on language-agnostic approaches and proven-correct refactoring.""
  - ""In this section, we have explained the assumptions we make on the refactoring definition and the abstractions we use for specifying transformations.""
  - ""The transformation function over models could be defined imperatively, but we aim at defining it as declaratively as possible -as mentioned above, declarative programs contain less details as to how the execution takes place and thus they tend to be more reliable.""
  - ""Conditional term rewrite rules consist of two patterns and a condition expression:
 

 In such a rule, the matching and replacement patterns are first-order terms: they can contain metavariables to extract subterms and use those to construct new terms.""
  - ""Semantic conditions. As mentioned already, [18] gives in-depth explanation of how difficult it may be to reason about side-conditions expressed in terms of reachability statements.""
  - ""Refactoring schemes. In general, single conditional rewrite rules can only define local changes, so-called local refactorings.""
  - ""Schemes are special strategies that combine conditional rewrite rules, and are defined using ordinary control strategies as well as target modifying strategies combined with semantic predicates.""
  - ""The abstractions for defining local and scheme-based extensive refactorings are supposed to be micro-refactorings: they carry out the least possible amount of transformation steps which form a consistent change in the program.""",,"- The paper discusses a generic framework for refactoring that is adaptable to multiple programming paradigms, indicating a focus on conceptual primitives that are orthogonal and abstract enough to be applicable across different languages.
 - The framework uses ""executable and extensible definitions"" and ""language-specific semantic predicates and refactoring schemes,"" which suggests that these are key conceptual primitives.
 - The paper mentions ""conditional term rewrite rules"" and ""semantic conditions"" as part of the framework, which are likely primitives for defining transformations.
 - ""Refactoring schemes"" are described as strategies that combine conditional rewrite rules, indicating they are another set of primitives for defining extensive changes.
 - The term ""micro-refactorings"" is used to describe the smallest units of transformation, suggesting these are fundamental primitives for building more complex refactorings.
 - The paper does not explicitly list these as ""conceptual primitives,"" but they are central to the framework's design and functionality.","- ""We propose a specification formalism and a generic framework for its processing, which claims to allow semi-automatic execution and formal verification, as well as to be adaptable to multiple paradigms.""
  - ""The transformation function over models could be defined imperatively, but we aim at defining it as declaratively as possible -as mentioned above, declarative programs contain less details as to how the execution takes place and thus they tend to be more reliable.""
  - ""Conditional term rewrite rules consist of two patterns and a condition expression:
 

 In such a rule, the matching and replacement patterns are first-order terms: they can contain metavariables to extract subterms and use those to construct new terms.""
  - ""Semantic conditions. As mentioned already, [18] gives in-depth explanation of how difficult it may be to reason about side-conditions expressed in terms of reachability statements. To overcome this issue, unlike traditional term rewriting, we do not refer to the rewrite relation in the condition; instead, the conditions are logic formulae over a predicate set characterising the abstractions of the object language.""
  - ""Refactoring schemes. In general, single conditional rewrite rules can only define local changes, so-called local refactorings. On the other hand, many refactorings span over entire projects and are inherently extensive: they affect many locations in the program, which have to be modified consistently.""
  - ""Consistency. The key concept behind schemes is dependency: extensive transformations have to follow dependency chains in the program, visit and change those program elements consistently that are interdependent.""
  - ""The prover builds on the metatheory definition by utilizing the axiomatic definition of the semantic predicates, the pattern equivalence is proven upon the definition of dynamic semantics and the definition of semantic equivalence.""
  - ""Verification of pattern equivalence is not decidable, but in a lot of cases, advanced, problem-specific proof tactics can lead to equivalence proofs.""",,"- The paper discusses a generic framework for refactoring that involves formal verification, indicating a mathematical framework is used.
 - The framework uses ""conditional term rewrite rules"" and ""semantic conditions"" expressed as logic formulae, suggesting a formal system based on term rewriting and predicate logic.
 - The use of ""refactoring schemes"" and ""consistency"" based on dependency chains implies a structured approach to ensuring correctness, possibly related to category theory or graph theory, but not explicitly mentioned.
 - The paper mentions ""axiomatic definition of semantic predicates"" and ""dynamic semantics,"" which are typical components of formal verification frameworks, often involving type theory or operational semantics.
 - The limitation mentioned is that ""verification of pattern equivalence is not decidable,"" indicating a constraint in the framework's ability to automatically verify certain properties.","- ""Our aim with this paper is to outline a generic design for a refactoring framework that has all the above-mentioned features: it uses executable and extensible definitions, supports multiple languages and enables semi-automatic formal verification.""
  - ""In particular, we present abstractions for program representation and refactoring definition, and we describe a language-parametric architecture that can be tailored to programming languages of different paradigms by supplying the formal definition of the language along with some refactoring schemes.""
  - ""The proposed design is language-generic: the refactoring specification language is independent of the object language, as well as the implementation framework is language-parametric.""
  - ""We sort of rephrase and restructure the usual way of defining and implementing a refactoring, and this rephrasing allows us to cut out and abstract away some language-specific elements.""
  - ""Language-independence of refactoring schemes. Language-level refactoring schemes enable high-level description of transformations that respect lower-level dependencies.""
  - ""Schemes may stem from concepts that are shared among different languages, and in the long term, we plan to investigate the possibility of implementing a set of schemes that are defined in terms of concepts common in various languages.""",,"- The paper discusses a generic framework for refactoring that is designed to be adaptable to multiple programming paradigms. This is indicated by the mention of a ""language-parametric architecture"" that can be tailored to different paradigms.
 - The framework uses ""executable and extensible definitions"" and supports ""semi-automatic formal verification,"" which suggests a flexible approach to integrating different paradigms.
 - The paper highlights the use of ""language-specific artefacts and language-independent components,"" which implies a modular approach to paradigm integration.
 - The concept of ""refactoring schemes"" is introduced as a way to describe transformations that respect lower-level dependencies, which could be a mechanism for integrating different paradigms.
 - The paper mentions that schemes may stem from shared concepts among languages, suggesting a potential for novel translation or embedding techniques based on commonalities between paradigms.
 - However, the paper does not provide specific details on interaction models between paradigms or explicit constraints or challenges in paradigm integration.","- ""Our aim with this paper is to outline a generic design for a refactoring framework that has all the above-mentioned features: it uses executable and extensible definitions, supports multiple languages and enables semi-automatic formal verification.""
  - ""The main contributions of this paper are:
 

 • Design of a generic refactoring approach that supports executable and semiautomatically verifiable transformations via language-specific semantic predicates and refactoring schemes;""
  - ""The transformation function over models could be defined imperatively, but we aim at defining it as declaratively as possible -as mentioned above, declarative programs contain less details as to how the execution takes place and thus they tend to be more reliable.""
  - ""The refactoring specification formalism, apart from the syntax of the patterns in the rewrite rules, is independent of the object language (we note that although predicates are language-dependent, the condition language over predicate symbols is language-independent).""
  - ""The proposed specification language is independent of the object language1 , and it can be interpreted in a generic framework parametrized by the definition of the object language.""
  - ""The framework accommodates a frontend and two backends for the two purposes. The frontend, using a lightweight analysis of the refactoring definition, creates the intermediate representation (IR) of the refactoring specification, whilst the two backends implement the two different sorts of semantics for the refactoring specification.""
  - ""The proposed design is language-generic: the refactoring specification language is independent of the object language, as well as the implementation framework is language-parametric.""",,"- The paper discusses a ""generic design"" for a refactoring framework, indicating a focus on generic programming.
 - The framework is designed to be ""language-generic,"" meaning it can be applied to multiple programming languages, which is a key aspect of generic programming.
 - The use of ""executable and extensible definitions"" and ""semi-automatic formal verification"" suggests mechanisms for representing generic abstractions.
 - The paper mentions a ""refactoring specification formalism"" that is independent of the object language, which implies a mechanism for abstraction.
 - The framework's architecture, with a frontend and two backends, suggests a structured approach to handling genericity and abstraction.
 - The paper does not explicitly discuss minimal type requirements or static checking strategies, but it does mention the use of ""language-specific semantic predicates"" and ""refactoring schemes,"" which could relate to type requirements and optimization strategies.","- ""The main contributions of this paper are:
 

 • Design of a generic refactoring approach that supports executable and semiautomatically verifiable transformations via language-specific semantic predicates and refactoring schemes;
 

 • Description of a language-parametric framework with language-specific artefacts and language-independent components, with a guideline on how the framework is tailored for a particular language;
 

 • Testimonials of applying the above-mentioned framework to languages of two different programming paradigms.""
  - ""Our aim with this paper is to outline a generic design for a refactoring framework that has all the above-mentioned features: it uses executable and extensible definitions, supports multiple languages and enables semi-automatic formal verification.""
  - ""The key concept behind schemes is dependency: extensive transformations have to follow dependency chains in the program, visit and change those program elements consistently that are interdependent.""
  - ""We have shown that the high abstraction level of the definition enables a fine-grained separation of the various components in a refactoring tool, which in turn allows the recognition and extraction of language-dependent elements, leading to a language-generic implementation.""
  - ""We propose two iterative methods for scheme construction: top-down and bottom-up.""
  - ""Our proposed solution facilitates execution and static verification of refactoring definitions for different object languages.""
  - ""The proposed design is language-generic: the refactoring specification language is independent of the object language, as well as the implementation framework is language-parametric.""",,"- The paper introduces a novel framework for refactoring that is generic and adaptable to multiple programming paradigms, which is a significant theoretical contribution.
 - The framework uses language-specific semantic predicates and refactoring schemes, which is a new approach to ensuring trustworthiness and genericity in refactoring.
 - The paper describes a language-parametric framework, which is a theoretical advancement beyond existing approaches that are often language-specific.
 - The use of high-level abstractions allows for a fine-grained separation of components, enabling a language-generic implementation.
 - The introduction of iterative methods for scheme construction (top-down and bottom-up) is a theoretical innovation in the design of refactoring schemes.
 - The focus on dependency chains in programs for extensive transformations is a novel insight into how refactoring can be made more trustworthy and efficient."
Readings and Reflections about Hierarchy and Heterarchy in Programming Paradigms,-,-,-,-,0,2007,"1. Primitive Name: Algebra
  Definition: A mathematical framework for expressing construction in computer science.
  Orthogonality Score: Not specified
 2. Primitive Name: Coalgebra
  Definition: A mathematical framework for expressing observation in computer science.
  Orthogonality Score: Not specified
 3. Primitive Name: Construction vs. Observation
  Definition: A dichotomy describing the basic approach to programming paradigms.
  Orthogonality Score: Not specified
 4. Primitive Name: Interacting-Components Architecture
  Definition: A computational model characterized by signal-response interaction.
  Orthogonality Score: Not specified","- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Fixed points of recursive type equations
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not explicitly mentioned",No specific integration approach described (the abstract discusses theoretical integration strategies and interaction models but does not provide specific mechanisms or techniques),Generic programming not extensively addressed,"- Key novel insights: The distinction between algebra and coalgebra as a fundamental dichotomy in computer science, described as construction versus observation.
 - Theoretical advancements: Characterization of interacting-components MOCs by a ""signal-response"" interaction, and the homogeneous structure of object-oriented programs.
 - Potential implications: Theoretical insights could inform the design of programming languages that better incorporate algebraic and coalgebraic concepts.","- ""A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""The basic dichotomy may be described as construction versus observation''""",,"- The abstract discusses the distinction between algebra and coalgebra as a fundamental conceptual framework in computer science, which suggests these are conceptual primitives.
 - The dichotomy of ""construction versus observation"" is highlighted as a basic principle, indicating it is a conceptual primitive.
 - The mention of ""interacting-components architecture"" and ""signal-response"" interaction suggests these are conceptual primitives related to computation models.
 - The abstract does not explicitly list these as ""conceptual primitives,"" but they are central to the discussion of programming paradigms.
 - The level of abstraction is high, as these concepts are foundational to understanding programming paradigms.
 - Orthogonality is not explicitly discussed, but the primitives seem to be distinct and non-overlapping.","- ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Whereas abstract data types in the initial approach may be formalized as minimal soulutions (fixed points) of recursive type equations, object types may be understood as maximal solutions (fixed points) of recursive type equations''""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines. A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""The initial algebras and terminal coalgebras ... can be described in a canonical way: an initial algebra can be obtained from the closed terms (i.e. from those terms which are generated by iteratively applying the algebra's constructor operations), and the terminal coalgebra can be obtained from the pure observations''""",,"- The abstract discusses the use of algebras and coalgebras as a mathematical framework to formalize data types and object types. This suggests that the mathematical framework is based on category theory, as algebras and coalgebras are central concepts in this field.
 - The mention of ""minimal soulutions (fixed points) of recursive type equations"" and ""maximal solutions (fixed points) of recursive type equations"" indicates specific mathematical properties related to type theory and fixed points, which are often used in category theory to guarantee properties of data types.
 - The abstract does not explicitly mention proof techniques or limitations of the framework, but it does describe the canonical way to obtain initial algebras and terminal coalgebras, which implies a formal verification process.
 - The abstract does not provide detailed information on proof methodologies or specific limitations of the framework, but it does highlight the role of algebras and coalgebras in formalizing data types and object types.","- ""The basic dichotomy may be described as construction versus observation''""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a fundamental aspect of programming paradigms, indicating a theoretical integration strategy.
 - It mentions the interaction between different computing units and models, suggesting an interaction model between paradigms.
 - The abstract highlights the role of object-oriented programming in integrating different models, such as message-passing and client/server models, which implies a specific integration mechanism.
 - The mention of ""signal-response"" interaction and different models of computation suggests a novel approach to integrating paradigms.
 - However, the abstract does not explicitly describe a specific integration approach or novel translation/embedding techniques beyond these general concepts.","- ""Whereas abstract data types in the initial approach may be formalized as minimal soulutions (fixed points) of recursive type equations, object types may be understood as maximal solutions (fixed points) of recursive type equations''""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""The initial algebras and terminal coalgebras ... can be described in a canonical way: an initial algebra can be obtained from the closed terms (i.e. from those terms which are generated by iteratively applying the algebra's constructor operations), and the terminal coalgebra can be obtained from the pure observations''""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Message-passing Models, Client/Server Models or Object Models [MCOM, Quib 99-104] are closely connected with the object abstraction:""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""",,"- The abstract discusses the distinction between algebra and coalgebra, which is relevant to understanding generic programming and abstraction mechanisms. Algebra is associated with construction, while coalgebra is associated with observation.
 - The mention of ""minimal soulutions (fixed points) of recursive type equations"" for abstract data types and ""maximal solutions (fixed points) of recursive type equations"" for object types suggests a focus on type systems and how they are formalized.
 - The description of initial algebras and terminal coalgebras provides insight into how these concepts are used to describe data and computation, which is relevant to generic programming.
 - The discussion of interacting-components architecture and signal-response interaction suggests a mechanism for representing generic abstractions through interaction models.
 - The abstract does not explicitly mention static checking or optimization strategies, nor does it provide a clear definition of ""concept"" or minimal type requirements.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""The basic dichotomy may be described as construction versus observation''""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a fundamental theoretical contribution in understanding programming paradigms. This distinction is framed in terms of data versus machines and construction versus observation, providing a novel insight into the nature of programming.
 - The mention of interacting-components MOCs and their characterization by a ""signal-response"" type of interaction suggests a theoretical advancement in understanding how computation is structured in these models.
 - The discussion of different interaction styles and their connection to object abstraction highlights a theoretical contribution in understanding how object-oriented programming differs from traditional programming paradigms.
 - The abstract does not explicitly mention potential implications for programming language design, but the theoretical insights provided could have implications for designing languages that better incorporate these concepts."
Semantics of Interaction,S. Abramsky,10.1007/3-540-61064-2_24,https://doi.org/10.1007/3-540-61064-2_24,Colloquium on Trees in Algebra and Programming,102,1996,Not specified (the abstract discusses theoretical frameworks but does not explicitly define conceptual primitives),"- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Limited in capturing fine-structural features and dynamical aspects","No specific integration approach described (the abstract discusses the need for integration and introduces Intensional Semantics as a bridge between paradigms, but does not provide specific mechanisms or techniques)",Generic programming not extensively addressed,"- Key novel insights: Intensional Semantics bridges denotational and operational semantics by incorporating dynamical aspects.
 - Theoretical advancements: Combines mathematical structure with dynamical aspects; addresses limitations in classical denotational semantics.
 - Potential implications: Enhances understanding of computational dynamics, potentially improving programming language design.","- ""We will focus on the recent work on Game semantics, which has led to some striking advances in the Full Abstraction problem for PCF and other programming languages""
  - ""A number of recent developments (and, with hindsight, some older ones) can be seen as contributing to this goal of Intensional Semantics.""
  - ""Thus we may think of Intensional semantics as “Denotational semantics + time (dynamics)”, or as “Syntax-free operational semantics”.""
  - ""This analysis suggests a desideratum of Intensional Semantics, interpolating between denotational and operational semantics as traditionally conceived.""
  - ""operational semantics is formulated in terms of the syntax of the language being modelled; it is highly intensional in character; and it is capable of expressing the dynamical aspects of computation.""
  - ""Denotational semantics is often referred to as “mathematical semantics” because it exhibits a high degree of mathematical structure; this is in part achieved by the fact that denotational semantics abstracts away from the dynamics of computation—from time.""
  - ""The “classical” paradigm for denotational semantics models data types as domains, i.e. structured sets of some kind, and programs as (suitable) functions between domains.""",,"- The abstract discusses the classical paradigm of denotational semantics, which models data types as domains and programs as functions between these domains. This is a conceptual framework rather than specific primitives.
 - It contrasts denotational semantics with operational semantics, highlighting their different focuses on mathematical structure versus dynamical aspects.
 - The abstract suggests a need for Intensional Semantics that combines the strengths of both denotational and operational semantics, but it does not explicitly define specific conceptual primitives.
 - The mention of Game semantics and its contributions to the Full Abstraction problem indicates a focus on this area, but again, no specific primitives are defined in the abstract.
 - The abstract does not provide explicit definitions or lists of conceptual primitives for reconstructing programming paradigms.","- ""Denotational semantics is often referred to as “mathematical semantics” because it exhibits a high degree of mathematical structure; this is in part achieved by the fact that denotational semantics abstracts away from the dynamics of computation—from time.""
  - ""The semantic universe in which the denotational modelling is carried out is thus a category with domains as objects, functions as morphisms, and composition of morphisms given by function composition.""
  - ""Thus we may think of Intensional semantics as “Denotational semantics + time (dynamics)”,""
  - ""This analysis suggests a desideratum of Intensional Semantics, interpolating between denotational and operational semantics as traditionally conceived.""
  - ""The classical denotational paradigm has been very successful, but has some definite limitations.""",,"- The abstract mentions that the semantic universe is modeled using a category with domains as objects and functions as morphisms, which indicates the use of category theory as the mathematical framework.
 - The abstract describes denotational semantics as exhibiting a high degree of mathematical structure, which suggests that the framework provides specific mathematical properties, although these are not explicitly detailed.
 - The limitations of the classical denotational paradigm are noted, particularly in capturing fine-structural features and dynamical aspects, which implies constraints or limitations of the framework.
 - The abstract does not explicitly mention specific proof techniques or methodologies used within this framework.
 - The abstract does not provide detailed information on the specific mathematical properties guaranteed by the framework or any formal verification discussions.","- ""We will focus on the recent work on Game semantics, which has led to some striking advances in the Full Abstraction problem for PCF and other programming languages""
  - ""A number of recent developments (and, with hindsight, some older ones) can be seen as contributing to this goal of Intensional Semantics.""
  - ""Thus we may think of Intensional semantics as “Denotational semantics + time (dynamics)”, or as “Syntax-free operational semantics”.""
  - ""This analysis suggests a desideratum of Intensional Semantics, interpolating between denotational and operational semantics as traditionally conceived.""
  - ""Neither concurrency nor “advanced” imperative features such as local references have been captured denotationally in a fully convincing fashion.""
  - ""The classical denotational paradigm has been very successful, but has some definite limitations.""",,"- The abstract discusses the limitations of the classical denotational paradigm, particularly in handling concurrency and advanced imperative features. This suggests a need for integration beyond traditional denotational semantics.
 - The concept of Intensional Semantics is introduced as a way to bridge the gap between denotational and operational semantics, which implies an integration approach.
 - The abstract describes Intensional Semantics as combining the structural properties of denotational semantics with the dynamical aspects of operational semantics, which is a form of integration.
 - The mention of Game semantics and its advances in Full Abstraction problems for various programming languages indicates a specific integration mechanism.
 - However, the abstract does not explicitly detail specific integration mechanisms, interaction models, constraints, or novel translation techniques beyond the general concept of Intensional Semantics and Game semantics.","- ""The “classical” paradigm for denotational semantics models data types as domains, i.e. structured sets of some kind, and programs as (suitable) functions between domains.""
  - ""Denotational semantics is often referred to as “mathematical semantics” because it exhibits a high degree of mathematical structure; this is in part achieved by the fact that denotational semantics abstracts away from the dynamics of computation—from time.""
  - ""The classical denotational paradigm has been very successful, but has some definite limitations.""
  - ""This analysis suggests a desideratum of Intensional Semantics, interpolating between denotational and operational semantics as traditionally conceived.""
  - ""Thus we may think of Intensional semantics as “Denotational semantics + time (dynamics)”, or as “Syntax-free operational semantics”.""
  - ""Our aim is to give a genuinely elementary first introduction; we therefore present a simplified version of game semantics, which nonetheless""",,"- The abstract primarily discusses the limitations of classical denotational semantics and the need for an intensional semantics that combines mathematical structure with dynamical aspects.
 - There is no mention of generic programming or abstraction mechanisms in the abstract.
 - The focus is on the transition from classical denotational semantics to intensional semantics, particularly through game semantics, but does not address genericity or abstraction mechanisms.
 - The abstract does not provide any information on the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""The classical denotational paradigm has been very successful, but has some definite limitations.""
  - ""fine-structural features of computation, such as sequentiality, computational complexity, and optimality of reduction strategies, have either not been captured at all denotationally, or not in a fully satisfactory fashion.""
  - ""Neither concurrency nor “advanced” imperative features such as local references have been captured denotationally in a fully convincing fashion.""
  - ""This analysis suggests a desideratum of Intensional Semantics, interpolating between denotational and operational semantics as traditionally conceived.""
  - ""This should combine the good mathematical structural properties of denotational semantics with the ability to capture dynamical aspects and to embody computational intuitions of operational semantics.""
  - ""Thus we may think of Intensional semantics as “Denotational semantics + time (dynamics)”, or as “Syntax-free operational semantics”.""
  - ""A number of recent developments (and, with hindsight, some older ones) can be seen as contributing to this goal of Intensional Semantics.""
  - ""We will focus on the recent work on Game semantics, which has led to some striking advances in the Full Abstraction problem for PCF and other programming languages""",,"- The abstract identifies limitations in the classical denotational paradigm, particularly in capturing fine-structural features of computation and concurrency.
 - It proposes a new approach called Intensional Semantics, which aims to bridge the gap between denotational and operational semantics by incorporating dynamical aspects.
 - The abstract suggests that Intensional Semantics can capture mathematical structure and dynamical aspects, offering a more comprehensive approach.
 - The focus on Game semantics indicates a theoretical advancement in addressing the Full Abstraction problem for programming languages like PCF.
 - The abstract implies that this work contributes to a broader goal of developing Intensional Semantics, which has potential implications for programming language design by providing a more nuanced understanding of computational dynamics."
Formalising sharing mechanisms in object-oriented paradigm,"Verónica Argarañaz, G. Baum, C. Pons, María José Presso, M. Prieto, Natalia Romero",-,-,-,0,1997,"1. Primitive Name: Objects
  Definition: Basic elements in the model used to construct sharing schemes.
  Orthogonality Score: Not specified
 2. Primitive Name: Messages
  Definition: Basic elements in the model used to construct sharing schemes.
  Orthogonality Score: Not specified
 3. Primitive Name: Delegation
  Definition: Ability to express delegation between concrete objects.
  Orthogonality Score: Not specified
 4. Primitive Name: Sharing Relationship in Object Creation
  Definition: Primitives to express the sharing relationship in object creation.
  Orthogonality Score: Not specified
 5. Primitive Name: Changing Sharing Relationship
  Definition: Primitives to change the sharing relationship.
  Orthogonality Score: Not specified
 6. Primitive Name: Referencing Donor of an Object
  Definition: Primitives to reference the donor of an object.
  Orthogonality Score: Not specified","Not specified (the abstract does not provide explicit details about the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework)","- Specific integration mechanisms proposed: Defining sharing constructs for an object-based (prototypes) high-level language and translating them into a formal calculus.
 - Interaction models between paradigms: Per object delegation to represent every sharing scheme possible in a prototype environment.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Using the impς-calculus to represent class-based and prototype-based languages within a unified framework.",Generic programming not extensively addressed,"- Key novel insights: The authors propose a more basic model for sharing schemes using only objects and messages, which can unify class-based and prototype-based languages.
 - Theoretical advancements: The work introduces per object delegation in the calculus, allowing for the representation of every sharing scheme possible in a prototype environment.
 - Potential implications: The model could influence programming language design by providing a unified and basic framework for object-oriented programming.","- ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""Abadi and Cardelli have defined a calculus of objects which represents the basic elements.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment,""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""There are primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object.""",,"- The abstract discusses the use of a basic model with ""just objects and messages"" as the foundation for constructing sharing schemes. This suggests that ""objects"" and ""messages"" are fundamental primitives in their approach.
 - The mention of Abadi and Cardelli's calculus of objects indicates that this calculus is a theoretical framework used to represent basic elements, likely including objects and messages.
 - The focus on ""delegation between concrete objects"" and ""per object delegation"" implies that delegation is a key primitive in their model, allowing for the representation of sharing schemes.
 - The abstract explicitly mentions ""primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object."" These are specific primitives related to sharing and delegation.
 - The level of abstraction is high since these primitives are foundational elements used to reconstruct programming paradigms.
 - Orthogonality is not explicitly discussed in the abstract, but the focus on basic, fundamental elements suggests an attempt to maintain orthogonality by using simple, non-overlapping concepts.","- ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in Object-Oriented languages can be built using only objects and messages.""
  - ""We have built per object delegation using the calculus.""
  - ""Abadi & Cardelli describe how to build the concepts of class based languages in their formalism, but they don't represent the ability to share behavior by delegation among concrete objects present in prototype based languages.""
  - ""Martin Abadi & Luca Cardelli have defined a formal calculus of objects, the impς-calculus, which consists just of objects, object communication and object update [Abadi96].""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""",,"- The abstract mentions the use of a ""formal calculus of objects"" known as the ""impς-calculus,"" which is a mathematical framework developed by Abadi and Cardelli.
 - This framework is based on objects, object communication, and object update, indicating a focus on object-oriented concepts.
 - The abstract does not specify the type of mathematical framework (e.g., type theory, category theory) explicitly, nor does it detail specific mathematical properties guaranteed or proof techniques used.
 - The focus is on the application of the calculus to represent sharing schemes and delegation, rather than on the underlying mathematical properties or proof methodologies.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""Sharing of behavior is one of the most important features in the Object-Oriented paradigm.""
  - ""The two classical organisations of sharing are classes and prototypes, raising two different models and two families of object oriented languages.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in OO can be built using only objects and messages.""
  - ""Martin Abadi & Luca Cardelli have defined a formal calculus of objects, the impς-calculus, which consists just of objects, object communication and object update""
  - ""Abadi & Cardelli describe how to build the concepts of class based languages in their formalism, but they don't represent the ability to share behavior by delegation among concrete objects present in prototype based languages.""
  - ""We have built per object delegation using the calculus.""",,"- The abstract discusses the integration of different programming paradigms within the Object-Oriented paradigm, specifically focusing on the integration of class-based and prototype-based models.
 - The authors propose a basic model using just objects and messages to construct sharing schemes, which is a novel approach to integrating these paradigms.
 - The integration mechanism involves defining sharing constructs for an object-based (prototypes) high-level language and translating them into a formal calculus.
 - The interaction model between paradigms is facilitated by per object delegation, which allows for the representation of every sharing scheme possible in a prototype environment.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the novelty of translating constructs into a formal calculus.
 - The novel translation technique involves using the impς-calculus to represent class-based languages and prototype-based languages within a unified framework.","- ""Sharing of behavior is one of the most important features in the Object-Oriented paradigm.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""Abadi and Cardelli have defined a calculus of objects which represents the basic elements.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment,""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""There are primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object.""",,"- The abstract focuses on the sharing mechanisms in object-oriented programming, particularly on how to express delegation between objects using a calculus defined by Abadi and Cardelli.
 - The study does not explicitly mention generic programming or abstraction mechanisms in terms of type systems or static checking.
 - The focus is on representing sharing schemes and delegation, which is related to abstraction but not specifically addressed as generic programming.
 - The abstract does not provide details on minimal type requirements or static checking strategies, which are typically associated with generic programming.
 - The study's approach is more about formalizing sharing mechanisms rather than generic programming or abstraction mechanisms.","- ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in OO can be built using only objects and messages.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in Object-Oriented languages can be built using only objects and messages.""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""",,"- The abstract claims that the authors have developed a more basic model for sharing schemes using only objects and messages, which is a novel insight into the fundamental nature of object-oriented programming.
 - The work introduces a new way to express delegation between concrete objects in the calculus, which is a theoretical advancement beyond existing approaches that typically focus on class-based or prototype-based models separately.
 - The authors demonstrate that their model can represent every sharing scheme possible in a prototype environment, which is a significant theoretical contribution as it unifies the representation of both class-based and prototype-based languages.
 - The development of sharing constructs for an object-based language and their translation into a formal calculus provides a theoretical framework that could influence programming language design by offering a more unified and basic model for object-oriented programming."
Programming as a mathematical exercise,J. Abrial,10.1098/rsta.1984.0070,https://doi.org/10.1098/rsta.1984.0070,Philosophical transactions of the Royal Society of London. Series A: Mathematical and physical sciences,18,1984,"1. Primitive Name: Logic
  Definition: Part of the formal framework integrating logic, set theory, and programming.
  Orthogonality Score: Not discussed
 2. Primitive Name: Set Theory
  Definition: Part of the formal framework integrating logic, set theory, and programming.
  Orthogonality Score: Not discussed
 3. Primitive Name: Basic Deduction and Definition Rules
  Definition: Presented to ensure a sound mechanizable foundation for proof construction.
  Orthogonality Score: Not discussed
 4. Primitive Name: Logical Calculi
  Definition: Part of the theories composing the framework.
  Orthogonality Score: Not discussed
 5. Primitive Name: Zermelo-Fraenkel Set Theory
  Definition: A weaker version used in the framework.
  Orthogonality Score: Not discussed
 6. Primitive Name: Natural Numbers
  Definition: Part of the elementary mathematical theories leading up to their construction.
  Orthogonality Score: Not discussed
 7. Primitive Name: Sequences
  Definition: Types constructed based on the paradigm of natural numbers.
  Orthogonality Score: Not discussed
 8. Primitive Name: Trees
  Definition: Types constructed based on the paradigm of natural numbers.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Logic and set theory (specifically, a weaker version of Zermelo-Fraenkel set theory)
 - Specific mathematical properties guaranteed: Formalization of programming notation within logic and set theory
 - Proof techniques used: Deduction and definition rules
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Transforming program construction into proof construction; axiomatizing programming notation within logic and set theory.
 - Interaction models between paradigms: Presenting theories in the form of deduction and definition rules.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned beyond the general framework.",Generic programming not extensively addressed,"- Key novel insights: Integration of logic, set theory, and programming; transformation of program construction into proof construction.
 - Theoretical advancements: Presentation of theories in deduction and definition rules; axiomatization of programming notation within logic and set theory.
 - Potential implications for programming language design: Mechanization of the calculus of proof for more rigorous programming.","- ""This paper contains a formal framework within which logic, set theory and programming are presented together.""
  - ""we no longer regard a (procedural) programming notation (such as PASCAL) as a notation for expressing a computation; rather, we regard it as a mere extension to the conventional language of logic and set theory.""
  - ""The extension constitutes a convenient (economical) way of expressing certain relational statements.""
  - ""To ensure that this activity of proof construction can be given a sound mechanizable foundation, we present a number of theories in the form of some basic deduction and definition rules.""
  - ""For instance, such theories compose the two logical calculi, a weaker version of the standard Zermelo-Fraenkel set theory, as well as some other elementary mathematical theories leading up to the construction of natural numbers.""
  - ""This last theory acts as a paradigm for the construction of other types such as sequences or trees.""
  - ""Parallel to these mathematical constructions we axiomatize a certain programming notation by giving equivalents to its basic constructs within logic and set theory.""",,"- The abstract discusses a formal framework that integrates logic, set theory, and programming, suggesting that these are foundational elements or primitives in the study.
 - The redefinition of programming notation as an extension of logic and set theory implies that these are conceptual primitives used to reconstruct programming paradigms.
 - The mention of ""basic deduction and definition rules"" and ""theories"" such as logical calculi and Zermelo-Fraenkel set theory suggests these are part of the conceptual primitives.
 - The construction of natural numbers and other types like sequences or trees indicates these are also considered primitives in the framework.
 - The axiomatization of programming notation within logic and set theory further supports the idea that these are conceptual primitives.","- ""This paper contains a formal framework within which logic, set theory and programming are presented together.""
  - ""we no longer regard a (procedural) programming notation (such as PASCAL) as a notation for expressing a computation; rather, we regard it as a mere extension to the conventional language of logic and set theory.""
  - ""The extension constitutes a convenient (economical) way of expressing certain relational statements.""
  - ""A consequence of this point of view is that the activity of program construction is transformed into that of proof construction.""
  - ""To ensure that this activity of proof construction can be given a sound mechanizable foundation, we present a number of theories in the form of some basic deduction and definition rules.""
  - ""For instance, such theories compose the two logical calculi, a weaker version of the standard Zermelo-Fraenkel set theory, as well as some other elementary mathematical theories leading up to the construction of natural numbers.""
  - ""This last theory acts as a paradigm for the construction of other types such as sequences or trees.""
  - ""Parallel to these mathematical constructions we axiomatize a certain programming notation by giving equivalents to its basic constructs within logic and set theory.""
  - ""A number of other non-logical theories are also presented, which allows us to completely mechanize the calculus of proof that is implied by this framework.""",,"- The abstract describes a ""formal framework"" that integrates logic, set theory, and programming, indicating a type of mathematical framework that combines these elements.
 - The framework is based on logic and set theory, specifically mentioning a ""weaker version of the standard Zermelo-Fraenkel set theory,"" which suggests a foundation in set theory.
 - The transformation of program construction into proof construction implies the use of proof techniques, likely involving deduction and definition rules.
 - The mention of ""basic deduction and definition rules"" suggests a formal verification approach.
 - The framework allows for the mechanization of proof calculus, indicating a focus on formal verification.
 - The abstract does not explicitly mention limitations or constraints of the framework.","- ""This paper contains a formal framework within which logic, set theory and programming are presented together.""
  - ""we no longer regard a (procedural) programming notation (such as PASCAL) as a notation for expressing a computation; rather, we regard it as a mere extension to the conventional language of logic and set theory.""
  - ""The extension constitutes a convenient (economical) way of expressing certain relational statements.""
  - ""the activity of program construction is transformed into that of proof construction.""
  - ""we present a number of theories in the form of some basic deduction and definition rules.""
  - ""Parallel to these mathematical constructions we axiomatize a certain programming notation by giving equivalents to its basic constructs within logic and set theory.""
  - ""A number of other non-logical theories are also presented, which allows us to completely mechanize the calculus of proof that is implied by this framework.""",,"- The abstract discusses a formal framework that integrates logic, set theory, and programming, suggesting a paradigm integration approach.
 - It redefines procedural programming notations like PASCAL as extensions of logic and set theory, which is a novel way of integrating programming paradigms.
 - The integration mechanism involves transforming program construction into proof construction, which is a theoretical integration strategy.
 - The abstract mentions presenting theories in the form of deduction and definition rules, which could be seen as interaction models between paradigms.
 - The axiomatization of programming notation within logic and set theory is a specific integration mechanism.
 - There is no mention of constraints or challenges in paradigm integration, nor are there explicit novel translation or embedding techniques described beyond the general framework.","- ""This paper contains a formal framework within which logic, set theory and programming are presented together.""
  - ""we no longer regard a (procedural) programming notation (such as PASCAL) as a notation for expressing a computation; rather, we regard it as a mere extension to the conventional language of logic and set theory.""
  - ""The extension constitutes a convenient (economical) way of expressing certain relational statements.""
  - ""the activity of program construction is transformed into that of proof construction.""
  - ""we present a number of theories in the form of some basic deduction and definition rules.""
  - ""such theories compose the two logical calculi, a weaker version of the standard Zermelo-Fraenkel set theory, as well as some other elementary mathematical theories leading up to the construction of natural numbers.""
  - ""Parallel to these mathematical constructions we axiomatize a certain programming notation by giving equivalents to its basic constructs within logic and set theory.""
  - ""A number of other non-logical theories are also presented, which allows us to completely mechanize the calculus of proof that is implied by this framework.""",,"- The abstract discusses a formal framework that integrates logic, set theory, and programming, which suggests a focus on theoretical foundations rather than specific programming methodologies like generic programming.
 - The transformation of program construction into proof construction indicates a focus on formal verification rather than generic programming.
 - The mention of constructing natural numbers and other mathematical theories suggests a focus on foundational mathematical concepts rather than generic programming.
 - The abstract does not explicitly mention generic programming, type systems, or abstraction mechanisms related to generic programming.
 - The focus is on formalizing programming within a logical and set-theoretical framework, which does not directly address generic programming or abstraction mechanisms.","- ""This paper contains a formal framework within which logic, set theory and programming are presented together.""
  - ""we no longer regard a (procedural) programming notation (such as PASCAL) as a notation for expressing a computation; rather, we regard it as a mere extension to the conventional language of logic and set theory.""
  - ""The extension constitutes a convenient (economical) way of expressing certain relational statements.""
  - ""A consequence of this point of view is that the activity of program construction is transformed into that of proof construction.""
  - ""we present a number of theories in the form of some basic deduction and definition rules.""
  - ""Parallel to these mathematical constructions we axiomatize a certain programming notation by giving equivalents to its basic constructs within logic and set theory.""
  - ""A number of other non-logical theories are also presented, which allows us to completely mechanize the calculus of proof that is implied by this framework.""",,"- The abstract introduces a novel framework that integrates logic, set theory, and programming, which is a unique theoretical contribution. This integration is highlighted by the statement that programming notation is seen as an extension of logic and set theory, rather than a separate entity for computation.
 - The transformation of program construction into proof construction is a key novel insight, as it shifts the focus from computational execution to logical verification.
 - The presentation of theories in the form of deduction and definition rules provides a theoretical advancement by offering a structured approach to proof construction.
 - The axiomatization of programming notation within logic and set theory is another theoretical contribution, as it provides a formal basis for programming language design.
 - The mechanization of the calculus of proof implies potential implications for programming language design, as it suggests a more rigorous and formal approach to programming."
Reusable Semantic Specifications of Programming Languages,Jose Emilio Labra Gayo,-,-,-,10,2002,Not specified (the abstract does not provide explicit definitions or details about conceptual primitives),Not specified (the abstract does not provide explicit details on the mathematical framework used),"- Specific integration mechanisms proposed: Reusable monadic semantics combining monadic semantics with generic programming concepts.
 - Interaction models between paradigms: Use of reusable semantic building blocks for modular integration.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed (the abstract mentions generic programming concepts but does not provide detailed information on mechanisms or strategies),"- Key novel insights: Introduction of reusable monadic semantics combining monadic semantics with generic programming concepts.
 - Theoretical advancements: Use of reusable semantic building blocks to facilitate comparison between different paradigms.
 - Potential implications: Enhanced modularity and reusability in programming language semantic specifications.","- ""the specification of simple functional, imperative and logic programming languages.""
  - ""The specifications are made from reusable semantic building blocks, which facilitates the comparison between different paradigms.""
  - ""we compare the main approaches for programming language semantic specification from the point of view of modularity and reusability.""
  - ""We will also present reusable monadic semantics, which combines monadic semantics with generic programming concepts""",,"- The abstract mentions ""reusable monadic semantics"" and ""reusable semantic building blocks,"" which suggests that these are conceptual primitives used for specifying programming languages.
 - The term ""monadic semantics"" implies a specific theoretical framework, but the abstract does not provide a precise definition of what these primitives are or how they are defined.
 - The mention of ""reusable semantic building blocks"" suggests a level of abstraction and modularity, but again, no explicit definitions or details about these primitives are provided in the abstract.
 - The abstract does not specify any explicit conceptual primitives or their definitions, nor does it discuss their orthogonality.","- ""The specifications are made from reusable semantic building blocks, which facilitates the comparison between different paradigms.""
  - ""we compare the main approaches for programming language semantic specification from the point of view of modularity and reusability.""
  - ""We will also present reusable monadic semantics, which combines monadic semantics with generic programming concepts""",,"- The abstract mentions ""reusable monadic semantics"" and ""generic programming concepts,"" which suggests a focus on modularity and reusability in semantic specifications.
 - The term ""monadic semantics"" implies a mathematical framework related to monads, which are a concept from category theory.
 - However, the abstract does not explicitly mention the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus on ""reusable semantic building blocks"" and ""comparison between different paradigms"" suggests a theoretical approach, but without explicit details on the mathematical framework.","- ""The specifications are made from reusable semantic building blocks, which facilitates the comparison between different paradigms.""
  - ""In this tutorial, we compare the main approaches for programming language semantic specification from the point of view of modularity and reusability.""
  - ""We will also present reusable monadic semantics, which combines monadic semantics with generic programming concepts""",,"- The abstract mentions the comparison of main approaches for programming language semantic specification, which implies a focus on modularity and reusability. This suggests an integration approach that emphasizes these aspects.
 - The presentation of ""reusable monadic semantics"" indicates a specific integration mechanism that combines monadic semantics with generic programming concepts. This is a novel approach to integrating different paradigms.
 - The use of ""reusable semantic building blocks"" facilitates comparison between different paradigms, which implies an interaction model that allows for modular integration of different programming paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it specify novel translation or embedding techniques beyond the use of reusable monadic semantics.","- ""We will also present reusable monadic semantics, which combines monadic semantics with generic programming concepts""
  - ""The specifications are made from reusable semantic building blocks, which facilitates the comparison between different paradigms.""",,"- The abstract mentions ""generic programming concepts"" in the context of ""reusable monadic semantics,"" indicating that generic programming is a part of the study.
 - The term ""reusable semantic building blocks"" suggests a mechanism for representing generic abstractions, as these blocks are likely designed to be modular and applicable across different programming paradigms.
 - The abstract does not provide specific details on the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies. These aspects are not explicitly mentioned in the abstract.
 - The focus on ""reusable semantic building blocks"" implies a form of abstraction mechanism, but the abstract does not delve into the specifics of these mechanisms or other aspects of generic programming.","- ""We will also present reusable monadic semantics, which combines monadic semantics with generic programming concepts""
  - ""In this tutorial, we compare the main approaches for programming language semantic specification from the point of view of modularity and reusability.""
  - ""The specifications are made from reusable semantic building blocks, which facilitates the comparison between different paradigms.""",,"- The abstract mentions a comparison of main approaches for programming language semantic specification, which suggests a theoretical contribution by providing a comprehensive overview and analysis of existing methods.
 - The introduction of ""reusable monadic semantics"" that combines monadic semantics with generic programming concepts is a novel theoretical contribution. This integration is likely to enhance modularity and reusability in semantic specifications.
 - The use of ""reusable semantic building blocks"" is another theoretical advancement, as it facilitates the comparison between different programming paradigms. This could have implications for programming language design by allowing for more modular and adaptable specifications.
 - The abstract does not explicitly mention potential implications for programming language design, but the focus on modularity and reusability suggests that these contributions could lead to more flexible and adaptable language specifications."
ATS: A Language That Combines Programming with Theorem Proving,"Sa Cui, Kevin Donnelly, H. Xi",10.1007/11559306_19,https://doi.org/10.1007/11559306_19,International Symposium on Frontiers of Combining Systems,147,2005,Not specified (the abstract does not explicitly define or list conceptual primitives),"- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Theorem proving
 - Limitations or constraints of the framework: Algorithmic decidability of constraint relations may not always be possible",No specific integration approach described (the abstract discusses integrating programming with theorem proving but lacks detailed mechanisms or models),Generic programming not extensively addressed,"- Key novel insights: Integration of theorem proving into programming, allowing programmers to construct proofs for constraint validity.
 - Theoretical advancements: Shift from syntactical restrictions to proof-based validation of constraints, accommodating a programming paradigm that combines programming with theorem proving.
 - Potential implications: Offers a more flexible and powerful way to handle type systems, potentially influencing future programming language design.","- ""In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable.""
  - ""we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving.""
  - ""Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints.""
  - ""we adopted a design in the past that imposes certain restrictions on the syntactic form of constraints so that some effective means can be found for solving constraints automatically.""
  - ""Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming.""",,"- The abstract discusses the Applied Type System (ATS) as a framework for designing and formalizing type systems, which suggests a focus on type systems as a conceptual primitive.
 - The mention of ""constraint relation"" and ""type equality"" indicates that these are key concepts within ATS, potentially serving as conceptual primitives.
 - The shift from imposing syntactical restrictions to allowing programmers to construct proofs suggests a conceptual primitive related to proof construction and validation.
 - The abstract does not explicitly list or define specific conceptual primitives, nor does it provide a detailed methodology or theoretical framework section where such primitives might be outlined.
 - The focus on combining programming with theorem proving implies a conceptual primitive related to integrating these two activities, but again, no explicit definition or list is provided.","- ""Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming.""
  - ""In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable.""
  - ""Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints.""
  - ""we adopted a design in the past that imposes certain restrictions on the syntactic form of constraints so that some effective means can be found for solving constraints automatically.""
  - ""we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving.""",,"- The abstract mentions the ""Applied Type System (ATS)"" as a framework for designing and formalizing type systems, indicating that the mathematical framework is based on type theory.
 - The mention of ""type equality"" and ""constraint relation"" suggests that the framework involves formal verification discussions related to type theory.
 - The abstract discusses the shift from imposing syntactical restrictions to allowing programmers to construct proofs, which implies a proof methodology involving theorem proving.
 - The abstract does not specify any limitations or constraints of the framework beyond the mention of algorithmic decidability of constraint relations.
 - The abstract does not provide specific mathematical properties guaranteed by the framework or detailed proof techniques used.","- ""Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming.""
  - ""In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable.""
  - ""To support practical programming, we adopted a design in the past that imposes certain restrictions on the syntactic form of constraints so that some effective means can be found for solving constraints automatically.""
  - ""Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints.""
  - ""In particular, we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving.""
  - ""Also we present some concrete examples in support of the practicality of this design.""",,"- The abstract discusses the Applied Type System (ATS) as a framework for designing and formalizing type systems, which is relevant to programming paradigms.
 - It mentions the integration of programming with theorem proving, which suggests a paradigm integration approach.
 - The abstract describes a shift from imposing syntactical restrictions on constraints to allowing programmers to construct proofs, which is a novel approach to integrating programming and theorem proving.
 - The mention of ""concrete examples"" suggests that there are practical applications or demonstrations of this integration approach.
 - However, the abstract does not explicitly detail specific integration mechanisms, interaction models, constraints, or novel translation techniques beyond the general concept of combining programming with theorem proving.","- ""we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving.""
  - ""In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable.""
  - ""Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming.""
  - ""To support practical programming, we adopted a design in the past that imposes certain restrictions on the syntactic form of constraints so that some effective means can be found for solving constraints automatically.""
  - ""Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints.""",,"- The abstract discusses the Applied Type System (ATS) as a framework for designing and formalizing type systems, which is relevant to generic programming and abstraction mechanisms.
 - The mention of ""constraint relation"" and ""syntactic form of constraints"" suggests a focus on type systems, but it does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not provide a definition of ""concept"" used in the context of generic programming.
 - There is no mention of mechanisms for representing generic abstractions or minimal type requirements.
 - The abstract does not discuss static checking or optimization strategies related to generic programming.
 - The focus is on combining programming with theorem proving, which is more related to formal verification than generic programming.","- ""Instead of imposing syntactical restrictions on constraints, we provide a means for the programmer to construct proofs that attest to the validity of constraints.""
  - ""In particular, we are to accommodate a programming paradigm that enables the programmer to combine programming with theorem proving.""
  - ""Applied Type System (ATS) is recently proposed as a framework for designing and formalizing (advanced) type systems in support of practical programming.""
  - ""In ATS, the definition of type equality involves a constraint relation, which may or may not be algorithmically decidable.""
  - ""Also we present some concrete examples in support of the practicality of this design.""",,"- The abstract introduces the Applied Type System (ATS) as a framework for designing and formalizing type systems, which is a novel approach in itself.
 - The ATS involves a constraint relation for type equality, which may not always be algorithmically decidable, indicating a theoretical advancement in handling complex type systems.
 - The key novelty is the shift from imposing syntactical restrictions on constraints to allowing programmers to construct proofs for constraint validity. This is a significant theoretical contribution as it integrates theorem proving into programming.
 - The abstract mentions accommodating a programming paradigm that combines programming with theorem proving, which is a unique theoretical contribution. This integration is not common in existing programming languages and represents a significant advancement.
 - The presentation of concrete examples supports the practicality of this design, implying potential implications for programming language design by offering a more flexible and powerful way to handle type systems."
"Voltaire: a database programming environment with a single execution model for evaluating queries, satisfying constraints and computing functions",Sunit K. Gala,-,-,-,1,1992,"1. Primitive Name: Modularity
  Definition: The language and its semantics are defined in a modular but additive fashion.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Automatic Integrity Enforcement
  Definition: The system provides automatic integrity enforcement in a lazy evaluation mode.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Persistent Functions
  Definition: Functions can have a persistent extent.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Functional Integration
  Definition: The query language incorporates functions by providing access to the persistent extent of a function or by allowing an actual function call.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Data Definition Facility
  Definition: The data definition (or type) facility is similar to what might be found in most semantic data models.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Type Algebra
  Definition: We have defined a type algebra that incorporates structure, extent and behavior.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Extensional Semantics
  Definition: Providing an extensional semantics for the behavior.
  Orthogonality Score: Not discussed
 

 8. Primitive Name: Denotational Semantics
  Definition: We also attempt to define a denotational semantics for the Voltaire language and environment.
  Orthogonality Score: Not discussed",Not specified (the abstract mentions denotational semantics and type algebra but does not specify the type of mathematical framework or specific properties guaranteed),"- Specific integration mechanisms proposed: Single execution model for queries, constraints, and functions; automatic integrity enforcement in a lazy evaluation mode.
 - Interaction models between paradigms: Unified execution model; incorporation of functions into query language.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Incorporation of functions into query language through access to persistent extents or function calls.","- Definition of ""concept"" used: Modular and additive semantics definition
 - Mechanisms for representing generic abstractions: Data definition facility similar to semantic data models; type algebra incorporating structure, extent, and behavior
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Novel combination of set-oriented and imperative programming paradigms.
 - Modular and additive language semantics facilitating bootstrapping.
 - Single execution model for queries, constraints, and functions.
 - Automatic integrity enforcement in lazy evaluation mode.
 - Type algebra incorporating structure, extent, and behavior.
 - Denotational semantics for formal language behavior.
 - Compromise between database systems and programming languages for data-intensive programming.","- ""The language and its semantics are defined in a modular but additive fashion, which facilitates some measure of bootstrapping.""
  - ""The system provides automatic integrity enforcement in a lazy evaluation mode.""
  - ""Functions are effectively computed as the result of integrity enforcement.""
  - ""There are no arbitrary restrictions on the persistence of values--even functions can have a persistent extent.""
  - ""the query language incorporates functions by providing access to the persistent extent of a function or by allowing an actual function call.""
  - ""The data definition (or type) facility is similar to what might be found in most semantic data models and is conducive to sharing heterogeneous records.""
  - ""We have defined a type algebra that incorporates structure, extent and behavior by providing an extensional semantics for the behavior.""
  - ""We also attempt to define a denotational semantics for the Voltaire language and environment.""",,"- The abstract discusses the modular and additive nature of the language and its semantics, which suggests a focus on modularity as a conceptual primitive.
 - The mention of automatic integrity enforcement and lazy evaluation mode implies that these are conceptual primitives related to data consistency and evaluation strategies.
 - The ability to treat functions as having persistent extent suggests a primitive related to persistence and function handling.
 - The incorporation of functions into the query language indicates a primitive related to functional programming integration.
 - The data definition facility and type algebra suggest primitives related to data structure and type systems.
 - The extensional semantics for behavior and denotational semantics for the language indicate primitives related to semantic definitions.","- ""The language and its semantics are defined in a modular but additive fashion, which facilitates some measure of bootstrapping.""
  - ""We also attempt to define a denotational semantics for the Voltaire language and environment.""
  - ""We have defined a type algebra that incorporates structure, extent and behavior by providing an extensional semantics for the behavior.""",,"- The abstract mentions that the language and its semantics are defined in a ""modular but additive fashion,"" which suggests a structured approach to defining the language's properties. However, this does not explicitly mention a specific mathematical framework like type theory or category theory.
 - The mention of ""denotational semantics"" indicates an attempt to formalize the language's behavior using a mathematical framework. Denotational semantics is a method for assigning meanings to programming language constructs, which is a mathematical framework for understanding the language's properties.
 - The ""type algebra"" and ""extensional semantics"" suggest a focus on formalizing the structure and behavior of the language, which are aspects of a mathematical framework. However, the abstract does not specify the type of mathematical framework (e.g., type theory) or specific mathematical properties guaranteed.
 - There is no mention of proof techniques or limitations of the framework in the abstract.","- ""The set expressions in the language are conducive to data intensive programming while maintaining a certain amount of efficiency by espousing the imperative paradigm.""
  - ""The language and its semantics are defined in a modular but additive fashion, which facilitates some measure of bootstrapping.""
  - ""We further argue that such an implementation model is desirable, since it provides a single execution model for evaluating queries, satisfying constraints and computing functions.""
  - ""The system provides automatic integrity enforcement in a lazy evaluation mode.""
  - ""Functions are effectively computed as the result of integrity enforcement.""
  - ""the query language incorporates functions by providing access to the persistent extent of a function or by allowing an actual function call.""
  - ""We believe that Voltaire is a suitable language for data intensive programming, and is a reasonable compromise between a database system and a programming language.""",,"- The abstract discusses the integration of different programming paradigms by mentioning the use of ""set expressions"" that are conducive to data-intensive programming while maintaining efficiency through the ""imperative paradigm."" This suggests a blend of declarative and imperative programming paradigms.
 - The language's modular and additive semantics facilitate bootstrapping, which implies a structured approach to integrating different programming paradigms.
 - The single execution model for queries, constraints, and functions indicates a unified interaction model between these paradigms.
 - The automatic integrity enforcement and lazy evaluation mode suggest specific integration mechanisms that ensure consistency and efficiency.
 - The incorporation of functions into the query language through access to persistent extents or function calls demonstrates a novel translation technique.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it provide a detailed comparative analysis of different integration strategies.","- ""The language and its semantics are defined in a modular but additive fashion, which facilitates some measure of bootstrapping.""
  - ""The data definition (or type) facility is similar to what might be found in most semantic data models and is conducive to sharing heterogeneous records.""
  - ""We have defined a type algebra that incorporates structure, extent and behavior by providing an extensional semantics for the behavior.""
  - ""We also attempt to define a denotational semantics for the Voltaire language and environment.""",,"- The abstract mentions that the language and its semantics are defined in a ""modular but additive fashion,"" which suggests a structured approach to defining concepts and abstractions. This could imply a form of generic programming methodology.
 - The ""data definition (or type) facility"" being similar to semantic data models and conducive to sharing heterogeneous records suggests a mechanism for representing generic abstractions, as it allows for the handling of diverse data types.
 - The mention of a ""type algebra"" that incorporates structure, extent, and behavior indicates a systematic approach to defining types, which is a key aspect of generic programming.
 - The attempt to define a ""denotational semantics"" for the language suggests an effort to provide a formal, abstract interpretation of the language's constructs, which is relevant to conceptual abstraction.
 - However, the abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, which are typically part of generic programming methodologies.","- ""In this thesis we present Voltaire, which is a set-oriented, imperative database programming language.""
  - ""The language and its semantics are defined in a modular but additive fashion, which facilitates some measure of bootstrapping.""
  - ""We further argue that such an implementation model is desirable, since it provides a single execution model for evaluating queries, satisfying constraints and computing functions.""
  - ""The system provides automatic integrity enforcement in a lazy evaluation mode.""
  - ""Functions are effectively computed as the result of integrity enforcement.""
  - ""The data definition (or type) facility is similar to what might be found in most semantic data models and is conducive to sharing heterogeneous records.""
  - ""We have defined a type algebra that incorporates structure, extent and behavior by providing an extensional semantics for the behavior.""
  - ""We also attempt to define a denotational semantics for the Voltaire language and environment.""
  - ""We believe that Voltaire is a suitable language for data intensive programming, and is a reasonable compromise between a database system and a programming language.""",,"- The abstract introduces Voltaire as a ""set-oriented, imperative database programming language,"" which suggests a novel combination of programming paradigms.
 - The modular and additive definition of the language's semantics is highlighted as a key feature, facilitating bootstrapping, which is a theoretical contribution in terms of language design.
 - The single execution model for queries, constraints, and functions is argued to be desirable, indicating a theoretical advancement in unifying these aspects.
 - The automatic integrity enforcement in a lazy evaluation mode and the computation of functions as part of integrity enforcement are novel insights into how constraints can be integrated into the programming model.
 - The type algebra and denotational semantics are theoretical contributions that enhance the language's ability to handle heterogeneous data and provide a formal basis for its behavior.
 - The abstract suggests that Voltaire represents a compromise between database systems and programming languages, which has implications for the design of future programming languages."
"A PROPOSAL FOR HARMONISING TYPES , INHERITANCE AND POLYMORPHISM FOR OBJECT-ORIENTED PROGRAMMING","A. Simons, A. J. Cowling",-,-,-,1,2006,Not specified (the abstract does not explicitly define or list conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework),No specific integration approach described,Generic programming not extensively addressed,"The study proposes a harmonization of types, inheritance, and polymorphism for object-oriented programming, addressing the challenge of creating formal typed models due to language flexibility. It aims to devise a typed functional algebra that aligns with operational definitions of OOP languages, potentially impacting programming language design.","- ""The present trend is away from type-free or dynamically typed languages and towards strong static typing, with some dynamic binding.""
  - ""Attempts to provide formal typed models of OOP have been frustrated by the great flexibility in languages that permit unrestricted redefinition of class properties.""
  - ""The principal difficulty lies in devising a typed functional algebra that conforms to the operational definition of OOP languages, which are usually described in completely different terms.""",,"- The abstract discusses the trend towards strong static typing and dynamic binding, which suggests a focus on type systems as a conceptual primitive.
 - The mention of ""formal typed models of OOP"" indicates an interest in defining types as a fundamental concept.
 - The difficulty in devising a ""typed functional algebra"" implies that the authors are considering algebraic structures as a conceptual primitive for OOP.
 - The abstract does not explicitly list or define specific conceptual primitives, nor does it provide a precise definition or orthogonality score for any primitives.
 - The focus on type systems and algebraic structures suggests that these might be considered as conceptual primitives, but they are not explicitly defined or listed in the abstract.","- ""Attempts to provide formal typed models of OOP have been frustrated by the great flexibility in languages that permit unrestricted redefinition of class properties.""
  - ""The principal difficulty lies in devising a typed functional algebra that conforms to the operational definition of OOP languages, which are usually described in completely different terms.""",,"- The abstract mentions the difficulty in devising a ""typed functional algebra"" which suggests an attempt to use a mathematical framework related to type theory.
 - However, it does not specify the type of mathematical framework (e.g., type theory, category theory) explicitly.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations/constraints of the framework.
 - The abstract does not provide details about the theoretical foundations, proof methodology, or formal verification discussions related to a mathematical framework.","- ""The principal difficulty lies in devising a typed functional algebra that conforms to the operational definition of OOP languages, which are usually described in completely different terms.""
  - ""Attempts to provide formal typed models of OOP have been frustrated by the great flexibility in languages that permit unrestricted redefinition of class properties.""
  - ""Goals for the paradigm have included bringing computational implementations closer to abstractions (the HCI school, exemplified by Smalltalk []), partitioning spaces of concepts (the AI school, exemplified by CLOS []) and software engineering for reuse and extensibility (the SE school, exemplified by Eiffel""",,"- The abstract mentions different schools of thought within Object-Oriented Programming (OOP), such as the HCI school (Smalltalk), AI school (CLOS), and SE school (Eiffel). This suggests a discussion of different paradigms within OOP.
 - The abstract does not explicitly describe specific integration mechanisms or interaction models between these paradigms. It focuses on the goals and challenges rather than proposing specific integration strategies.
 - The mention of ""attempts to provide formal typed models of OOP"" and the difficulty in devising a ""typed functional algebra"" indicates challenges in integrating these paradigms, particularly due to the flexibility in language design.
 - There is no mention of novel translation or embedding techniques in the abstract.","- ""software engineering for reuse and extensibility (the SE school, exemplified by Eiffel""
  - ""The principal difficulty lies in devising a typed functional algebra that conforms to the operational definition of OOP languages, which are usually described in completely different terms.""
  - ""Attempts to provide formal typed models of OOP have been frustrated by the great flexibility in languages that permit unrestricted redefinition of class properties.""
  - ""partitioning spaces of concepts (the AI school, exemplified by CLOS""
  - ""Goals for the paradigm have included bringing computational implementations closer to abstractions (the HCI school, exemplified by Smalltalk""",,"- The abstract mentions ""bringing computational implementations closer to abstractions"" and ""partitioning spaces of concepts,"" which suggests a focus on abstraction mechanisms. However, it does not provide a specific definition of ""concept"" used in the study.
 - The mention of ""software engineering for reuse and extensibility"" implies a focus on generic programming, but again, no specific mechanisms for representing generic abstractions are detailed in the abstract.
 - The abstract discusses the challenge of creating formal typed models due to the flexibility in redefining class properties, which relates to type systems and static checking. However, it does not specify minimal type requirements or strategies for static checking or optimization.
 - The abstract does not explicitly address generic programming methodology, type system discussions, or abstraction mechanism explanations in detail.","- ""The principal difficulty lies in devising a typed functional algebra that conforms to the operational definition of OOP languages, which are usually described in completely different terms.""
  - ""Attempts to provide formal typed models of OOP have been frustrated by the great flexibility in languages that permit unrestricted redefinition of class properties.""",,"- The title suggests a proposal for harmonizing types, inheritance, and polymorphism, which implies a novel approach to addressing these aspects of object-oriented programming.
 - The abstract mentions the difficulty in creating formal typed models due to the flexibility in languages, indicating a gap in current theoretical frameworks.
 - The mention of devising a ""typed functional algebra"" suggests a theoretical advancement in providing a formal model that aligns with operational definitions of OOP languages.
 - The abstract does not explicitly state the novelty or theoretical contribution, but it implies that the proposal aims to address existing challenges in formalizing OOP concepts, which could have implications for programming language design."
The -calculus,"N. J. Rehof, Morten Heine Ssrensen",-,-,-,0,1994,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Type theory, Curry-Howard Isomorphism
 - Specific mathematical properties guaranteed: Strong normalization, Church-Rosser property
 - Proof techniques used: Normalization, reduction
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Development of a new operator and a fully compatible, Church-Rosser control calculus; strongly normalizing typed subcalculus with reduction corresponding closely to systems of proof normalization for classical logic.
 - Theoretical advancements beyond existing approaches: The new calculus has desirable properties not shared by existing systems.
 - Potential implications for programming language design: Ability to express a call-by-name catch-throw programming paradigm.","- ""By restriction of Felleisen's control operator F we obtain an operator and a fully compatible, Church-Rosser control calculus enjoying a number of desirable properties.""
  - ""It is shown that contains a strongly normalizing typed subcalculus with a reduction corresponding closely to systems of proof normalization for classical logic.""
  - ""The calculus is more than strong enough to express a call-by-name catch=throw-programming paradigm.""
  - ""The Curry-Howard Isomorphism and classical logic.""
  - ""The so-called Curry-Howard Isomorphism states a correspondence between typed-calculi and systems of formal logic.""
  - ""At the heart of the isomorphism is the perception of proofs as functions, as formalized in Kleene's Realizability Interpretation Kle52].""",,"- The abstract discusses the development of a control calculus by restricting Felleisen's control operator F, which suggests a focus on control structures in programming.
 - The mention of a ""strongly normalizing typed subcalculus"" indicates a focus on type systems and normalization processes, which are conceptual primitives in programming paradigms.
 - The reference to the Curry-Howard Isomorphism highlights the connection between typed calculi and formal logic, suggesting that proofs and functions are conceptual primitives.
 - The abstract does not explicitly list or define specific conceptual primitives, but it implies that the control calculus and the Curry-Howard Isomorphism are foundational to the study.
 - The level of abstraction is high, as it deals with theoretical foundations of programming paradigms.
 - Orthogonality is not explicitly discussed in the abstract.","- ""By restriction of Felleisen's control operator F we obtain an operator and a fully compatible, Church-Rosser control calculus enjoying a number of desirable properties.""
  - ""It is shown that contains a strongly normalizing typed subcalculus with a reduction corresponding closely to systems of proof normalization for classical logic.""
  - ""The calculus is more than strong enough to express a call-by-name catch=throw-programming paradigm.""
  - ""The Curry-Howard Isomorphism and classical logic.""
  - ""The so-called Curry-Howard Isomorphism states a correspondence between typed-calculi and systems of formal logic.""
  - ""At the heart of the isomorphism is the perception of proofs as functions, as formalized in Kleene's Realizability Interpretation Kle52].""
  - ""According to Gallier, \the correspondence between proof normalization and term reduction is the deepest and most fruitful aspect of the Curry-Howard Ismorphism"" Gal92] p8.""",,"- The abstract discusses the use of a ""fully compatible, Church-Rosser control calculus,"" which suggests a type of mathematical framework related to type theory and control operators.
 - The mention of a ""strongly normalizing typed subcalculus"" indicates specific mathematical properties related to normalization and type theory.
 - The reference to the Curry-Howard Isomorphism and its connection to classical logic suggests that the framework involves type theory and formal logic.
 - The abstract does not explicitly mention category theory or other frameworks, focusing instead on type theory and the Curry-Howard Isomorphism.
 - The proof techniques seem to involve normalization and reduction, as indicated by the correspondence between proof normalization and term reduction.
 - There is no explicit mention of limitations or constraints of the framework in the abstract.","- ""The calculus is more than strong enough to express a call-by-name catch=throw-programming paradigm.""",,"- The abstract mentions that the calculus is capable of expressing a ""call-by-name catch=throw-programming paradigm."" This suggests that the study integrates or addresses the call-by-name paradigm, which is a specific programming paradigm.
 - However, the abstract does not provide specific details about the integration mechanisms, interaction models, constraints, or novel translation techniques related to integrating different programming paradigms.
 - The focus of the abstract is on the properties and capabilities of the calculus rather than on a detailed integration approach for multiple paradigms.","- ""By restriction of Felleisen's control operator F we obtain an operator and a fully compatible, Church-Rosser control calculus enjoying a number of desirable properties.""
  - ""It is shown that contains a strongly normalizing typed subcalculus with a reduction corresponding closely to systems of proof normalization for classical logic.""
  - ""The calculus is more than strong enough to express a call-by-name catch=throw-programming paradigm.""
  - ""The Curry-Howard Isomorphism and classical logic.""
  - ""The so-called Curry-Howard Isomorphism states a correspondence between typed-calculi and systems of formal logic.""
  - ""At the heart of the isomorphism is the perception of proofs as functions, as formalized in Kleene's Realizability Interpretation Kle52].""",,"- The abstract discusses the development of a control calculus and its properties, particularly in relation to the Curry-Howard Isomorphism and classical logic. This suggests a focus on theoretical foundations rather than practical programming methodologies.
 - The mention of a ""strongly normalizing typed subcalculus"" and ""reduction corresponding closely to systems of proof normalization"" indicates a focus on type systems and proof normalization, which are related to abstraction mechanisms but do not directly address generic programming.
 - The abstract does not explicitly mention generic programming, abstraction mechanisms, or type requirements that are typically associated with genericity and abstraction in programming.
 - The focus on the Curry-Howard Isomorphism and classical logic suggests a theoretical approach rather than a practical methodology for generic programming.","- ""By restriction of Felleisen's control operator F we obtain an operator and a fully compatible, Church-Rosser control calculus enjoying a number of desirable properties.""
  - ""The second subsection describes our contribution: a typed-calculus with a number of desirable properties, not all shared by the systems mentioned in the rst subsection.""
  - ""It is shown that contains a strongly normalizing typed subcalculus with a reduction corresponding closely to systems of proof normalization for classical logic.""
  - ""The calculus is more than strong enough to express a call-by-name catch=throw-programming paradigm.""",,"- The abstract mentions the development of a new operator and a fully compatible, Church-Rosser control calculus, which suggests a theoretical advancement in the field of programming language design.
 - The mention of a ""strongly normalizing typed subcalculus"" indicates a novel insight into the normalization process, which is a key aspect of the Curry-Howard Isomorphism.
 - The ability to express a call-by-name catch-throw programming paradigm suggests a potential implication for programming language design, as it expands the capabilities of the calculus.
 - The abstract explicitly states that the new calculus has ""desirable properties, not all shared by the systems mentioned in the rst subsection,"" indicating a theoretical contribution beyond existing approaches."
Monads are not what they seem Uncovering the hidden nature of programming concepts,T. Petříček,-,-,-,0,2017,"1. Primitive Name: Formal
  Definition: Not explicitly defined
  Orthogonality Score: Not specified
 2. Primitive Name: Metaphorical
  Definition: Not explicitly defined
  Orthogonality Score: Not specified
 3. Primitive Name: Implementation
  Definition: Not explicitly defined
  Orthogonality Score: Not specified",Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Development of a broader understanding of monads; importance of metaphors in understanding monads.
 - Theoretical advancements: Framework for understanding programming concepts at three levels (formal, metaphorical, and implementation); review of monads through philosophical, mathematical, and cognitive science perspectives.
 - Potential implications for programming language design: Broader perspective helps programmers choose more appropriate abstractions, potentially leading to more intuitive and effective programming tools.","- ""We develop a framework for understanding programming concepts that considers them at three levels: formal, metaphorical and implementation.""
  - ""Our observations are based on established results about the scientific method and mathematical entities – cognitive sciences suggest that the metaphors used when thinking about monads are more important than widely accepted, while philosophy of science explains how the research paradigm from which monads originate influences and restricts their use.""",,"- The abstract mentions a framework that considers programming concepts at three levels: formal, metaphorical, and implementation. These levels can be interpreted as conceptual primitives for understanding programming concepts.
 - The abstract does not provide explicit definitions for these primitives, but it suggests that they are foundational in understanding programming concepts like monads.
 - The mention of metaphors being important and the influence of the research paradigm suggests that these levels are not just abstract concepts but are grounded in cognitive sciences and philosophy of science.
 - There is no explicit mention of orthogonality or a specific score for it, nor is there a detailed definition of each primitive beyond their names.","- ""We review the history of monads in the context of programming and study the development through the perspectives of philosophy of science and mathematics,""
  - ""cognitive sciences suggest that the metaphors used when thinking about monads are more important than widely accepted,""
  - ""philosophy of science explains how the research paradigm from which monads originate influences and restricts their use.""
  - ""We develop a framework for understanding programming concepts that considers them at three levels: formal, metaphorical and implementation.""
  - ""a programming concept that got into programming from category theory,""",,"- The abstract mentions that monads ""got into programming from category theory,"" which suggests that category theory is the mathematical framework used to formalize and guarantee properties of monads.
 - The abstract does not provide specific details about the mathematical properties guaranteed by this framework or the proof techniques used.
 - The abstract discusses a framework for understanding programming concepts at three levels (formal, metaphorical, and implementation), but it does not specify the mathematical framework characteristics such as type theory or specific mathematical properties.
 - The abstract focuses more on the philosophical and cognitive aspects rather than the mathematical framework characteristics.","- ""Finally, we provide evidence for why a broader philosophical, sociological look at programming concepts should be of interest for programmers.""
  - ""Our observations are based on established results about the scientific method and mathematical entities – cognitive sciences suggest that the metaphors used when thinking about monads are more important than widely accepted, while philosophy of science explains how the research paradigm from which monads originate influences and restricts their use.""
  - ""We develop a framework for understanding programming concepts that considers them at three levels: formal, metaphorical and implementation.""
  - ""We review the history of monads in the context of programming and study the development through the perspectives of philosophy of science and mathematics, as well as cognitive sciences.""
  - ""In this paper, we develop such broader understanding of monads – a programming concept that got into programming from category theory, has language support in several languages and has a reputation for being elegant and powerful, but also intimidating and difficult to understand.""",,"- The abstract discusses the development of a broader understanding of monads, which involves historical, philosophical, and cognitive aspects. However, it does not explicitly mention any specific integration mechanisms or interaction models between different programming paradigms.
 - The framework developed in the paper considers programming concepts at three levels (formal, metaphorical, and implementation), but this is not explicitly linked to integrating different programming paradigms.
 - The abstract mentions the influence of the research paradigm on the use of monads, but this is more about understanding the origins and limitations of monads rather than integrating different paradigms.
 - There is no mention of specific integration mechanisms, interaction models, constraints, or novel translation techniques related to integrating different programming paradigms.","- ""We develop a framework for understanding programming concepts that considers them at three levels: formal, metaphorical and implementation.""
  - ""Computer science provides an in-depth understanding of technical and mathematical aspects of programming concepts such as monads, but there is more to monads.""
  - ""We review the history of monads in the context of programming and study the development through the perspectives of philosophy of science and mathematics, as well as cognitive sciences.""
  - ""we develop such broader understanding of monads – a programming concept that got into programming from category theory, has language support in several languages and has a reputation for being elegant and powerful, but also intimidating and difficult to understand.""
  - ""Our observations are based on established results about the scientific method and mathematical entities – cognitive sciences suggest that the metaphors used when thinking about monads are more important than widely accepted, while philosophy of science explains how the research paradigm from which monads originate influences and restricts their use.""",,"- The abstract discusses the broader understanding of monads, which includes historical, philosophical, and cognitive aspects, but it does not specifically mention generic programming or abstraction mechanisms.
 - The focus is on understanding monads at three levels (formal, metaphorical, and implementation), but this does not directly address generic programming or abstraction mechanisms.
 - There is no mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The abstract does not provide a definition of ""concept"" in the context of generic programming or abstraction mechanisms.
 - The study's approach is more focused on the philosophical and cognitive aspects of programming concepts rather than specific programming methodologies like generic programming.","- ""In this paper, we develop such broader understanding of monads – a programming concept that got into programming from category theory, has language support in several languages and has a reputation for being elegant and powerful, but also intimidating and difficult to understand.""
  - ""Finally, we provide evidence for why a broader philosophical, sociological look at programming concepts should be of interest for programmers. It lets us understand programming concepts better and, fundamentally, choose more appropriate abstractions as illustrated in a number of case studies that conclude the paper.""
  - ""We review the history of monads in the context of programming and study the development through the perspectives of philosophy of science and mathematics, as well as cognitive sciences.""
  - ""We develop a framework for understanding programming concepts that considers them at three levels: formal, metaphorical and implementation.""
  - ""Our observations are based on established results about the scientific method and mathematical entities – cognitive sciences suggest that the metaphors used when thinking about monads are more important than widely accepted, while philosophy of science explains how the research paradigm from which monads originate influences and restricts their use.""",,"- The abstract mentions the development of a ""broader understanding of monads,"" which suggests a novel insight into how monads are perceived and utilized in programming.
 - The study reviews the history of monads and examines their development through philosophical, mathematical, and cognitive science perspectives, which is a unique approach compared to purely technical analyses.
 - The development of a framework that considers programming concepts at three levels (formal, metaphorical, and implementation) is a theoretical advancement, as it provides a structured way to analyze complex programming concepts like monads.
 - The emphasis on metaphors and their importance in understanding monads is a key novel insight, as it highlights the cognitive aspects of programming concepts.
 - The abstract suggests that this broader perspective can help programmers choose more appropriate abstractions, which has implications for programming language design by potentially leading to more intuitive and effective programming tools.
 - The study's focus on the philosophical and sociological aspects of programming concepts is a theoretical contribution that goes beyond existing technical analyses, offering a more holistic understanding of programming."
"The programming language jigsaw: mixins, modularity and multiple inheritance",Gilad Bracha,-,-,-,246,1992,"1. Primitive Name: Combination
  Definition: Independently controlling combination effects
  Orthogonality Score: Not specified
 2. Primitive Name: Modification
  Definition: Independently controlling modification effects
  Orthogonality Score: Not specified
 3. Primitive Name: Encapsulation
  Definition: Independently controlling encapsulation effects
  Orthogonality Score: Not specified
 4. Primitive Name: Name Resolution
  Definition: Independently controlling name resolution effects
  Orthogonality Score: Not specified
 5. Primitive Name: Sharing
  Definition: Independently controlling sharing effects
  Orthogonality Score: Not specified","- Type of mathematical framework: Denotational semantics
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described (the abstract mentions applicability across paradigms but lacks specific integration mechanisms or strategies),Generic programming not extensively addressed,"- Key novel insights: ""unbundling"" of class roles into independent operators, integration of multiple inheritance, mixins, encapsulation, and strong typing.
 - Theoretical advancements: rigorous semantics based on a denotational model of inheritance, modularity independent of computational paradigms.
 - Potential implications: Enhancing modularity in special-purpose languages without custom mechanisms.","- ""In Jigsaw, the roles of classes in existing languages are ""unbundled,"" by providing a suite of operators independently controlling such effects as combination, modification, encapsulation, name resolution, and sharing, all on the single notion of module.""
  - ""This allows a previously unobtainable spectrum of features to be combined in a cohesive manner, including multiple inheritance, mixins, encapsulation and strong typing.""
  - ""All module operators are forms of inheritance.""",,"- The abstract mentions that in Jigsaw, the roles of classes are ""unbundled"" into a suite of operators. This suggests that these operators are conceptual primitives used to reconstruct programming paradigms.
 - The operators are described as controlling effects such as combination, modification, encapsulation, name resolution, and sharing. These are the specific conceptual primitives proposed by the study.
 - The abstract states that all module operators are forms of inheritance, indicating that inheritance is a foundational concept in Jigsaw.
 - The combination of features like multiple inheritance, mixins, encapsulation, and strong typing suggests that these are also part of the conceptual framework, but they are more like features enabled by the primitives rather than the primitives themselves.
 - The abstract does not provide explicit definitions for each primitive or discuss their orthogonality score.","- ""Jigsaw has a rigorous semantics, based upon a denotational model of inheritance.""",,"- The abstract mentions that Jigsaw has a ""rigorous semantics"" based on a ""denotational model of inheritance."" This suggests that the mathematical framework used is related to denotational semantics, which is a method for assigning meanings to programming languages.
 - Denotational semantics is a type of mathematical framework used to formalize the meaning of programming languages, focusing on the mathematical structures that describe the behavior of programs.
 - The abstract does not specify any particular mathematical properties guaranteed by this framework, nor does it mention specific proof techniques or limitations.
 - The mention of a ""denotational model"" implies a focus on mathematical structures to describe inheritance, but it does not provide further details on the type of mathematical framework, specific properties, or proof techniques.","- ""Jigsaw can therefore be applied to a wide variety of languages, especially special-purpose languages where the effort of designing specific mechanisms for modularity is difficult to justify, but which could still benefit from such mechanisms.""
  - ""Jigsaw provides a notion of modularity independent of a particular computational paradigm.""",,"- The abstract mentions that Jigsaw provides a notion of modularity that is independent of a particular computational paradigm. This suggests that Jigsaw can be applied across different programming paradigms, indicating a level of integration.
 - The mention of Jigsaw being applicable to ""a wide variety of languages"" implies that it can integrate with different programming paradigms by providing modularity mechanisms that are not specific to one paradigm.
 - However, the abstract does not provide specific details on the integration mechanisms, interaction models, constraints, or novel translation techniques. It focuses more on the general applicability and modularity framework rather than specific integration strategies.","- ""This dissertation provides a framework for modularity in programming languages.""
  - ""In Jigsaw, the roles of classes in existing languages are ""unbundled,"" by providing a suite of operators independently controlling such effects as combination, modification, encapsulation, name resolution, and sharing, all on the single notion of module.""
  - ""All module operators are forms of inheritance.""
  - ""This allows a previously unobtainable spectrum of features to be combined in a cohesive manner, including multiple inheritance, mixins, encapsulation and strong typing.""
  - ""Jigsaw has a rigorous semantics, based upon a denotational model of inheritance.""
  - ""Jigsaw provides a notion of modularity independent of a particular computational paradigm.""
  - ""The framework is used to derive an extension of Modula-3 that supports the new operations.""",,"- The abstract primarily focuses on modularity and inheritance rather than generic programming or abstraction mechanisms.
 - The mention of ""unbundling"" roles of classes and providing operators for various effects suggests a focus on modularity and module manipulation rather than generic programming.
 - The abstract discusses multiple inheritance, mixins, encapsulation, and strong typing, which are related to object-oriented programming rather than generic programming.
 - There is no explicit mention of generic programming, type systems, or static checking strategies in the abstract.
 - The focus on modularity and inheritance suggests that generic programming is not a primary focus of the dissertation.","- ""This dissertation provides a framework for modularity in programming languages.""
  - ""In Jigsaw, the roles of classes in existing languages are ""unbundled,"" by providing a suite of operators independently controlling such effects as combination, modification, encapsulation, name resolution, and sharing, all on the single notion of module.""
  - ""All module operators are forms of inheritance.""
  - ""This allows a previously unobtainable spectrum of features to be combined in a cohesive manner, including multiple inheritance, mixins, encapsulation and strong typing.""
  - ""Jigsaw has a rigorous semantics, based upon a denotational model of inheritance.""
  - ""Jigsaw provides a notion of modularity independent of a particular computational paradigm.""
  - ""The framework is used to derive an extension of Modula-3 that supports the new operations.""",,"- The abstract introduces a new framework called Jigsaw, which is a significant theoretical contribution as it provides a novel approach to modularity in programming languages.
 - The ""unbundling"" of class roles into independent operators is a key novel insight, as it allows for more flexible and modular programming.
 - The integration of multiple inheritance, mixins, encapsulation, and strong typing in a cohesive manner is a theoretical advancement beyond existing approaches, as it addresses a previously unobtainable combination of features.
 - The use of a denotational model of inheritance provides a rigorous semantics, which is a theoretical contribution to the understanding of inheritance mechanisms.
 - The framework's independence from specific computational paradigms is a significant theoretical advancement, as it makes Jigsaw applicable to a wide range of languages.
 - The potential implications for programming language design are substantial, as Jigsaw can be applied to special-purpose languages, enhancing their modularity without requiring custom mechanisms."
Systematic parallel programming (formal program development),"J. Dingel, S. Brookes",-,-,-,5,2000,"1. Primitive Name: Fair Parallelism
  Definition: Supported by the programming/specification notation
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Shared Variable Concurrency
  Definition: Supported by the programming/specification notation
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Message-Passing Concurrency
  Definition: Supported by the programming/specification notation
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Local Variables
  Definition: Supported by the programming/specification notation
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Channels
  Definition: Supported by the programming/specification notation
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Compositional Trace Semantics
  Definition: Treats shared-variable and message-passing concurrency uniformly
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Refinement Relation
  Definition: Combines context-sensitive trace inclusion and assumption-commitment reasoning
  Orthogonality Score: Not discussed
 

 8. Primitive Name: Syntax-Directed Refinement Rules
  Definition: Corresponds to specific language constructs
  Orthogonality Score: Not discussed","- Type of mathematical framework: Refinement calculus
 - Specific mathematical properties guaranteed: Compositional trace semantics, context-sensitive notion of trace inclusion, assumption-commitment reasoning
 - Proof techniques used: Stepwise formal derivation
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Refinement calculus allows shared-variable programs to be refined into distributed, message-passing programs and vice versa.
 - Interaction models between paradigms: Compositional trace semantics treats shared-variable and message-passing concurrency uniformly.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Syntax-directed refinement rules for integrating paradigms at the language construct level.","- Definition of ""concept"" used: The concept of refinement calculus is used to develop a formal basis for parallel program design.
 - Mechanisms for representing generic abstractions: The calculus allows for stepwise formal derivation from high-level specifications to low-level implementations, and it treats shared-variable and message-passing concurrency uniformly.
 - Minimal type requirements identified: Not explicitly mentioned in the abstract.
 - Static checking or optimization strategies: Not explicitly mentioned in the abstract.","- Key novel insights: Development of a formal basis for parallel program design using refinement calculus; uniform treatment of shared-variable and message-passing concurrency.
 - Theoretical advancements: Stepwise formal derivation of implementations from specifications; increased portability through isolation of machine-dependent features; programs correct by construction.
 - Potential implications for programming language design: Influence on handling concurrency in future languages; extension to fine-grained levels of concurrency.","- ""Our programming/specification notation supports fair parallelism, shared varia-ble and message-passing concurrency, local variables and channels.""
  - ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""",,"- The abstract discusses a refinement calculus that is used for the formal derivation of parallel programs. This suggests that the conceptual primitives are related to the components of this calculus.
 - The programming/specification notation supports several concurrency models, including fair parallelism, shared variables, message-passing concurrency, local variables, and channels. These are likely conceptual primitives as they are fundamental to the programming paradigm.
 - The compositional trace semantics and refinement relation are key components of the calculus, indicating they are also conceptual primitives.
 - The mention of syntax-directed refinement rules suggests that these rules are part of the primitives, as they correspond to specific language constructs.","- ""This thesis addresses some of these problems by developing a formal basis for the design of parallel programs in form of a refinement calculus.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""
  - ""The calculus thus helps structuring and documenting the development process.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""
  - ""The calculus straddles both concurrency paradigms.""
  - ""A shared-variable program can be refined into a distributed, message-passing program and vice versa.""
  - ""Moreover, the framework naturally extends to fine-grained levels of concurrency.""",,"- The abstract mentions the development of a ""refinement calculus"" as the mathematical framework for formalizing parallel programs. This indicates that the type of mathematical framework used is a refinement calculus.
 - The framework is based on ""compositional trace semantics,"" which suggests that it uses trace semantics to handle concurrency uniformly.
 - The refinement relation uses ""context-sensitive notion of trace inclusion and assumption-commitment reasoning,"" which are specific mathematical properties guaranteed by the framework.
 - The framework allows for the stepwise formal derivation of implementations from specifications, which implies a structured proof methodology.
 - The abstract does not explicitly mention limitations or constraints of the framework, but it does highlight its ability to handle both shared-variable and message-passing concurrency paradigms and its extension to fine-grained concurrency levels.","- ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The calculus straddles both concurrency paradigms. A shared-variable program can be refined into a distributed, message-passing program and vice versa.""",,"- The abstract discusses a refinement calculus that integrates different programming paradigms, specifically shared-variable and message-passing concurrency.
 - The calculus allows for the refinement of shared-variable programs into distributed, message-passing programs and vice versa, indicating a mechanism for integrating these paradigms.
 - The use of a compositional trace semantics suggests a theoretical integration strategy that treats both paradigms uniformly.
 - The refinement relation, which includes context-sensitive trace inclusion and assumption-commitment reasoning, provides a specific integration mechanism.
 - The syntax-directed refinement rules suggest a structured approach to integrating the paradigms at the language construct level.","- ""This thesis addresses some of these problems by developing a formal basis for the design of parallel programs in form of a refinement calculus.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""
  - ""The calculus thus helps structuring and documenting the development process.""
  - ""Portability is increased, because the introduction of a machine-dependent feature can be located in the refinement tree.""
  - ""Development efforts above this point in the tree are independent of that feature and are thus reusable.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""Most refinement rules are syntax-directed in the sense that each rule corresponds to a specific language construct.""
  - ""The calculus straddles both concurrency paradigms. A shared-variable program can be refined into a distributed, message-passing program and vice versa.""",,"- The abstract discusses the development of a refinement calculus as a formal basis for designing parallel programs. This suggests a focus on abstraction mechanisms through the use of a calculus that allows for stepwise derivation from high-level specifications to low-level implementations.
 - The mention of ""structuring and documenting the development process"" implies that the calculus provides a structured approach to abstraction, which is a key aspect of generic programming.
 - The increase in portability due to the ability to locate machine-dependent features in the refinement tree suggests a mechanism for representing generic abstractions that are independent of specific machine features.
 - The compositional trace semantics and refinement relation indicate a systematic approach to abstraction, which is crucial for generic programming.
 - The syntax-directed refinement rules suggest a structured mechanism for representing generic abstractions, as each rule corresponds to a specific language construct.
 - The ability to refine shared-variable programs into distributed, message-passing programs and vice versa indicates flexibility in abstraction mechanisms, which is a characteristic of generic programming.","- ""This thesis addresses some of these problems by developing a formal basis for the design of parallel programs in form of a refinement calculus.""
  - ""The calculus allows the stepwise formal derivation of an abstract, low-level implementation from a trusted, high-level specification.""
  - ""Portability is increased, because the introduction of a machine-dependent feature can be located in the refinement tree.""
  - ""Development efforts above this point in the tree are independent of that feature and are thus reusable.""
  - ""Moreover, the discovery of new, possibly more efficient solutions is facilitated.""
  - ""programs are correct by construction, which obviates the need for difficult debugging.""
  - ""The calculus rests on a compositional trace semantics that treats shared-variable and message-passing concurrency uniformly.""
  - ""The refinement relation combines a context-sensitive notion of trace inclusion and assumption-commitment reasoning to achieve compositionality.""
  - ""A shared-variable program can be refined into a distributed, message-passing program and vice versa.""
  - ""Moreover, the framework naturally extends to fine-grained levels of concurrency.""",,"- The abstract introduces a ""formal basis for the design of parallel programs"" using a ""refinement calculus,"" which is a novel theoretical contribution as it provides a structured approach to developing parallel programs.
 - The calculus allows for the stepwise derivation of implementations from specifications, which is a key theoretical advancement as it ensures programs are ""correct by construction,"" reducing the need for debugging.
 - The refinement calculus increases portability by isolating machine-dependent features, making development efforts reusable, which is a significant theoretical contribution to parallel programming.
 - The framework's ability to treat shared-variable and message-passing concurrency uniformly and to refine programs between these paradigms is a novel insight, as it bridges different concurrency models.
 - The extension to fine-grained levels of concurrency suggests potential implications for programming language design, as it could influence how future languages handle concurrency."
A Glimpse of Paradise,H. Aït-Kaci,10.1007/3-540-54141-1_2,https://doi.org/10.1007/3-540-54141-1_2,East/West Database Workshop,5,1990,"1. Primitive Name: Abstract Data Structures
  Definition: Not specified
  Orthogonality Score: Not discussed
 2. Primitive Name: Abstract Control Structures
  Definition: Not specified
  Orthogonality Score: Not discussed
 3. Primitive Name: Abstract Constraint Structures
  Definition: Not specified
  Orthogonality Score: Not discussed",Not specified (the abstract does not mention any mathematical framework or theoretical foundations),No specific integration approach described (the abstract discusses the conceptual framework of integrating paradigms through primeval abstractions but lacks specific mechanisms or strategies),"- Definition of ""concept"" used: Not explicitly mentioned
 - Mechanisms for representing generic abstractions: Three primeval abstractions (abstract data structures, abstract control structures, abstract constraint structures)
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: Coexistence of different programming paradigms without mutual exclusion.
 - Theoretical advancements: Introduction of three primeval abstractions for abstract data structures, control structures, and constraint structures.
 - Potential implications: More flexible and integrated programming language design allowing for explicit manipulation of these abstractions.","- ""In the next decade, computer programming should allow specifying (1) abstract data structures, (2) abstract control structures, and (3) abstract constraint structures.""
  - ""we language designers must provide three primeval abstractions which could allow retrieving of most particular programming styles as particular instances, with the additional freedom of manipulating these abstractions explicitly.""",,"- The abstract mentions ""three primeval abstractions"" that are necessary for allowing different programming styles to coexist. These are identified as ""abstract data structures,"" ""abstract control structures,"" and ""abstract constraint structures.""
 - These three abstractions are proposed as conceptual primitives for reconstructing programming paradigms, as they are intended to allow for the retrieval of most particular programming styles.
 - The abstract does not provide a precise definition for each primitive beyond their names, nor does it discuss their orthogonality.
 - The level of abstraction is implied by the term ""abstract,"" suggesting that these primitives are intended to be high-level concepts.","- ""In the next decade, computer programming should allow specifying (1) abstract data structures, (2) abstract control structures, and (3) abstract constraint structures.""
  - ""we language designers must provide three primeval abstractions which could allow retrieving of most particular programming styles as particular instances, with the additional freedom of manipulating these abstractions explicitly.""
  - ""Having understood that most attractive programming paradigms introduced recently in declarative symbolic programming languages need not be provided at the detriment of one another, we also believe that they can and should coexist with the more conventional state-effecting style of explicit control and data processing of imperative programming.""
  - ""we shall propose and sketch a specific design for a language and lay out some explicit requirements.""",,"- The abstract discusses the integration of different programming paradigms and the need for abstractions that can coexist with conventional programming styles. However, it does not mention any specific mathematical framework or theoretical foundations.
 - The abstract focuses on the design of a language and the specification of abstract structures, but it does not provide details about the mathematical framework used to formalize these concepts.
 - There is no mention of type theory, category theory, or any other mathematical framework in the abstract.
 - The abstract does not discuss proof methodology, formal verification, or specific mathematical properties guaranteed by a framework.
 - The limitations or constraints of any mathematical framework are not addressed in the abstract.","- ""most attractive programming paradigms introduced recently in declarative symbolic programming languages need not be provided at the detriment of one another,""
  - ""they can and should coexist with the more conventional state-effecting style of explicit control and data processing of imperative programming.""
  - ""provide three primeval abstractions which could allow retrieving of most particular programming styles as particular instances, with the additional freedom of manipulating these abstractions explicitly.""
  - ""specifying (1) abstract data structures, (2) abstract control structures, and (3) abstract constraint structures.""
  - ""propose and sketch a specific design for a language and lay out some explicit requirements.""
  - ""try to compare this attempt to the state of the art.""",,"- The abstract suggests that the study aims to integrate different programming paradigms by allowing them to coexist without one being at the expense of the other. This is indicated by the statement that paradigms ""need not be provided at the detriment of one another.""
 - The integration approach involves providing ""three primeval abstractions"" that can be manipulated explicitly, which are abstract data structures, abstract control structures, and abstract constraint structures. These abstractions are proposed as a way to retrieve different programming styles as instances.
 - The abstract does not provide specific details on interaction models between paradigms or constraints/challenges in paradigm integration. It focuses on the conceptual framework rather than detailed mechanisms or challenges.
 - There is no mention of novel translation or embedding techniques in the abstract.
 - The study aims to propose a specific design for a language and compare it to the state of the art, but the abstract does not provide explicit integration mechanisms or detailed strategies.","- ""three primeval abstractions which could allow retrieving of most particular programming styles as particular instances, with the additional freedom of manipulating these abstractions explicitly.""
  - ""most attractive programming paradigms introduced recently in declarative symbolic programming languages need not be provided at the detriment of one another,""
  - ""they can and should coexist with the more conventional state-effecting style of explicit control and data processing of imperative programming.""
  - ""we shall propose and sketch a specific design for a language and lay out some explicit requirements.""
  - ""computer programming should allow specifying (1) abstract data structures, (2) abstract control structures, and (3) abstract constraint structures.""",,"- The abstract discusses the integration of different programming paradigms, suggesting a focus on genericity and abstraction by allowing various styles to coexist.
 - The mention of ""three primeval abstractions"" indicates a mechanism for representing generic abstractions, as these abstractions are meant to encompass various programming styles.
 - The abstract specifies ""abstract data structures,"" ""abstract control structures,"" and ""abstract constraint structures,"" which are mechanisms for representing generic abstractions.
 - There is no explicit mention of minimal type requirements or static checking/optimization strategies in the abstract.
 - The abstract does not provide a detailed definition of ""concept"" or specific strategies for static checking or optimization.","- ""Having understood that most attractive programming paradigms introduced recently in declarative symbolic programming languages need not be provided at the detriment of one another, we also believe that they can and should coexist with the more conventional state-effecting style of explicit control and data processing of imperative programming.""
  - ""we language designers must provide three primeval abstractions which could allow retrieving of most particular programming styles as particular instances, with the additional freedom of manipulating these abstractions explicitly.""
  - ""Doing so, we shall try to compare this attempt to the state of the art.""
  - ""In the next decade, computer programming should allow specifying (1) abstract data structures, (2) abstract control structures, and (3) abstract constraint structures.""
  - ""we shall propose and sketch a specific design for a language and lay out some explicit requirements.""",,"- The abstract suggests a novel insight that different programming paradigms can coexist without being mutually exclusive, which is a departure from the traditional view where paradigms are seen as distinct and separate.
 - The introduction of ""three primeval abstractions"" for abstract data structures, control structures, and constraint structures represents a theoretical advancement. These abstractions are proposed as a way to unify different programming styles, allowing for their explicit manipulation.
 - The proposal to specify these abstract structures implies a theoretical contribution towards a more flexible and integrated programming language design.
 - The mention of comparing this attempt to the ""state of the art"" suggests a comparative analysis with existing work, indicating an effort to position this contribution within the broader context of programming language design.
 - The abstract does not provide specific implementation details but focuses on theoretical innovations and potential implications for programming language design."
Synthesis from multi-paradigm specifications,"Ioannis Filippidis, R. Murray, G. Holzmann",-,-,-,2,2015,"1. Primitive Name: Imperative Elements
  Definition: Transition systems and guarded commands, expressed in a syntax based on Promela, allowing for control and data flow definition and separation of assumptions and guarantees.
  Orthogonality Score: Not specified
 2. Primitive Name: Declarative Elements
  Definition: LTL fragment of generalized reactivity(1)
  Orthogonality Score: Not specified","- Type of mathematical framework: Game-theoretic framework
 - Specific mathematical properties guaranteed: Linear temporal logic (LTL) properties
 - Proof techniques used: Efficient synthesis algorithms
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Integration of imperative and declarative elements.
 - Interaction models between paradigms: Transition systems and guarded commands serve as imperative constructs; syntax allows defining control flow and separating assumptions and guarantees.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Integration of imperative and declarative elements for reactive synthesis problems.
 - Theoretical advancements: Structured programming language for synthesis problems, addressing sequential constraints more effectively.
 - Potential implications: Influence on programming language design to be more versatile and efficient in synthesis tasks.","- ""This work proposes a language for describing reactive synthesis problems that integrates imperative and declarative elements.""
  - ""Transition systems and guarded commands serve as imperative constructs, expressed in a syntax based on that of the modeling language Promela.""
  - ""The declarative part is expressed in the LTL fragment of generalized reactivity(1), which admits efficient synthesis algorithms.""
  - ""The syntax allows defining which player controls data and control flow, and separating a program into assumptions and guarantees.""
  - ""The semantics is defined in terms of two-player turn-based infinite games with full information.""",,"- The abstract mentions the integration of ""imperative and declarative elements,"" which suggests that these are conceptual primitives used in the study.
 - ""Transition systems and guarded commands"" are identified as imperative constructs, indicating they are part of the imperative primitive.
 - The syntax based on Promela allows for defining control and data flow, as well as separating assumptions and guarantees, which are likely part of the imperative primitive.
 - The declarative part is expressed in ""the LTL fragment of generalized reactivity(1),"" which is a specific declarative primitive.
 - The abstract does not provide explicit definitions or orthogonality scores for these primitives, nor does it mention any specific names for them beyond their functional descriptions.","- ""The semantics is defined in terms of two-player turn-based infinite games with full information.""
  - ""The declarative part is expressed in the LTL fragment of generalized reactivity(1), which admits efficient synthesis algorithms.""",,"- The abstract mentions that the semantics of the proposed language are defined in terms of ""two-player turn-based infinite games with full information."" This suggests a game-theoretic framework, which is a type of mathematical framework used to formalize and guarantee properties.
 - The use of ""LTL fragment of generalized reactivity(1)"" indicates a specific mathematical property related to linear temporal logic (LTL), which is a formal system for expressing temporal properties.
 - The mention of ""efficient synthesis algorithms"" implies that the framework is designed to support efficient synthesis, which is a proof technique used in formal verification.
 - There is no explicit mention of limitations or constraints of the framework in the abstract.","- ""This work proposes a language for describing reactive synthesis problems that integrates imperative and declarative elements.""
  - ""The semantics is defined in terms of two-player turn-based infinite games with full information.""
  - ""Transition systems and guarded commands serve as imperative constructs, expressed in a syntax based on that of the modeling language Promela.""
  - ""The syntax allows defining which player controls data and control flow, and separating a program into assumptions and guarantees.""
  - ""The integration of imperative and declarative paradigms allows using the paradigm that is most appropriate for expressing each requirement.""
  - ""The declarative part is expressed in the LTL fragment of generalized reactivity(1), which admits efficient synthesis algorithms.""",,"- The abstract mentions the integration of ""imperative and declarative elements"" in the proposed language, indicating a specific integration mechanism.
 - The use of ""transition systems and guarded commands"" as imperative constructs suggests a structured approach to integrating these elements.
 - The syntax based on Promela allows for defining control flow and separating assumptions and guarantees, which are interaction models between paradigms.
 - The integration enables the use of the most appropriate paradigm for each requirement, suggesting flexibility in paradigm interaction.
 - The declarative part is expressed in LTL, which is a specific integration strategy for declarative elements.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the integration of imperative and declarative elements.","- ""This work proposes a language for describing reactive synthesis problems that integrates imperative and declarative elements.""
  - ""The semantics is defined in terms of two-player turn-based infinite games with full information.""
  - ""Transition systems and guarded commands serve as imperative constructs, expressed in a syntax based on that of the modeling language Promela.""
  - ""The syntax allows defining which player controls data and control flow, and separating a program into assumptions and guarantees.""
  - ""The integration of imperative and declarative paradigms allows using the paradigm that is most appropriate for expressing each requirement.""
  - ""The declarative part is expressed in the LTL fragment of generalized reactivity(1), which admits efficient synthesis algorithms.""",,"- The abstract discusses the integration of imperative and declarative elements in a language for describing reactive synthesis problems. This suggests a focus on combining different programming paradigms rather than generic programming or abstraction mechanisms.
 - The use of transition systems and guarded commands indicates a structured approach to specifying synthesis problems, but it does not explicitly mention generic programming or abstraction mechanisms.
 - The syntax based on Promela allows for defining control flow and separating assumptions and guarantees, which is more about structuring the program than about genericity or abstraction.
 - The integration of paradigms is about choosing the most appropriate paradigm for each requirement, which is not directly related to generic programming or abstraction mechanisms.
 - The abstract does not mention any specific mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""This work proposes a language for describing reactive synthesis problems that integrates imperative and declarative elements.""
  - ""The semantics is defined in terms of two-player turn-based infinite games with full information.""
  - ""Currently, synthesis tools accept linear temporal logic (LTL) as input, but this description is less structured and does not facilitate the expression of sequential constraints.""
  - ""This motivates the use of a structured programming language to specify synthesis problems.""
  - ""The integration of imperative and declarative paradigms allows using the paradigm that is most appropriate for expressing each requirement.""
  - ""The declarative part is expressed in the LTL fragment of generalized reactivity(1), which admits efficient synthesis algorithms.""",,"- The abstract introduces a novel language that integrates both imperative and declarative elements for describing reactive synthesis problems. This integration is a key theoretical contribution as it allows for a more structured approach to specifying synthesis problems.
 - The use of a structured programming language to specify synthesis problems is highlighted as a motivation due to the limitations of current LTL-based inputs. This suggests a theoretical advancement in addressing sequential constraints more effectively.
 - The integration of paradigms allows for flexibility in expressing requirements, which is a theoretical innovation beyond existing approaches that may rely solely on one paradigm.
 - The mention of the LTL fragment of generalized reactivity(1) indicates a theoretical contribution in terms of efficient synthesis algorithms, which is a significant advancement in the field.
 - The potential implications for programming language design are evident in the development of a language that can handle both imperative and declarative elements, which could influence future language design to be more versatile and efficient in synthesis tasks."
"Speciication, Transformation, and Programming of Concurrent Systems in Rewriting Logic","P. Lincoln, N. Mart I-Oliet, P. Lincoln, N. Mart I-Oliet, And J Meseguer",-,-,-,4,1994,"1. Primitive Name: Algebraically axiomatized data structures
  Definition: States of a system understood as algebraically axiomatized data structures
  Orthogonality Score: Not discussed
 2. Primitive Name: Rewrite rules
  Definition: Basic local changes axiomatized as rewrite rules corresponding to local patterns
  Orthogonality Score: Not discussed
 3. Primitive Name: Term rewriting
  Definition: Type of rewriting supported by Simple Maude
  Orthogonality Score: Not discussed
 4. Primitive Name: Graph rewriting
  Definition: Type of rewriting supported by Simple Maude
  Orthogonality Score: Not discussed
 5. Primitive Name: Object-oriented rewriting
  Definition: Type of rewriting supported by Simple Maude
  Orthogonality Score: Not discussed","- Type of mathematical framework: Rewriting logic
 - Specific mathematical properties guaranteed: Algebraic axiomatization of data structures
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Rewriting logic as a generalization to express functional and non-functional computations; Simple Maude supporting term, graph, and object-oriented rewriting.
 - Interaction models between paradigms: Program transformation techniques mapping rewriting logic specifications into Simple Maude programs; incorporation of modules with conventional code or special subsystems.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"" used: Rewriting logic as a logic of change with algebraically axiomatized data structures.
 - Mechanisms for representing generic abstractions: Term, graph, and object-oriented rewriting in Simple Maude.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Program transformation techniques discussed.","- Key novel insights: Implicit and machine-independent parallelism through rewriting logic.
 - Theoretical advancements: Generalization of rewriting to include functional and nonfunctional computations; rewriting logic as a logic of change.
 - Potential implications for programming language design: Machine-independent parallel programming language (Simple Maude) with support for term, graph, and object-oriented rewriting.","- ""The generalization in question is provided by rewriting logic, a logic of change in which the states of a system are understood as algebraically axiomatized data structures""
  - ""the basic local changes that can concurrently occur in a system are axiomatized as rewrite rules that correspond to local patterns that, when present in the state of a system, can change into other patterns.""
  - ""Simple Maude, a carefully designed sublanguage of rewriting logic supporting three types of rewriting|term, graph, and object-oriented|, is then proposed as a machine-independent parallel programming language""
  - ""This paper proposes a declarative paradigm in which paral-lelism is implicit and machine-independent, and the programs so developed are intrinsically parallel.""",,"- The abstract discusses a ""declarative paradigm"" where parallelism is implicit and machine-independent, indicating a conceptual framework for programming.
 - Rewriting logic is introduced as a ""logic of change"" where system states are represented as algebraically axiomatized data structures. This suggests a primitive related to data structures.
 - The concept of ""rewrite rules"" is mentioned as a way to represent local changes in a system, which can be considered a primitive for expressing parallel computations.
 - Simple Maude is described as supporting three types of rewriting: term, graph, and object-oriented. These could be considered as specific primitives within the rewriting logic framework.
 - The abstract does not explicitly define these concepts as ""conceptual primitives,"" but they are central to the proposed paradigm and methodology.","- ""Simple Maude, a carefully designed sublanguage of rewriting logic supporting three types of rewriting|term, graph, and object-oriented|, is then proposed as a machine-independent parallel programming language that can be eeciently implemented in parallel on many diierent machines.""
  - ""The generalization in question is provided by rewriting logic, a logic of change in which the states of a system are understood as algebraically axiomatized data structures""
  - ""the basic local changes that can concurrently occur in a system are axiomatized as rewrite rules that correspond to local patterns that, when present in the state of a system, can change into other patterns.""
  - ""This paper proposes a declarative paradigm in which paral-lelism is implicit and machine-independent, and the programs so developed are intrinsically parallel.""",,"- The abstract mentions ""rewriting logic"" as the mathematical framework used to formalize and guarantee properties of the conceptual primitives. This indicates that the type of mathematical framework is rewriting logic.
 - The abstract describes rewriting logic as ""a logic of change in which the states of a system are understood as algebraically axiomatized data structures."" This suggests that the framework involves algebraic axiomatization, which is a specific mathematical property.
 - The abstract does not explicitly mention specific mathematical properties guaranteed by the framework, proof techniques used, or limitations or constraints of the framework. Therefore, these details are not specified in the abstract.","- ""This paper proposes a declarative paradigm in which paral-lelism is implicit and machine-independent, and the programs so developed are intrinsically parallel.""
  - ""The generalization in question is provided by rewriting logic, a logic of change in which the states of a system are understood as algebraically axiomatized data structures , and the basic local changes that can concurrently occur in a system are axiomatized as rewrite rules that correspond to local patterns that, when present in the state of a system, can change into other patterns.""
  - ""Simple Maude, a carefully designed sublanguage of rewriting logic supporting three types of rewriting|term, graph, and object-oriented|, is then proposed as a machine-independent parallel programming language that can be eeciently implemented in parallel on many diierent machines.""
  - ""The adequacy of term, graph, and object-oriented rewriting to naturally express many diierent parallel programming problems is illustrated with examples.""
  - ""Several program transformation techniques mapping rewriting logic speciications into Simple Maude programs are discussed using representative examples.""
  - ""The incorporation of modules containing conventional code or special subsystems or devices within Simple Maude is also discussed.""",,"- The abstract discusses a declarative paradigm that integrates parallelism implicitly and is machine-independent, which suggests a focus on integrating different programming paradigms within a single framework.
 - Rewriting logic is presented as a generalization that can express both functional and non-functional computations, indicating a mechanism for integrating different types of computations.
 - Simple Maude is described as supporting term, graph, and object-oriented rewriting, which implies an integration of these different programming paradigms within the language.
 - The mention of program transformation techniques and the incorporation of modules with conventional code or special subsystems suggests interaction models and constraints in integrating these paradigms.
 - The abstract does not explicitly mention novel translation or embedding techniques, but the discussion of program transformation techniques implies some form of integration strategy.","- ""The generalization in question is provided by rewriting logic, a logic of change in which the states of a system are understood as algebraically axiomatized data structures""
  - ""Simple Maude, a carefully designed sublanguage of rewriting logic supporting three types of rewriting|term, graph, and object-oriented|, is then proposed as a machine-independent parallel programming language""
  - ""The adequacy of term, graph, and object-oriented rewriting to naturally express many diierent parallel programming problems is illustrated with examples.""
  - ""Several program transformation techniques mapping rewriting logic speciications into Simple Maude programs are discussed using representative examples.""
  - ""This paper proposes a declarative paradigm in which paral-lelism is implicit and machine-independent, and the programs so developed are intrinsically parallel.""",,"- The abstract discusses a declarative paradigm with implicit parallelism, which suggests a focus on abstraction and genericity in programming.
 - Rewriting logic is introduced as a generalization that allows for expressing a wide variety of parallel computations, indicating a mechanism for representing generic abstractions.
 - Simple Maude is described as a machine-independent parallel programming language, which implies a level of abstraction and genericity in its design.
 - The mention of term, graph, and object-oriented rewriting suggests mechanisms for representing different types of abstractions.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does discuss program transformation techniques, which could relate to optimization strategies.","- ""This paper proposes a declarative paradigm in which paral-lelism is implicit and machine-independent, and the programs so developed are intrinsically parallel.""
  - ""The generalization in question is provided by rewriting logic, a logic of change in which the states of a system are understood as algebraically axiomatized data structures , and the basic local changes that can concurrently occur in a system are axiomatized as rewrite rules that correspond to local patterns that, when present in the state of a system, can change into other patterns.""
  - ""This paradigm is obtained by generalizing the notion of rewriting to make it more widely applicable and capable of expressing not only functional computations but also a wide variety of parallel computations that are highly nonfunctional in nature.""
  - ""Finally, the advances made so far on general compilation techniques for Simple Maude are summarized.""
  - ""The incorporation of modules containing conventional code or special subsystems or devices within Simple Maude is also discussed.""",,"- The abstract introduces a novel paradigm that makes parallelism implicit and machine-independent, which is a significant theoretical contribution. This paradigm is based on generalizing the notion of rewriting to include both functional and nonfunctional computations.
 - The use of rewriting logic as a ""logic of change"" is a theoretical advancement. It provides a framework for understanding system states as algebraically axiomatized data structures and local changes as rewrite rules, which is a new way of conceptualizing parallel computations.
 - The proposal of Simple Maude as a machine-independent parallel programming language is another theoretical contribution. It supports various types of rewriting and can be efficiently implemented on different machines, which has implications for programming language design.
 - The discussion of program transformation techniques and the incorporation of modules within Simple Maude suggests theoretical advancements in how parallel programming problems are addressed and integrated with existing code or systems.
 - The abstract does not explicitly mention a conclusion or comparative analysis with existing work, but the description of the paradigm and the use of rewriting logic imply a theoretical contribution beyond existing approaches."
Modeling Languages : A new Paradigm of Programming ∗,T. Hürlimann,-,-,-,0,1998,Not specified (the abstract does not provide explicit names or definitions for conceptual primitives),Not specified (the abstract does not provide details about the mathematical framework or theoretical foundations),"- Specific integration mechanisms proposed: Strict separation of declarative and algorithmic parts syntactically and semantically.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Integration of declarative and algorithmic knowledge in a single language.
 - Theoretical advancements: Strict syntactic and semantic separation of declarative and algorithmic parts.
 - Potential implications: Introduction of a new paradigm in programming language design.","- ""strictly separates syntactically and sematically the declarative from the algorithmic part.""
  - ""mathematical-logical constraints on the one hand and an instruction sequence defining an algorithm on the other hand.""
  - ""a new type of programming language (also called modeling language) which allows a modeler to combine declarative and algorithmic knowledge,""",,"- The abstract discusses a new type of programming language that combines declarative and algorithmic knowledge. This suggests that the conceptual primitives might involve these two types of knowledge.
 - The mention of ""mathematical-logical constraints"" and ""instruction sequence defining an algorithm"" indicates that these could be the specific primitives, as they are the components being combined.
 - The abstract does not provide explicit names for these primitives, nor does it define them in detail beyond their roles in the language.
 - There is no mention of orthogonality or the level of abstraction of these primitives in the abstract.
 - The abstract does not specify any explicit conceptual primitives beyond the general concepts of declarative and algorithmic knowledge.","- ""The approach is new in the sense that it strictly separates syntactically and sematically the declarative from the algorithmic part.""
  - ""This paper presents a new type of programming language (also called modeling language) which allows a modeler to combine declarative and algorithmic knowledge, that is, mathematical-logical constraints on the one hand and an instruction sequence defining an algorithm on the other hand.""
  - ""Examples illustrate the flavour of such a language.""
  - ""Advantages of doing so are presented.""",,"- The abstract mentions the combination of ""mathematical-logical constraints"" and ""instruction sequence defining an algorithm,"" which suggests a focus on integrating different types of knowledge within the programming language.
 - The separation of declarative and algorithmic parts is highlighted as a new approach, but there is no specific mention of a mathematical framework or theoretical foundations.
 - The abstract does not provide details about the type of mathematical framework used, specific mathematical properties guaranteed, proof techniques, or limitations of the framework.
 - The focus is on the language's ability to combine different types of knowledge and the advantages of this separation, rather than on the mathematical framework itself.","- ""Examples illustrate the flavour of such a language.""
  - ""Advantages of doing so are presented.""
  - ""The approach is new in the sense that it strictly separates syntactically and sematically the declarative from the algorithmic part.""
  - ""This paper presents a new type of programming language (also called modeling language) which allows a modeler to combine declarative and algorithmic knowledge, that is, mathematical-logical constraints on the one hand and an instruction sequence defining an algorithm on the other hand.""",,"- The abstract mentions a new type of programming language that combines declarative and algorithmic knowledge, which suggests an integration of different programming paradigms.
 - The integration mechanism proposed is the strict separation of declarative and algorithmic parts syntactically and semantically.
 - The abstract does not explicitly mention interaction models between paradigms or specific constraints or challenges in paradigm integration.
 - There is no mention of novel translation or embedding techniques in the abstract.
 - The abstract does not provide a detailed discussion of paradigm interactions, theoretical integration strategies, or comparative analysis sections.","- ""This paper presents a new type of programming language (also called modeling language) which allows a modeler to combine declarative and algorithmic knowledge, that is, mathematical-logical constraints on the one hand and an instruction sequence defining an algorithm on the other hand.""
  - ""Examples illustrate the flavour of such a language.""
  - ""Advantages of doing so are presented.""
  - ""The approach is new in the sense that it strictly separates syntactically and sematically the declarative from the algorithmic part.""",,"- The abstract discusses a new type of programming language that combines declarative and algorithmic knowledge, which suggests a focus on integrating different programming paradigms rather than generic programming or abstraction mechanisms.
 - The separation of declarative and algorithmic parts is highlighted as a new approach, but this does not directly relate to generic programming or abstraction mechanisms.
 - The abstract does not mention any specific mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The focus of the abstract is on the integration of declarative and algorithmic knowledge rather than on generic programming or abstraction mechanisms.","- ""This paper presents a new type of programming language (also called modeling language) which allows a modeler to combine declarative and algorithmic knowledge, that is, mathematical-logical constraints on the one hand and an instruction sequence defining an algorithm on the other hand.""
  - ""Examples illustrate the flavour of such a language.""
  - ""The approach is new in the sense that it strictly separates syntactically and sematically the declarative from the algorithmic part.""
  - ""Advantages of doing so are presented.""",,"- The abstract introduces a ""new type of programming language"" that integrates both declarative and algorithmic knowledge, which suggests a novel insight in programming language design.
 - The novelty is highlighted by the strict separation of declarative and algorithmic parts syntactically and semantically, which is a unique theoretical contribution.
 - The mention of ""advantages"" implies that there are theoretical advancements beyond existing approaches, as these advantages are likely compared to previous methods.
 - The abstract does not explicitly mention potential implications for programming language design, but the introduction of a new paradigm suggests potential impacts on future language design."
Acknowledgements I am much indebted to Mark Norris of British Telecom Research Laboratories for promoting and encouraging my interest in applying definitive principles to concur-,"M. Slade, E. Yung, W. M. Beynon, Y. Yung, A. Cartwright",-,-,-,0,2007,Not specified (the abstract does not explicitly define or list conceptual primitives),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of a novel approach to concurrent programming based on definitive programming.
 - Theoretical advancements: Advancement of definitive programming as a basis for general-purpose parallel computing, with a focus on its general principles and specific features compared to existing paradigms.
 - Potential implications: Development of an abstract machine model for simulating concurrent systems, which could influence programming language design.","- ""An appropriate abstract machine model is motivated, described and illustrated with reference to the simulation of a simple concurrent system.""
  - ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms,""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests that this approach involves specific conceptual primitives.
 - The phrase ""formulation of definitions"" implies that these primitives are related to defining or specifying elements within the programming paradigm.
 - The abstract discusses ""general principles and specific features"" of definitive programming, which could include conceptual primitives, but it does not explicitly list or define these primitives.
 - The mention of an ""abstract machine model"" suggests a theoretical framework, but again, no specific primitives are detailed in the abstract.
 - The abstract does not provide explicit definitions or names of conceptual primitives, nor does it discuss their orthogonality or level of abstraction.","- ""An appropriate abstract machine model is motivated, described and illustrated with reference to the simulation of a simple concurrent system.""
  - ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms,""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests a focus on definitions and possibly a formal framework.
 - The discussion of ""general principles and specific features"" implies some theoretical foundation, but it does not specify a mathematical framework.
 - The mention of an ""abstract machine model"" suggests some level of formalization, but again, no specific mathematical framework is named.
 - There is no explicit mention of a type of mathematical framework (e.g., type theory, category theory), specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms,""
  - ""the relative merits of definitive programming for general-purpose parallelism are considered.""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests a new paradigm or approach rather than an integration of existing paradigms.
 - The discussion of ""definitive programming"" in the context of existing paradigms implies a comparison or consideration of how it relates to other paradigms, but it does not explicitly mention integration mechanisms or strategies.
 - There is no mention of specific integration mechanisms, interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques in the abstract.
 - The focus appears to be on presenting a new paradigm rather than integrating different paradigms.","- ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms,""
  - ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""An appropriate abstract machine model is motivated, described and illustrated with reference to the simulation of a simple concurrent system.""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests a focus on defining principles rather than generic programming or abstraction mechanisms.
 - The discussion of ""general principles and specific features"" implies a focus on the paradigm itself rather than specific mechanisms for genericity or abstraction.
 - The mention of an ""abstract machine model"" could relate to abstraction, but it is not explicitly linked to generic programming or abstraction mechanisms.
 - There is no mention of generic programming methodology, type system discussions, or specific abstraction mechanisms in the abstract.","- ""A novel approach to concurrent programming, based upon the formulation of definitions (""definitive programming""), is outlined.""
  - ""The general principles and specific features of definitive programming are discussed in the context of existing programming paradigms, and the relative merits of definitive programming for general-purpose parallelism are considered.""
  - ""An appropriate abstract machine model is motivated, described and illustrated with reference to the simulation of a simple concurrent system.""
  - ""A case for the further investigation and development of the definitive programming paradigm as a basis for general-purpose parallel computing is presented.""",,"- The abstract mentions a ""novel approach to concurrent programming"" based on ""definitive programming,"" which suggests a new theoretical contribution in the field of concurrent programming.
 - The presentation of a ""case for the further investigation and development"" of this paradigm indicates that the study is advancing the theoretical understanding of definitive programming as a basis for general-purpose parallel computing.
 - The discussion of ""general principles and specific features"" of definitive programming in relation to existing paradigms implies a comparative analysis that highlights the theoretical advancements of this approach.
 - The motivation, description, and illustration of an ""abstract machine model"" suggest a theoretical innovation in how concurrent systems are modeled and simulated."
"Semantics, Logic, and Verification of ""Exact Real Computation""","F. Brauße, P. Collins, Johannes Kanig, SunYoung Kim, M. Konečný, Gyesik Lee, N. Müller, E. Neumann, Sewon Park, N. Preining, M. Ziegler",-,-,-,5,2016,"1. Primitive Name: Partial Inequality Predicate
  Definition: A predicate used in the language for comparing real numbers.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Multivalued Binary SELECT
  Definition: An operation that selects values based on conditions, allowing for multiple outcomes.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Continuous Conditional (PARALLEL-IF)
  Definition: A conditional operation that allows for continuous evaluation based on conditions.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Approximation
  Definition: The ability to approximate functions up to a guaranteed absolute error.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Algebraic imperative programming with Recursive Analysis
 - Specific mathematical properties guaranteed: Rigorous semantics, Turing-COMPLETE, decidable, model complete
 - Proof techniques used: First-order theory over two sorts (integers and reals), extended Hoare Logic
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Combining algebraic imperative programming with recursive analysis for ""Exact Real Computation"" (ERC).
 - Interaction models between paradigms: Presenting approximations as exact values to the user while ensuring functions can be realized with guaranteed absolute error.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Extension of Hoare Logic rules to support formal correctness proofs in ERC.","- Definition of ""concept"" used: Abstract data types (ADTs) for continuous structures.
 - Mechanisms for representing generic abstractions: Rigorous semantics, sound semantics of primitives computable in the sense of Recursive ANALYSIS, partial inequality predicate, multivalued binary SELECT, and continuous conditional operations.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Implicit in the rigorous semantics and decidability of the first-order theory.","- Key novel insights: Formalization of ""Exact Real Computation"" (ERC) paradigm combining algebraic imperative programming with sound semantics for continuous structures.
 - Theoretical advancements: Specification of a Turing-complete language for real numbers with rigorous semantics, introduction of a decidable and model complete first-order theory for non-extensional computations, extension of Hoare Logic rules for formal correctness proofs.
 - Potential implications for programming language design: Enhanced reliability and verifiability of computations with real numbers, novel control-flow considerations for reliable numerics.","- ""arguments are provided, passed to and received from calls to functions (like $e^x$), and operated on EXACTLY -- with partial inequality predicate and multivalued binary SELECT and continuous conditional (aka PARALLEL-IF) operations""
  - ""a paradigm combining (i) ALGEBRAIC imperative programming of/over abstract data types (ADTs) for CONTINUOUS structures with (ii) a selection and sound semantics of primitives computable in the sense of Recursive ANALYSIS,""
  - ""Rules of Hoare Logic are extended to support formal correctness proofs in ERC.""
  - ""REALIZING a function (again like $e^x$) requires only to APPROXIMATE its return value up to guaranteed absolute error $2^p$ for any given integer $p$:""
  - ""a small imperative programming language for the ADT of real (i.e., including transcendental) numbers with rigorous semantics:""",,"- The abstract describes a paradigm that combines algebraic imperative programming with a selection of primitives computable in the sense of Recursive Analysis. This suggests that the primitives are related to these computational aspects.
 - The mention of ""a small imperative programming language for the ADT of real numbers"" indicates that the primitives are likely related to operations on real numbers.
 - The abstract specifies operations such as ""partial inequality predicate,"" ""multivalued binary SELECT,"" and ""continuous conditional (aka PARALLEL-IF) operations."" These are likely conceptual primitives as they are described as part of the language's semantics.
 - The requirement to approximate functions like $e^x$ up to a guaranteed absolute error suggests that approximation is a key primitive in this paradigm.
 - The extension of Hoare Logic rules implies that these primitives are used in formal correctness proofs, indicating their importance in the theoretical framework.","- ""This work formalizes ""Exact Real Computation"" (ERC): a paradigm combining (i) ALGEBRAIC imperative programming of/over abstract data types (ADTs) for CONTINUOUS structures with (ii) a selection and sound semantics of primitives computable in the sense of Recursive ANALYSIS, that is, by means of approximations -- yet presented to the user as exact.""
  - ""We prove this language Turing-COMPLETE: it can express precisely those partial real functions computable in the sense of Recursive Analysis; similarly for functionALs.""
  - ""We specify a small imperative programming language for the ADT of real (i.e., including transcendental) numbers with rigorous semantics: arguments are provided, passed to and received from calls to functions (like $e^x$), and operated on EXACTLY -- with partial inequality predicate and multivalued binary SELECT and continuous conditional (aka PARALLEL-IF) operations -- yet REALIZING a function (again like $e^x$) requires only to APPROXIMATE its return value up to guaranteed absolute error $2^p$ for any given integer $p$: closure under composition is implicit.""
  - ""Rules of Hoare Logic are extended to support formal correctness proofs in ERC.""
  - ""For rigorously specifying and arguing about such (non-extensional) computations, we propose a first-order theory over two sorts: integers and reals; and prove it both decidable and 'model complete': thus reflecting the elegance inherent to real (as opposed to rational/floating point) numbers.""",,"- The abstract mentions the use of ""ALGEBRAIC imperative programming"" and ""Recursive ANALYSIS,"" which suggests a type of mathematical framework that involves algebraic structures and recursive analysis.
 - The framework is described as having ""rigorous semantics"" and being ""Turing-COMPLETE,"" indicating that it is designed to ensure precise and complete computation of real functions.
 - The mention of ""partial inequality predicate and multivalued binary SELECT and continuous conditional (aka PARALLEL-IF) operations"" suggests specific mathematical properties related to handling real numbers and conditional operations.
 - The use of a ""first-order theory over two sorts: integers and reals"" indicates a formal verification approach that is both decidable and model complete, which are specific mathematical properties guaranteed by the framework.
 - The extension of ""Rules of Hoare Logic"" for formal correctness proofs suggests a proof technique used within the framework.","- ""Rules of Hoare Logic are extended to support formal correctness proofs in ERC.""
  - ""We prove this language Turing-COMPLETE: it can express precisely those partial real functions computable in the sense of Recursive Analysis; similarly for functionALs.""
  - ""We specify a small imperative programming language for the ADT of real (i.e., including transcendental) numbers with rigorous semantics: arguments are provided, passed to and received from calls to functions (like $e^x$), and operated on EXACTLY -- with partial inequality predicate and multivalued binary SELECT and continuous conditional (aka PARALLEL-IF) operations -- yet REALIZING a function (again like $e^x$) requires only to APPROXIMATE its return value up to guaranteed absolute error $2^p$ for any given integer $p$: closure under composition is implicit.""
  - ""This work formalizes ""Exact Real Computation"" (ERC): a paradigm combining (i) ALGEBRAIC imperative programming of/over abstract data types (ADTs) for CONTINUOUS structures with (ii) a selection and sound semantics of primitives computable in the sense of Recursive ANALYSIS, that is, by means of approximations -- yet presented to the user as exact.""",,"- The abstract describes the integration of two programming paradigms: algebraic imperative programming and recursive analysis. This is evident from the mention of combining these paradigms in the context of ""Exact Real Computation"" (ERC).
 - The integration mechanism involves specifying a small imperative programming language for abstract data types (ADTs) of real numbers, which includes rigorous semantics for operations like partial inequality predicates and multivalued binary SELECT operations.
 - The interaction model between paradigms is based on presenting approximations as exact values to the user, while ensuring that functions can be realized with guaranteed absolute error.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the achievement of Turing completeness, which suggests a successful integration.
 - The extension of Hoare Logic rules to support formal correctness proofs in ERC indicates a novel translation or embedding technique for ensuring the correctness of computations within this integrated paradigm.","- ""This work formalizes ""Exact Real Computation"" (ERC): a paradigm combining (i) ALGEBRAIC imperative programming of/over abstract data types (ADTs) for CONTINUOUS structures with (ii) a selection and sound semantics of primitives computable in the sense of Recursive ANALYSIS, that is, by means of approximations -- yet presented to the user as exact.""
  - ""We prove this language Turing-COMPLETE: it can express precisely those partial real functions computable in the sense of Recursive Analysis; similarly for functionALs.""
  - ""We specify a small imperative programming language for the ADT of real (i.e., including transcendental) numbers with rigorous semantics: arguments are provided, passed to and received from calls to functions (like $e^x$), and operated on EXACTLY -- with partial inequality predicate and multivalued binary SELECT and continuous conditional (aka PARALLEL-IF) operations -- yet REALIZING a function (again like $e^x$) requires only to APPROXIMATE its return value up to guaranteed absolute error $2^p$ for any given integer $p$: closure under composition is implicit.""
  - ""Rules of Hoare Logic are extended to support formal correctness proofs in ERC.""
  - ""For rigorously specifying and arguing about such (non-extensional) computations, we propose a first-order theory over two sorts: integers and reals; and prove it both decidable and 'model complete': thus reflecting the elegance inherent to real (as opposed to rational/floating point) numbers.""",,"- The abstract discusses the formalization of ""Exact Real Computation"" (ERC), which involves algebraic imperative programming over abstract data types (ADTs) for continuous structures. This suggests a focus on abstract data types, which is a form of abstraction mechanism.
 - The mention of ""rigorous semantics"" and ""sound semantics of primitives computable in the sense of Recursive ANALYSIS"" indicates a focus on formalizing the behavior of these abstractions, which is related to generic programming.
 - The language specified for the ADT of real numbers includes operations like partial inequality predicate and multivalued binary SELECT, which are mechanisms for representing generic abstractions.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on rigorous semantics and decidability suggests some level of static checking.
 - The extension of Hoare Logic for formal correctness proofs implies a mechanism for ensuring the correctness of generic abstractions.","- ""This work formalizes ""Exact Real Computation"" (ERC): a paradigm combining (i) ALGEBRAIC imperative programming of/over abstract data types (ADTs) for CONTINUOUS structures with (ii) a selection and sound semantics of primitives computable in the sense of Recursive ANALYSIS, that is, by means of approximations -- yet presented to the user as exact.""
  - ""We specify a small imperative programming language for the ADT of real (i.e., including transcendental) numbers with rigorous semantics: arguments are provided, passed to and received from calls to functions (like $e^x$), and operated on EXACTLY -- with partial inequality predicate and multivalued binary SELECT and continuous conditional (aka PARALLEL-IF) operations -- yet REALIZING a function (again like $e^x$) requires only to APPROXIMATE its return value up to guaranteed absolute error $2^p$ for any given integer $p$: closure under composition is implicit.""
  - ""We prove this language Turing-COMPLETE: it can express precisely those partial real functions computable in the sense of Recursive Analysis; similarly for functionALs.""
  - ""Three basic numerical problems demonstrate both the convenience and novel control-flow considerations of this approach to Reliable Numerics: multivalued integer rounding, solving systems of linear equations, and simple root finding.""
  - ""For rigorously specifying and arguing about such (non-extensional) computations, we propose a first-order theory over two sorts: integers and reals; and prove it both decidable and 'model complete': thus reflecting the elegance inherent to real (as opposed to rational/floating point) numbers.""
  - ""Rules of Hoare Logic are extended to support formal correctness proofs in ERC.""",,"- The abstract introduces a novel paradigm called ""Exact Real Computation"" (ERC), which combines algebraic imperative programming with sound semantics for continuous structures. This is a key theoretical contribution as it formalizes a new approach to handling real numbers in programming.
 - The specification of a small imperative programming language for real numbers with rigorous semantics is a significant theoretical advancement. It allows for exact operations on real numbers while only requiring approximations for function realization, which is a novel insight.
 - The language is proven to be Turing-complete, which is a theoretical advancement as it ensures that the language can express all computable partial real functions, aligning with Recursive Analysis.
 - The introduction of a first-order theory for specifying and arguing about non-extensional computations is another theoretical contribution. This theory is both decidable and model complete, which reflects the elegance of working with real numbers.
 - The extension of Hoare Logic rules to support formal correctness proofs in ERC is a theoretical innovation that enhances the reliability and verifiability of computations in this paradigm."
Automatic Synthesis of Typed Lambda-Programs on Term Algebras,"C. Böhm, A. Berarducci",10.1016/0304-3975(85)90135-5,https://doi.org/10.1016/0304-3975(85)90135-5,Theoretical Computer Science,232,1985,"1. Primitive Name: Iteratively defined functions
  Definition: Introduced as the solution of a finite set of equations of a special shape
  Orthogonality Score: Not specified
 2. Primitive Name: Second-order typed lambda-calculus (Λ)
  Definition: Enables representation of algebra elements and iterative functions
  Orthogonality Score: Not specified
 3. Primitive Name: Completeness theorem for Λ-terms
  Definition: Proved for Λ-terms with type of degree at most two
  Orthogonality Score: Not specified
 4. Primitive Name: New congruence relation
  Definition: Stronger than Λ-convertibility, meaning of a Λ-program equivalence
  Orthogonality Score: Not specified","- Type of mathematical framework: Type theory (second-order typed lambda-calculus)
 - Specific mathematical properties guaranteed: Completeness theorem for Λ-terms with type of degree at most two; new congruence relation stronger than Λ-convertibility
 - Proof techniques used: Proving a completeness theorem and introducing a congruence relation
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,"- Definition of ""concept"" used: Iteratively defined functions from and to heterogeneous term algebras.
 - Mechanisms for representing generic abstractions: Second-order typed lambda-calculus (Λ) and automatic uniform synthesis paradigms.
 - Minimal type requirements identified: Completeness theorem for Λ-terms with type of degree at most two.
 - Static checking or optimization strategies: New congruence relation stronger than Λ-convertibility.","- Novel concept of iteratively defined functions on heterogeneous term algebras as a solution to a finite set of equations.
 - Use of second-order typed lambda-calculus (Λ) to represent algebra elements and iterative functions without conditional or recursive constructs.
 - Completeness theorem and corollary for Λ-programs.
 - New congruence relation stronger than Λ-convertibility for program equivalence.
 - Extension of paradigms to functions of higher complexity.","- ""The notion of iteratively defined functions from and to heterogeneous term algebras is introduced as the solution of a finite set of equations of a special shape.""
  - ""Choosing the second-order typed lamdda-calculus (Λ for short) as a programming language enables one to represent algebra elements and iterative functions by automatic uniform synthesis paradigms, using neither conditional nor recursive constructs.""
  - ""All the concepts are explained and motivated by examples over integers, list- and tree-structures.""
  - ""A new congruence relation for the last-mentioned Λ-terms which is stronger than Λ-convertibility is introduced and proved to have the meaning of a Λ-program equivalence.""
  - ""A completeness theorem for Λ-terms with type of degree at most two and a companion corollary for Λ-programs have been proved.""",,"- The abstract introduces the concept of ""iteratively defined functions from and to heterogeneous term algebras"" as a solution to a set of equations. This suggests a primitive related to iterative functions and term algebras.
 - The use of ""second-order typed lambda-calculus (Λ)"" as a programming language indicates that lambda-calculus is a fundamental primitive for representing algebra elements and functions.
 - The mention of a ""completeness theorem for Λ-terms"" and a ""new congruence relation"" implies that these are theoretical primitives used to establish equivalence and completeness in the context of lambda-calculus.
 - The abstract does not provide explicit definitions for these primitives, nor does it specify their orthogonality or level of abstraction beyond their application in the context of lambda-calculus and term algebras.","- ""A completeness theorem for Λ-terms with type of degree at most two and a companion corollary for Λ-programs have been proved.""
  - ""A new congruence relation for the last-mentioned Λ-terms which is stronger than Λ-convertibility is introduced and proved to have the meaning of a Λ-program equivalence.""
  - ""The notion of iteratively defined functions from and to heterogeneous term algebras is introduced as the solution of a finite set of equations of a special shape.""",,"- The abstract mentions the use of ""second-order typed lambda-calculus (Λ)"" as a programming language, which indicates that the mathematical framework is based on type theory.
 - The mention of ""completeness theorem for Λ-terms with type of degree at most two"" suggests that the framework guarantees certain properties related to completeness, specifically for terms of a certain type degree.
 - The introduction of a ""new congruence relation"" that is ""stronger than Λ-convertibility"" implies that the framework involves formal verification discussions, particularly in terms of equivalence relations.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it detail specific proof techniques used beyond the mention of proving a completeness theorem and introducing a congruence relation.","- ""Moreover, an extension of the paradigms to the synthesis of functions of higher complexity is considered and exemplified.""
  - ""A new congruence relation for the last-mentioned Λ-terms which is stronger than Λ-convertibility is introduced and proved to have the meaning of a Λ-program equivalence.""
  - ""A completeness theorem for Λ-terms with type of degree at most two and a companion corollary for Λ-programs have been proved.""
  - ""The notion of iteratively defined functions from and to heterogeneous term algebras is introduced as the solution of a finite set of equations of a special shape.""",,"- The abstract discusses the use of the second-order typed lambda-calculus (Λ) as a programming language, which is a specific paradigm.
 - It mentions the representation of algebra elements and iterative functions using automatic uniform synthesis paradigms, which suggests a mechanism for integrating these elements within the Λ paradigm.
 - The abstract does not explicitly mention the integration of different programming paradigms or specific integration mechanisms, interaction models, constraints, or novel translation techniques.
 - The focus is on the use and extension of the Λ paradigm rather than integrating it with other paradigms.","- ""The notion of iteratively defined functions from and to heterogeneous term algebras is introduced as the solution of a finite set of equations of a special shape.""
  - ""All the concepts are explained and motivated by examples over integers, list- and tree-structures.""
  - ""A new congruence relation for the last-mentioned Λ-terms which is stronger than Λ-convertibility is introduced and proved to have the meaning of a Λ-program equivalence.""
  - ""A completeness theorem for Λ-terms with type of degree at most two and a companion corollary for Λ-programs have been proved.""",,"- The abstract discusses the use of the second-order typed lambda-calculus (Λ) as a programming language, which is a mechanism for representing generic abstractions. This suggests a focus on generic programming.
 - The mention of ""iteratively defined functions from and to heterogeneous term algebras"" implies a mechanism for representing generic abstractions, as it involves functions that can operate on different types of data structures.
 - The ""completeness theorem for Λ-terms with type of degree at most two"" indicates a minimal type requirement, as it specifies a limit on the type degree for these terms.
 - The introduction of a ""new congruence relation"" that is stronger than Λ-convertibility suggests a form of static checking or optimization strategy, as it provides a way to determine equivalence between programs.
 - The abstract does not explicitly mention static checking or optimization strategies, but the focus on type systems and congruence relations implies some level of static analysis.","- ""The notion of iteratively defined functions from and to heterogeneous term algebras is introduced as the solution of a finite set of equations of a special shape.""
  - ""Choosing the second-order typed lamdda-calculus (Λ for short) as a programming language enables one to represent algebra elements and iterative functions by automatic uniform synthesis paradigms, using neither conditional nor recursive constructs.""
  - ""an extension of the paradigms to the synthesis of functions of higher complexity is considered and exemplified.""
  - ""A new congruence relation for the last-mentioned Λ-terms which is stronger than Λ-convertibility is introduced and proved to have the meaning of a Λ-program equivalence.""
  - ""A completeness theorem for Λ-terms with type of degree at most two and a companion corollary for Λ-programs have been proved.""",,"- The abstract introduces a novel concept of iteratively defined functions on heterogeneous term algebras, which is a key theoretical contribution. This concept is presented as a solution to a set of equations, indicating a new approach to handling functions in term algebras.
 - The use of the second-order typed lambda-calculus (Λ) to represent algebra elements and iterative functions without conditional or recursive constructs is a significant theoretical advancement. It suggests a new paradigm for programming that avoids traditional constructs, which could have implications for programming language design.
 - The completeness theorem and its corollary for Λ-programs are theoretical advancements that provide a foundation for the synthesis of programs within this framework. This indicates a rigorous theoretical underpinning for the proposed approach.
 - The introduction of a new congruence relation stronger than Λ-convertibility is another theoretical contribution. It provides a new way to understand program equivalence, which is crucial for programming language theory.
 - The extension of these paradigms to functions of higher complexity suggests potential for further theoretical development and application, indicating a broader impact on programming language design and theory."
The design and implementation of object-constraint programming,T. Felgentreff,-,-,-,0,2017,"1. Primitive Name: Constraints
  Definition: Allow developers to specify properties of systems that are automatically maintained.
  Orthogonality Score: Not discussed
 2. Primitive Name: Unified Method Definitions
  Definition: Use only object-oriented method definitions for both declarative and imperative code.
  Orthogonality Score: Not discussed
 3. Primitive Name: Constraint Expression
  Definition: Constraints are expressed using ordinary imperative expressions.
  Orthogonality Score: Not discussed
 4. Primitive Name: Constraint Satisfaction
  Definition: System attempts to satisfy constraints if they are not currently true and keeps them satisfied.
  Orthogonality Score: Not discussed
 5. Primitive Name: Solver Architecture
  Definition: Integration of multiple cooperating solvers.
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Unification of encapsulation and abstraction constructs using object-oriented method definitions for both declarative and imperative code.
 - Interaction models between paradigms: Constraints are expressed using ordinary imperative expressions and are satisfied by the system.
 - Constraints or challenges in paradigm integration: Current integrations often lead to redundant code due to lack of unification.
 - Novel translation or embedding techniques: Integration of an architecture for using multiple cooperating solvers.",Generic programming not extensively addressed,"- Key novel insights: Unification of encapsulation and abstraction constructs in object-constraint programming.
 - Theoretical advancements: Integration of constraint programming with object-oriented programming using unified constructs; architecture for multiple cooperating solvers.
 - Potential implications: Enhanced reusability and flexibility in programming language design; making constraint solving accessible to object-oriented programmers.","- ""Constraints allow developers to specify properties of systems and have those properties be maintained automatically.""
  - ""Our design unifies the constructs for encapsulation and abstraction by using only objectoriented method definitions for both declarative and imperative code.""
  - ""Just like assertions, our constraints are expressed using ordinary imperative expressions, including full objects and message sends.""
  - ""Unlike assertions, however, the system attempts to satisfy them if they are not currently true, and keeps them satisfied throughout the remaining execution.""
  - ""We provide a semantics that guides implementers of our design to combine Babelsberg with existing object-oriented host languages both semantically and syntactically""
  - ""To allow developers to use the power of constraints without having to understand the specifics of different constraint solving strategies, we integrate an architecture for using multiple cooperating solvers.""",,"- The abstract discusses the use of constraints as a conceptual primitive, allowing developers to specify system properties that are automatically maintained.
 - The design unifies encapsulation and abstraction constructs using object-oriented method definitions, which suggests a primitive related to unified method definitions.
 - Constraints are expressed using imperative expressions, which indicates a primitive related to constraint expression.
 - The system's ability to satisfy constraints not currently true and keep them satisfied suggests a primitive related to constraint satisfaction.
 - The integration of multiple cooperating solvers implies a primitive related to solver architecture.
 - The abstract does not explicitly list these as ""conceptual primitives"" but they are key concepts in the design and implementation of object-constraint programming.","- ""We provide a semantics that guides implementers of our design to combine Babelsberg with existing object-oriented host languages both semantically and syntactically and to demonstrate its feasibility with an executable semantics and three concrete implementations of Babelsberg.""
  - ""We argue that our approach provides a useful step towardmaking constraint solving a useful tool for object-oriented programmers.""",,"- The abstract mentions the provision of a ""semantics"" that guides the implementation of Babelsberg, which suggests a theoretical foundation for the framework.
 - However, there is no explicit mention of a specific mathematical framework such as type theory or category theory.
 - The abstract does not provide details on specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the design and implementation of object-constraint programming rather than on a detailed mathematical framework.","- ""Constraints allow developers to specify properties of systems and have those properties be maintained automatically.""
  - ""Despite these advantages, constraint programming is not yet widespread, with imperative programming still being the norm.""
  - ""There is a long history of research on constraint programming as well as its integration with general purpose programming languages, especially from the imperative paradigm.""
  - ""However, this integration typically does not unify the constructs for encapsulation and abstraction from both paradigms and often leads to a parallel world of constraint code fragments and abstractions intermingled with the general purpose code.""
  - ""In our work, we have developed a design for a family of object-constraint languages called Babelsberg.""
  - ""Our design unifies the constructs for encapsulation and abstraction by using only objectoriented method definitions for both declarative and imperative code.""
  - ""Unlike assertions, however, the system attempts to satisfy them if they are not currently true, and keeps them satisfied throughout the remaining execution.""
  - ""We provide a semantics that guides implementers of our design to combine Babelsberg with existing object-oriented host languages both semantically and syntactically and to demonstrate its feasibility with an executable semantics and three concrete implementations of Babelsberg.""
  - ""To allow developers to use the power of constraints without having to understand the specifics of different constraint solving strategies, we integrate an architecture for using multiple cooperating solvers.""",,"- The abstract discusses the integration of constraint programming with general-purpose programming languages, particularly from the imperative paradigm.
 - It highlights the challenge that current integrations often do not unify encapsulation and abstraction constructs from both paradigms, leading to redundant code.
 - The study proposes a design for object-constraint languages called Babelsberg, which unifies these constructs using object-oriented method definitions for both declarative and imperative code.
 - The integration approach involves using ordinary imperative expressions for constraints, which are then satisfied by the system.
 - The abstract mentions providing a semantics to guide implementers in combining Babelsberg with existing object-oriented languages, indicating a focus on syntactic and semantic integration.
 - The integration of an architecture for multiple cooperating solvers is also mentioned, which allows developers to use constraints without needing to understand specific solving strategies.","- ""Constraints allow developers to specify properties of systems and have those properties be maintained automatically.""
  - ""Constraints thus provide flexibility and expressiveness for solving complex problems and maintaining a desired system state.""
  - ""Our design unifies the constructs for encapsulation and abstraction by using only objectoriented method definitions for both declarative and imperative code.""
  - ""Unlike assertions, however, the system attempts to satisfy them if they are not currently true, and keeps them satisfied throughout the remaining execution.""
  - ""We provide a semantics that guides implementers of our design to combine Babelsberg with existing object-oriented host languages both semantically and syntactically""
  - ""To allow developers to use the power of constraints without having to understand the specifics of different constraint solving strategies, we integrate an architecture for using multiple cooperating solvers.""
  - ""We argue that our approach provides a useful step towardmaking constraint solving a useful tool for object-oriented programmers.""",,"- The abstract discusses the use of constraints to specify properties of systems, which can be seen as a form of abstraction. However, it does not explicitly mention generic programming or genericity.
 - The focus is on integrating constraint programming with object-oriented programming, which involves encapsulation and abstraction, but not specifically generic programming.
 - There is no mention of a definition of ""concept"" used in the context of generic programming.
 - The abstract does not discuss mechanisms for representing generic abstractions or minimal type requirements.
 - There is no mention of static checking or optimization strategies related to generic programming.
 - The abstract primarily focuses on the integration of constraint programming with object-oriented programming, rather than generic programming.","- ""Constraints allow developers to specify properties of systems and have those properties be maintained automatically.""
  - ""Despite these advantages, constraint programming is not yet widespread, with imperative programming still being the norm.""
  - ""However, this integration typically does not unify the constructs for encapsulation and abstraction from both paradigms and often leads to a parallel world of constraint code fragments and abstractions intermingled with the general purpose code.""
  - ""In our work, we have developed a design for a family of object-constraint languages called Babelsberg.""
  - ""Our design unifies the constructs for encapsulation and abstraction by using only objectoriented method definitions for both declarative and imperative code.""
  - ""Unlike assertions, however, the system attempts to satisfy them if they are not currently true, and keeps them satisfied throughout the remaining execution.""
  - ""We provide a semantics that guides implementers of our design to combine Babelsberg with existing object-oriented host languages both semantically and syntactically and to demonstrate its feasibility with an executable semantics and three concrete implementations of Babelsberg.""
  - ""To allow developers to use the power of constraints without having to understand the specifics of different constraint solving strategies, we integrate an architecture for using multiple cooperating solvers.""
  - ""We argue that our approach provides a useful step towardmaking constraint solving a useful tool for object-oriented programmers.""",,"- The abstract discusses the limitations of current constraint programming integration with general-purpose programming languages, highlighting the lack of unification in encapsulation and abstraction constructs.
 - The novel insight is the development of Babelsberg, a family of object-constraint languages that unifies these constructs using object-oriented method definitions for both declarative and imperative code.
 - The theoretical advancement is the integration of constraint programming with object-oriented programming in a way that does not require separate code fragments or abstractions, enhancing reusability and flexibility.
 - The potential implication for programming language design is the provision of a semantics that allows Babelsberg to be combined with existing object-oriented languages, making constraint solving more accessible to object-oriented programmers.
 - The integration of an architecture for using multiple cooperating solvers is another theoretical contribution, as it simplifies the use of constraints without requiring deep understanding of different solving strategies."
Teaching Programming with the Kernel Language Approach,"P. V. Roy, Seif Haridi",-,-,-,4,-,Not specified (the abstract does not explicitly list or define the conceptual primitives),Not specified (the abstract does not provide explicit details on the mathematical framework characteristics),"- Specific integration mechanisms proposed: Translation into kernel languages
 - Interaction models between paradigms: Uniform setting showing deep relationships
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Straightforward translations into kernel languages",Generic programming not extensively addressed,"- Key novel insights: The kernel language approach integrates various programming paradigms into a uniform setting, showing their deep relationships.
 - Theoretical advancements: Kernel languages simplify complex programming languages, providing simple formal semantics for reasoning about correctness and complexity.
 - Potential implications: Enhances teaching programming by integrating both science and technology, potentially improving programming language design.","- ""a new way to teach programming that situates most of the widely-known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) in a uniform setting that shows their deep relationships and how to use them together.""
  - ""Widely-different practical languages (exemplified by Java, Haskell, Prolog, and Erlang) with their rich panoplies of abstractions and syntax are explained by straightforward translations into closely-related kernel languages, simple languages that consist of small numbers of programmer-significant concepts.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""",,"- The abstract discusses the ""kernel language approach"" as a method to teach programming by situating various paradigms in a uniform setting. This suggests that the approach involves breaking down complex programming concepts into simpler, more fundamental elements.
 - The mention of ""kernel languages"" that are ""simple languages that consist of small numbers of programmer-significant concepts"" implies that these kernel languages are composed of basic conceptual primitives. However, the abstract does not explicitly list or define these primitives.
 - The abstract does not provide specific names or definitions for the conceptual primitives, nor does it discuss their orthogonality or level of abstraction in detail.
 - The focus is on the approach and its application rather than the explicit definition of primitives.","- ""The science should be practical, that is, able to explain the technology, making it useful for a practicing programmer.""
  - ""The science consists of a broad and deep theory with predictive power, allowing to understand programming.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""",,"- The abstract mentions that kernel languages have a ""simple formal semantics,"" which suggests a mathematical framework is used to formalize these languages. However, it does not specify the type of mathematical framework (e.g., type theory, category theory).
 - The mention of ""simple formal semantics"" implies that there is some form of mathematical structure, but the abstract does not provide details on the specific mathematical properties guaranteed or the proof techniques used.
 - The abstract discusses the importance of a ""broad and deep theory with predictive power,"" which could imply a theoretical foundation, but again, no specific mathematical framework or properties are detailed.
 - There is no explicit mention of proof methodology, formal verification discussions, or limitations/constraints of the framework in the abstract.","- ""Widely-different practical languages (exemplified by Java, Haskell, Prolog, and Erlang) with their rich panoplies of abstractions and syntax are explained by straightforward translations into closely-related kernel languages, simple languages that consist of small numbers of programmer-significant concepts.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""
  - ""We present the kernel language approach, a new way to teach programming that situates most of the widely-known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) in a uniform setting that shows their deep relationships and how to use them together.""",,"- The abstract describes the ""kernel language approach"" as a method to teach programming that integrates various paradigms (imperative, object-oriented, concurrent, logic, and functional) into a uniform setting. This suggests a theoretical integration strategy where different paradigms are related and used together.
 - The approach involves translating practical languages into ""kernel languages,"" which are simpler and have straightforward formal semantics. This implies a novel translation technique that simplifies complex languages into more understandable forms.
 - The abstract does not explicitly mention specific interaction models between paradigms or constraints/challenges in integration, but it emphasizes the use of kernel languages as a mechanism to integrate different paradigms.
 - The focus on kernel languages and their simple formal semantics suggests a strategy for integrating paradigms by providing a common, simplified framework for understanding and reasoning about different programming languages.","- ""a new way to teach programming that situates most of the widely-known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) in a uniform setting that shows their deep relationships and how to use them together.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""
  - ""Widely-different practical languages (exemplified by Java, Haskell, Prolog, and Erlang) with their rich panoplies of abstractions and syntax are explained by straightforward translations into closely-related kernel languages, simple languages that consist of small numbers of programmer-significant concepts.""",,"- The abstract discusses a ""kernel language approach"" that integrates various programming paradigms into a uniform setting, which suggests a focus on abstraction and genericity.
 - The mention of ""straightforward translations into closely-related kernel languages"" implies a mechanism for representing generic abstractions by simplifying complex languages into simpler, more fundamental concepts.
 - The abstract does not explicitly define ""concept"" or discuss minimal type requirements, static checking, or optimization strategies in detail.
 - The focus on kernel languages and their simplicity suggests an emphasis on conceptual abstraction, but the abstract does not extensively address generic programming methodologies or type system discussions.","- ""We present the kernel language approach, a new way to teach programming that situates most of the widely-known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) in a uniform setting that shows their deep relationships and how to use them together.""
  - ""Widely-different practical languages (exemplified by Java, Haskell, Prolog, and Erlang) with their rich panoplies of abstractions and syntax are explained by straightforward translations into closely-related kernel languages, simple languages that consist of small numbers of programmer-significant concepts.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""
  - ""The approach is the fruit of ten years of research by an international team, the Mozart Consortium.""
  - ""Teaching programming means to teach both the science and the technology.""
  - ""Surprisingly, we find that programming is almost never taught in this way.""",,"- The abstract introduces the ""kernel language approach"" as a novel method for teaching programming, which is a key theoretical contribution. This approach integrates various programming paradigms into a uniform framework, highlighting their interconnections.
 - The use of ""kernel languages"" to explain complex programming languages like Java, Haskell, Prolog, and Erlang is a theoretical advancement. It simplifies the understanding of these languages by translating them into simpler, more manageable forms.
 - The emphasis on kernel languages having ""simple formal semantics"" is significant. This allows programmers to reason about program correctness and complexity more effectively, which is a theoretical contribution to programming language design.
 - The abstract notes that existing approaches to teaching programming often fail to integrate both the science and technology of programming. The kernel language approach addresses this gap by teaching both aspects, which is a theoretical innovation.
 - The mention of the approach being the result of ten years of research by the Mozart Consortium suggests a comprehensive and well-developed theoretical framework."
First-class isomorphic specialization by staged evaluation,"A. Slesarenko, A. Filippov, Alexey Romanov",10.1145/2633628.2633632,https://doi.org/10.1145/2633628.2633632,Workshop on Generic Programming,6,2014,"1. Primitive Name: Staged Evaluation
  Definition: A new method of program staging implemented as zipper-based traversal of program terms.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Generic Programming Techniques
  Definition: Used together with staged evaluation to achieve isomorphic specialization.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Isomorphic Specialization
  Definition: Utilizes first-class definitions of isomorphisms between data types to provide guarantee of abstraction elimination.
  Orthogonality Score: Not specified",Not specified (the abstract does not explicitly mention the type of mathematical framework or specific mathematical properties guaranteed),"- Specific integration mechanisms proposed: Extension of higher-order functional language with abstraction mechanisms, staged evaluation, zipper-based traversal of program terms.
 - Interaction models between paradigms: Generic programming techniques with staged evaluation and isomorphic specialization.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Implementation as a generic programming framework with first-class staging, term rewriting, and isomorphic specialization.","- Definition of ""concept"" used: Not mentioned
 - Mechanisms for representing generic abstractions: Staged evaluation, zipper-based traversal
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: Introduction of staged evaluation as a new method of program staging; integration of generic programming techniques with staged evaluation for isomorphic specialization.
 - Theoretical advancements: Extension of higher-order functional language to eliminate abstraction overhead; formalized framework for first-class specialization capability.
 - Potential implications: New paradigm for developing domain-specific software components without abstraction penalty.","- ""We give a formalized description of the isomorphic specialization algorithm and show how it can be implemented as a set of term rewriting rules using active patterns and staged evaluation.""
  - ""We show how generic programming techniques together with staged evaluation lead to a very simple yet powerful method of isomorphic specialization which utilizes first-class definitions of isomorphisms between data types to provide guarantee of abstraction elimination.""
  - ""We propose staged evaluation as a new method of program staging and show how it can be implemented as zipper-based traversal of program terms where one-hole contexts are generically constructed from the abstract syntax of the language.""
  - ""We show how to extend a higher-order functional language with abstraction mechanisms carefully designed to provide automatic and guaranteed elimination of abstraction overhead.""
  - ""We develop a systematic approach and formalized framework for implementing software components with a first-class specialization capability.""",,"- The abstract discusses several key concepts that are central to the study: ""first-class specialization capability,"" ""staged evaluation,"" ""generic programming techniques,"" and ""isomorphic specialization.""
 - These concepts are described as part of a systematic approach and formalized framework, indicating they are foundational to the methodology proposed by the study.
 - ""Staged evaluation"" is explicitly mentioned as a new method of program staging, suggesting it is a conceptual primitive.
 - ""Generic programming techniques"" and ""isomorphic specialization"" are also highlighted as key components, indicating they are conceptual primitives used to achieve abstraction elimination.
 - The abstract does not provide explicit definitions for these primitives in the traditional sense, but they are described in terms of their functionality and role in the framework.
 - The level of abstraction is high, as these primitives are related to programming language design and software development methodologies.
 - Orthogonality is not explicitly discussed in the abstract, but the combination of these primitives suggests a structured approach to software development.","- ""We propose staged evaluation as a new method of program staging and show how it can be implemented as zipper-based traversal of program terms where one-hole contexts are generically constructed from the abstract syntax of the language.""
  - ""We show how to extend a higher-order functional language with abstraction mechanisms carefully designed to provide automatic and guaranteed elimination of abstraction overhead.""
  - ""We give a formalized description of the isomorphic specialization algorithm and show how it can be implemented as a set of term rewriting rules using active patterns and staged evaluation.""
  - ""We develop a systematic approach and formalized framework for implementing software components with a first-class specialization capability.""",,"- The abstract mentions a ""formalized framework"" and ""formalized description,"" indicating that a mathematical framework is used to formalize the approach.
 - The framework involves extending a ""higher-order functional language,"" which suggests a connection to type theory, as higher-order functions are a key component of type theory.
 - The use of ""staged evaluation"" and ""term rewriting rules"" implies a focus on formal verification techniques, possibly related to proof theory or category theory.
 - The abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no explicit mention of proof techniques or limitations/constraints of the framework in the abstract.","- ""We develop a systematic approach and formalized framework for implementing software components with a first-class specialization capability.""
  - ""We show how to extend a higher-order functional language with abstraction mechanisms carefully designed to provide automatic and guaranteed elimination of abstraction overhead.""
  - ""We propose staged evaluation as a new method of program staging and show how it can be implemented as zipper-based traversal of program terms where one-hole contexts are generically constructed from the abstract syntax of the language.""
  - ""We show how generic programming techniques together with staged evaluation lead to a very simple yet powerful method of isomorphic specialization which utilizes first-class definitions of isomorphisms between data types to provide guarantee of abstraction elimination.""
  - ""We give a formalized description of the isomorphic specialization algorithm and show how it can be implemented as a set of term rewriting rules using active patterns and staged evaluation.""
  - ""We implemented our approach as a generic programming framework with first-class staging, term rewriting and isomorphic specialization and show in our evaluation that the proposed capabilities give rise to a new paradigm to develop domain-specific software components without abstraction penalty.""",,"- The abstract discusses the development of a systematic approach and formalized framework for implementing software components with first-class specialization capability. This suggests an integration of different programming paradigms, specifically focusing on functional programming and generic programming.
 - The extension of a higher-order functional language with abstraction mechanisms indicates an integration of functional programming with other paradigms to reduce abstraction overhead.
 - The use of staged evaluation and zipper-based traversal of program terms suggests a novel technique for integrating different programming paradigms by managing abstraction overhead.
 - The mention of generic programming techniques and isomorphic specialization implies an interaction model between paradigms, where these techniques are used to ensure abstraction elimination.
 - The implementation of the approach as a generic programming framework with first-class staging, term rewriting, and isomorphic specialization indicates a novel translation or embedding technique for integrating paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the achievement of developing domain-specific software components without abstraction penalty, which implies overcoming potential challenges.","- ""We develop a systematic approach and formalized framework for implementing software components with a first-class specialization capability.""
  - ""We show how to extend a higher-order functional language with abstraction mechanisms carefully designed to provide automatic and guaranteed elimination of abstraction overhead.""
  - ""We propose staged evaluation as a new method of program staging and show how it can be implemented as zipper-based traversal of program terms where one-hole contexts are generically constructed from the abstract syntax of the language.""
  - ""We show how generic programming techniques together with staged evaluation lead to a very simple yet powerful method of isomorphic specialization which utilizes first-class definitions of isomorphisms between data types to provide guarantee of abstraction elimination.""
  - ""We give a formalized description of the isomorphic specialization algorithm and show how it can be implemented as a set of term rewriting rules using active patterns and staged evaluation.""
  - ""We implemented our approach as a generic programming framework with first-class staging, term rewriting and isomorphic specialization and show in our evaluation that the proposed capabilities give rise to a new paradigm to develop domain-specific software components without abstraction penalty.""",,"- The abstract discusses the development of a systematic approach and formalized framework for implementing software components with first-class specialization, which implies a focus on generic programming.
 - The mention of extending a higher-order functional language with abstraction mechanisms suggests a focus on abstraction mechanisms.
 - The use of staged evaluation and zipper-based traversal indicates a method for representing generic abstractions.
 - The abstract mentions generic programming techniques leading to isomorphic specialization, which implies a focus on genericity.
 - The implementation of a generic programming framework with first-class staging, term rewriting, and isomorphic specialization further supports the focus on generic programming.
 - However, the abstract does not explicitly define the concept of ""concept"" used, nor does it specify minimal type requirements or static checking or optimization strategies.","- ""We develop a systematic approach and formalized framework for implementing software components with a first-class specialization capability.""
  - ""We show how to extend a higher-order functional language with abstraction mechanisms carefully designed to provide automatic and guaranteed elimination of abstraction overhead.""
  - ""We propose staged evaluation as a new method of program staging and show how it can be implemented as zipper-based traversal of program terms where one-hole contexts are generically constructed from the abstract syntax of the language.""
  - ""We show how generic programming techniques together with staged evaluation lead to a very simple yet powerful method of isomorphic specialization which utilizes first-class definitions of isomorphisms between data types to provide guarantee of abstraction elimination.""
  - ""We give a formalized description of the isomorphic specialization algorithm and show how it can be implemented as a set of term rewriting rules using active patterns and staged evaluation.""
  - ""We implemented our approach as a generic programming framework with first-class staging, term rewriting and isomorphic specialization and show in our evaluation that the proposed capabilities give rise to a new paradigm to develop domain-specific software components without abstraction penalty.""",,"- The abstract introduces a ""systematic approach and formalized framework"" for implementing software components with ""first-class specialization capability,"" which suggests a novel theoretical contribution by providing a structured method for achieving specialization.
 - The extension of a higher-order functional language to eliminate abstraction overhead is a theoretical advancement, as it addresses a common issue in software development where abstraction mechanisms can lead to performance degradation.
 - The proposal of ""staged evaluation"" as a new method of program staging is a key novel insight, as it offers a fresh approach to managing program complexity.
 - The integration of generic programming techniques with staged evaluation to achieve isomorphic specialization is a theoretical advancement, as it provides a powerful method for eliminating abstraction overhead.
 - The formalized description of the isomorphic specialization algorithm and its implementation using term rewriting rules is a theoretical contribution, as it provides a detailed framework for achieving abstraction elimination.
 - The potential implications for programming language design are significant, as the approach allows for the development of domain-specific software components without the typical abstraction penalty, suggesting a new paradigm in software development."
Reactive Programming without Functions,"Bjarno Oeyen, Joeri De Koster, W. Meuter",10.22152/programming-journal.org/2024/8/11,https://doi.org/10.22152/programming-journal.org/2024/8/11,"The Art, Science, and Engineering of Programming",1,2024,"1. Primitive Name: Reactors
  Definition: The basic abstraction type for expressing reactive computations.
  Orthogonality Score: High (central to the language model)
 

 2. Primitive Name: Trampoline Variables
  Definition: Mechanism for deployments to accumulate state.
  Orthogonality Score: Medium (specific to state management)
 

 3. Primitive Name: Conditional Signals
  Definition: Signals whose value is determined by a specified condition.
  Orthogonality Score: Medium (specific to dynamic dependencies)
 

 4. Primitive Name: First-Class Reactors
  Definition: Reactors can be emitted by signals, enabling dynamic deployments.
  Orthogonality Score: High (enables flexibility in programming)
 

 5. Primitive Name: Anonymous Reactors
  Definition: Lexically scoped reactors for abstraction and encapsulation.
  Orthogonality Score: High (supports modular programming)",Not specified (the paper does not explicitly mention a mathematical framework for formalizing and guaranteeing properties),No specific integration approach described,Generic programming not extensively addressed,"- Novelty: Haai is a purely reactive programming language that eliminates the need for functions and lifting, avoiding the Reactive/Imperative Impedance mismatch.
 - Theoretical Contribution: Introduction of a Uniform Reactor Model inspired by the Uniform Object Model, stateful reactors, and conditional signals that maintain strong reactivity.
 - Implications: Potential for more responsive and predictable reactive systems by avoiding issues associated with lifting and impedance mismatch.","- ""The basic abstraction type of the language, which we call a reactor, serves as the sole construct for expressing (reactive) computations.""
  - ""The language does not have the notion of functions, and thus unlike other RP languages there is no lifting either.""
  - ""The computational model of our language can be summarised as follows: reactors will, when instantiated, create the time-varying signals that make up the reactive program.""
  - ""In Haai, deployments are able to accumulate state by means of so-called trampoline variables -or trampolines for short.""
  - ""conditional signals are signals whose value is determined in relation to a specified condition.""
  - ""We now make reactors in Haai first-class values: i.e. they can now be emitted by signals.""
  - ""Anonymous reactors in Haai are lexically scoped.""
  - ""The Haai Language does not feature functions, only reactors.""",,"- The paper introduces ""reactors"" as the fundamental conceptual primitive for expressing reactive computations. This is a key abstraction in the language.
 - The absence of functions and lifting is highlighted, indicating that reactors are the primary mechanism for computation.
 - The concept of ""trampoline variables"" is introduced as a way for deployments to accumulate state, which is a primitive related to state management.
 - Conditional signals are defined as a primitive for handling dynamic dependencies based on conditions.
 - The concept of reactors being first-class values allows for dynamic deployments, which is another primitive related to flexibility in programming.
 - Anonymous reactors are introduced with lexical scoping, which is a primitive related to abstraction and encapsulation.","- ""While a formal calculus that captures the essence of RP is not part of this paper, we will discuss the fundamental aspects of what makes a reactive language reactive in terms of our actual language.""
  - ""We base our arguments by analysing the effect that each feature has on our language: e.g., by analysing how signals are updated, how they are created and how dependencies between signals can be affected.""
  - ""We now present Haai, a pure reactive programming language that has been designed from first principles.""
  - ""The basis of Haai is -as we will discuss in Section 2.7 -strongly reactive.""
  - ""An overview of features with their classification is shown near the end of this paper (Table 1""
  - ""The Haai Language does not feature functions, only reactors.""
  - ""The Haai language has a prototypical implementation developed in Racket [16]""","- ""(Page 19, Table 1) | Type of Reactors | Reactivity Level  |
 \n|-----------------------------------------|--------------------------|
 \n| First-Order Reactors (Section 2) | Eventual or Strong* |""","- The paper does not explicitly mention a specific mathematical framework such as type theory or category theory.
 - It discusses the design principles and features of the Haai language but does not delve into a formal mathematical framework for guaranteeing properties.
 - The paper focuses on the conceptual and practical aspects of the language rather than a theoretical mathematical framework.
 - The mention of a ""formal calculus"" suggests that such a framework might be considered in future work, but it is not part of this paper.
 - The paper provides an overview of features and their reactivity levels, but this is not a formal mathematical framework.","- ""In our description of these language features, we not only describe the syntax and semantics, but also how each features compares to the problems that exist in (EDSL) RP languages.""
  - ""By considering a pure (reactive-only) reactive language, we avoid the adverse consequences caused by the Reactive/Imperative Impedance mismatch.""
  - ""The Haai Language does not feature functions, only reactors.""
  - ""The main idea here is that future language implementations can provide domain-specific operators: e.g., a variation of Haai for embedded devices can provide specialised operators for the various sensors and actuators in a physical device""
  - ""The Haai language has a prototypical implementation developed in Racket""
  - ""The Haai Language does not feature functions, only reactors. This raises the question whether or not this limits expressivity.""",,"- The paper discusses the integration of reactive programming paradigms by proposing a new language, Haai, which is purely reactive and does not integrate with non-reactive paradigms. This is a significant departure from existing two-layered RP languages that integrate reactive and non-reactive code.
 - The approach avoids the Reactive/Imperative Impedance mismatch by not including functions and lifting, which are common in other RP languages that integrate with host languages.
 - The language is designed to be reactive-only, which means it does not embed or translate between different paradigms but rather focuses on a single paradigm to avoid integration issues.
 - The paper mentions the potential for domain-specific operators in future implementations, suggesting a modular approach to extending the language for specific applications without integrating different paradigms.
 - The prototypical implementation in Racket indicates a focus on developing a standalone reactive language rather than integrating with other paradigms.","- ""We propose a new reactive programming language, that has been meticulously designed to be reactive-only.""
  - ""The language does not have the notion of functions, and thus unlike other RP languages there is no lifting either.""
  - ""The basic abstraction type of the language, which we call a reactor, serves as the sole construct for expressing (reactive) computations.""
  - ""Reactors in Haai can have more than one sink signal.""
  - ""In Haai, deployments are able to accumulate state by means of so-called trampoline variables -or trampolines for short.""
  - ""Conditional signals and dynamic deployments result in a language that is still strongly reactive.""
  - ""We now make reactors in Haai first-class values: i.e. they can now be emitted by signals.""
  - ""Anonymous reactors in Haai are lexically scoped.""
  - ""Deployed captures are like ordinary reactors, except that they have additional signals in scope (i.e. captured signals).""","- ""(Page 6, Table 1) | Non-terminal  | Production  |
 \n|----------------------------|----------------------------------------------------------------------------|
 \n| ⟨program⟩  | ⟶ ⟨definition⟩* |""
  - ""(Page 19, Table 1) | Type of Reactors | Reactivity Level  |
 \n|-----------------------------------------|--------------------------|
 \n| First-Order Reactors (Section 2) | Eventual or Strong* |""","- The paper introduces a reactive programming language called Haai, which is designed to be reactive-only, indicating a focus on reactive programming rather than generic programming.
 - The language uses reactors as the basic abstraction type, which are used to express reactive computations. This suggests a focus on reactive abstractions rather than generic programming.
 - The paper discusses various features such as stateful reactors, conditional signals, and anonymous reactors, which are related to reactive programming rather than generic programming.
 - The tables provided at the end of the paper focus on the syntax and reactivity guarantees of Haai, rather than generic programming or type systems.
 - There is no explicit mention of generic programming methodology, type systems, or minimal type requirements in the paper.","- ""Our language shows how a purely reactive programming is able to express the same kinds of programs as in other RP languages that require the use of (unchecked) functions.""
  - ""By considering reactive programs as a collection of pure (reactive-only) reactors, we aim to increase how reactive programming is comprehended by both language designers and its users.""
  - ""By considering a pure (reactive-only) reactive language, we avoid the adverse consequences caused by the Reactive/Imperative Impedance mismatch.""
  - ""This makes stateful reactors in Haai a strongly reactive feature.""
  - ""Conditional signals and dynamic deployments result in a language that is still strongly reactive.""
  - ""The Haai Language does not feature functions, only reactors. This raises the question whether or not this limits expressivity.""
  - ""we claim that there is no fundamental restriction with regards to expressivity.""
  - ""The Haai language has a prototypical implementation developed in Racket""
  - ""This paper presented Haai, a reactive programming language designed from first principles.""
  - ""Inspired by Self and Smalltalk's Uniform Object Model, Haai employs a Uniform Reactor Model where programs are composed of reactors and every runtime value is passed over signals spawned by deploying these reactors.""","- ""(Page 19, Table 1) | Type of Reactors | Reactivity Level  |
 \n|-----------------------------------------|--------------------------|
 \n| First-Order Reactors (Section 2) | Eventual or Strong* |""","- The paper introduces a novel reactive programming language, Haai, which is designed from first principles to be purely reactive, eliminating the need for functions and lifting.
 - Haai's design avoids the Reactive/Imperative Impedance mismatch by ensuring that reactive code and non-reactive code are never combined, which is a significant theoretical contribution.
 - The language features a Uniform Reactor Model, inspired by the Uniform Object Model of Self and Smalltalk, which simplifies the design and understanding of reactive programming.
 - The paper demonstrates that Haai can express the same kinds of programs as other RP languages without using functions, which is a key novel insight.
 - Theoretical advancements include the introduction of stateful reactors and conditional signals that maintain strong reactivity, which are unique contributions to the field.
 - The potential implications for programming language design include the possibility of creating more responsive and predictable reactive systems by avoiding the issues associated with lifting and impedance mismatch."
Multi-paradigm Logic Programming Integrating Paradigms via Interaction Nets (extended Abstract),"M. Fernández, I. Mackie",-,-,-,0,2007,"1. Primitive Name: Interaction Nets
  Definition: A very simple kind of rewrite system based on rewriting of networks with a linear logic foundation.
  Orthogonality Score: Not specified","- Type of mathematical framework: Linear logic
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Lafont's interaction nets as a unifying framework
 - Interaction models between paradigms: Interaction nets provide a uniform implementation and semantic framework
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Key novel insights: Integration of programming paradigms using interaction nets as a unifying framework.
 - Theoretical advancements: Linear logic foundation providing a refined view of computation; uniform implementation and semantic framework for combined lambda-calculus and term rewriting systems.
 - Potential implications: Extension to other programming paradigms for future programming language design.","- ""Interaction nets are a very simple kind of rewrite system based on rewriting of networks.""
  - ""In this paper we begin a study of the integration of programming paradigms using Lafont's interaction nets as a unifying framework.""
  - ""We show that interaction nets give a uniform implementation and semantic framework for this kind of language, which we hope to extend also to other programming paradigms.""
  - ""Here we study the implementation of languages based on combinations of the-calculus and term rewriting systems.""
  - ""Because of their linear logic foundation they give a reened view of computation; they have been used for the implementation of programming languages based on the-calculus, and recently for the implementation of term rewriting systems.""",,"- The abstract discusses the use of ""Lafont's interaction nets"" as a unifying framework for integrating programming paradigms. This suggests that interaction nets are a key conceptual primitive in the study.
 - Interaction nets are described as a ""very simple kind of rewrite system based on rewriting of networks,"" which provides a definition of this primitive.
 - The abstract mentions that interaction nets have a ""linear logic foundation,"" which further defines their nature and role in computation.
 - The study focuses on implementing languages based on combinations of the-calculus and term rewriting systems using interaction nets, indicating that these are also conceptual primitives being integrated.
 - The abstract does not provide explicit names or definitions for specific conceptual primitives beyond interaction nets and their application to the-calculus and term rewriting systems.
 - There is no mention of orthogonality scores or levels of abstraction for these primitives in the abstract.","- ""Because of their linear logic foundation they give a reened view of computation; they have been used for the implementation of programming languages based on the-calculus, and recently for the implementation of term rewriting systems.""
  - ""In this paper we begin a study of the integration of programming paradigms using Lafont's interaction nets as a unifying framework.""
  - ""We show that interaction nets give a uniform implementation and semantic framework for this kind of language, which we hope to extend also to other programming paradigms.""
  - ""Interaction nets are a very simple kind of rewrite system based on rewriting of networks.""",,"- The abstract mentions ""Lafont's interaction nets"" as the unifying framework, which suggests a specific mathematical framework.
 - Interaction nets are described as a ""rewrite system based on rewriting of networks,"" indicating a focus on rewriting rules.
 - The mention of ""linear logic foundation"" suggests that the mathematical framework is rooted in linear logic, which is a type of mathematical framework.
 - The abstract does not explicitly mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus on interaction nets and linear logic provides some insight into the type of mathematical framework, but other details such as specific properties or proof techniques are not specified.","- ""In this paper we begin a study of the integration of programming paradigms using Lafont's interaction nets as a unifying framework.""
  - ""We show that interaction nets give a uniform implementation and semantic framework for this kind of language, which we hope to extend also to other programming paradigms.""
  - ""Interaction nets are a very simple kind of rewrite system based on rewriting of networks.""
  - ""Because of their linear logic foundation they give a reened view of computation; they have been used for the implementation of programming languages based on the-calculus, and recently for the implementation of term rewriting systems.""
  - ""Here we study the implementation of languages based on combinations of the-calculus and term rewriting systems.""",,"- The abstract mentions the use of ""Lafont's interaction nets as a unifying framework"" for integrating programming paradigms, indicating that interaction nets are the primary mechanism for integration.
 - Interaction nets are described as a ""very simple kind of rewrite system based on rewriting of networks,"" suggesting that they provide a theoretical framework for integrating different paradigms by rewriting networks.
 - The abstract notes that interaction nets have been used for implementing languages based on the-calculus and term rewriting systems, indicating that these are specific paradigms being integrated.
 - The study aims to provide a ""uniform implementation and semantic framework"" for languages combining these paradigms, suggesting that interaction nets serve as a common ground for integrating different programming paradigms.
 - There is no mention of specific constraints or challenges in paradigm integration, nor are there any novel translation or embedding techniques explicitly discussed in the abstract.","- ""In this paper we begin a study of the integration of programming paradigms using Lafont's interaction nets as a unifying framework.""
  - ""We show that interaction nets give a uniform implementation and semantic framework for this kind of language, which we hope to extend also to other programming paradigms.""
  - ""Because of their linear logic foundation they give a reened view of computation; they have been used for the implementation of programming languages based on the-calculus, and recently for the implementation of term rewriting systems.""
  - ""Here we study the implementation of languages based on combinations of the-calculus and term rewriting systems.""
  - ""Interaction nets are a very simple kind of rewrite system based on rewriting of networks.""",,"- The abstract discusses the integration of programming paradigms using interaction nets, which suggests a focus on combining different programming approaches rather than generic programming or abstraction mechanisms.
 - There is no mention of generic programming methodology, type systems, or abstraction mechanisms in the abstract.
 - The focus is on the use of interaction nets as a unifying framework for different programming paradigms, not on genericity or abstraction.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.","- ""In this paper we begin a study of the integration of programming paradigms using Lafont's interaction nets as a unifying framework.""
  - ""We show that interaction nets give a uniform implementation and semantic framework for this kind of language, which we hope to extend also to other programming paradigms.""
  - ""Interaction nets are a very simple kind of rewrite system based on rewriting of networks.""
  - ""Because of their linear logic foundation they give a reened view of computation; they have been used for the implementation of programming languages based on the-calculus, and recently for the implementation of term rewriting systems.""
  - ""Here we study the implementation of languages based on combinations of the-calculus and term rewriting systems.""",,"- The abstract introduces the use of interaction nets as a unifying framework for integrating programming paradigms, which is a novel approach.
 - It highlights the linear logic foundation of interaction nets, providing a refined view of computation, which is a theoretical advancement.
 - The study focuses on implementing languages that combine lambda-calculus and term rewriting systems, which is a new integration not previously explored in this context.
 - The abstract mentions that interaction nets provide a uniform implementation and semantic framework for these combined languages, which is a theoretical contribution.
 - The potential for extending this framework to other programming paradigms suggests future implications for programming language design."
New directions in logic programming,K. Bowen,10.1145/324634.325181,https://doi.org/10.1145/324634.325181,International Conference on Scientific Computing,3,1986,"Not specified (the abstract does not explicitly define conceptual primitives, but it describes elements of the logic programming paradigm and its extensions)",Not specified (the abstract does not provide specific details about the mathematical framework characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Extension of Prolog's capabilities through concurrency, functional programming, and metalevel reasoning.
 - Theoretical advancements: Introduction of new syntactic constructs in Concurrent Prolog (commit operator and read-only variable annotation) to exploit parallelism.
 - Potential implications: Enhancements in programming language design through the integration of concurrency and functional programming capabilities.","- ""The logic programming enterprise seeks to utilize formal logical systems as languages for controlling computers.""
  - ""The basic methodology lies in the adaptat ion of theorem-provers for logical systems to create abstract machines which ""execute"" formulas of the logical system.""
  - ""Concurrent Prolog introduces two new syntactic constructs to ordinary Prolog: the commit operator (I) and the read-only variable annotation""
  - ""The commit operator appears in the bodies of clauses, either explicitly or implicitly immediately following the clause arrow""
  - ""Such clauses have the form A : G 1 ..... G k [ B 1 ..... B n. and are called guarded clauses.""
  - ""The portion (A) to the left of the arrow ( : ) is called the head, the portion (G1,...,Gk) between the arrow and the commit operator ([) is called the guard, and the portion (B1,...,Bn) to the right of the commit""",,"- The abstract discusses the logic programming paradigm and its extension through Prolog, focusing on concurrency and other enhancements.
 - The ""logic programming enterprise"" is described as using formal logical systems to control computers, which implies a theoretical framework based on logical systems.
 - The methodology involves adapting theorem-provers to create abstract machines that execute logical formulas, which is a conceptual primitive in the logic programming paradigm.
 - Concurrent Prolog introduces specific syntactic constructs: the commit operator (I) and the read-only variable annotation (?), which are conceptual primitives for concurrency.
 - The commit operator and guarded clauses are defined with specific roles (head, guard, and body), indicating a structured approach to concurrency.
 - The abstract does not explicitly mention ""conceptual primitives"" or provide a list of primitives, but it describes key elements of the logic programming paradigm and its extensions.","- ""The survey is in no way intended to be complete, nor does the choice of projects described imply a value judgment vis-a-vie those projects not described.""
  - ""The basic methodology lies in the adaptat ion of theorem-provers for logical systems to create abstract machines which ""execute"" formulas of the logical system.""
  - ""The logic programming enterprise seeks to utilize formal logical systems as languages for controlling computers.""
  - ""Prolog is a highly successful example of this approach.""",,"- The abstract mentions the use of ""formal logical systems"" as a basis for logic programming, which suggests a mathematical framework.
 - The adaptation of ""theorem-provers for logical systems"" implies a theoretical foundation in logic.
 - The creation of ""abstract machines which 'execute' formulas of the logical system"" suggests a formal verification process.
 - However, the abstract does not specify the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no mention of specific proof techniques or limitations of the framework.
 - The abstract does not provide detailed information about the mathematical framework characteristics.","- ""The survey is in no way intended to be complete, nor does the choice of projects described imply a value judgment vis-a-vie those projects not described.""
  - ""The discussion is simply intended to present a flavor of some of the new directions in Prolog research.""
  - ""These investigations include incorporation of concurrency constructs and distributed execution, functional programming constructs, and metalevel reasoning constructs, including control.""
  - ""These include treatment of concurrency, inclusion of functional programming capabilities, and incorporation of metalevel reasoning techniques.""
  - ""Today there are a number of vigorous research streams exploring methods of extending the capabilities and capacities achieved by Prolog.""",,"- The abstract mentions the integration of different programming paradigms by extending Prolog's capabilities, specifically through the inclusion of concurrency, functional programming, and metalevel reasoning techniques.
 - The abstract does not provide specific integration mechanisms or detailed interaction models between these paradigms.
 - There is no mention of constraints or challenges in paradigm integration or any novel translation or embedding techniques.
 - The abstract is more focused on surveying new directions in Prolog research rather than detailing a specific integration approach.","- ""The logic programming enterprise seeks to utilize formal logical systems as languages for controlling computers.""
  - ""These investigations include incorporation of concurrency constructs and distributed execution, functional programming constructs, and metalevel reasoning constructs, including control.""
  - ""The survey is in no way intended to be complete, nor does the choice of projects described imply a value judgment vis-a-vie those projects not described.""
  - ""The basic methodology lies in the adaptat ion of theorem-provers for logical systems to create abstract machines which ""execute"" formulas of the logical system.""",,"- The abstract discusses the logic programming paradigm and its extensions, focusing on concurrency, functional programming, and metalevel reasoning.
 - There is no mention of generic programming or abstraction mechanisms in the abstract.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The focus is on exploring new directions in Prolog research, particularly in concurrency and other areas, but not on generic programming.","- ""Prolog has established itself as a highly successful example of the logic programming paradigm.""
  - ""Today there are a number of vigorous research streams exploring methods of extending the capabilities and capacities achieved by Prolog.""
  - ""These include treatment of concurrency, inclusion of functional programming capabilities, and incorporation of metalevel reasoning techniques.""
  - ""The paper will survey the goals and current state of these explorations.""
  - ""The logic programming enterprise seeks to utilize formal logical systems as languages for controlling computers.""
  - ""These investigations include incorporation of concurrency constructs and distributed execution, functional programming constructs, and metalevel reasoning constructs, including control.""
  - ""The survey is in no way intended to be complete, nor does the choice of projects described imply a value judgment vis-a-vie those projects not described.""
  - ""The discussion is simply intended to present a flavor of some of the new directions in Prolog research.""
  - ""Major work in this area began with the development of systems leading to PARLOG by Clark and Gregory ([19811, [1984a1, [1984b1, [19847]) at Imperial College in London, and (concurrently) the development of Concurrent Prolog and its descendents by Shapiro [1983] and his students at the Weizmann Institute in Rehovot, Israel.""
  - ""All of the efforts are motivated by a desire to exploit the inherent AND-parallelism and OR-parallelism of logic programming languages.""
  - ""Concurrent Prolog introduces two new syntactic constructs to ordinary Prolog: the commit operator (I) and the read-only variable annotation""",,"- The abstract discusses the extension of Prolog's capabilities, which suggests a focus on theoretical advancements beyond existing approaches.
 - The mention of ""treatment of concurrency, inclusion of functional programming capabilities, and incorporation of metalevel reasoning techniques"" indicates novel insights into how these areas can enhance logic programming.
 - The abstract highlights the development of systems like PARLOG and Concurrent Prolog, which are motivated by exploiting parallelism in logic programming languages. This suggests a theoretical contribution in terms of concurrency.
 - The introduction of new syntactic constructs in Concurrent Prolog, such as the commit operator and read-only variable annotation, represents a theoretical advancement in programming language design.
 - The abstract does not provide specific details on the implications for programming language design, but the focus on extending Prolog's capabilities implies potential for broader theoretical contributions."
Design and implementation of static analyses for higher-order languages,Ilya Sergey,-,-,-,0,2015,"1. Primitive Name: Monads
  Definition: Used to abstract over computational effects in static analysis
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Logic Formalism
  Definition: Includes expressiveness, structure, compositionality, and foundational aspects for concurrent program verification
  Orthogonality Score: Not discussed","- Type of mathematical framework: Category theory (monads from functional programming)
 - Specific mathematical properties guaranteed: Unification of implementation methodologies for static analyzers
 - Proof techniques used: Syntax-oriented inference rules
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Use of monads from functional programming to abstract over computational effects.
 - Interaction models between paradigms: Logic-based approach to concurrent program verification that accommodates modern programming paradigms.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"" used: Not explicitly mentioned
 - Mechanisms for representing generic abstractions: Use of monads from functional programming
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: Abstract interpretation as a particular case of computational effects using monads; novel cardinality analysis for Haskell.
 - Theoretical advancements: Unifying implementation methodology for static analyzers using monads; sound and efficient solution to a long-standing problem in lazy functional programming languages.
 - Potential implications for programming language design: Structured, compositional, and foundational framework for concurrent program verification; accommodation of modern programming paradigms.","- ""This idea was presented in my work on monadic abstract interpreters [14] that described a unifying implementation methodology for static analyzers, which allows one, by changing a representation monad, to recover a spectrum of analyses.""
  - ""This insight provided a way of extracting the common patterns in the design and implementation of static analyzers and led to the idea of considering abstract interpretation as a particular case of computational effects, which can be abstracted over using a concept of monads from functional programming.""
  - ""A well-designed logic formalism is: • Expressive: Program specifications and their proofs can accommodate modern programming paradigms, such as higher-order code, locally-created threads, etc. • Structured: A proof of a program’s correctness can be carried out mechanically, basing on the program’s syntax, via a number of syntax-oriented inference rules, provided by the logical framework. • Compositional: Once a library is given a suitable specification and verified against it, its code is not required to be re-examined ever again: all reasoning about the client code that makes use of that library can be done solely using the specification. • Foundational: A program logic can be efficiently embedded into a general-purpose mechanized mathematical framework.""
  - ""Logic-based approach to concurrent program verification Program logics are an appealing way to specify the behaviour of concurrent programs as well as to verify that a program is correct (i.e., obeys its specification).""
  - ""The developed analyzer has been included into GHC since version 7.8.""",,"- The abstract discusses the use of ""monads from functional programming"" as a conceptual primitive for abstracting over computational effects in static analysis. This suggests that monads are a key primitive in the study.
 - The mention of ""monadic abstract interpreters"" indicates that monads are used as a unifying methodology for static analyzers, which implies they are a fundamental primitive in the study's framework.
 - The abstract also discusses a ""logic-based approach to concurrent program verification,"" which includes characteristics such as expressiveness, structure, compositionality, and foundational aspects. These could be considered conceptual primitives for reconstructing programming paradigms related to concurrent program verification.
 - The abstract does not provide explicit definitions for these primitives beyond their roles in the methodology and framework, nor does it discuss their orthogonality.","- ""This insight provided a way of extracting the common patterns in the design and implementation of static analyzers and led to the idea of considering abstract interpretation as a particular case of computational effects, which can be abstracted over using a concept of monads from functional programming.""
  - ""A well-designed logic formalism is: • Expressive: Program specifications and their proofs can accommodate modern programming paradigms, such as higher-order code, locally-created threads, etc. • Structured: A proof of a program’s correctness can be carried out mechanically, basing on the program’s syntax, via a number of syntax-oriented inference rules, provided by the logical framework. • Compositional: Once a library is given a suitable specification and verified against it, its code is not required to be re-examined ever again: all reasoning about the client code that makes use of that library can be done solely using the specification. • Foundational: A program logic can be efficiently embedded into a general-purpose mechanized mathematical framework.""
  - ""Furthermore, the framework hosting the logic can be employed to write programs and verify them, therefore conflating programming and proving.""
  - ""Logic-based approach to concurrent program verification Program logics are an appealing way to specify the behaviour of concurrent programs as well as to verify that a program is correct (i.e., obeys its specification).""
  - ""This idea was presented in my work on monadic abstract interpreters [14] that described a unifying implementation methodology for static analyzers, which allows one, by changing a representation monad, to recover a spectrum of analyses.""",,"- The abstract mentions the use of ""monads from functional programming"" as a concept to abstract over computational effects, which suggests a type of mathematical framework related to functional programming and category theory.
 - The mention of ""monadic abstract interpreters"" indicates a specific mathematical property guaranteed by this framework, which is the ability to unify implementation methodologies for static analyzers.
 - The abstract discusses a ""logic-based approach to concurrent program verification,"" which implies a formal verification framework that is expressive, structured, compositional, and foundational.
 - The framework is described as being able to embed program logics into a ""general-purpose mechanized mathematical framework,"" which suggests a type of mathematical framework that supports formal verification and proof techniques.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or limitations of the framework beyond its characteristics as being expressive, structured, compositional, and foundational.","- ""A well-designed logic formalism is: • Expressive: Program specifications and their proofs can accommodate modern programming paradigms, such as higher-order code, locally-created threads, etc.""
  - ""Logic-based approach to concurrent program verification Program logics are an appealing way to specify the behaviour of concurrent programs as well as to verify that a program is correct (i.e., obeys its specification).""
  - ""The scalability has been a guiding principle in my work on designing a novel cardinality analysis for Haskell programming language [13], which provided a practically satisfactory solution to a 25-years old problem of soundly and efficiently identifying and exploiting program parts that are used only once in lazy functional programming languages.""
  - ""Modular, higher-order cardinality analysis.""
  - ""This insight provided a way of extracting the common patterns in the design and implementation of static analyzers and led to the idea of considering abstract interpretation as a particular case of computational effects, which can be abstracted over using a concept of monads from functional programming.""",,"- The abstract discusses the use of monads from functional programming to abstract over computational effects, which suggests a mechanism for integrating different programming paradigms by leveraging functional programming concepts.
 - The mention of ""modular, higher-order cardinality analysis"" implies a focus on integrating higher-order programming paradigms, particularly in the context of Haskell.
 - The abstract highlights the scalability and efficiency of the cardinality analysis in Haskell, indicating a practical integration of functional programming paradigms.
 - The logic-based approach to concurrent program verification suggests an interaction model where program specifications and proofs can accommodate modern programming paradigms, including higher-order code and concurrent programming.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, or constraints beyond the use of monads and logic formalisms.","- ""This insight provided a way of extracting the common patterns in the design and implementation of static analyzers and led to the idea of considering abstract interpretation as a particular case of computational effects, which can be abstracted over using a concept of monads from functional programming.""
  - ""This idea was presented in my work on monadic abstract interpreters [14] that described a unifying implementation methodology for static analyzers, which allows one, by changing a representation monad, to recover a spectrum of analyses.""
  - ""The developed analyzer has been included into GHC since version 7.8.""",,"- The abstract discusses the use of monads from functional programming to abstract over computational effects, which is a mechanism for representing generic abstractions. This suggests a focus on generic programming through the use of monads.
 - The mention of ""monadic abstract interpreters"" indicates a methodology for static analyzers that can be generalized across different analyses by changing the representation monad. This implies a mechanism for representing generic abstractions.
 - The abstract does not explicitly define a ""concept"" used in the context of generic programming, nor does it mention minimal type requirements or specific static checking or optimization strategies related to generic programming.
 - The focus on monads and their application in abstract interpretation suggests a conceptual abstraction mechanism, but the abstract does not provide detailed discussions on type systems or minimal type requirements.","- ""This insight provided a way of extracting the common patterns in the design and implementation of static analyzers and led to the idea of considering abstract interpretation as a particular case of computational effects, which can be abstracted over using a concept of monads from functional programming.""
  - ""This idea was presented in my work on monadic abstract interpreters [14] that described a unifying implementation methodology for static analyzers, which allows one, by changing a representation monad, to recover a spectrum of analyses.""
  - ""The scalability has been a guiding principle in my work on designing a novel cardinality analysis for Haskell programming language [13], which provided a practically satisfactory solution to a 25-years old problem of soundly and efficiently identifying and exploiting program parts that are used only once in lazy functional programming languages.""
  - ""A well-designed logic formalism is: • Expressive: Program specifications and their proofs can accommodate modern programming paradigms, such as higher-order code, locally-created threads, etc. • Structured: A proof of a program’s correctness can be carried out mechanically, basing on the program’s syntax, via a number of syntax-oriented inference rules, provided by the logical framework. • Compositional: Once a library is given a suitable specification and verified against it, its code is not required to be re-examined ever again: all reasoning about the client code that makes use of that library can be done solely using the specification. • Foundational: A program logic can be efficiently embedded into a general-purpose mechanized mathematical framework.""
  - ""Logic-based approach to concurrent program verification Program logics are an appealing way to specify the behaviour of concurrent programs as well as to verify that a program is correct (i.e., obeys its specification).""",,"- The abstract discusses the theoretical contribution of considering abstract interpretation as a particular case of computational effects, which can be abstracted over using monads. This is a novel insight as it provides a unifying framework for static analyzers.
 - The work on monadic abstract interpreters offers a theoretical advancement by providing a methodology that allows for the recovery of a spectrum of analyses by changing the representation monad. This is a significant theoretical contribution as it simplifies and unifies the design of static analyzers.
 - The novel cardinality analysis for Haskell addresses a long-standing problem in lazy functional programming languages, providing a sound and efficient solution. This is a theoretical advancement as it solves a previously unsolved problem.
 - The logic-based approach to concurrent program verification is another theoretical contribution. It provides a structured, compositional, and foundational framework for specifying and verifying concurrent programs, which is a significant advancement in programming language design.
 - The abstract highlights the potential implications for programming language design by providing a framework that can accommodate modern programming paradigms and can be embedded into a general-purpose mechanized mathematical framework."
Logic programming and constraint logic programming,Jacques Cohen,10.1145/234313.234416,https://doi.org/10.1145/234313.234416,CSUR,9,1996,"1. Primitive Name: Resolution
  Definition: An inference step used to prove the validity of predicate calculus formulas expressed as clauses.
  Orthogonality Score: High (distinct procedural primitive)
 2. Primitive Name: Unification
  Definition: The matching of terms used in a resolution step.
  Orthogonality Score: High (distinct procedural primitive)
 3. Primitive Name: Horn Clause
  Definition: A clause containing at most one positive literal.
  Orthogonality Score: High (distinct structural primitive)
 4. Primitive Name: Definite Clause
  Definition: A clause with exactly one positive literal.
  Orthogonality Score: High (distinct structural primitive)","- Type of mathematical framework: Predicate calculus
 - Specific mathematical properties guaranteed: Resolution theorem proving, unification
 - Proof techniques used: Resolution
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"Not mentioned (the abstract does not explicitly mention novel insights, theoretical advancements beyond existing approaches, or potential implications for programming language design)","- ""Logic programming is a language paradigm based on logic, more specifically on resolution theorem proving in the predicate calculus as proposed in Robinson [1965].""
  - ""Robinson had the foresight to distinguish the importance of two components in automatic theorem proving: a single inference rule called resolution and the testing for equality of trees called unification.""
  - ""Resolution is an inference step used to prove the validity of predicate calculus formulas expressed as clauses.""
  - ""Unification is the matching of terms used in a resolution step.""
  - ""Prolog, the main representative of LP, consists of a sequence of Horn clauses.""
  - ""A Horn clause is one containing (at most) one positive literal.""
  - ""The term definite clause is used to denote a clause with exactly one positive literal.""
  - ""Prolog programs can be viewed as a set of definite clauses in which the positive literal is the head of the rule and the negative literals constitute the body or tail of the rule.""",,"- The abstract discusses the foundational components of logic programming, specifically highlighting ""resolution"" and ""unification"" as key conceptual primitives. These are fundamental to the logic programming paradigm.
 - Resolution is defined as an inference step for proving the validity of predicate calculus formulas, which is a core primitive in logic programming.
 - Unification is described as the matching of terms used in a resolution step, which is another essential primitive.
 - The abstract also mentions Horn clauses and definite clauses, which are structural primitives in Prolog programming. A Horn clause is defined as containing at most one positive literal, and a definite clause is a clause with exactly one positive literal.
 - These primitives are orthogonal in the sense that they serve distinct functions within the logic programming paradigm: resolution and unification are procedural primitives, while Horn and definite clauses are structural primitives.","- ""Logic programming is a language paradigm based on logic, more specifically on resolution theorem proving in the predicate calculus as proposed in Robinson [1965].""
  - ""Resolution is an inference step used to prove the validity of predicate calculus formulas expressed as clauses.""
  - ""Unification is the matching of terms used in a resolution step.""
  - ""Prolog, the main representative of LP, consists of a sequence of Horn clauses.""
  - ""A Horn clause is one containing (at most) one positive literal.""
  - ""Prolog programs can be viewed as a set of definite clauses in which the positive literal is the head of the rule and the negative literals constitute the body or tail of the rule.""",,"- The abstract discusses logic programming and its basis in predicate calculus, which is a mathematical framework.
 - The mention of ""resolution theorem proving"" and ""predicate calculus"" indicates that the mathematical framework is based on these concepts.
 - The abstract describes ""resolution"" as an inference step for proving the validity of predicate calculus formulas, which is a specific mathematical property guaranteed by this framework.
 - ""Unification"" is another key concept, which involves testing the satisfiability of term equalities, a mathematical property related to the framework.
 - The abstract does not explicitly mention type theory, category theory, or other specific mathematical frameworks, but it does focus on predicate calculus and resolution theorem proving.
 - There is no explicit discussion of proof techniques or limitations of the framework in the abstract.","- ""Logic programming is a language paradigm based on logic, more specifically on resolution theorem proving in the predicate calculus as proposed in Robinson [1965].""
  - ""Resolution is an inference step used to prove the validity of predicate calculus formulas expressed as clauses.""
  - ""Unification is the matching of terms used in a resolution step.""
  - ""Prolog, the main representative of LP, consists of a sequence of Horn clauses.""
  - ""Prolog programs can be viewed as a set of definite clauses in which the positive literal is the head of the rule and the negative literals constitute the body or tail of the rule.""
  - ""From a procedural point of view, a head corresponds to the definition of a Boolean function whose body consists of conjunctions of calls to the Boolean functions representing the tail [Kowalski 1979].""
  - ""A quintessential example of a Prolog program is that of append.""",,"- The abstract primarily discusses the basics of logic programming and its implementation in Prolog, focusing on resolution and unification.
 - There is no mention of integrating different programming paradigms or any specific integration mechanisms.
 - The abstract does not discuss interaction models between paradigms or any constraints or challenges in paradigm integration.
 - There is no mention of novel translation or embedding techniques related to integrating different programming paradigms.
 - The focus is on explaining the foundational concepts of logic programming rather than integrating it with other paradigms.","- ""Logic programming is a language paradigm based on logic, more specifically on resolution theorem proving in the predicate calculus as proposed in Robinson [1965].""
  - ""Resolution is an inference step used to prove the validity of predicate calculus formulas expressed as clauses.""
  - ""Unification is the matching of terms used in a resolution step.""
  - ""Prolog, the main representative of LP, consists of a sequence of Horn clauses.""
  - ""A Horn clause is one containing (at most) one positive literal.""
  - ""Prolog programs can be viewed as a set of definite clauses in which the positive literal is the head of the rule and the negative literals constitute the body or tail of the rule.""
  - ""From a procedural point of view, a head corresponds to the definition of a Boolean function whose body consists of conjunctions of calls to the Boolean functions representing the tail [Kowalski 1979].""
  - ""A quintessential example of a Prolog program is that of append. It consists of two Horn clauses specifying that list L3 is the concatenation of two lists, L1 and L2:""",,"- The abstract discusses logic programming and its basis in predicate calculus, focusing on resolution and unification. These are fundamental concepts in logic programming but do not directly address generic programming or abstraction mechanisms.
 - The abstract describes Prolog and its structure using Horn clauses, which are a form of logical statement. While this is relevant to logic programming, it does not explicitly discuss generic programming or abstraction mechanisms.
 - The mention of Boolean functions and their representation in Prolog programs suggests a level of abstraction, but it does not specifically address generic programming or the mechanisms for representing generic abstractions.
 - There is no mention of type systems, minimal type requirements, or static checking strategies, which are typically relevant to discussions of generic programming.
 - The abstract does not contain a section or discussion explicitly focused on generic programming methodology or type system discussions.","- ""Logic programming is a language paradigm based on logic, more specifically on resolution theorem proving in the predicate calculus as proposed in Robinson [1965].""
  - ""Robinson had the foresight to distinguish the importance of two components in automatic theorem proving: a single inference rule called resolution and the testing for equality of trees called unification.""
  - ""Resolution is an inference step used to prove the validity of predicate calculus formulas expressed as clauses.""
  - ""Unification is the matching of terms used in a resolution step.""
  - ""Prolog, the main representative of LP, consists of a sequence of Horn clauses.""
  - ""A Horn clause is one containing (at most) one positive literal.""
  - ""Prolog programs can be viewed as a set of definite clauses in which the positive literal is the head of the rule and the negative literals constitute the body or tail of the rule.""
  - ""From a procedural point of view, a head corresponds to the definition of a Boolean function whose body consists of conjunctions of calls to the Boolean functions representing the tail [Kowalski 1979].""
  - ""A quintessential example of a Prolog program is that of append.""",,"- The abstract discusses the foundational concepts of logic programming (LP) and constraint logic programming, highlighting the importance of resolution and unification as proposed by Robinson.
 - It explains how Prolog, a main representative of LP, uses Horn clauses and definite clauses to structure programs.
 - The abstract provides a procedural view of Prolog programs, relating them to Boolean functions, which is a theoretical contribution to understanding how these programs operate.
 - The mention of Robinson's foresight and the explanation of resolution and unification suggest a theoretical advancement in understanding the components of automatic theorem proving.
 - The abstract does not explicitly mention new insights or advancements beyond existing approaches, nor does it discuss potential implications for programming language design.
 - The focus is on explaining existing theoretical foundations rather than introducing novel theoretical contributions."
CCS Programming in an ML Framework: An Account of LCS,B. Berthomieu,10.1007/978-1-4612-2274-3_4,https://doi.org/10.1007/978-1-4612-2274-3_4,-,0,1997,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Type theory (extension of Standard ML with behavior types), Process algebra (CCS formalism)
 - Specific mathematical properties guaranteed: Consistency of communications between processes
 - Proof techniques used: Operational semantics using observation relation (labeled transition system), refinement into reduction relation
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Extension of Standard ML with behavior expressions based on CCS formalism.
 - Interaction models between paradigms: Processes communicate by rendezvous over named communication ports.
 - Constraints or challenges in paradigm integration: Extension of SML's polymorphic typing discipline with behavior types to ensure consistency of communications.
 - Novel translation or embedding techniques: Use of an observation relation and its refinement into a reduction relation.","- Definition of ""concept"" used: Behavior expressions based on CCS formalism
 - Mechanisms for representing generic abstractions: Extension of Standard ML with behavior expressions; introduction of behavior types
 - Minimal type requirements identified: Not explicitly mentioned
 - Static checking or optimization strategies: Type reconstruction similar to SML, with behavior types enforcing consistency","- Novel integration of CCS formalism with Standard ML to create LCS.
 - Introduction of behavior types to enforce consistency in communications between processes.
 - Theoretical innovation in type theory through behavior types related to but differing from existing type systems.
 - Operational semantics defined through an observation relation and refined into a reduction relation.","- ""LCS is an experimental highlevel asynchronous parallel programming language primarily aimed at exploring design, implementation, and use of programming languages based upon the behavioral paradigms introduced by CSP and CCS.""
  - ""The language extends Standard ML with behavior expressions based upon a higher-order extension of the CCS formalism.""
  - ""The extended CCS constructions express concurrency and communication; the SML constructions are used to specify messages, derived behavior combinators, and programs (behaviors).""
  - ""Processes communicate by rendezvous over named communication ports.""
  - ""The language is layered, with behaviors as the highest-level units of computation.""
  - ""The polymorphic typing discipline of SML is extended with the so-called behavior types, assigned to behavior expressions, to enforce consistency of communications between processes.""
  - ""Behavior types bear strong relationships with Wand’s row types and Rémy’s extensible record types, though they differ in their logical interpretation.""
  - ""Behaviors are assigned a type information that attach a polymorphic type to every possible communication label.""
  - ""The operational semantics of the language is given in terms of an observation relation (or labeled transition system), from which various equivalence notions for programs can be defined.""",,"- The abstract discusses the extension of Standard ML with behavior expressions based on CCS formalism, which suggests that the conceptual primitives are related to concurrency and communication.
 - The mention of ""behavior expressions"" and ""behavior types"" indicates that these are key primitives in the language.
 - The use of ""rendezvous over named communication ports"" suggests a primitive related to process communication.
 - The abstract does not explicitly list or define specific conceptual primitives, but it implies that behaviors and behavior types are central to the language's design.
 - The level of abstraction is high, as the language is described as ""highlevel"" and focuses on behavioral paradigms.
 - Orthogonality is not explicitly discussed in the abstract.","- ""The language extends Standard ML with behavior expressions based upon a higher-order extension of the CCS formalism.""
  - ""The polymorphic typing discipline of SML is extended with the so-called behavior types, assigned to behavior expressions, to enforce consistency of communications between processes.""
  - ""Behavior types bear strong relationships with Wand’s row types and Rémy’s extensible record types, though they differ in their logical interpretation.""
  - ""The operational semantics of the language is given in terms of an observation relation (or labeled transition system), from which various equivalence notions for programs can be defined.""
  - ""As a step towards implementation, this observation relation is refined into a readily implementable reduction relation.""",,"- The abstract mentions the use of a ""higher-order extension of the CCS formalism,"" which suggests that the mathematical framework is based on process algebra, specifically CCS (Calculus of Communicating Systems).
 - The extension of Standard ML with behavior types indicates a type theory framework, as it involves polymorphic typing to ensure consistency in communications.
 - The mention of ""behavior types"" and their relationship with ""Wand’s row types and Rémy’s extensible record types"" suggests a connection to type theory, particularly in how types are used to enforce consistency.
 - The operational semantics are described using an ""observation relation (or labeled transition system),"" which is a common mathematical framework for formalizing process behavior and equivalence notions.
 - The refinement into a ""readily implementable reduction relation"" implies a focus on operational semantics and possibly proof techniques related to reduction systems.","- ""LCS is an experimental highlevel asynchronous parallel programming language primarily aimed at exploring design, implementation, and use of programming languages based upon the behavioral paradigms introduced by CSP and CCS.""
  - ""The language extends Standard ML with behavior expressions based upon a higher-order extension of the CCS formalism.""
  - ""The extended CCS constructions express concurrency and communication; the SML constructions are used to specify messages, derived behavior combinators, and programs (behaviors).""
  - ""Processes communicate by rendezvous over named communication ports.""
  - ""The polymorphic typing discipline of SML is extended with the so-called behavior types, assigned to behavior expressions, to enforce consistency of communications between processes.""
  - ""Behavior types bear strong relationships with Wand’s row types and Rémy’s extensible record types, though they differ in their logical interpretation.""
  - ""The operational semantics of the language is given in terms of an observation relation (or labeled transition system), from which various equivalence notions for programs can be defined.""
  - ""As a step towards implementation, this observation relation is refined into a readily implementable reduction relation.""",,"- The abstract discusses the integration of different programming paradigms by extending Standard ML with behavior expressions based on CCS formalism. This indicates a specific integration mechanism where CCS is embedded into ML.
 - The interaction model between paradigms is described as processes communicating by rendezvous over named communication ports, which is a mechanism for interaction between different processes.
 - The extension of SML's polymorphic typing discipline with behavior types is a constraint or challenge in paradigm integration, as it requires ensuring consistency of communications between processes.
 - The abstract mentions the use of an observation relation and its refinement into a reduction relation, which could be considered as novel translation or embedding techniques for integrating the paradigms.
 - The abstract does not explicitly mention any comparative analysis or theoretical integration strategies beyond the extension and interaction mechanisms described.","- ""The language extends Standard ML with behavior expressions based upon a higher-order extension of the CCS formalism.""
  - ""The polymorphic typing discipline of SML is extended with the so-called behavior types, assigned to behavior expressions, to enforce consistency of communications between processes.""
  - ""Except for the introduction of behavior types, type reconstruction for LCS programs is as in SML.""
  - ""Behaviors are assigned a type information that attach a polymorphic type to every possible communication label.""
  - ""Behavior types bear strong relationships with Wand’s row types and Rémy’s extensible record types, though they differ in their logical interpretation.""",,"- The abstract discusses the extension of Standard ML with behavior expressions based on CCS formalism, which suggests a mechanism for representing generic abstractions through these behavior expressions.
 - The introduction of ""behavior types"" indicates a mechanism for enforcing consistency in communications between processes, which is a form of abstraction.
 - The mention of polymorphic typing discipline and the assignment of polymorphic types to communication labels suggests a focus on generic programming.
 - The comparison of behavior types with Wand’s row types and Rémy’s extensible record types implies a conceptual abstraction mechanism.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the extension of SML's type system suggests some level of static checking.","- ""LCS is an experimental highlevel asynchronous parallel programming language primarily aimed at exploring design, implementation, and use of programming languages based upon the behavioral paradigms introduced by CSP and CCS.""
  - ""The language extends Standard ML with behavior expressions based upon a higher-order extension of the CCS formalism.""
  - ""The polymorphic typing discipline of SML is extended with the so-called behavior types, assigned to behavior expressions, to enforce consistency of communications between processes.""
  - ""Behavior types bear strong relationships with Wand’s row types and Rémy’s extensible record types, though they differ in their logical interpretation.""
  - ""The operational semantics of the language is given in terms of an observation relation (or labeled transition system), from which various equivalence notions for programs can be defined.""
  - ""As a step towards implementation, this observation relation is refined into a readily implementable reduction relation.""",,"- The abstract introduces LCS as an experimental language that extends Standard ML with behavior expressions based on CCS formalism, which is a novel integration of these paradigms.
 - The extension of Standard ML with behavior expressions and the introduction of behavior types are key theoretical contributions. These types enforce consistency in communications between processes, which is a significant advancement in ensuring reliable concurrent programming.
 - The mention of behavior types bearing relationships with existing type systems (Wand’s row types and Rémy’s extensible record types) but differing in logical interpretation suggests a theoretical innovation in type theory.
 - The operational semantics defined through an observation relation and its refinement into a reduction relation are theoretical advancements that provide a solid foundation for understanding and analyzing the behavior of LCS programs.
 - These contributions have potential implications for programming language design, particularly in the areas of concurrency and communication, by providing a framework for designing languages that can handle complex asynchronous parallel programming tasks."
Data Parallelism and Functional Programming,B. Lisper,10.1007/3-540-61736-1_50,https://doi.org/10.1007/3-540-61736-1_50,The Data Parallel Programming Model,32,1996,Not specified (the abstract discusses the integration of paradigms and characteristics of the formalism but does not explicitly list or define specific conceptual primitives),Not specified (the abstract does not provide details on the mathematical framework used),"- Specific integration mechanisms proposed: Merging data parallel and functional paradigms to create new languages and formalisms.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Discussion of issues for languages based directly on the formalism.
 - Any novel translation or embedding techniques: Allows for very simple languages and succinct expression of algorithms.",Generic programming not extensively addressed,"- Key novel insights: Integration of data parallelism and functional programming paradigms in a declarative setting.
 - Theoretical advancements: Development of a formalism for data parallel functional programming that abstracts aggregate data.
 - Potential implications: Simplification of algorithm expression and potential challenges for language design based on this formalism.","- ""Data parallelism is often seen as a form of explicit parallelism for SIMD and vector machines, and data parallel programming as an explicit programming paradigm for these architectures.""
  - ""Data parallel languages possess certain software qualities as well, which justifies their use in higher level programming and specification closer to the algorithm domain.""
  - ""Thus, it is interesting to study how the data parallel paradigm can be best realized in a declarative setting, since declarative languages offer a pure view of computation which is good for these purposes.""
  - ""For numerical computing the functional programming paradigm is especially attractive, since numerical algorithms often are specified by recursion equations and thus can be translated more or less directly into recursive functional programs.""
  - ""Merging the data parallel and functional paradigms then yields languages and formalisms where many algorithms can be expressed in a very succinct fashion.""
  - ""We then proceed to describe a formalism for data parallel functional programming, allowing very simple languages, where the view of aggregate data is particularly abstract.""
  - ""We explain how various data parallel operations can be expressed in this formalism.""",,"- The abstract discusses the integration of data parallelism and functional programming paradigms, indicating a focus on how these paradigms can be combined to create more efficient and expressive programming languages.
 - It mentions that data parallel languages have certain software qualities that make them suitable for higher-level programming and specification, suggesting that these qualities are conceptual primitives in the context of data parallelism.
 - The abstract highlights the use of declarative languages for a pure view of computation, which is a conceptual primitive in the context of functional programming.
 - The mention of numerical algorithms being specified by recursion equations and translated into recursive functional programs suggests that recursion is a conceptual primitive in functional programming.
 - The abstract describes a formalism for data parallel functional programming that allows for simple languages with an abstract view of aggregate data, indicating that this formalism is built on conceptual primitives related to data abstraction and parallelism.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It discusses the integration of paradigms and the characteristics of the resulting formalism but does not provide a detailed list of primitives.","- ""Finally, we conclude with a discussion of issues for languages based directly on the formalism.""
  - ""We then proceed to describe a formalism for data parallel functional programming, allowing very simple languages, where the view of aggregate data is particularly abstract.""
  - ""Merging the data parallel and functional paradigms then yields languages and formalisms where many algorithms can be expressed in a very succinct fashion.""
  - ""Thus, it is interesting to study how the data parallel paradigm can be best realized in a declarative setting, since declarative languages offer a pure view of computation which is good for these purposes.""
  - ""We explain how various data parallel operations can be expressed in this formalism.""",,"- The abstract mentions the integration of data parallelism and functional programming paradigms, which suggests a focus on programming languages rather than a specific mathematical framework.
 - The term ""declarative setting"" implies a focus on declarative programming, which is often associated with functional programming, but it does not specify a particular mathematical framework.
 - The mention of a ""formalism for data parallel functional programming"" suggests some level of formalization, but it does not specify the type of mathematical framework used (e.g., type theory, category theory).
 - The abstract does not provide details on specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the programming paradigm and language formalism rather than on a specific mathematical framework or its characteristics.","- ""Merging the data parallel and functional paradigms then yields languages and formalisms where many algorithms can be expressed in a very succinct fashion.""
  - ""We then proceed to describe a formalism for data parallel functional programming, allowing very simple languages, where the view of aggregate data is particularly abstract.""
  - ""We explain how various data parallel operations can be expressed in this formalism.""
  - ""it is interesting to study how the data parallel paradigm can be best realized in a declarative setting,""
  - ""Finally, we conclude with a discussion of issues for languages based directly on the formalism.""",,"- The abstract mentions the integration of data parallel and functional programming paradigms, indicating a focus on how these two paradigms can be merged.
 - The phrase ""Merging the data parallel and functional paradigms"" suggests a direct integration approach where both paradigms are combined to create new languages and formalisms.
 - The description of a ""formalism for data parallel functional programming"" implies a specific integration mechanism, as it involves creating a new formalism that combines elements of both paradigms.
 - The abstract does not explicitly mention interaction models or constraints, but it does indicate that the integration allows for ""very simple languages"" and ""a very succinct fashion"" of expressing algorithms, which could imply a novel translation or embedding technique.
 - The discussion of ""issues for languages based directly on the formalism"" suggests that there may be challenges or constraints in the integration process, but these are not detailed in the abstract.","- ""Data parallel languages possess certain software qualities as well, which justifies their use in higher level programming and specification closer to the algorithm domain.""
  - ""We then proceed to describe a formalism for data parallel functional programming, allowing very simple languages, where the view of aggregate data is particularly abstract.""
  - ""We explain how various data parallel operations can be expressed in this formalism.""
  - ""Merging the data parallel and functional paradigms then yields languages and formalisms where many algorithms can be expressed in a very succinct fashion.""
  - ""Thus, it is interesting to study how the data parallel paradigm can be best realized in a declarative setting, since declarative languages offer a pure view of computation which is good for these purposes.""",,"- The abstract discusses the integration of data parallelism and functional programming, which suggests a focus on abstraction mechanisms.
 - The mention of ""higher level programming and specification closer to the algorithm domain"" implies a focus on abstraction, as it involves moving towards more general and abstract representations.
 - The integration of data parallel and functional paradigms is expected to yield ""languages and formalisms where many algorithms can be expressed in a very succinct fashion,"" which suggests a mechanism for representing generic abstractions.
 - The description of a formalism for data parallel functional programming that allows ""very simple languages"" with an ""abstract view of aggregate data"" indicates a focus on abstraction mechanisms.
 - However, the abstract does not explicitly mention generic programming methodology, type system discussions, or specific mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.","- ""Merging the data parallel and functional paradigms then yields languages and formalisms where many algorithms can be expressed in a very succinct fashion.""
  - ""Thus, it is interesting to study how the data parallel paradigm can be best realized in a declarative setting, since declarative languages offer a pure view of computation which is good for these purposes.""
  - ""We then proceed to describe a formalism for data parallel functional programming, allowing very simple languages, where the view of aggregate data is particularly abstract.""
  - ""We explain how various data parallel operations can be expressed in this formalism.""
  - ""Finally, we conclude with a discussion of issues for languages based directly on the formalism.""",,"- The abstract discusses the integration of data parallelism and functional programming paradigms, which is a novel approach as it combines two distinct programming paradigms.
 - The mention of realizing the data parallel paradigm in a declarative setting suggests a theoretical contribution by exploring how these paradigms can be merged effectively.
 - The description of a formalism for data parallel functional programming indicates a theoretical advancement, as it provides a new framework for expressing algorithms succinctly.
 - The focus on abstracting the view of aggregate data suggests a theoretical innovation in how data is handled in programming languages.
 - The discussion of issues for languages based on this formalism implies potential implications for programming language design, as it considers the practical applications and challenges of implementing this theoretical framework."
Reactive imperative programming with dataflow constraints,"C. Demetrescu, Irene Finocchi, Andrea Ribichini",10.1145/2048066.2048100,https://doi.org/10.1145/2048066.2048100,"Conference on Object-Oriented Programming Systems, Languages, and Applications",33,2011,"1. Primitive Name: Reactive Memory Locations
  Definition: Memory that can be read and written like ordinary memory but logs dependencies and automatically re-executes constraints upon changes.
  Orthogonality Score: High
 

 2. Primitive Name: Constraints
  Definition: Ordinary commands in the host language that are sensitive to changes in reactive memory locations and are automatically re-evaluated when these locations change.
  Orthogonality Score: High","- Type of mathematical framework: Not explicitly specified (uses formal semantics and iterative processes)
 - Specific mathematical properties guaranteed: Convergence to a common fixpoint, deterministic results
 - Proof techniques used: Results from the theory of function iterations
 - Limitations or constraints of the framework: Not explicitly discussed","- Specific integration mechanisms proposed: Defining ordinary statements in the imperative language to enforce constraints between reactive objects; altering semantics of elementary operations for reading and modifying objects.
 - Interaction models between paradigms: Constraints are written as ordinary commands and can be dynamically added or removed; transparent constraint solving mechanism.
 - Constraints or challenges in paradigm integration: No syntax extensions or new primitives required except for managing reactive memory and solver activations.
 - Novel translation or embedding techniques: Reactive memory locations and constraints as ordinary commands.","- Definition of ""concept"" used: Reactive objects and constraints as generic abstractions.
 - Mechanisms for representing generic abstractions: Use of reactive objects and constraints applicable to any legal type in the host language.
 - Minimal type requirements identified: Any legal type in the host language.
 - Static checking or optimization strategies: Not mentioned.","- Novel approach integrating dataflow constraints into imperative programming without special data types or syntactic extensions.
 - Reactive objects can be of any legal type in the host language.
 - Transparent constraint solving by altering semantics of elementary operations.
 - Support for arbitrary code within constraints, including loops and recursion.
 - Ability to handle cyclic constraints, addressing previously unsolvable problems.
 - Formal semantics provided for the framework.","- ""Reactive memory can be read and written just like ordinary memory. However, differently from ordinary memory:
 

 1. If a constraint c reads a reactive memory location ℓ during its execution, a dependency (ℓ, c) of c from ℓ is logged in a set D of dependencies.
 

 2. If the value stored in a reactive memory location ℓ is changed, all constraints depending on ℓ (i.e., all constraints c such that (ℓ, c) ∈ D) are automatically reexecuted.""
  - ""Our approach hinges upon two key notions: reactive memory locations and constraints.""
  - ""The main feature of a constraint is its sensitivity to modifications of reactive objects: a constraint is automatically re-evaluated whenever any of the reactive locations it depends on is changed, either by the imperative program, or by another constraint.""
  - ""Constraints are written as ordinary commands of the host imperative language and can be added and removed dynamically at run time.""",,"- The paper introduces two primary conceptual primitives: ""reactive memory locations"" and ""constraints.""
 - Reactive memory locations are defined as memory that can be read and written like ordinary memory but with additional properties related to dependency logging and automatic constraint re-execution upon changes.
 - Constraints are defined as ordinary commands in the host language that are sensitive to changes in reactive memory locations and are automatically re-evaluated when these locations change.
 - These primitives are orthogonal as they serve distinct purposes: reactive memory locations are about data storage and dependency tracking, while constraints are about the logic that reacts to changes in these locations.
 - The level of abstraction is high as these primitives are fundamental to the framework proposed by the study, allowing for a general-purpose approach to integrating dataflow constraints into imperative programming.","- ""We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers.""
  - ""In Section 2 we abstract our mechanism showing how to extend an elementary imperative language to support one-way dataflow constraints using reactive memory.""
  - ""We formally describe our mixed imperative/dataflow computational model by defining the interactions between these modes and providing a formal semantics of our mechanism.""
  - ""In Section 3 we discuss convergence of the dataflow constraint solver by modeling the computation as an iterative process that aims at finding a common fixpoint for the current set of constraints.""
  - ""Using results from the theory of function iterations [15], we show that any arbitrary collection of inflationary one-way constraints has the desired property.""
  - ""We can now discuss convergence properties of our solver:
 

 PROOF (SKETCH). Consider the sequence S 0 , S 1 , . . . of scheduling sets resulting from a recursive application of rule SOLVER-2 terminated by rule SOLVER-1 (see Figure 4 ), with S 0 = S.""
  - ""Assuming that functions in Lemma 1 and Theorem 1 are also monotonic, it is possible to prove that the solver always converges to the least common fixpoint, yielding deterministic results independently of the scheduling order.""
  - ""A more general approach, which we follow in our work, consists of modeling dataflow constraint solving as an iterative process that aims at finding a common fixpoint for the current set of constraints.""",,"- The paper provides a formal semantics for the dataflow constraint system, which is a key component of the mathematical framework.
 - The framework is based on an iterative process that aims to find a common fixpoint for the constraints, which is a mathematical property guaranteed by the framework.
 - The paper uses results from the theory of function iterations to prove convergence properties, indicating a reliance on mathematical theories related to function iterations.
 - The framework ensures that the solver converges to the least common fixpoint, which is a specific mathematical property guaranteed by the framework.
 - The paper does not explicitly mention a specific type of mathematical framework like type theory or category theory, but it does use formal semantics and iterative processes, which are common in mathematical frameworks.
 - The limitations or constraints of the framework are not explicitly discussed in terms of mathematical limitations, but the paper does address the convergence properties and scheduling strategies.","- ""In this paper we propose a novel approach that smoothly combines the two paradigms without placing undue burden on the programmer.""
  - ""our framework, programmers can define ordinary statements of the imperative host language that enforce constraints between objects stored in special memory locations designated as ""reactive"".""
  - ""Differently from previous approaches, reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures.""
  - ""The constraint solving mechanism is handled transparently by altering the semantics of elementary operations of the host language for reading and modifying objects.""
  - ""Our approach hinges upon two key notions: reactive memory locations and constraints.""
  - ""Constraints are written as ordinary commands of the host imperative language and can be added and removed dynamically at run time.""
  - ""the whole constraint solving mechanism is handled transparently by altering the semantics of elementary operations of the host imperative language for reading and modifying objects.""
  - ""No syntax extensions are required and no new primitives are needed except for adding/removing constraints, allocating/deallocating reactive memory locations, and controlling the granularity of solver activations.""",,"- The paper proposes a novel approach to integrate imperative and dataflow programming paradigms, allowing for smooth combination without additional burden on the programmer.
 - The integration mechanism involves defining ordinary statements in the imperative language that enforce constraints between reactive objects, which can be of any legal type in the host language.
 - The interaction model involves altering the semantics of elementary operations for reading and modifying objects, making the constraint solving mechanism transparent.
 - Constraints are written as ordinary commands and can be dynamically added or removed, indicating a flexible interaction model.
 - The approach does not require syntax extensions or new primitives, except for managing reactive memory and solver activations, which simplifies integration.
 - The use of reactive memory locations and constraints as ordinary commands facilitates a seamless interaction between the two paradigms.","- ""In our framework, programmers can define ordinary statements of the imperative host language that enforce constraints between objects stored in special memory locations designated as ""reactive"".""
  - ""Differently from previous approaches, reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures.""
  - ""Constraints are written as ordinary commands of the host imperative language and can be added and removed dynamically at run time.""
  - ""No syntax extensions are required and no new primitives are needed except for adding/removing constraints, allocating/deallocating reactive memory locations, and controlling the granularity of solver activations.""
  - ""DC has exactly the same syntax as C/C++, but operations that read or modify objects have a different semantics.""
  - ""All other primitives, including creating and deleting constraints and allocating and deallocating reactive memory blocks, are provided as runtime library functions.""",,"- The paper discusses a framework that integrates dataflow constraints into an imperative language, allowing for generic programming by enabling constraints to be applied to any legal type in the host language.
 - The mechanism for representing generic abstractions is through the use of ""reactive objects"" and ""constraints,"" which can be applied to various data types without requiring special data types or syntax extensions.
 - The minimal type requirements are not explicitly stated, but it is implied that any legal type in the host language can be used with reactive objects and constraints.
 - There is no mention of specific static checking or optimization strategies related to generic programming in the paper.","- ""In this paper we propose a novel approach that smoothly combines the two paradigms without placing undue burden on the programmer.""
  - ""Our Contributions. We present a general-purpose framework where programmers can specify generic one-way constraints between objects of arbitrary types stored in reactive memory locations.""
  - ""Differently from previous approaches, reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures.""
  - ""The constraint solving mechanism is handled transparently by altering the semantics of elementary operations of the host language for reading and modifying objects.""
  - ""Our approach hinges upon two key notions: reactive memory locations and constraints.""
  - ""We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers.""
  - ""Differently from previous approaches, programmers are not forced to use any special data types provided by the language extension, and can resort to the full range of conventional constructs for accessing and manipulating objects offered by the host language.""
  - ""our framework supports all the other features that have been recognized to be important in the design of dataflow constraint systems [38], including:
 

 Arbitrary code: constraints consist of arbitrary code that is legal in the underlying imperative language, thus including loops, conditionals, function calls, and recursion.""
  - ""Differently from previous approaches to solving one-way dataflow constraints [6,17,26,27], which were targeted to acyclic dependencies, our abstract machine can handle the most general case of cyclic constraints embedded within an imperative program.""
  - ""This opens up the possibility to address problems that would not be solvable using acyclic dataflow graphs, backed up with a formal machinery to help designers prove their convergence properties (Section 3.1).""
  - ""we show that any arbitrary collection of inflationary one-way constraints has the desired property. This class of constraints includes, for instance, any program that can be described in terms of an acyclic dataflow graph such as computational circuits [6], non-circular attribute grammars [29], and spreadsheets [28] (see Section 3.2).""
  - ""We remark, however, that it is more general as it allows it to address problems that would not be solvable without cyclic dependencies (an example is given in Section 3.3).""",,"- The paper introduces a novel approach that integrates dataflow constraints into imperative programming without requiring special data types or syntactic extensions, which is a significant theoretical contribution.
 - The framework allows for reactive objects to be of any legal type in the host language, enhancing flexibility and reducing the burden on programmers.
 - The transparent handling of constraint solving by altering the semantics of elementary operations is a theoretical advancement beyond existing approaches.
 - The support for arbitrary code within constraints, including loops and recursion, is a key feature that distinguishes this work from previous approaches.
 - The ability to handle cyclic constraints is a significant theoretical contribution, as it opens up possibilities for solving problems that were previously unsolvable with acyclic dataflow graphs.
 - The formal semantics provided for the framework is a theoretical contribution, as it offers a rigorous foundation for understanding and implementing the approach.
 - The potential implications for programming language design include the integration of dataflow constraints into existing imperative languages without requiring significant changes to the language itself."
Extending the Quantitative Pattern-Matching Paradigm,"Sandra Alves, D. Kesner, Miguel Ramos",10.48550/arXiv.2408.11007,https://doi.org/10.48550/arXiv.2408.11007,Asian Symposium on Programming Languages and Systems,0,2024,"1. Primitive Name: λ c -calculus
  Definition: A weak and closed λ-calculus integrating a pattern matching mechanism on algebraic data types (ADTs) to model functional programming languages.
  Orthogonality Score: High (models functional programming languages closely)
 

 2. Primitive Name: Non-idempotent Intersection Types
  Definition: Type systems based on non-idempotent intersection types to characterize termination properties and provide quantitative information about evaluation steps.
  Orthogonality Score: High (provides quantitative information about termination)
 

 3. Primitive Name: Evaluation Strategy → D
  Definition: An evaluation strategy based on an extension of the weak head reduction strategy to define term evaluation in the λ c -calculus.
  Orthogonality Score: High (defines evaluation process in λ c -calculus)
 

 4. Primitive Name: Multiset Types and Term Types
  Definition: Distinction between multiset types and term types in the type system to structure and use types.
  Orthogonality Score: High (fundamental distinction in type system)","- Type of mathematical framework: Type theory (non-idempotent intersection types)
 - Specific mathematical properties guaranteed: Termination properties, type safety (well-typed programs do not go wrong)
 - Proof techniques used: Logical methods, typing rules
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Encoding of Plotkin's CBV and CBN λ-calculus, and the bang-calculus within the λ c -calculus.
 - Interaction models between paradigms: Encoding and translation techniques, such as translation (_) • for CBV λ-calculus.
 - Constraints or challenges in paradigm integration: Future work involving extensions like fixpoints and open versions of the λ c -calculus.
 - Novel translation or embedding techniques: Encoding of CBV λ-calculus into the λ c -calculus.",Generic programming not extensively addressed,"- Novel extension of type systems based on non-idempotent intersection types to characterize termination properties in functional programming languages with pattern matching.
 - Extension of existing pattern calculi with tagged products and case expressions to model ADTs.
 - Detailed operational treatment of the λ c -calculus with a new evaluation strategy.
 - Introduction of a non-idempotent intersection type system for quantitative characterization of termination.
 - Quantitative characterization of termination linking typability with termination and providing upper bounds for evaluation steps.
 - Ensuring well-typed programs are clash-free, contributing to programming language design.","- ""We show how (well-established) type systems based on non-idempotent intersection types can be extended to characterize termination properties of functional programming languages with pattern matching features.""
  - ""To model such programming languages, we use a (weak and closed) $\lambda$-calculus integrating a pattern matching mechanism on algebraic data types (ADTs).""
  - ""The calculus that is obtained, called the λ c -calculus, models functional programming languages more closely.""
  - ""The main contributions of this work are threefold. First, we provide a detailed operational treatment of the λ c -calculus in Section 2, for which we propose an evaluation strategy → D based on an extension of the well-known weak head reduction strategy.""
  - ""Finally, we define a non-idempotent intersection type system in Section 4 that naturally extends type system U from [4].""
  - ""The type system for the λ c -calculus is inspired by the non-idempotent type system in [4]. We consider the following grammars: Notice that we distinguish between multiset types and term types.""",,"- The paper introduces the λ c -calculus as a conceptual framework for modeling functional programming languages with pattern matching features. This suggests that the λ c -calculus itself is a conceptual primitive.
 - The use of non-idempotent intersection types is a key conceptual primitive for characterizing termination properties and providing quantitative information about evaluation steps.
 - The evaluation strategy → D is another conceptual primitive, as it defines how terms are evaluated in the λ c -calculus.
 - The distinction between multiset types and term types is a conceptual primitive in the type system, indicating a level of abstraction in how types are structured and used.","- ""We show how (well-established) type systems based on non-idempotent intersection types can be extended to characterize termination properties of functional programming languages with pattern matching features.""
  - ""Type systems based on intersection types can not only guarantee termination (a typable term is terminating), but also characterize it (a terminating term is typable)""
  - ""Intersection types extend simple types with an intersection constructor""
  - ""The type system for the λ c -calculus is inspired by the non-idempotent type system in [4].""
  - ""We provide a purely logical and quantitative characterization of termination, i.e. we show that a program t is typable if, and only if, its evaluation terminates (in a clash-free normal form).""
  - ""the size of type derivations provide upper bounds for the number of evaluation steps.""
  - ""The type system for the λ c -calculus is denoted by T and defined by the typing rules in Fig. 2""
  - ""The Typing Rules. Most of the rules are straightforward.""
  - ""The quantitative flavor of Lemma 11 gives us a good measure that ensures termination.""",,"- The paper uses a type system based on non-idempotent intersection types as its mathematical framework. This is explicitly mentioned in several places, indicating that the framework is centered around type theory.
 - The framework guarantees termination properties, specifically that typable terms are terminating and vice versa. This is a key property of the type system.
 - The use of non-idempotent intersection types provides quantitative information about termination, such as upper bounds for the number of evaluation steps.
 - The proof techniques involve logical methods and the use of typing rules to establish the properties of the type system.
 - The framework is designed to ensure that well-typed programs do not go wrong, which is a fundamental property of type safety.
 - The paper does not mention any specific limitations or constraints of the framework, but it does highlight the improvements and benefits of using non-idempotent intersection types.","- ""In particular, it is shown that our language encodes Plotkin's CBV and CBN λ-calculus [36], and also the bang-calculus, written λ ! , that was proposed in [7] as a subsuming framework for CBN and CBV λ-calculus based on Girard's encodings [20].""
  - ""Plotkin's CBN λ-calculus is a strict subset of our language.""
  - ""The Bang-Calculus. The terms, list contexts, and weak head surface contexts of the λ ! -calculus are generated by the grammars 5""
  - ""Something that looks challenging is to consider an open version of λ c -calculus. This would allow us to extend the results in [10] to generalized λ-abstractions and case expressions.""
  - ""The calculus in [5] includes a fixpoint, we would like to consider such an extension as well.""",,"- The paper discusses the integration of different programming paradigms by showing how the λ c -calculus can encode various existing paradigms such as Plotkin's CBV and CBN λ-calculus, as well as the bang-calculus.
 - The integration mechanism involves encoding these paradigms within the λ c -calculus, indicating a theoretical integration strategy where the λ c -calculus serves as a unifying framework.
 - The interaction model between paradigms is achieved through encoding and translation techniques, such as the translation (_) • for CBV λ-calculus.
 - Constraints or challenges in paradigm integration are not explicitly discussed, but the paper mentions future work involving extensions like fixpoints and open versions of the λ c -calculus, which could pose challenges.
 - Novel translation or embedding techniques are described, particularly the encoding of CBV λ-calculus into the λ c -calculus.","- ""We show how (well-established) type systems based on non-idempotent intersection types can be extended to characterize termination properties of functional programming languages with pattern matching features.""
  - ""In this work, patterns are either variables (for which matching always succeeds) or tagged products, which are products tagged by a unique name.""
  - ""Patterns are assumed to be linear, i.e. each variable occurs at most once, and so are tuples of patterns, i.e. no variable is shared between patterns in a tuple.""
  - ""Intersection types extend simple types with an intersection constructor ∩. Intuitively, a program t is typable with the intersection of types τ ∩ σ if t is typable with both τ and σ independently""
  - ""The type system for the λ c -calculus is inspired by the non-idempotent type system in [4].""
  - ""The size of multiset type M (i.e. its length) is denoted by |M|. The empty multiset type is denoted by [ ]. Multiset union is denoted by""
  - ""Type abs is a special constant type that is used to type abstractions for which no arguments are provided.""
  - ""The type system for the λ c -calculus is denoted by T and defined by the typing rules in Fig. 2""",,"- The paper focuses on extending type systems based on non-idempotent intersection types to characterize termination properties, which is related to abstraction mechanisms but not directly addressing generic programming.
 - The use of patterns as variables or tagged products and the assumption of linear patterns suggest a mechanism for abstraction but not specifically generic programming.
 - Intersection types and non-idempotent intersections are discussed as a way to improve type systems, which could be related to abstraction but not explicitly genericity.
 - The type system described is inspired by non-idempotent types, which is more about abstraction and type safety than generic programming.
 - There is no explicit mention of generic programming or mechanisms for representing generic abstractions in the provided quotes.","- ""We show how (well-established) type systems based on non-idempotent intersection types can be extended to characterize termination properties of functional programming languages with pattern matching features.""
  - ""This work extends the pattern calculi in [8,10,4] with tagged products and case expressions, which capture ADT's.""
  - ""The main contributions of this work are threefold. First, we provide a detailed operational treatment of the λ c -calculus in Section 2, for which we propose an evaluation strategy → D based on an extension of the well-known weak head reduction strategy.""
  - ""Finally, we define a non-idempotent intersection type system in Section 4 that naturally extends type system U from [4].""
  - ""We provide a purely logical and quantitative characterization of termination, i.e. we show that a program t is typable if, and only if, its evaluation terminates (in a clash-free normal form).""
  - ""Moreover, the characterization result is quantitative: we show that the size of type derivations provide upper bounds for the number of evaluation steps.""
  - ""This work provides a quantitative insight into the semantics of programming languages with pattern matching.""
  - ""Crucially, we also prove that system T ensures that ""well-typed programs do not go wrong"" or, equivalently, by using the terminology adopted in this work, that typable programs are clash-free.""",,"- The paper introduces a novel extension of type systems based on non-idempotent intersection types to characterize termination properties in functional programming languages with pattern matching (Quote 1). This is a key theoretical contribution as it provides a new framework for understanding termination.
 - The work extends existing pattern calculi by incorporating tagged products and case expressions, which are essential for modeling algebraic data types (ADTs) (Quote 2). This is a significant theoretical advancement as it enhances the expressiveness of the calculus.
 - The paper provides a detailed operational treatment of the λ c -calculus, including a new evaluation strategy (Quote 3). This contributes to a deeper understanding of the operational semantics of pattern matching.
 - The introduction of a non-idempotent intersection type system (Quote 4) is a theoretical innovation that allows for quantitative characterization of termination.
 - The paper achieves a quantitative characterization of termination, linking typability with termination and providing upper bounds for evaluation steps (Quotes 5 and 6). This is a novel insight into the quantitative semantics of programming languages.
 - The work ensures that well-typed programs are clash-free, which is a significant theoretical contribution to programming language design (Quote 8)."
Dagstuhl Seminar Expressiveness in Concurrency,"R. Nicola, U. Goltz, F. Vaandrager",-,-,-,0,2008,"1. Primitive Name: Communication Primitives
  Definition: Synchronous vs asynchronous
  Orthogonality Score: Not specified
 2. Primitive Name: Nondeterministic Choice
  Definition: Internal vs external
  Orthogonality Score: Not specified
 3. Primitive Name: Semantic Models
  Definition: Process algebras, Petri nets, modal logics, rewrite systems
  Orthogonality Score: Not specified
 4. Primitive Name: Semantics Approaches
  Definition: Algebraic, axiomatic, operational, denotational
  Orthogonality Score: Not specified","- Type of mathematical framework: Process algebras, Petri nets, modal logics, rewrite systems
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Systematic study and formal comparison of expressive power of programming concepts for parallel and distributed systems.
 - Theoretical advancements: Definition of a general framework for comparing formal methods across programming paradigms, with a focus on process algebras; understanding interconnections between programming concepts.
 - Potential implications: Improved understanding of concurrent systems semantics could inform design principles for concurrent programming languages.","- ""the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external);""
  - ""the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""
  - ""the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems),""",,"- The abstract mentions ""primitives for communication"" and ""nondeterministic choice,"" which are conceptual primitives related to how systems interact and make decisions.
 - The abstract specifies these primitives as ""synchronous vs asynchronous"" for communication and ""internal vs external"" for nondeterministic choice, providing a clear definition for each.
 - The abstract also discusses different semantic models and their focus on ""causal and temporal dependencies,"" which are related to how systems are understood and analyzed.
 - The abstract does not provide a detailed definition or orthogonality score for these primitives, nor does it explicitly state them as part of a formal framework or methodology.
 - The abstract does not mention any specific level of abstraction or orthogonality for these primitives.","- ""The different talks and the lively discussion offered the occasion for comparing specification and verification methods, developed various programming paradigms, and threw light on: • the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external); • the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems), • the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""
  - ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""
  - ""A systematic study and a formal comparison is even more needed in the case of formalisms for programming or specifying parallel and distributed systems.""
  - ""the development of formal methods for the design and implementation of programming languages.""
  - ""the problem of the relative expressive power of the various programming concepts has rarely been addressed systematically.""",,"- The abstract discusses the development of formal methods for programming languages, which implies a focus on theoretical foundations.
 - It mentions the need for a systematic study and formal comparison of formalisms for parallel and distributed systems, suggesting a framework for comparison.
 - The final objective is to define a general framework for comparing formal methods, particularly focusing on process algebras, which is a type of mathematical framework.
 - The abstract highlights the discussion on various semantic models such as process algebras, Petri nets, modal logics, and rewrite systems, indicating a focus on these mathematical frameworks.
 - It also mentions different approaches to concurrent systems semantics, such as algebraic, axiomatic, operational, and denotational, which are types of mathematical frameworks.
 - However, the abstract does not specify the exact mathematical properties guaranteed, proof techniques used, or limitations of these frameworks.","- ""The different talks and the lively discussion offered the occasion for comparing specification and verification methods, developed various programming paradigms, and threw light on: • the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external); • the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems), • the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""
  - ""The seminar gave the possibility to compare results of the project with related approaches.""
  - ""The main aim of the seminar, organized within the program of the HCM-network EXPRESS, was a better understanding of the interconnections and relations between programming concepts, constructs, models and logics for concurrent specification and implementation languages.""
  - ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""",,"- The abstract mentions the aim of understanding interconnections and relations between programming concepts, which suggests a focus on integration.
 - The objective of defining a general framework for comparing formal methods across paradigms implies a theoretical integration strategy.
 - The seminar provided a platform for comparing specification and verification methods across paradigms, indicating interaction models between paradigms.
 - The discussion on primitives for communication and semantic models suggests constraints or challenges in paradigm integration.
 - However, the abstract does not explicitly mention specific integration mechanisms, novel translation techniques, or detailed constraints.","- ""the problem of the relative expressive power of the various programming concepts has rarely been addressed systematically.""
  - ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""
  - ""the development of formal methods for the design and implementation of programming languages.""
  - ""The main aim of the seminar, organized within the program of the HCM-network EXPRESS, was a better understanding of the interconnections and relations between programming concepts, constructs, models and logics for concurrent specification and implementation languages.""
  - ""The different talks and the lively discussion offered the occasion for comparing specification and verification methods, developed various programming paradigms, and threw light on: • the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external); • the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems), • the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""",,"- The abstract discusses the development of formal methods for programming languages and the comparison of their expressive power, but it does not specifically mention generic programming or abstraction mechanisms.
 - The focus is on understanding interconnections between programming concepts and models for concurrent systems, which does not directly relate to generic programming or abstraction mechanisms.
 - The abstract mentions process algebras and other semantic models, but these are not explicitly linked to generic programming or abstraction mechanisms.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract.","- ""the problem of the relative expressive power of the various programming concepts has rarely been addressed systematically.""
  - ""A systematic study and a formal comparison is even more needed in the case of formalisms for programming or specifying parallel and distributed systems.""
  - ""The main aim of the seminar, organized within the program of the HCM-network EXPRESS, was a better understanding of the interconnections and relations between programming concepts, constructs, models and logics for concurrent specification and implementation languages.""
  - ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""
  - ""The seminar gave the possibility to compare results of the project with related approaches.""
  - ""The different talks and the lively discussion offered the occasion for comparing specification and verification methods, developed various programming paradigms, and threw light on: • the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external); • the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems), • the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""",,"- The abstract highlights a significant gap in the field: the lack of systematic study and formal comparison of the expressive power of programming concepts, particularly for parallel and distributed systems. This indicates a novel insight into the need for such a systematic approach.
 - The seminar aimed to provide a better understanding of the interconnections between various programming concepts, which suggests a theoretical advancement in understanding these relationships.
 - The final objective of defining a general framework for comparing formal methods across programming paradigms, with a focus on process algebras, represents a theoretical contribution by providing a structured approach to comparison.
 - The seminar facilitated comparisons with related approaches, which implies a theoretical advancement in understanding the relative merits of different semantic models and approaches to concurrent systems semantics.
 - The discussion on primitives for communication and nondeterministic choice, as well as the emphasis on causal and temporal dependencies, suggests novel insights into these aspects of concurrent systems.
 - The abstract does not explicitly mention potential implications for programming language design, but the focus on understanding and comparing formal methods implies potential contributions to designing more effective concurrent programming languages."
Adaptation of a Refactoring DSL for the Object-Oriented Paradigm,"D. J. Németh, Dániel Horpácsi, M. Tejfel",10.14232/ACTACYB.284280,https://doi.org/10.14232/ACTACYB.284280,Acta Cybernetica,0,2021,"1. Primitive Name: Local Refactoring Scheme
  Definition: Used to define simple, block-local refactorings on the level of single expressions and statements.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Block Refactoring Scheme
  Definition: An extension to the local scheme for refactoring entire code blocks.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Lambda Refactoring Scheme
  Definition: For lambda functions, practical for acting as data or code.
  Orthogonality Score: Not specified
 

 4. Primitive Name: Class Refactoring Scheme
  Definition: Designed for refactorings that modify classes and class members.
  Orthogonality Score: Not specified","- Type of mathematical framework: Operational semantics embedded into reachability logic
 - Specific mathematical properties guaranteed: Soundness, preservation of behavior through refactoring
 - Proof techniques used: Two-fold verification (manual and automatic)
 - Limitations or constraints of the framework: Sound but not necessarily complete","- Specific integration mechanisms proposed: Multilayered definition of equivalence for Java programs; high-level, reusable refactoring schemes.
 - Interaction models between paradigms: Semantic functions and predicates related to the target paradigm for describing transformation preconditions.
 - Constraints or challenges in paradigm integration: Complexity of term rewriting; need for high-level schemes for verifiability.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"- Novel multilayered definition of equivalence for Java programs.
 - Adaptation of an existing domain-specific language to the object-oriented paradigm.
 - Introduction of new semantic functions and predicates related to object-oriented abstractions.
 - Proposal for intra- and interhierarchy-reachability definitions.
 - Aim to make the framework more language-agnostic.","- ""The main contributions of this paper are the following:
 

 • A multilayered definition of equivalence for Java programs, used to characterize the behavior-preserving property of discussed refactorings.""
  - ""The basis of our work is an existing domain-specific language which makes it possible to define executable and verifiable refactorings using syntactic code patterns over the to-be-refactored language""
  - ""The core of the description language is conditional term rewriting -a powerful tool for specifying program transformations based on syntactic patterns.""
  - ""The problem with term rewriting, however, is that it is a low-level approach which makes definitions of complex refactorings complicated and error prone, especially in the case of extensive transformations with many compensational modifications""
  - ""To make refactoring definitions safer and even verifiable, the discussed method restricts the set of possible transformations by introducing highlevel, reusable refactoring schemes.""
  - ""The provided schemes already contain the necessary control logic, and only have to be parameterized by term rewrite rules to yield concrete microrefactorings.""
  - ""In this section, we present a case study where we identify new schemes based on the bottom-up method.""
  - ""To define a scheme, we have to provide its name, potential clauses, rewrite control logic, preconditions and contracts.""
  - ""Local refactoring scheme. The local scheme can be used to define simple, block-local refactorings on the level of single expressions and statements.""
  - ""Block refactoring scheme. The block scheme can be seen as an extension to the local one.""
  - ""Lambda refactoring scheme. As Schäfer et al. [15] suggest in their work, lambda functions are practical because of their ability to act either as data or as code,""
  - ""Class refactoring scheme. The class scheme was designed for refactorings that modify classes and class members.""",,"- The paper discusses the adaptation of a domain-specific language for refactoring from the functional to the object-oriented paradigm, specifically using Java.
 - The main conceptual primitives defined in the paper are related to the refactoring schemes, which are high-level, reusable patterns for specifying program transformations.
 - The paper identifies four types of refactoring schemes: local, block, lambda, and class. These schemes are designed to capture different levels of abstraction and complexity in refactoring operations.
 - The local scheme is for simple, block-local refactorings; the block scheme extends this for entire code blocks; the lambda scheme is for lambda functions; and the class scheme is for class modifications.
 - These schemes are orthogonal in that they address different aspects of refactoring and can be combined to achieve more complex transformations.
 - The paper does not provide a specific orthogonality score but implies that these schemes are designed to be orthogonal by addressing different levels and types of refactoring.","- ""The basis of this method is the operational semantics of the target language, which is embedded into reachability logic [14].""
  - ""Then, scheme instances are examined whether the concrete rewrite rules used in them satisfy the contract of the instantiated scheme.""
  - ""The verification process is two-fold. At first, the provided refactoring schemes are manually verified based on assertions concerning their rewrite rule parameters, collectively called the contract of the scheme.""
  - ""The proposed proof system is sound, but not necessarily complete, however, as neither the to-be-adapted refactoring language, nor our adaptation aims for completeness, the soundness of the verification backend can be considered adequate in both cases.""
  - ""the formal method presented by Ciobaca et al. [4] can be applied to carry out the verification automatically with the correct tooling.""",,"- The paper discusses a two-fold verification process, which involves manual verification of refactoring schemes and automatic verification of scheme instances. This suggests a structured approach to ensuring the properties of the refactoring language.
 - The use of ""operational semantics"" and ""reachability logic"" indicates that the mathematical framework is based on these concepts. Operational semantics is a way to describe the meaning of programming languages, and reachability logic is a formal method for proving properties about programs.
 - The mention of a ""sound, but not necessarily complete"" proof system suggests that the framework guarantees soundness, meaning that if a proof is accepted, it is correct, but it may not be able to prove all true statements.
 - The framework is described as being based on the operational semantics of the target language, which is embedded into reachability logic. This provides a specific mathematical property guaranteed by the framework: the preservation of behavior through refactoring.
 - The limitations or constraints of the framework are noted as being sound but not necessarily complete, indicating that while it ensures correctness, it may not cover all possible cases.","- ""The goal of our research was to investigate whether this method could be applied to other paradigms and languages. Since one of today's most popular paradigm is OOP, we have chosen it as our target, and selected Java as its representative due to its high-level nature and widespread support.""
  - ""The main motivation behind this paper is to recreate the existing framework for a significantly different target language, ultimately achieving another step towards making it more language-agnostic.""
  - ""The basis of our work is an existing domain-specific language which makes it possible to define executable and verifiable refactorings using syntactic code patterns over the to-be-refactored language""
  - ""The main contributions of this paper are the following:
 

 • A multilayered definition of equivalence for Java programs, used to characterize the behavior-preserving property of discussed refactorings.""
  - ""The problem with term rewriting, however, is that it is a low-level approach which makes definitions of complex refactorings complicated and error prone, especially in the case of extensive transformations with many compensational modifications""
  - ""To make refactoring definitions safer and even verifiable, the discussed method restricts the set of possible transformations by introducing highlevel, reusable refactoring schemes.""",,"- The paper discusses adapting a domain-specific language (DSL) from the functional programming paradigm to the object-oriented programming (OOP) paradigm, specifically using Java as a representative language.
 - The integration approach involves creating a multilayered definition of equivalence for Java programs to ensure behavior-preserving transformations.
 - The paper introduces high-level, reusable refactoring schemes to make definitions safer and verifiable, which is a key mechanism for integrating different paradigms.
 - The study involves identifying new transformation schemes and modifying the description language to accommodate these schemes, which is part of the integration process.
 - The paper also discusses semantic functions and predicates related to the target paradigm, which are used to describe transformation preconditions, indicating an interaction model between paradigms.
 - The challenges in paradigm integration include the complexity of term rewriting and the need for high-level schemes to ensure verifiability.
 - The paper does not explicitly mention novel translation or embedding techniques but focuses on adapting existing frameworks to new paradigms.","- ""The main contributions of this paper are the following:
 

 • A multilayered definition of equivalence for Java programs, used to characterize the behavior-preserving property of discussed refactorings.""
  - ""The basis of our work is an existing domain-specific language which makes it possible to define executable and verifiable refactorings using syntactic code patterns over the to-be-refactored language""
  - ""The core of the description language is conditional term rewriting -a powerful tool for specifying program transformations based on syntactic patterns.""
  - ""The problem with term rewriting, however, is that it is a low-level approach which makes definitions of complex refactorings complicated and error prone, especially in the case of extensive transformations with many compensational modifications""
  - ""To make refactoring definitions safer and even verifiable, the discussed method restricts the set of possible transformations by introducing highlevel, reusable refactoring schemes.""
  - ""Microrefactorings defined as scheme instances can then be composed to obtain more complex transformations.""
  - ""The verification process is two-fold. At first, the provided refactoring schemes are manually verified based on assertions concerning their rewrite rule parameters, collectively called the contract of the scheme.""
  - ""The chosen formal model is the operational semantics of the target language, which makes it possible to mathematically reason about the execution of programs, e.g. by symbolically computing the possible outputs and side effects of a given function.""
  - ""The basis of this method is the operational semantics of the target language, which is embedded into reachability logic""
  - ""The proposed proof system is sound, but not necessarily complete, however, as neither the to-be-adapted refactoring language, nor our adaptation aims for completeness, the soundness of the verification backend can be considered adequate in both cases.""",,"- The paper primarily focuses on adapting a refactoring DSL from a functional to an object-oriented paradigm, specifically using Java as a representative language.
 - The concept of ""concept"" in this context is related to the idea of refactoring schemes, which are high-level, reusable patterns for transformations.
 - Mechanisms for representing generic abstractions include the use of conditional term rewriting and the introduction of high-level, reusable refactoring schemes.
 - Minimal type requirements are not explicitly discussed in terms of generic programming, but the paper does mention the use of operational semantics and reachability logic for verification.
 - Static checking or optimization strategies are implied through the manual verification of refactoring schemes and the use of operational semantics for mathematical reasoning about program execution.","- ""The main contributions of this paper are the following:
 

 • A multilayered definition of equivalence for Java programs, used to characterize the behavior-preserving property of discussed refactorings.""
  - ""A case study which shows how new transformation schemes can be identified from a complex refactoring rule, along with modifications and extensions of the description language required to accommodate them.""
  - ""Semantic functions and predicates related to abstractions of the target paradigm, which we use to describe transformation preconditions.""
  - ""The basis of our work is an existing domain-specific language which makes it possible to define executable and verifiable refactorings using syntactic code patterns over the to-be-refactored language""
  - ""The main motivation behind this paper is to recreate the existing framework for a significantly different target language, ultimately achieving another step towards making it more language-agnostic.""
  - ""we propose to replace the aforementioned definition of equivalence with one of its -more easily specifiable -characterizations, e.g. the preservation of data flow, control flow and binding, as suggested by Schäfer et al.""
  - ""we introduce several, generally stricter variants of it, specialized for the possible types of transformation scopes.""
  - ""we propose the following definitions about the so-called intra-and interhierarchy-reachability of a predefinition.""
  - ""Based on the case study, we conclude that the first steps towards adapting the scheme-based refactoring approach to OOP have been successful: we were able to express a complex Java refactoring in the modified language.""",,"- The paper introduces a novel multilayered definition of equivalence for Java programs, which is a significant theoretical contribution as it provides a more nuanced understanding of behavior preservation in refactorings.
 - The adaptation of an existing domain-specific language to the object-oriented paradigm is a theoretical advancement, as it extends the applicability of the language to a new paradigm.
 - The introduction of new semantic functions and predicates related to object-oriented abstractions is a theoretical contribution, as it enhances the language's ability to describe transformation preconditions accurately.
 - The proposal for intra- and interhierarchy-reachability definitions is a novel theoretical contribution, as it addresses the complexity of object-oriented systems and their dynamic aspects.
 - The paper's focus on making the framework more language-agnostic is a theoretical advancement, as it aims to generalize the approach beyond specific languages."
Execution models for Constraint Programming: kernel language design through semantics equivalence. . (Modèles d'exe'cution pour la programmation par contraintes : conception d'un langage noyau par le biais d'e'quivalences se'mantiques),Thierry Martinez,-,-,-,0,2015,"1. Primitive Name: Constraint Handling Rules (CHR)
  Definition: A language for constraint programming that can be semantically equivalent to LLCC.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Linear Logic Concurrent Constraint (LLCC)
  Definition: A language for concurrent constraint programming that can be semantically equivalent to CHR.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Search Procedures
  Definition: Internalized within constraint models with a fixed enumeration strategy.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Primitive Synchronization Mechanism
  Definition: Part of a kernel language sufficient to reconstruct other forms of synchronizations.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Elementary Constraint System
  Definition: Part of a kernel language sufficient to reconstruct other constraint systems.
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention a specific mathematical framework),"- Specific integration mechanisms proposed: Program transformations between CHR and LLCC languages; internalizing search procedures in the constraint model.
 - Interaction models between paradigms: Integration of logic programming and constraint programming through semantics equivalence; internalization of search procedures in constraint models.
 - Constraints or challenges in paradigm integration: Hierarchy of non-equivalent semantics in concurrent constraint logic programming.
 - Novel translation or embedding techniques: Transforming search procedures into constraint satisfaction problems; using a reification-based constraint kernel for compilation.",Generic programming not extensively addressed,"- Key novel insights: Integration of control and search into logic or constraint models while preserving semantics; internalization of search procedures within the constraint model.
 - Theoretical advancements: Semantic equivalences between CHR and LLCC languages, and between constraint logic programs and constraint models; identification of a kernel language with primitive synchronization and elementary constraint system.
 - Potential implications for programming language design: Modular and flexible systems with easily integrable or replaceable components.","- ""First, we show that simple program transformations exist back and forth be- tween Constraint Handling Rules (CHR) and Linear Logic Concurrent Constraint (LLCC) languages, making them semantically equivalent even if syntactically dif- ferent,""
  - ""The main consequence of this collapse is the identification of a kernel language, with a primitive synchronization mechanism and an elementary constraint system which are sufficient to reconstruct the other forms of synchronizations and other constraint systems as modules,""
  - ""Execution models result from the operational interpretation of logical provability in logic programming, and of constraint propagation in constraint programming.""
  - ""Secondly, we show that a wide variety of search procedures can be internalized in the constraint model with a fixed enumeration strategy.""
  - ""Finally, in concurrent constraint logic programming, committed-choice semantics create a hierarchy of non-equivalent semantics axed on the expressive power of synchronization mechanism.""
  - ""The three parts of the thesis correspond to the three semantics equivalence that are showed: the first between two committed-choice forward-chaining logic languages, the second between constraint logic programs and constraint models, and the third between guard semantics in angelic settings.""",,"- The abstract discusses the operational interpretation of logical provability and constraint propagation, which are foundational concepts in logic and constraint programming.
 - It mentions three semantics equivalences, which are central to the study's methodology and theoretical framework.
 - The first equivalence involves transformations between Constraint Handling Rules (CHR) and Linear Logic Concurrent Constraint (LLCC) languages, indicating these as conceptual primitives for reconstructing programming paradigms.
 - The second equivalence involves internalizing search procedures within constraint models, suggesting that search strategies are also considered as primitives.
 - The third equivalence discusses guard semantics in angelic settings, which relates to synchronization mechanisms.
 - The abstract concludes with the identification of a kernel language featuring a primitive synchronization mechanism and an elementary constraint system, which are proposed as conceptual primitives for reconstructing other forms of synchronizations and constraint systems.","- ""Execution models result from the operational interpretation of logical provability in logic programming, and of constraint propagation in constraint programming.""
  - ""The three parts of the thesis correspond to the three semantics equivalence that are showed: the first between two committed-choice forward-chaining logic languages, the second between constraint logic programs and constraint models, and the third between guard semantics in angelic settings.""
  - ""Each of these equivalence is constructive in the sense that there exists an encoding that enables the compilation from one of the paradigm to the other.""
  - ""First, we show that simple program transformations exist back and forth be- tween Constraint Handling Rules (CHR) and Linear Logic Concurrent Constraint (LLCC) languages, making them semantically equivalent even if syntactically dif- ferent,""
  - ""Secondly, we show that a wide variety of search procedures can be internalized in the constraint model with a fixed enumeration strategy.""
  - ""Finally, in concurrent constraint logic programming, committed-choice semantics create a hierarchy of non-equivalent semantics axed on the expressive power of synchronization mechanism.""",,"- The abstract discusses the operational interpretation of logical provability and constraint propagation, which suggests a focus on formal semantics rather than a specific mathematical framework like type theory or category theory.
 - The mention of ""semantics equivalence"" and ""constructive"" encodings implies a focus on formal verification and proof techniques, but it does not specify a particular mathematical framework.
 - The abstract does not explicitly mention any specific mathematical framework such as type theory or category theory.
 - The focus on semantics equivalence and constructive encodings suggests a theoretical foundation in formal semantics, but the abstract does not provide details on the type of mathematical framework used.","- ""Logic programming and constraint programming are two declarative programming paradigms which rely on the identification of programs to theories, and program- ming to modeling.""
  - ""Execution models result from the operational interpretation of logical provability in logic programming, and of constraint propagation in constraint programming.""
  - ""The three parts of the thesis correspond to the three semantics equivalence that are showed: the first between two committed-choice forward-chaining logic languages, the second between constraint logic programs and constraint models, and the third between guard semantics in angelic settings.""
  - ""First, we show that simple program transformations exist back and forth be- tween Constraint Handling Rules (CHR) and Linear Logic Concurrent Constraint (LLCC) languages, making them semantically equivalent even if syntactically dif- ferent,""
  - ""Secondly, we show that a wide variety of search procedures can be internalized in the constraint model with a fixed enumeration strategy.""
  - ""Transforming search procedures into constraint satisfaction problems presents several advantages: (1) it makes search strategies declarative and modeled as constraint satisfaction problems; (2) it makes it possible to express search strategies in existing front-end modeling languages without any extension; (3) it opens up constraint propagation algorithms to search constraints and to the implementation of novel search procedures based on constraint propagation.""
  - ""Finally, in concurrent constraint logic programming, committed-choice semantics create a hierarchy of non-equivalent semantics axed on the expressive power of synchronization mechanism.""
  - ""We show that the hierarchy of guard semantics col- lapses with angelic semantics, allowing the most primitive synchronization mechanism to encode all the others.""",,"- The abstract discusses the integration of logic programming and constraint programming paradigms by focusing on execution models and semantics equivalence.
 - The study proposes specific integration mechanisms such as showing that simple program transformations exist between Constraint Handling Rules (CHR) and Linear Logic Concurrent Constraint (LLCC) languages, making them semantically equivalent.
 - The interaction model involves internalizing search procedures within the constraint model, which allows for declarative modeling of search strategies and integration with existing front-end modeling languages.
 - The abstract mentions constraints or challenges in paradigm integration by highlighting the hierarchy of non-equivalent semantics in concurrent constraint logic programming, which is addressed by collapsing guard semantics with angelic semantics.
 - Novel translation or embedding techniques include transforming search procedures into constraint satisfaction problems and using a reification-based constraint kernel for compilation.","- ""Execution models result from the operational interpretation of logical provability in logic programming, and of constraint propagation in constraint programming.""
  - ""The three parts of the thesis correspond to the three semantics equivalence that are showed: the first between two committed-choice forward-chaining logic languages, the second between constraint logic programs and constraint models, and the third between guard semantics in angelic settings.""
  - ""Each of these equivalence is constructive in the sense that there exists an encoding that enables the compilation from one of the paradigm to the other.""
  - ""First, we show that simple program transformations exist back and forth be- tween Constraint Handling Rules (CHR) and Linear Logic Concurrent Constraint (LLCC) languages, making them semantically equivalent even if syntactically dif- ferent,""
  - ""Secondly, we show that a wide variety of search procedures can be internalized in the constraint model with a fixed enumeration strategy.""
  - ""Transforming search procedures into constraint satisfaction problems presents several advantages: (1) it makes search strategies declarative and modeled as constraint satisfaction problems; (2) it makes it possible to express search strategies in existing front-end modeling languages without any extension; (3) it opens up constraint propagation algorithms to search constraints and to the implementation of novel search procedures based on constraint propagation.""
  - ""Finally, in concurrent constraint logic programming, committed-choice semantics create a hierarchy of non-equivalent semantics axed on the expressive power of synchronization mechanism.""
  - ""We show that the hierarchy of guard semantics col- lapses with angelic semantics, allowing the most primitive synchronization mechanism to encode all the others.""",,"- The abstract discusses execution models and semantics equivalences in constraint programming, which involves abstracting concepts and representing them in different forms.
 - The mention of ""semantics equivalence"" and ""constructive encoding"" suggests a focus on abstracting concepts to enable compilation between different paradigms.
 - The transformation of search procedures into constraint satisfaction problems indicates a mechanism for representing generic abstractions by making search strategies declarative.
 - The abstract does not explicitly mention ""generic programming"" or ""type system discussions,"" but it implies abstraction mechanisms through the equivalence and encoding processes.
 - There is no explicit mention of minimal type requirements or static checking strategies in the abstract.","- ""This thesis investigates execution models in which control and search can be shifted into the logic or the constraint model, while preserving the semantics.""
  - ""The three parts of the thesis correspond to the three semantics equivalence that are showed: the first between two committed-choice forward-chaining logic languages, the second between constraint logic programs and constraint models, and the third between guard semantics in angelic settings.""
  - ""First, we show that simple program transformations exist back and forth be- tween Constraint Handling Rules (CHR) and Linear Logic Concurrent Constraint (LLCC) languages, making them semantically equivalent even if syntactically dif- ferent,""
  - ""Secondly, we show that a wide variety of search procedures can be internalized in the constraint model with a fixed enumeration strategy.""
  - ""Finally, in concurrent constraint logic programming, committed-choice semantics create a hierarchy of non-equivalent semantics axed on the expressive power of synchronization mechanism.""
  - ""We show that the hierarchy of guard semantics col- lapses with angelic semantics, allowing the most primitive synchronization mechanism to encode all the others.""
  - ""The main consequence of this collapse is the identification of a kernel language, with a primitive synchronization mechanism and an elementary constraint system which are sufficient to reconstruct the other forms of synchronizations and other constraint systems as modules,""",,"- The thesis explores new execution models where control and search are integrated into the logic or constraint model, which is a novel approach to maintaining semantics.
 - It establishes semantic equivalences between different programming paradigms, such as between CHR and LLCC languages, and between constraint logic programs and constraint models. This is a theoretical advancement as it shows that these languages can be transformed into each other while preserving their meaning.
 - The study demonstrates that search procedures can be internalized within the constraint model, making search strategies declarative and modeled as constraint satisfaction problems. This is a key novel insight as it simplifies the expression of search strategies and opens up new possibilities for constraint propagation algorithms.
 - The thesis identifies a kernel language with a primitive synchronization mechanism and an elementary constraint system that can encode other forms of synchronizations and constraint systems. This is a significant theoretical contribution as it provides a foundational framework for designing programming languages.
 - The potential implications for programming language design include the ability to create more flexible and modular systems, where different components can be easily integrated or replaced without affecting the overall semantics."
iTask as a New Paradigm for Building GUI Applications,"Steffen Michels, M. J. Plasmeijer, P. Achten",10.1007/978-3-642-24276-2_10,https://doi.org/10.1007/978-3-642-24276-2_10,International Symposium on Implementation and Application of Functional Languages,10,2010,"1. Primitive Name: Workflow Definition
  Definition: A definition in which interactive elements are defined by editors on model values.
  Orthogonality Score: High
 

 2. Primitive Name: Basic Tasks
  Definition: Atomic actions like updateInformation, enterInformation, and enterChoice.
  Orthogonality Score: High
 

 3. Primitive Name: TaskAction
  Definition: A type that adds identification and predicates to task actions.
  Orthogonality Score: High
 

 4. Primitive Name: GUI Elements
  Definition: Dynamically opening and closing windows, organizing user actions into buttons and menus.
  Orthogonality Score: High",Not specified (the paper does not explicitly mention a specific mathematical framework or formal verification details),"- Specific integration mechanisms proposed: Orthogonal extension of the iTask system to include GUI programming features such as windows, menus, and dynamic task management.
 - Interaction models between paradigms: Declarative definitions of dependencies between application state and user interface using predicates and views.
 - Constraints or challenges in paradigm integration: Retaining the level of abstraction offered by the iTask system.
 - Any novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"" used: The iTask system uses a combinator library to define workflows, which is a form of generic abstraction.
 - Mechanisms for representing generic abstractions: The iTask system uses type classes (e.g., iTask) to automatically perform conversions and manage state.
 - Minimal type requirements identified: The compiler can automatically derive certain types.
 - Static checking or optimization strategies: The system uses static checking through type classes and automatic derivation of types.","- Key novel insights: Declarative programming of GUI applications focusing on data and processes; use of predicates and views to manage dependencies between application state and user interface.
 - Theoretical advancements: Extension of the iTask system to support GUI programming; declarative definition of control flow; automatic generation and management of GUIs and execution state.
 - Potential implications for programming language design: Simplification of GUI programming by focusing on high-level abstractions; potential for more flexible and customizable GUI design through fine-grained annotations.","- ""The iTask system is a combinator library written in Clean offering a declarative, domain-specific language for defining workflows.""
  - ""In the iTask paradigm, a workflow is a definition in which interactive elements are defined by editors on model values (abstracting from concrete GUI implementation details).""
  - ""Defining interactive elements and the order of their appearance are also major concerns when programming GUI applications.""
  - ""The extensions are fundamental GUI elements: windows that can be dynamically opened and closed, and user actions that are (dynamically) organized in buttons and menus.""
  - ""The iTask library consists of basic tasks, representing the atomic actions the user can take, which can be composed to build complex workflows using combinators.""
  - ""The basic task updateInformation generates a form for a value of type a.""
  - ""The function enterInformation is the same except that the system generates a form with blank fields for entering a value of type a.""
  - ""The function enterChoice lets the user choose a value from a list of options.""
  - ""The type TaskAction a is defined in the library: Instead of using only text labels, a list of task actions given to the editor task updateInformationActions adds an identification (ActionID) and a predicate (Selectable a) to each label.""
  - ""The extensions are orthogonal to the iTask system, i.e. they do not alter existing workflow applications.""
  - ""The final part to discuss is to decide the rendering of the tasks replace and edit. For this purpose we introduce a new instance for the task annotation operator By annotating a task as Fixed, it displays its content in a fixed window; Floating tasks can be moved around by the user, and Modal tasks are shown in a modal dialog, forcing the user the finish this task before any other.""",,"- The paper discusses the iTask system as a combinator library for defining workflows, which is a conceptual primitive for workflow management.
 - Interactive elements are defined by editors on model values, abstracting from concrete GUI implementation details, which is a conceptual primitive for GUI programming.
 - The paper introduces fundamental GUI elements such as dynamically opening and closing windows and organizing user actions into buttons and menus, which are conceptual primitives for GUI programming.
 - Basic tasks like updateInformation, enterInformation, and enterChoice are atomic actions that can be composed to build complex workflows, indicating they are conceptual primitives for workflow construction.
 - The type TaskAction a is a conceptual primitive for defining actions with identification and predicates, enhancing the declarative nature of the system.
 - The orthogonality of these primitives is highlighted by their ability to extend the iTask system without altering existing workflow applications, indicating a high level of abstraction and orthogonality.","- ""The iTask system is a monadic combinator library for specifying workflows.""
  - ""The type class SharedVariable contains a new generic function that takes care of the automatic update of registered views whenever a shared value is modified.""
  - ""The system automatically creates proper GUIs, stores intermediate results, and keeps track of the execution state.""
  - ""Dependencies between the application's state and the user interface are declaratively defined using predicates and views.""
  - ""The iTask paradigm lets the programmer concentrate on defining the workflow processes and the data involved. The generic machinery takes care of building and handling forms, storing intermediate results, and keeping track of the application state.""",,"- The paper describes the iTask system as a ""monadic combinator library,"" which suggests a connection to type theory, as monads are a concept within type theory used to manage side effects in functional programming.
 - The mention of ""generic machinery"" and ""type class SharedVariable"" indicates the use of generic programming techniques, which are often formalized using type theory.
 - The paper discusses the automatic update of views and the declarative definition of dependencies using predicates and views, which implies a formal framework for ensuring consistency and correctness.
 - However, the paper does not explicitly mention a specific mathematical framework like type theory or category theory, nor does it detail specific mathematical properties guaranteed or proof techniques used.
 - The focus is more on the practical application and extension of the iTask system for GUI programming rather than on the theoretical foundations or formal verification.","- ""The iTask system is a combinator library written in Clean offering a declarative, domain-specific language for defining workflows.""
  - ""the iTask paradigm is potentially suited to program GUI applications as well.""
  - ""In this paper, we identify these key features and show how they can be added to the iTask system in an orthogonal way, thus creating a new paradigm for programming GUI applications.""
  - ""The extensions are orthogonal to the iTask system, i.e. they do not alter existing workflow applications.""
  - ""The iTask paradigm lets the programmer concentrate on defining the workflow processes and the data involved.""
  - ""The generic machinery takes care of building and handling forms, storing intermediate results, and keeping track of the application state.""
  - ""We have shown that the workflow-based iTask system can be used as a paradigm for building GUI applications.""
  - ""One design goal was to retain the level of abstraction as offered by the iTask system.""
  - ""Dependencies between the application's state and the user interface are declaratively defined using predicates and views.""",,"- The paper discusses the integration of the iTask system, originally designed for workflow management, with GUI programming. This is a form of paradigm integration where a declarative, domain-specific language for workflows is extended to support GUI applications.
 - The integration is described as ""orthogonal,"" meaning that the extensions do not alter existing workflow applications. This suggests a modular approach to integration where new features are added without disrupting the existing paradigm.
 - The paper emphasizes the retention of abstraction levels and the use of declarative definitions for dependencies between application state and user interface. This indicates a focus on maintaining a high level of abstraction in the integration process.
 - The integration involves adding features such as windows, menus, and dynamic task management to the iTask system, which are typical of GUI programming paradigms.
 - The paper does not explicitly mention novel translation or embedding techniques but focuses on the extension of the iTask system to accommodate GUI programming features.","- ""The iTask system is a combinator library written in Clean offering a declarative, domain-specific language for defining workflows.""
  - ""Due to the use of generic programming techniques, an iTask programmer does not need to worry about boilerplate programming, such as the handling of the communication between client and server, and the form rendering and handling of form updates on the browser.""
  - ""the iTask paradigm allows the programmer of a workflow to fully concentrate on its logic: the description of tasks and the dependencies between them.""
  - ""The generic machinery takes care of building and handling forms, storing intermediate results, and keeping track of the application state.""
  - ""The iTask library consists of basic tasks, representing the atomic actions the user can take, which can be composed to build complex workflows using combinators.""
  - ""The iTask system automatically performs the necessary conversions, using generic functions for serialisation, generating user interfaces, updating and verifying values included in the type class iTask.""
  - ""The compiler can derive them automatically.""
  - ""The system automatically creates proper GUIs, stores intermediate results, and keeps track of the execution state.""
  - ""Dependencies between the application's state and the user interface are declaratively defined using predicates and views.""",,"- The paper discusses the use of generic programming techniques in the iTask system, which allows programmers to focus on workflow logic without worrying about boilerplate code.
 - The iTask system uses a combinator library to define workflows, which is a form of generic abstraction.
 - The generic machinery handles tasks such as form rendering, communication, and state management, indicating a high level of abstraction.
 - The system uses type classes (e.g., iTask) to automatically perform conversions and manage state, which is a mechanism for representing generic abstractions.
 - The compiler can automatically derive certain types, suggesting a level of static checking or optimization.
 - The paper emphasizes declarative definitions of dependencies between state and user interface, which is a conceptual abstraction mechanism.","- ""In this paper, we identify these key features and show how they can be added to the iTask system in an orthogonal way, thus creating a new paradigm for programming GUI applications.""
  - ""The contributions of this paper are:
 

 -We show that the iTask system can be extended to support programming GUI applications. The result is a new paradigm for programming GUI applications in a declarative way, i.e., only data and processes (tasks) need to be defined.""
  - ""Having the possibility to define the control flow in a declarative way is a unique advantage of the iTask paradigm.""
  - ""One design goal was to retain the level of abstraction as offered by the iTask system. When defining GUI applications, programmers only have to define the processed data and the application's control flow in the same spirit as with the 'original' iTask system.""
  - ""Dependencies between the application's state and the user interface are declaratively defined using predicates and views.""
  - ""The system automatically creates proper GUIs, stores intermediate results, and keeps track of the execution state.""
  - ""Although generically generated GUIs are very powerful, for some applications one might want to influence the layout more precisely. One direction for future work is to develop a way to influence the layout with more fine-grained annotations in the same spirit as done for menus.""",,"- The paper introduces a new paradigm for programming GUI applications by extending the iTask system, which is a significant theoretical contribution. This paradigm allows for declarative programming of GUI applications, focusing on data and processes rather than low-level implementation details.
 - The iTask paradigm's ability to define control flow in a declarative way is highlighted as a unique advantage, which is a theoretical advancement beyond existing approaches that often require manual handling of application state.
 - The paper emphasizes the retention of abstraction levels, allowing programmers to focus on data and control flow without worrying about GUI implementation details. This is a theoretical contribution as it simplifies the programming process.
 - The use of predicates and views to declaratively define dependencies between application state and user interface is a novel insight, as it provides a structured way to manage complex GUI interactions.
 - The automatic generation of GUIs and management of execution state by the system is a theoretical advancement, as it reduces the burden on programmers and ensures consistency in GUI applications.
 - The potential for future work on fine-grained layout annotations suggests ongoing theoretical development in making GUI programming more flexible and customizable."
Extraction of Efficient Programs in IΣ1-arithmetic,"Ján Komara, Paul J. Voda",-,-,arXiv.org,0,2019,Not specified (the abstract does not explicitly define specific conceptual primitives),"- Type of mathematical framework: $\mathit{PR}{+}I\Sigma_1$ paradigm (primitive recursive functions with $I\Sigma_1$-arithmetic)
 - Specific mathematical properties guaranteed: Efficient extraction of primitive recursive programs from $\Pi_2$-specifications
 - Proof techniques used: Extraction proofs
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Implementation of $\mathit{PR}{+}I\Sigma_1$ paradigm in Clausal Language (CL).
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Extraction proofs for extracting primitive recursive programs from $\Pi_2$-specifications.",Generic programming not extensively addressed,"- Key novel insights: Introduction of extraction proofs as an extension of $I\Sigma_1$-proofs to extract efficient primitive recursive programs.
 - Theoretical advancements: Extraction of programs as efficient as hand-coded ones from $\Pi_2$-specifications; alignment of programming constructs with proof rules.
 - Potential implications: Improved efficiency in programming language design by aligning programming with mathematical proofs.","- ""This paper introduces an extension of $I\Sigma_1$-proofs called extraction proofs where one can extract from the proofs of $\Pi_2$-specifications primitive recursive programs as efficient as the hand-coded ones.""
  - ""This is achieved by having the programming constructs correspond exactly to the proof rules with the computational content.""
  - ""CL is an implementation of, what we call, $\mathit{PR}{+}I\Sigma_1$ paradigm (primitive recursive functions with $I\Sigma_1$-arithmetic).""
  - ""Clausal Language (CL) is a declarative programming and verifying system used in our teaching of computer science.""",,"- The abstract mentions the ""Clausal Language (CL)"" as a declarative programming and verifying system, which suggests it is a conceptual framework or paradigm rather than a specific set of primitives.
 - The term ""$\mathit{PR}{+}I\Sigma_1$ paradigm"" refers to a combination of primitive recursive functions and $I\Sigma_1$-arithmetic, which are mathematical concepts rather than specific primitives.
 - The abstract discusses ""extraction proofs"" and the ability to extract ""primitive recursive programs,"" but it does not explicitly define these as conceptual primitives.
 - The mention of ""programming constructs correspond exactly to the proof rules with the computational content"" implies a relationship between programming constructs and proof rules, but again, this does not explicitly define specific conceptual primitives.
 - Overall, the abstract does not explicitly list or define specific conceptual primitives for reconstructing programming paradigms.","- ""This paper introduces an extension of $I\Sigma_1$-proofs called extraction proofs where one can extract from the proofs of $\Pi_2$-specifications primitive recursive programs as efficient as the hand-coded ones.""
  - ""Clausal Language (CL) is a declarative programming and verifying system used in our teaching of computer science.""
  - ""This is achieved by having the programming constructs correspond exactly to the proof rules with the computational content.""
  - ""CL is an implementation of, what we call, $\mathit{PR}{+}I\Sigma_1$ paradigm (primitive recursive functions with $I\Sigma_1$-arithmetic).""",,"- The abstract mentions that Clausal Language (CL) is based on the $\mathit{PR}{+}I\Sigma_1$ paradigm, which suggests a mathematical framework involving primitive recursive functions and $I\Sigma_1$-arithmetic.
 - The term $I\Sigma_1$-arithmetic refers to a specific type of arithmetic that is part of the framework, indicating a focus on arithmetic properties.
 - The introduction of ""extraction proofs"" implies a proof methodology that allows for the extraction of efficient programs from proofs, which is a key aspect of the framework.
 - The correspondence between programming constructs and proof rules suggests a formal verification approach, where the framework ensures that the programs extracted are as efficient as hand-coded ones.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it specify other mathematical properties or proof techniques beyond the extraction proofs.","- ""CL is an implementation of, what we call, $\mathit{PR}{+}I\Sigma_1$ paradigm (primitive recursive functions with $I\Sigma_1$-arithmetic).""
  - ""This is achieved by having the programming constructs correspond exactly to the proof rules with the computational content.""
  - ""This paper introduces an extension of $I\Sigma_1$-proofs called extraction proofs where one can extract from the proofs of $\Pi_2$-specifications primitive recursive programs as efficient as the hand-coded ones.""
  - ""Clausal Language (CL) is a declarative programming and verifying system used in our teaching of computer science.""",,"- The abstract discusses the integration of programming paradigms through the implementation of the $\mathit{PR}{+}I\Sigma_1$ paradigm in Clausal Language (CL). This suggests a specific integration mechanism where primitive recursive functions are combined with $I\Sigma_1$-arithmetic.
 - The mention of ""extraction proofs"" indicates a novel translation technique where proofs are used to extract efficient programs, which is a form of integration between proof-based and programming constructs.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration. It focuses on the integration of specific mathematical constructs into a programming system.
 - The abstract does not provide a comparative analysis or discuss theoretical integration strategies beyond the implementation of the $\mathit{PR}{+}I\Sigma_1$ paradigm.","- ""This paper introduces an extension of $I\Sigma_1$-proofs called extraction proofs where one can extract from the proofs of $\Pi_2$-specifications primitive recursive programs as efficient as the hand-coded ones.""
  - ""Clausal Language (CL) is a declarative programming and verifying system used in our teaching of computer science.""
  - ""This is achieved by having the programming constructs correspond exactly to the proof rules with the computational content.""
  - ""CL is an implementation of, what we call, $\mathit{PR}{+}I\Sigma_1$ paradigm (primitive recursive functions with $I\Sigma_1$-arithmetic).""",,"- The abstract discusses Clausal Language (CL) as a declarative programming and verifying system, which suggests a focus on programming methodologies.
 - The mention of the $\mathit{PR}{+}I\Sigma_1$ paradigm indicates a specific approach to programming, but it does not explicitly address generic programming or abstraction mechanisms.
 - The introduction of extraction proofs and the correspondence between programming constructs and proof rules implies a focus on proof-based programming, but again, there is no explicit mention of genericity or abstraction mechanisms.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""This paper introduces an extension of $I\Sigma_1$-proofs called extraction proofs where one can extract from the proofs of $\Pi_2$-specifications primitive recursive programs as efficient as the hand-coded ones.""
  - ""This is achieved by having the programming constructs correspond exactly to the proof rules with the computational content.""",,"- The abstract mentions the introduction of ""extraction proofs"" as an extension of $I\Sigma_1$-proofs. This suggests a novel insight into how proofs can be used to extract efficient programs.
 - The ability to extract ""primitive recursive programs as efficient as the hand-coded ones"" from $\Pi_2$-specifications indicates a theoretical advancement. It implies that the extracted programs are comparable in efficiency to those manually written, which is a significant contribution.
 - The correspondence between programming constructs and proof rules with computational content is a theoretical innovation. It suggests a new way of aligning programming with proof theory, which could have implications for programming language design by potentially making it more efficient and aligned with mathematical proofs.
 - The abstract does not mention any comparative analysis with existing work, but the introduction of extraction proofs and the alignment of programming constructs with proof rules are presented as new contributions."
A New Framework for Declarative Programming: Categorial Perspectives,"James Lipton, S. E. Finkelstein, P. Freyd",10.1007/3-540-60983-0_14,https://doi.org/10.1007/3-540-60983-0_14,Extensions of Logic Programming,1,1996,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Incorporation of constraint information into signatures
 - Proof techniques used: Categorical semantics, uniform proof systems
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of a new framework for logic programming syntax and semantics based on finite product categories with integrated constraint information.
 - Theoretical advancements: Generalization of the Kowalski-van Emden fixed point interpretation to operational, non-ground, categorical semantics.
 - Potential implications: Potential influence on future programming language design through a semantics-based definition of declarative programming.","- ""Our treatment forms the basis of a semantics-based definition of declarative programming.""
  - ""We propose a new framework for the syntax and semantics of logic programming, based on programming over finite product categories which incorporate constraint information directly into the notion of signature.""
  - ""In this framework, we generalize the Kowalski-van Emden fixed point interpretation, a cornerstone of the declarative paradigm, to an operational, non-ground, categorical semantics for generalized languages based on uniform proof systems.""",,"- The abstract discusses a new framework for logic programming that involves ""finite product categories"" and ""constraint information directly into the notion of signature."" This suggests that these concepts are foundational to the framework proposed by the authors.
 - The generalization of the ""Kowalski-van Emden fixed point interpretation"" to an ""operational, non-ground, categorical semantics"" indicates that these are key conceptual elements in the framework.
 - The abstract does not explicitly list or define specific conceptual primitives in the traditional sense, but it implies that the framework is built around these generalized concepts.
 - The level of abstraction is high, as the framework deals with abstract mathematical structures like categories and semantics.
 - Orthogonality is not explicitly discussed in the abstract.","- ""We propose a new framework for the syntax and semantics of logic programming, based on programming over finite product categories which incorporate constraint information directly into the notion of signature.""
  - ""Our treatment forms the basis of a semantics-based definition of declarative programming.""
  - ""we generalize the Kowalski-van Emden fixed point interpretation, a cornerstone of the declarative paradigm, to an operational, non-ground, categorical semantics for generalized languages based on uniform proof systems.""",,"- The abstract mentions that the framework is based on ""programming over finite product categories,"" which indicates that the mathematical framework used is category theory.
 - The framework incorporates ""constraint information directly into the notion of signature,"" suggesting that it involves specific mathematical properties related to constraints and signatures.
 - The generalization of the ""Kowalski-van Emden fixed point interpretation"" to a ""categorical semantics for generalized languages based on uniform proof systems"" implies that the framework uses categorical semantics and uniform proof systems as part of its proof methodology.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it specify other mathematical properties or proof techniques beyond what is mentioned.","- ""Our treatment forms the basis of a semantics-based definition of declarative programming.""
  - ""In this framework, we generalize the Kowalski-van Emden fixed point interpretation, a cornerstone of the declarative paradigm, to an operational, non-ground, categorical semantics for generalized languages based on uniform proof systems.""
  - ""We propose a new framework for the syntax and semantics of logic programming, based on programming over finite product categories which incorporate constraint information directly into the notion of signature.""",,"- The abstract discusses a new framework for logic programming that incorporates constraint information into the notion of signature, which is a part of the declarative paradigm.
 - It generalizes the Kowalski-van Emden fixed point interpretation to a broader categorical semantics, which suggests an integration of different semantic approaches within the declarative paradigm.
 - The abstract does not explicitly mention the integration of different programming paradigms (e.g., object-oriented, functional) or specific mechanisms for integrating these paradigms.
 - There is no mention of interaction models between different paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.
 - The focus is on enhancing the declarative paradigm rather than integrating multiple paradigms.","- ""Our treatment forms the basis of a semantics-based definition of declarative programming.""
  - ""We propose a new framework for the syntax and semantics of logic programming, based on programming over finite product categories which incorporate constraint information directly into the notion of signature.""
  - ""In this framework, we generalize the Kowalski-van Emden fixed point interpretation, a cornerstone of the declarative paradigm, to an operational, non-ground, categorical semantics for generalized languages based on uniform proof systems.""",,"- The abstract discusses a new framework for logic programming based on finite product categories, which suggests a focus on categorical semantics rather than generic programming.
 - The mention of ""programming over finite product categories"" and ""categorical semantics"" indicates a focus on abstract mathematical structures rather than generic programming mechanisms.
 - The abstract does not explicitly mention generic programming, type systems, or abstraction mechanisms related to genericity.
 - The focus is on declarative programming and semantics rather than generic programming or abstraction mechanisms.","- ""We propose a new framework for the syntax and semantics of logic programming, based on programming over finite product categories which incorporate constraint information directly into the notion of signature.""
  - ""Our treatment forms the basis of a semantics-based definition of declarative programming.""
  - ""In this framework, we generalize the Kowalski-van Emden fixed point interpretation, a cornerstone of the declarative paradigm, to an operational, non-ground, categorical semantics for generalized languages based on uniform proof systems.""",,"- The abstract introduces a ""new framework for the syntax and semantics of logic programming,"" which suggests a novel approach to how logic programming is structured and understood.
 - The framework is based on ""programming over finite product categories which incorporate constraint information directly into the notion of signature,"" indicating a theoretical innovation in how constraints are integrated into programming.
 - The generalization of the ""Kowalski-van Emden fixed point interpretation"" to an ""operational, non-ground, categorical semantics"" represents a theoretical advancement beyond existing approaches, as it extends a foundational concept in declarative programming to broader applications.
 - The development of a ""semantics-based definition of declarative programming"" implies a significant theoretical contribution, as it provides a new foundation for understanding declarative programming.
 - The abstract does not explicitly mention potential implications for programming language design, but the introduction of a new framework and the generalization of existing interpretations suggest potential for influencing future programming language design."
Semantic predicate types and approximation for class-based object oriented programming,"S. V. Bakel, R. Rowe",10.1145/1557898.1557901,https://doi.org/10.1145/1557898.1557901,FTfJP@ECOOP,5,2009,"1. Primitive Name: Predicate System
  Definition: A system that provides an analysis more expressive than simple type systems, capturing runtime properties.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Predicate Language
  Definition: Associates a family of predicates with a class, crucial for linking semantics and predicates.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Object Predicates
  Definition: Sequences of statements describing the behavior of an object.
  Orthogonality Score: Not specified
 

 4. Primitive Name: Approximant
  Definition: A 'snapshot' of a computation, used to understand the semantics of expressions.
  Orthogonality Score: Not specified","- Type of mathematical framework: Intersection type discipline (type theory)
 - Specific mathematical properties guaranteed: Soundness, expressiveness
 - Proof techniques used: Application of intersection types, Hoare-style system
 - Limitations or constraints of the framework: Semi-decidability issues requiring limitations in expressiveness for static analysis","- Specific integration mechanisms proposed: Application of intersection type discipline to class-based object-oriented programming.
 - Interaction models between paradigms: Not explicitly discussed.
 - Constraints or challenges in paradigm integration: Achieving subject expansion.
 - Any novel translation or embedding techniques: Not explicitly discussed.",Generic programming not extensively addressed,"- Introduction of a novel extension of Featherweight Java called pFJ with a sound and expressive predicate system.
 - Generalization of the concept of approximant from the Lambda Calculus to object-oriented programming, providing a semantic underpinning.
 - Demonstration of an approximation result linking predicates with approximants for abstract interpretation and termination analysis.
 - Enhanced expressiveness compared to traditional type systems for Java.
 - Potential implications for programming language design include extending to stateful models and addressing subject expansion issues.","- ""We define an extension of Featherweight Java, pFJ, and present a predicate system which we show to be sound and expressive.""
  - ""Object predicates thus comprise a sequence of statements describing the behaviour of an object.""
  - ""Crucial to this result is the notion of predicate language, which associates a family of predicates with a class.""
  - ""The notion of approximant was first introduced for the λ-calculus by C. Wadsworth""
  - ""We consider the behaviour of an expression (or rather, the object to which the expression evaluates) in terms of the operations that we may perform on it, i.e. accessing a field or invoking a method.""",,"- The paper discusses the extension of Featherweight Java (pFJ) and introduces a predicate system, which is a conceptual framework for analyzing object-oriented programs. This suggests that the predicate system itself could be considered a conceptual primitive.
  
 - The ""predicate language"" is highlighted as crucial, associating a family of predicates with a class. This indicates that the predicate language is a fundamental concept in their framework.
 

 - The behavior of expressions in terms of operations like field access and method invocation is considered, which implies that these operations are conceptual primitives in understanding object behavior.
 

 - Object predicates are described as sequences of statements about object behavior, suggesting that these sequences are a primitive for capturing semantic properties.
 

 - The notion of ""approximant"" is mentioned as a concept borrowed from λ-calculus, indicating it is a primitive used to understand the semantics of expressions.
 

 - The paper does not explicitly list or define these as ""conceptual primitives,"" but these elements are foundational to the theoretical framework they propose.","- ""We apply the principles of the intersection type discipline to the study of class-based object oriented programs and; our work follows from a similar approach (in the context of Abadi and Cardelli's ς-object calculus) taken by van Bakel and de'Liguoro.""
  - ""We define an extension of Featherweight Java, pFJ, and present a predicate system which we show to be sound and expressive.""
  - ""The strength of ITD motivated de'Liguoro [19] to apply the principles of intersection types to object oriented programming, in particular to the Varsigma Calculus.""
  - ""The goal of our research is to come to a semantics-based or typebased abstract interpretation for object orientation, for which the present paper contains the first steps.""
  - ""we can show a soundness result for pFJ:
 

 THEOREM 1. For type consistent execution contexts if Γ ⊢ e:C and e → e ′ then Γ ⊢ e ′ :C""
  - ""We now come to describe the first contribution of our work: the predicate system. Our system aims to provide an analysis which is more expressive than the simple type system of FJ: rather than simply guaranteeing global properties of programs, we wish our predicate types to be semantic in nature, and capture runtime properties.""
  - ""We can see the predicate system as a Hoare-style system of preand post-conditions.""
  - ""The approximation result is the following: any expression to which a predicate can be assigned has an approximant with that same predicate.""
  - ""The system, being semi-decidable at best, would need to be limited in expressiveness before it can be used for static analysis.""",,"- The paper uses the ""intersection type discipline"" as its mathematical framework, which is a type theory approach. This is evident from the repeated references to ITD and its application to object-oriented programming.
 - The framework guarantees soundness and expressiveness, as indicated by the soundness result for pFJ (Theorem 1) and the description of the predicate system as ""sound and expressive.""
 - The proof techniques used include the application of intersection types to object-oriented programming and the use of a Hoare-style system for pre- and post-conditions.
 - The limitations of the framework include the need to limit expressiveness for static analysis due to semi-decidability issues.","- ""We apply the principles of the intersection type discipline to the study of class-based object oriented programs and; our work follows from a similar approach (in the context of Abadi and Cardelli's ς-object calculus) taken by van Bakel and de'Liguoro.""
  - ""The goal of our research is to come to a semantics-based or typebased abstract interpretation for object orientation, for which the present paper contains the first steps.""
  - ""We now come to describe the first contribution of our work: the predicate system. Our system aims to provide an analysis which is more expressive than the simple type system of FJ: rather than simply guaranteeing global properties of programs, we wish our predicate types to be semantic in nature, and capture runtime properties.""
  - ""We have presented a predicate (type) system for pFJ, a variant of FJ, and shown that our predicates describe semantic properties of expressions. Our system thus has more expressive power than traditional type systems for Java.""
  - ""A key development towards this aim will be to extend our system to a stateful programming model, akin to Middleweight Java [12].""
  - ""Another objective of immediate concern to us is that of addressing the issues discussed in §5 and achieving subject expansion.""",,"- The paper discusses the application of intersection type discipline to class-based object-oriented programming, which is a theoretical integration strategy.
 - The study aims to integrate object-oriented programming with a more expressive type system that captures runtime properties, which is a specific integration mechanism proposed.
 - The paper does not explicitly discuss interaction models between paradigms or novel translation or embedding techniques.
 - The challenges in paradigm integration are hinted at in the discussion of achieving subject expansion, which is a constraint or challenge in integrating different paradigms.
 - The paper does not provide a detailed comparative analysis of different integration approaches or novel techniques for embedding one paradigm into another.","- ""We apply the principles of the intersection type discipline to the study of class-based object oriented programs and; our work follows from a similar approach (in the context of Abadi and Cardelli's ς-object calculus) taken by van Bakel and de'Liguoro.""
  - ""We define an extension of Featherweight Java, pFJ, and present a predicate system which we show to be sound and expressive.""
  - ""The goal of our research is to come to a semantics-based or typebased abstract interpretation for object orientation, for which the present paper contains the first steps.""
  - ""We consider the behaviour of an expression (or rather, the object to which the expression evaluates) in terms of the operations that we may perform on it, i.e. accessing a field or invoking a method.""
  - ""We follow in the tradition of intersection types, originally defined as sequences [16], however, by treating our predicates as such: a predicate is a sequence of (potentially incomparable) behaviours, from which any specific one can be selected for an expression as demanded by to the context in which it appears.""
  - ""The normal, class-based type system for our variant of Java is sound, but not expressive enough to come to in-depth analysis of programs; we therefore introduce the additional concept of predicates, which express the functional behaviour of programs, and allow their execution to be traced.""
  - ""The system, being semi-decidable at best, would need to be limited in expressiveness before it can be used for static analysis.""",,"- The paper primarily focuses on applying intersection type discipline to object-oriented programming, which is a form of abstraction mechanism.
 - The study defines an extension of Featherweight Java (pFJ) and introduces a predicate system to enhance expressiveness and provide a semantic underpinning for object-oriented programming.
 - The paper discusses the use of predicates to describe the behavior of expressions in terms of operations like field access and method invocation, which is a form of abstraction.
 - The intersection type discipline is used to represent generic abstractions by allowing multiple types for free and bound variables, grouped in intersections.
 - The paper does not explicitly discuss generic programming methodology or minimal type requirements in the context of generic programming.
 - The focus is more on the abstraction mechanisms through predicates and intersection types rather than generic programming.","- ""We define an extension of Featherweight Java, pFJ, and present a predicate system which we show to be sound and expressive.""
  - ""We have presented a predicate (type) system for pFJ, a variant of FJ, and shown that our predicates describe semantic properties of expressions. Our system thus has more expressive power than traditional type systems for Java.""
  - ""Another objective of immediate concern to us is that of addressing the issues discussed in §5 and achieving subject expansion.""
  - ""A key development towards this aim will be to extend our system to a stateful programming model, akin to Middleweight Java [12].""
  - ""The goal of our research is to come to a semantics-based or typebased abstract interpretation for object orientation, for which the present paper contains the first steps.""
  - ""We also show that our system provides a semantic underpinning for the object oriented paradigm by generalising the concept of approximant from the Lambda Calculus and demonstrating an approximation result: all expressions to which we can assign a predicate have an approximant that satisfies the same predicate.""
  - ""The approximation result is the following: any expression to which a predicate can be assigned has an approximant with that same predicate.""
  - ""We show that the standard (functional) properties hold and, moreover, put in evidence that we have a strong semantic system: we prove an approximation result and characterise head-normalisation and termination.""",,"- The paper introduces a novel extension of Featherweight Java called pFJ, which includes a predicate system that is both sound and expressive. This is a key theoretical contribution as it enhances the expressiveness of type systems for object-oriented programming.
 - The generalization of the concept of approximant from the Lambda Calculus to object-oriented programming is a significant theoretical advancement. It provides a semantic underpinning for object-oriented programming by linking predicates with approximants, which is a new insight in the field.
 - The paper demonstrates an approximation result, which is a theoretical contribution. This result shows that any expression to which a predicate can be assigned has an approximant that satisfies the same predicate, which is crucial for abstract interpretation and termination analysis.
 - The system described in the paper has more expressive power than traditional type systems for Java, which is a theoretical advancement. It provides a stronger semantic system by proving approximation results and characterizing head-normalization and termination.
 - The paper sets the stage for future work by aiming to extend the system to a stateful programming model and addressing issues related to subject expansion. These are potential implications for programming language design, as they could lead to more robust and expressive type systems."
19th international workshop on foundations of object-oriented languages (FOOL'12),"Jeremy G. Siek, Jonathan Aldrich, J. Boyland",10.1145/2384716.2384785,https://doi.org/10.1145/2384716.2384785,"ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity",0,2012,Not specified (the abstract does not explicitly define any conceptual primitives),Not specified (the abstract does not provide details about the mathematical framework used),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Not mentioned (the abstract does not specify novel insights).
 - Theoretical advancements beyond existing approaches: Not mentioned (the abstract does not detail specific advancements).
 - Potential implications for programming language design: Not mentioned (the abstract does not discuss implications).","- ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""
  - ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, and meta-programming.""
  - ""The search for sound principles for object-oriented languages has given rise to considerable research during the last few decades, leading to a better understanding of the key concepts of object-oriented languages and to important developments in type theory, semantics, program verification, and program development.""",,"- The abstract discusses the search for sound principles in object-oriented languages, which implies a focus on foundational concepts. However, it does not explicitly define any conceptual primitives.
 - The abstract mentions ""key concepts of object-oriented languages"" but does not specify what these concepts are or provide definitions.
 - The purpose of the workshop is to discuss new ideas and provide feedback, which suggests a focus on exploration rather than the presentation of specific conceptual primitives.
 - The abstract mentions integration with other paradigms and extensions like aspects, components, and meta-programming, but again, no specific primitives are defined or discussed.","- ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""
  - ""The search for sound principles for object-oriented languages has given rise to considerable research during the last few decades, leading to a better understanding of the key concepts of object-oriented languages and to important developments in type theory, semantics, program verification, and program development.""
  - ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, and meta-programming.""",,"- The abstract mentions ""important developments in type theory, semantics, program verification, and program development,"" which suggests that these areas are relevant to the mathematical framework. However, it does not specify any particular mathematical framework or its characteristics.
 - The abstract does not provide details about the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework.
 - The focus of the abstract is on the workshop's purpose and the general area of submissions rather than on specific mathematical frameworks or their characteristics.","- ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, and meta-programming.""
  - ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""",,"- The abstract mentions that the workshop invites submissions related to the integration of object-oriented languages with other paradigms, which suggests a focus on integration.
 - The mention of ""integration with other paradigms and extensions, such as aspects, components, and meta-programming"" indicates that the workshop is interested in exploring how object-oriented languages can be integrated with these other paradigms.
 - However, the abstract does not provide specific details about the integration mechanisms, interaction models, constraints, or novel translation techniques. It only indicates that these topics are within the scope of the workshop.
 - The abstract does not describe any specific integration approach or provide details on how these integrations are achieved.","- ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, and meta-programming.""
  - ""The search for sound principles for object-oriented languages has given rise to considerable research during the last few decades, leading to a better understanding of the key concepts of object-oriented languages and to important developments in type theory, semantics, program verification, and program development.""
  - ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""",,"- The abstract discusses the search for sound principles in object-oriented languages, which includes developments in type theory and semantics. However, it does not specifically mention generic programming or abstraction mechanisms.
 - The purpose of the workshop is to discuss new ideas in the foundations of object-oriented languages, but it does not specify a focus on generic programming or abstraction.
 - The abstract mentions integration with other paradigms and extensions like aspects, components, and meta-programming, but it does not provide details on genericity or abstraction mechanisms.
 - There is no mention of a definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""The search for sound principles for object-oriented languages has given rise to considerable research during the last few decades, leading to a better understanding of the key concepts of object-oriented languages and to important developments in type theory, semantics, program verification, and program development.""
  - ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""
  - ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, and meta-programming.""",,"- The abstract discusses the workshop's purpose as a forum for discussing new ideas in the foundations of object-oriented languages, which implies a focus on theoretical contributions and novel insights.
 - The mention of ""considerable research during the last few decades"" suggests a historical context of ongoing theoretical advancements in object-oriented languages.
 - The abstract highlights ""important developments in type theory, semantics, program verification, and program development,"" which are areas of theoretical contribution.
 - The invitation for submissions in areas like ""integration with other paradigms and extensions"" indicates a focus on theoretical advancements beyond existing approaches.
 - The abstract does not provide specific novel insights or detailed theoretical advancements, as it is more focused on the workshop's purpose and scope rather than specific contributions."
Multi-Views Formal Specifications : A General Frame,Fabrice Barbier,-,-,-,0,-,"1. Primitive Name: Aspects
  Definition: Orthogonal properties of systems such as functional, dynamic, distributed
  Orthogonality Score: High (aspects are described as very different)",Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),"- Specific integration mechanisms proposed: Not mentioned
 - Interaction models between paradigms: Not mentioned
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned","Generic programming not extensively addressed (the abstract focuses on abstraction and genericity in terms of integrating multiple system aspects, but does not explicitly address minimal type requirements or static checking strategies)","- Key novel insights: Proposal of a logic for mixed specifications to provide abstract denotational semantics.
 - Theoretical advancements: General frame for multi-views formal specifications, meta-definition of aspects and their combination, tools for verifying consistency.
 - Potential implications for programming language design: Influence on handling multiple aspects and views in programming languages.","- ""We call systems mixed when they have more than one aspect.""
  - ""The goal of mixed specification languages is to take into account all or at least several aspects of systems.""
  - ""The objective is to propose a meta-definition of the notions of aspect and combination of aspects, but also to give tools to verify and answer the question of the views’ consistency.""
  - ""Our first work is to propose a logic for mixed specifications that aims at providing a first proposal to give an abstract denotational semantics for mixed specification languages.""",,"- The abstract discusses the concept of ""aspects"" in software systems, which are described as orthogonal properties such as functional, dynamic, and distributed. These are considered conceptual primitives as they are fundamental properties used to describe mixed systems.
 - The abstract mentions the goal of proposing a logic for mixed specifications, which implies a theoretical framework for understanding these aspects.
 - The term ""meta-definition"" suggests an attempt to define these aspects and their combinations at a high level of abstraction.
 - The abstract does not provide explicit definitions for each primitive but implies that these aspects are conceptual primitives by discussing their orthogonality and importance in mixed systems.","- ""Our first work is to propose a logic for mixed specifications that aims at providing a first proposal to give an abstract denotational semantics for mixed specification languages.""
  - ""This logic enables one to reason about a specification at a high level, abstracting away from implementation details and without targetting a specific (often initial) model.""
  - ""The homogeneous approach uses a single formalism (often extending it in a syntactical way) to specify both aspects""
  - ""The heterogeneous approach uses different formalisms""
  - ""However, we also think that the homogeneous approach is better suited (ie simpler) to the verification part of the specification process: no integration problems arise as the verification may be done in a unique framework.""
  - ""our goal is to give a general frame for multi-views formal specifications.""
  - ""Therefore, we have to think about a meta-model that allow us to caracterize the aspects we want to specify and how to combine them.""
  - ""The objective is to propose a meta-definition of the notions of aspect and combination of aspects, but also to give tools to verify and answer the question of the views’ consistency.""",,"- The abstract mentions the proposal of a ""logic for mixed specifications"" which suggests a mathematical framework for formalizing mixed specification languages.
 - The logic is described as providing ""abstract denotational semantics,"" which implies a focus on abstract mathematical properties.
 - The abstract discusses two approaches: homogeneous and heterogeneous. The homogeneous approach uses a single formalism, which could imply a type of mathematical framework like type theory.
 - The heterogeneous approach uses different formalisms, which might suggest a framework that accommodates multiple mathematical structures, possibly akin to category theory.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used.
 - There is no explicit mention of limitations or constraints of the framework.
 - The abstract does not provide detailed information about the type of mathematical framework, specific properties, or proof techniques, so these details are not specified.","- ""The goal of mixed specification languages is to take into account all or at least several aspects of systems.""
  - ""We found out that a lot of mixed specification languages do share most of their features.""
  - ""Our first work is to propose a logic for mixed specifications that aims at providing a first proposal to give an abstract denotational semantics for mixed specification languages.""
  - ""Two different approaches may be used to specify mixed systems [18]. The homogeneous approach uses a single formalism (often extending it in a syntactical way) to specify both aspects [15, 6, 5]. The heterogeneous approach uses different formalisms [14, 18, 11, 10, 19].""
  - ""This last approach is well adapted to the mixed specification as it enables one to use the more adapted formalism for each aspect adapted eventually meaning the formalism one knows well or the formalism of a given component one wishes to reuse.""
  - ""However, we also think that the homogeneous approach is better suited (ie simpler) to the verification part of the specification process: no integration problems arise as the verification may be done in a unique framework.""
  - ""As there already exist a large number of multi-aspects specification formalisms, our goal is to give a general frame for multi-views formal specifications.""
  - ""Therefore, we have to think about a meta-model that allow us to caracterize the aspects we want to specify and how to combine them.""",,"- The abstract discusses the integration of different programming paradigms through the concept of ""mixed specification languages,"" which aim to account for multiple aspects of systems.
 - Two integration approaches are mentioned: the homogeneous approach, which uses a single formalism to specify multiple aspects, and the heterogeneous approach, which uses different formalisms for each aspect.
 - The heterogeneous approach is highlighted as being well-suited for mixed specifications because it allows for the use of the most adapted formalism for each aspect, facilitating reuse and adaptation.
 - The abstract does not provide specific integration mechanisms or interaction models between paradigms but focuses on the general framework and theoretical strategies.
 - There is no mention of novel translation or embedding techniques or specific constraints or challenges in paradigm integration beyond the general discussion of homogeneous and heterogeneous approaches.","- ""The goal of mixed specification languages is to take into account all or at least several aspects of systems.""
  - ""Our first work is to propose a logic for mixed specifications that aims at providing a first proposal to give an abstract denotational semantics for mixed specification languages.""
  - ""This logic enables one to reason about a specification at a high level, abstracting away from implementation details and without targetting a specific (often initial) model.""
  - ""Two different approaches may be used to specify mixed systems [18]. The homogeneous approach uses a single formalism (often extending it in a syntactical way) to specify both aspects [15, 6, 5]. The heterogeneous approach uses different formalisms [14, 18, 11, 10, 19].""
  - ""Therefore this is the approach we follow. However, we also think that the homogeneous approach is better suited (ie simpler) to the verification part of the specification process: no integration problems arise as the verification may be done in a unique framework.""
  - ""As there already exist a large number of multi-aspects specification formalisms, our goal is to give a general frame for multi-views formal specifications.""
  - ""Therefore, we have to think about a meta-model that allow us to caracterize the aspects we want to specify and how to combine them.""",,"- The abstract discusses the integration of multiple aspects in software engineering, which implies a level of abstraction and genericity in handling different system properties.
 - The proposal of a logic for mixed specifications suggests an abstract denotational semantics, which is a mechanism for representing generic abstractions by abstracting away from implementation details.
 - The mention of orthogonal properties and the use of different formalisms indicates a focus on conceptual abstraction by considering various aspects of systems.
 - The discussion of homogeneous and heterogeneous approaches suggests a consideration of different mechanisms for representing generic abstractions, with the homogeneous approach being simpler for verification.
 - The goal of providing a general frame for multi-views formal specifications implies a focus on genericity and abstraction mechanisms to handle multiple aspects.
 - However, the abstract does not explicitly mention minimal type requirements or static checking strategies, which are typically part of generic programming methodologies.","- ""Our first work is to propose a logic for mixed specifications that aims at providing a first proposal to give an abstract denotational semantics for mixed specification languages.""
  - ""The goal of mixed specification languages is to take into account all or at least several aspects of systems.""
  - ""our goal is to give a general frame for multi-views formal specifications.""
  - ""This logic enables one to reason about a specification at a high level, abstracting away from implementation details and without targetting a specific (often initial) model.""
  - ""The objective is to propose a meta-definition of the notions of aspect and combination of aspects, but also to give tools to verify and answer the question of the views’ consistency.""",,"- The abstract discusses the need for a separation of concerns in software engineering, which is a recognized issue. This indicates a focus on theoretical contributions related to handling multiple aspects of systems.
 - The proposal of a logic for mixed specifications is a novel insight, as it aims to provide an abstract denotational semantics. This is a theoretical advancement because it allows for reasoning about specifications at a high level without being tied to specific implementation details.
 - The goal of providing a general frame for multi-views formal specifications is a theoretical contribution, as it seeks to unify various aspects of system specification under a single framework.
 - The objective of proposing a meta-definition for aspects and their combination, along with tools for verifying consistency, is a theoretical advancement. It addresses the challenge of ensuring consistency across different views of a system, which is a significant theoretical contribution.
 - The abstract does not mention specific implications for programming language design, but the theoretical contributions could potentially influence how programming languages are designed to handle multiple aspects and views."
Parametrized programming in LILEANNA,W. Tracz,10.1145/162754.162815,https://doi.org/10.1145/162754.162815,ACM Symposium on Applied Computing,29,1993,Not specified (the abstract does not explicitly list or define specific conceptual primitives),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described,"- Definition of ""concept"" used: Not mentioned
 - Mechanisms for representing generic abstractions: LILEANNA is a language for formally specifying and generating Ada packages
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: The need for tools to support parameterized programming and integration of components to avoid duplicated efforts.
 - Theoretical advancements: LILEANNA as an implementation of Goguen’s LIL, supporting formal specification and generation of Ada packages.
 - Potential implications: A new paradigm for programming language design focusing on parameterization and integration.","- ""Programmers traditionally construct solutions to problems one line at a time, often duplicating the efforts (as well as the mistakes) of others.""
  - ""LILEANNA is an implementation of Goguen’s LIL (Library Interconnect Language""",,"- The abstract discusses the need for tools to support the design and development of parameterized components and software architectures, which implies a focus on modular and reusable programming elements.
 - It mentions the lack of tools for integrating instantiated components, suggesting a need for primitives related to component integration.
 - The paper describes the rationale for a parameterized programming paradigm supported by LILEANNA, indicating that the primitives might be related to parameterization and modularization.
 - LILEANNA is described as a language for formally specifying and generating Ada packages, which suggests that the primitives might be related to package specification and generation.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It provides context and rationale but does not detail the primitives themselves.","- ""LILEANNA is an implementation of Goguen’s LIL (Library Interconnect Language""",,"- The abstract mentions that LILEANNA is an implementation of Goguen’s LIL, which suggests a connection to formal methods, as LIL is known for its formal specification capabilities.
 - The mention of ""formally specifying and generating Ada packages"" implies a structured approach to software development, which often involves mathematical frameworks.
 - However, the abstract does not explicitly mention any specific mathematical framework, such as type theory or category theory, nor does it discuss specific mathematical properties guaranteed or proof techniques used.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""LILEANNA is an implementation of Goguen’s LIL (Library Interconnect Language""
  - ""Programmers traditionally construct solutions to problems one line at a time, often duplicating the efforts (as well as the mistakes) of others.""",,"- The abstract discusses the need for tools to support the design and development of parameterized components and software architectures, which implies a focus on integration.
 - It mentions the lack of tools to integrate instantiated components, suggesting a gap in current integration mechanisms.
 - The paper describes the rationale for a parameterized programming paradigm supported by LILEANNA, which is an implementation of Goguen’s LIL.
 - LILEANNA is used for formally specifying and generating Ada packages, indicating a focus on integration through formal specification and generation.
 - However, the abstract does not explicitly describe specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques.","- ""LILEANNA is an implementation of Goguen’s LIL (Library Interconnect Language""
  - ""Programmers traditionally construct solutions to problems one line at a time, often duplicating the efforts (as well as the mistakes) of others.""",,"- The abstract discusses the need for tools to support the design and development of parameterized components and software architectures, which implies a focus on generic programming.
 - The mention of ""parameterised programming paradigm"" suggests that the study addresses genericity and abstraction mechanisms.
 - LILEANNA is described as a language for formally specifying and generating Ada packages, which indicates a mechanism for representing generic abstractions.
 - The abstract does not provide specific details on the definition of ""concept,"" minimal type requirements, or static checking strategies, but it does highlight the focus on parameterized programming and formal specification.
 - The abstract does not explicitly mention type system discussions or static checking strategies, but it implies a focus on generic programming through the use of parameterized components and software architectures.","- ""LILEANNA is an implementation of Goguen’s LIL (Library Interconnect Language""
  - ""Programmers traditionally construct solutions to problems one line at a time, often duplicating the efforts (as well as the mistakes) of others.""",,"- The abstract highlights a traditional problem in programming where efforts are duplicated due to a lack of tools for parameterized programming and integration of components. This suggests a gap in existing approaches that the paper aims to address.
 - The introduction of LILEANNA as a tool that supports parameterized programming and integration of components indicates a novel insight into how programming can be more efficient and less repetitive.
 - The mention of LILEANNA as an implementation of Goguen’s LIL and its role in formally specifying and generating Ada packages suggests a theoretical advancement in programming language design, particularly in terms of formal specification and generation.
 - The abstract implies that LILEANNA offers a new paradigm for programming, which could have significant implications for how programming languages are designed in the future, focusing on parameterization and integration."
Modeling Answer Constraints in Constraint Logic Programs,"M. Gabbrielli, G. Levi",-,-,International Conference on Logic Programming,69,1991,Not specified (the abstract focuses on semantic extensions and frameworks rather than explicit conceptual primitives),"- Type of mathematical framework: Algebraic semantics
 - Specific mathematical properties guaranteed: Operational, model-theoretic, and xpoint semantics
 - Proof techniques used: Immediate consequences operators
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Integration of constraints with logic programming framework, extension of semantics for success set case.
 - Interaction models between paradigms: Retaining semantic properties of logic languages, achieving equivalence between operational and declarative semantics.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Bottom-up abstract interpretation framework generalizing an approach for pure logic programs to CLP.","- Definition of ""concept"" used: Integration of generic computational mechanisms with logic programming framework.
 - Mechanisms for representing generic abstractions: Framework for defining various notions of models, new notion of interpretation.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Equivalence between operational and declarative semantics, abstract immediate consequence operators.","- Key novel insights: Extension of semantics for the success set case to fully characterize operational behavior; introduction of a framework for defining various notions of models.
 - Theoretical advancements: New notion of interpretation; natural extension of the standard notion of truth; achievement of equivalence between operational and declarative semantics.
 - Potential implications: Basis for program transformation and analysis techniques; generalization of abstract interpretation framework to CLP.","- ""The construction is based on a new notion of interpretation (set of constrained atoms), on a natural extension of the standard notion of truth and on the dee-nition of various immediate consequences operators T i , whose least xpoints on the lattice of interpretations are models corresponding to various observable properties.""
  - ""This paradigm retains the semantic properties of logic languages, namely the existence of equivalent operational, model theo-retic and xpoint semantics.""
  - ""we propose an extension of such a semantics, for the success set case, in order to fully characterize the operational behaviour of programs.""
  - ""We introduce a framework for deening various notions of models, each corresponding to a speciic operationally observable property.""
  - ""CLP(X) programs have an equivalent \algebraic""""",,"- The abstract discusses the extension of semantics for CLP(X) to fully characterize operational behavior, which suggests a focus on semantic properties rather than specific conceptual primitives.
 - The mention of ""equivalent operational, model theo-retic and xpoint semantics"" indicates a focus on semantic frameworks rather than specific primitives.
 - The introduction of a ""framework for deening various notions of models"" and a ""new notion of interpretation (set of constrained atoms)"" suggests the development of theoretical frameworks rather than explicit conceptual primitives.
 - The abstract does not explicitly list or define specific conceptual primitives; instead, it focuses on semantic extensions and frameworks.","- ""The constraint logic programming paradigm CLP(X) (CLP for short) has been proposed by Jaaar and Lassez in order to integrate a generic computational mechanism based on constraints with the logic programming framework.""
  - ""This paradigm retains the semantic properties of logic languages, namely the existence of equivalent operational, model theo-retic and xpoint semantics.""
  - ""CLP(X) programs have an equivalent \algebraic""""
  - ""We introduce a framework for deening various notions of models, each corresponding to a speciic operationally observable property.""
  - ""The construction is based on a new notion of interpretation (set of constrained atoms), on a natural extension of the standard notion of truth and on the dee-nition of various immediate consequences operators T i , whose least xpoints on the lattice of interpretations are models corresponding to various observable properties.""
  - ""Since within our framework the equivalence between the operational and the declarative semantics can be fully achieved, it can be taken as the basis of program transformation and analyses techniques.""",,"- The abstract discusses the CLP(X) paradigm, which integrates constraints with logic programming, indicating a focus on constraint logic programming as the mathematical framework.
 - It mentions the retention of semantic properties from logic languages, including operational, model-theoretic, and xpoint semantics, suggesting these are part of the framework.
 - The mention of ""algebraic semantics"" implies that the framework involves algebraic structures, which are a type of mathematical framework.
 - The introduction of a new notion of interpretation and immediate consequences operators suggests specific mathematical properties and techniques used in the framework.
 - The abstract does not explicitly mention type theory or category theory, but it does discuss algebraic semantics and operational semantics, which are relevant mathematical properties.
 - The framework is used for program transformation and analysis techniques, indicating its application but not explicitly stating limitations or constraints.","- ""The constraint logic programming paradigm CLP(X) (CLP for short) has been proposed by Jaaar and Lassez in order to integrate a generic computational mechanism based on constraints with the logic programming framework.""
  - ""This paradigm retains the semantic properties of logic languages, namely the existence of equivalent operational, model theo-retic and xpoint semantics.""
  - ""Moreover, since computation is performed over the particular domain of computation X, CLP(X) programs have an equivalent \algebraic""""
  - ""In this paper we propose an extension of such a semantics, for the success set case, in order to fully characterize the operational behaviour of programs.""
  - ""We introduce a framework for deening various notions of models, each corresponding to a speciic operationally observable property.""
  - ""The construction is based on a new notion of interpretation (set of constrained atoms), on a natural extension of the standard notion of truth and on the dee-nition of various immediate consequences operators T i , whose least xpoints on the lattice of interpretations are models corresponding to various observable properties.""
  - ""Since within our framework the equivalence between the operational and the declarative semantics can be fully achieved, it can be taken as the basis of program transformation and analyses techniques.""
  - ""In particular, it is possible to deene suitable abstract immediate consequence operators and therefore a bottom-up abstract interpretation framework which generalizes to the CLP case an approach developed for pure logic programs.""",,"- The abstract discusses the integration of a generic computational mechanism based on constraints with the logic programming framework, which is a key aspect of the CLP(X) paradigm.
 - The integration is achieved by retaining the semantic properties of logic languages, ensuring equivalent operational, model-theoretic, and xpoint semantics.
 - The extension of semantics for the success set case is proposed to fully characterize operational behavior, indicating a focus on integrating operational and declarative semantics.
 - The framework introduces new notions of interpretation and truth, along with immediate consequences operators, to define models corresponding to observable properties.
 - The abstract mentions achieving equivalence between operational and declarative semantics, which is crucial for program transformation and analysis techniques.
 - The integration approach involves a bottom-up abstract interpretation framework that generalizes an approach developed for pure logic programs to the CLP case.","- ""The constraint logic programming paradigm CLP(X) (CLP for short) has been proposed by Jaaar and Lassez in order to integrate a generic computational mechanism based on constraints with the logic programming framework.""
  - ""This paradigm retains the semantic properties of logic languages, namely the existence of equivalent operational, model theo-retic and xpoint semantics.""
  - ""Moreover, since computation is performed over the particular domain of computation X, CLP(X) programs have an equivalent \algebraic""""
  - ""We introduce a framework for deening various notions of models, each corresponding to a speciic operationally observable property.""
  - ""The construction is based on a new notion of interpretation (set of constrained atoms), on a natural extension of the standard notion of truth and on the dee-nition of various immediate consequences operators T i , whose least xpoints on the lattice of interpretations are models corresponding to various observable properties.""
  - ""Since within our framework the equivalence between the operational and the declarative semantics can be fully achieved, it can be taken as the basis of program transformation and analyses techniques.""
  - ""In particular, it is possible to deene suitable abstract immediate consequence operators and therefore a bottom-up abstract interpretation framework which generalizes to the CLP case an approach developed for pure logic programs.""",,"- The abstract discusses the integration of a ""generic computational mechanism"" into the CLP(X) paradigm, indicating a focus on generic programming.
 - The mention of ""equivalent operational, model theo-retic and xpoint semantics"" suggests a conceptual abstraction mechanism that aligns different semantic perspectives.
 - The introduction of a ""framework for deening various notions of models"" and ""a new notion of interpretation"" implies mechanisms for representing generic abstractions.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does discuss the equivalence between operational and declarative semantics, which could relate to optimization strategies.
 - The mention of ""abstract immediate consequence operators"" and a ""bottom-up abstract interpretation framework"" suggests a focus on abstraction mechanisms.","- ""In this paper we propose an extension of such a semantics, for the success set case, in order to fully characterize the operational behaviour of programs.""
  - ""The construction is based on a new notion of interpretation (set of constrained atoms), on a natural extension of the standard notion of truth and on the dee-nition of various immediate consequences operators T i , whose least xpoints on the lattice of interpretations are models corresponding to various observable properties.""
  - ""In particular, it is possible to deene suitable abstract immediate consequence operators and therefore a bottom-up abstract interpretation framework which generalizes to the CLP case an approach developed for pure logic programs.""
  - ""Since within our framework the equivalence between the operational and the declarative semantics can be fully achieved, it can be taken as the basis of program transformation and analyses techniques.""",,"- The abstract mentions an ""extension of such a semantics"" for the success set case, indicating a novel theoretical contribution by expanding existing semantics to better capture operational behavior.
 - The introduction of a ""framework for deining various notions of models"" suggests a theoretical advancement by providing a structured approach to understanding different operational properties.
 - The use of a ""new notion of interpretation"" and ""natural extension of the standard notion of truth"" implies a theoretical innovation in how interpretations are defined and truth is assessed.
 - The mention of achieving ""equivalence between the operational and the declarative semantics"" is a significant theoretical contribution, as it provides a solid foundation for program analysis and transformation techniques.
 - The development of ""suitable abstract immediate consequence operators"" and a ""bottom-up abstract interpretation framework"" generalizes existing approaches to CLP, indicating a theoretical advancement in programming language design."
An Abstract View on Optimizations in Propositional Frameworks,Yuliya Lierler,10.48550/arXiv.2206.06440,https://doi.org/10.48550/arXiv.2206.06440,Annals of Mathematics and Artificial Intelligence,2,2022,"1. Primitive Name: Weight Systems
  Definition: A unifying framework that eliminates syntactic distinctions between paradigms to study optimization statements.
  Orthogonality Score: High (applies across different logics and vocabularies)
 

 2. Primitive Name: W-Condition
  Definition: A pair consisting of a theory and a weighted expression (w@l).
  Orthogonality Score: High (integrates with various logics)
 

 3. Primitive Name: W-System
  Definition: A pair of an abstract modular system and a set of w-conditions.
  Orthogonality Score: High (integrates hard and soft constraints)
 

 4. Primitive Name: Optimal Model
  Definition: A model that satisfies the equation for optimal models.
  Orthogonality Score: High (applies to various optimization criteria)
 

 5. Primitive Name: Min-Optimal Model
  Definition: A model that satisfies the conditions of optimal model with max replaced by min.
  Orthogonality Score: High (applies to various optimization criteria)","- Type of mathematical framework: Abstract modular framework
 - Specific mathematical properties guaranteed: Embedding of SAT-based optimization formalisms, processing of ASP-WC programs by MaxSAT/MinSAT solvers
 - Proof techniques used: Logical reasoning, lemmas, propositions
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Weight systems framework to eliminate syntactic distinctions between paradigms.
 - Interaction models between paradigms: Embedding SAT-based optimization formalisms and ASP-WC into the weight systems framework.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Processing ASP-WC programs using MaxSAT/MinSAT solvers.",Generic programming not extensively addressed,"- Key novel insights: Introduction of a unifying framework called ""weight systems"" that eliminates syntactic distinctions between optimization paradigms.
 - Theoretical advancements: Extension of modular systems to include soft modules, embedding of SAT-based optimization formalisms into the framework.
 - Potential implications for programming language design: Provides a unified view for understanding and comparing optimization criteria across paradigms, serving as a foundation for future work on integrating propositional and non-propositional variables.","- ""Here we propose a unifying framework of so-called weight systems that eliminates syntactic distinctions between paradigms and allows us to see essential similarities and differences between optimization statements provided by paradigms.""
  - ""We extend the framework in a way that soft modules can be formulated and studied under one roof.""
  - ""A pair (T L , w@l) -consisting of a theory T L of logic L (or L-module) and an expression w@l, where w is an integer and l is a positive integer -is called an L-w(eighted)-condition (or a w-condition, if the explicit reference to its logic is not necessary).""
  - ""A pair (H, Z) consisting of an AMS H and a set Z of w-conditions (possibly in different logics and over different vocabularies) so that σ Z ⊆ σ H is called a w(eighted)-abstract modular system (or w-system).""
  - ""We identify w-conditions of the form (T, w@1) with expressions (T, w) (i.e., when the level is missing it is considered to be one).""
  - ""For a collection Z of w-conditions, the union of the vocabularies of the logics of the wconditions in Z forms the vocabulary of Z, denoted by σ Z""
  - ""Let W = (H, Z) be a w-system (H and Z intuitively stand for hard and soft). The vocabulary of H forms the vocabulary of W, denoted by σ W""
  - ""A model I * of W is optimal if I * satisfies equation
 

 where I ranges over models of W.""
  - ""A model I * of W is min-optimal if it satisfies the conditions of optimal model, where in the equation above we replace max by min.""
  - ""We now provide the definition of an optimal model for the general form of w-systems.""",,"- The paper introduces a unifying framework called ""weight systems"" to bridge different optimization paradigms, indicating a conceptual primitive focused on abstraction and modularity.
 - The framework extends abstract modular systems to include ""soft modules,"" which are formulated using ""w-conditions"" that consist of a theory and a weighted expression.
 - A ""w-condition"" is defined as a pair consisting of a theory and a weighted expression, which is a key conceptual primitive for expressing optimization criteria.
 - The ""w-system"" is another primitive, defined as a pair of an abstract modular system and a set of w-conditions, which integrates hard and soft constraints.
 - The vocabulary of a w-system is defined by the union of vocabularies from its components, indicating a focus on semantic integration.
 - The definitions of optimal and min-optimal models provide a basis for evaluating solutions within this framework, suggesting these as conceptual primitives for optimization evaluation.
 - The paper discusses the orthogonality of these primitives by showing how they can be applied across different logics and vocabularies, indicating a high level of abstraction and flexibility.","- ""This paper takes modularity and abstraction as key tools for building a thorough understanding between related and, yet, disperse advances pertaining to optimizations or soft modules within different AR communities.""
  - ""Lierler and Truszczynski (2015) proposed an abstract modular framework that allows us to bypass the syntactic details of a particular logic and study advances in AR from a bird's eye view.""
  - ""We extend the framework in a way that soft modules can be formulated and studied under one roof.""
  - ""We illustrate how a family of SAT based optimization formalisms such as MaxSAT, weighted MaxSAT, and partial weighted MaxSAT (pw-MaxSAT) can be embedded into the proposed framework.""
  - ""The paper culminates in a result illustrating how ASP-WC programs can be processed by means of MaxSAT/MinSAT solvers.""
  - ""The proofs of the formal results of this paper are presented in its final section.""
  - ""The proof of the claim of Proposition 1 relies on the following lemmas that we list here as they refer to interesting properties of l-optimal models.""",,"- The paper discusses the use of an ""abstract modular framework"" as a key tool for understanding optimizations in automated reasoning (AR) communities. This suggests a focus on modularity and abstraction as theoretical foundations.
 - The framework is extended to include soft modules, indicating a development of existing theoretical structures to accommodate new types of optimizations.
 - The paper embeds various SAT-based optimization formalisms into this framework, suggesting a focus on propositional logic and satisfiability as part of the mathematical framework.
 - The paper includes a section on proofs, which implies the use of formal verification techniques to guarantee properties of the framework.
 - The mention of ""lemmas"" and ""propositions"" indicates the use of logical reasoning and proof techniques to establish mathematical properties.
 - The paper does not explicitly mention a specific type of mathematical framework like type theory or category theory, but it emphasizes modularity and abstraction, which are common in theoretical computer science.","- ""Here we propose a unifying framework of so-called weight systems that eliminates syntactic distinctions between paradigms and allows us to see essential similarities and differences between optimization statements provided by paradigms.""
  - ""This unifying outlook has significant simplifying and explanatory potential in the studies of optimization and modularity in automated reasoning and knowledge representation.""
  - ""We extend the framework in a way that soft modules can be formulated and studied under one roof.""
  - ""We illustrate how a family of SAT based optimization formalisms such as MaxSAT, weighted MaxSAT, and partial weighted MaxSAT (pw-MaxSAT) can be embedded into the proposed framework.""
  - ""We also illustrate how ASP-WC fits into the same framework.""
  - ""The paper culminates in a result illustrating how ASP-WC programs can be processed by means of MaxSAT/MinSAT solvers.""
  - ""we propose to utilize abstract view on logics and modularity as tools for constructing overarching view for distinct criteria used for optimization within different AR communities.""
  - ""Propositions 2, 3, 4, and 5 allow us to identify MaxSAT, weighted MaxSAT, pw-MaxSAT, and o-programs with respective w-systems.""
  - ""Optimal answer sets of a positive-singular o-program (Π, {B 1 , . . . , B m }), whose all conditions are of the same level 1, coincide with optimal models of pw-MaxSAT problem""
  - ""Optimal answer sets of a negatively-singular o-program (Π, {B 1 , . . . , B m }), whose all conditions are of the same level 1, coincide with optimal models of pw-MinSAT problem""",,"- The paper proposes a unifying framework called ""weight systems"" to integrate different programming paradigms, specifically focusing on optimization statements (Quote 1).
 - This framework aims to simplify and explain the similarities and differences between optimization statements across paradigms (Quote 2).
 - The framework is extended to include soft modules, which are essential for formulating optimization criteria (Quote 3).
 - The paper demonstrates how various SAT-based optimization formalisms (MaxSAT, weighted MaxSAT, pw-MaxSAT) can be embedded into this framework (Quote 4).
 - Similarly, it shows how ASP-WC (Answer Set Programming with Weak Constraints) can be integrated into the same framework (Quote 5).
 - A key integration mechanism is the ability to process ASP-WC programs using MaxSAT/MinSAT solvers, indicating a translation or embedding technique (Quote 6).
 - The paper uses an abstract view on logics and modularity to construct an overarching view for optimization criteria across different automated reasoning communities (Quote 7).
 - Theoretical integration strategies are supported by propositions that equate different paradigms with w-systems, facilitating their comparison and integration (Quotes 8, 9, 10).","- ""This paper takes modularity and abstraction as key tools for building a thorough understanding between related and, yet, disperse advances pertaining to optimizations or soft modules within different AR communities.""
  - ""Lierler and Truszczynski (2015) proposed an abstract modular framework that allows us to bypass the syntactic details of a particular logic and study advances in AR from a bird's eye view.""
  - ""We extend the framework in a way that soft modules can be formulated and studied under one roof.""
  - ""The predominant focus of this work are so called quantitative optimizations/preferences.""
  - ""Weighted-conditions of introduced weighted systems are vehicles for expressing these objective functions.""
  - ""we propose to utilize abstract view on logics and modularity as tools for constructing overarching view for distinct criteria used for optimization within different AR communities.""",,"- The paper emphasizes the use of modularity and abstraction as key mechanisms for understanding optimizations across different automated reasoning (AR) communities. This suggests a focus on conceptual abstraction rather than generic programming in the traditional sense.
 - The abstract modular framework proposed by Lierler and Truszczynski (2015) is extended to include soft modules, indicating a mechanism for representing generic abstractions by abstracting away syntactic details.
 - The paper does not explicitly discuss generic programming methodology or type systems, which are typical components of generic programming.
 - The focus on quantitative optimizations and the use of weighted systems to express objective functions suggests a conceptual abstraction mechanism rather than a generic programming approach.
 - There is no mention of minimal type requirements or static checking strategies, which are common in generic programming.","- ""Here we propose a unifying framework of so-called weight systems that eliminates syntactic distinctions between paradigms and allows us to see essential similarities and differences between optimization statements provided by paradigms.""
  - ""This unifying outlook has significant simplifying and explanatory potential in the studies of optimization and modularity in automated reasoning and knowledge representation.""
  - ""We extend the framework in a way that soft modules can be formulated and studied under one roof.""
  - ""We illustrate how a family of SAT based optimization formalisms such as MaxSAT, weighted MaxSAT, and partial weighted MaxSAT (pw-MaxSAT) can be embedded into the proposed framework.""
  - ""The predominant focus of this work are so called quantitative optimizations/preferences.""
  - ""we propose to utilize abstract view on logics and modularity as tools for constructing overarching view for distinct criteria used for optimization within different AR communities.""
  - ""We trust that the proposed unifying framework of w-systems will allow developers of distinct automated paradigms to better grasp similarities and differences of the kind of optimization criteria their paradigms support.""
  - ""This work is a stepping stone towards extending these translational approaches with the support for optimization statements.""
  - ""The formal results of this paper support the validity of this approach (see Proposition 19 and 20).""
  - ""this work served a role of a spring board for a unifying framework studied in (Lierler 2022) that looked into formalisms which mix propositional and non-propositional (e.g., integer) variables in their languages and optimization statements.""",,"- The paper introduces a novel framework called ""weight systems"" that unifies different optimization paradigms, eliminating syntactic differences and highlighting similarities and differences (Quotes 1, 4).
 - This framework extends existing modular systems to include soft modules, providing a comprehensive view of optimization criteria (Quotes 3, 5).
 - The paper provides theoretical advancements by embedding various SAT-based optimization formalisms into this framework, demonstrating its explanatory power (Quotes 4, 6).
 - The work has implications for programming language design by offering a unified view that can help developers understand and compare different optimization criteria across paradigms (Quotes 7, 8).
 - The paper serves as a foundation for future work on integrating propositional and non-propositional variables in optimization statements, indicating potential for further theoretical contributions (Quote 10)."
Mathematical Theory of Computation,J. McCarthy,10.21236/ada239419,https://doi.org/10.21236/ada239419,-,371,1991,"1. Primitive Name: Function
  Definition: Part of higher order abstractions for software development
  Orthogonality Score: Not specified
 2. Primitive Name: Control
  Definition: Part of higher order abstractions for software development
  Orthogonality Score: Not specified
 3. Primitive Name: Assignment
  Definition: Part of higher order abstractions for software development
  Orthogonality Score: Not specified
 4. Primitive Name: Process
  Definition: Part of higher order abstractions for software development
  Orthogonality Score: Not specified
 5. Primitive Name: Reflection
  Definition: Part of higher order abstractions for software development
  Orthogonality Score: Not specified",Not specified (the abstract mentions a semantic framework and logical formalisms but does not specify the type of mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Development of correct and reusable software using higher order abstractions and reflection.
 - Theoretical advancements: Creation of a semantic framework for these abstractions; development of logical formalisms for reasoning about programs using these abstractions.
 - Potential implications for programming language design: New ways to reason about and manipulate programs, potentially leading to more efficient and reliable software development.","- ""the development of correct and reusable software through the use of higher order abstractions (function, control, assignment, process) and reflection.""
  - ""A semantic framework for these notions will be the basis of an experimental system for manipulating and reasoning about programs.""
  - ""the development of logical formalisms for reasoning about programs that use abstractions and reflection,""
  - ""logics for reasoning about function and control abstractions;""
  - ""logics for reasoning about data mutation;""
  - ""logics for reasoning about function and control abstractions in the presence of mutable data;""",,"- The abstract mentions ""higher order abstractions (function, control, assignment, process) and reflection"" as key concepts in the development of software. These are identified as conceptual primitives.
 - The mention of a ""semantic framework"" suggests that these primitives are part of a theoretical framework for understanding and manipulating programs.
 - The abstract discusses the development of ""logical formalisms"" for reasoning about these abstractions, indicating that they are foundational elements in the study's methodology.
 - The specific logics for reasoning about ""function and control abstractions,"" ""data mutation,"" and ""function and control abstractions in the presence of mutable data"" further detail the conceptual primitives.
 - The level of abstraction is high, as these primitives are foundational concepts in programming paradigms.
 - Orthogonality is not explicitly discussed in the abstract, but the primitives seem to be distinct and separate concepts.","- ""A semantic framework for these notions will be the basis of an experimental system for manipulating and reasoning about programs.""
  - ""The goals of this project were the development of logical formalisms for reasoning about programs that use abstractions and reflection,""
  - ""The accomplishments of this project fit into four categories: (1) logics for reasoning about function and control abstractions; (2) logics for reasoning about data mutation; (3) logics for reasoning about function and control abstractions in the presence of mutable data; and (4) applying methodology for reasoning about programs to the mechanical verification of hardware.""",,"- The abstract mentions the development of a ""semantic framework"" and ""logical formalisms,"" which suggests the use of a mathematical framework for formalizing and reasoning about programs.
 - The focus on ""logics for reasoning about function and control abstractions"" and ""logics for reasoning about data mutation"" indicates that the framework likely involves logical systems, possibly related to type theory or formal verification techniques.
 - The mention of ""applying methodology for reasoning about programs to the mechanical verification of hardware"" suggests the use of formal verification techniques, which are often based on mathematical frameworks like type theory or model checking.
 - However, the abstract does not specify the exact type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed by the framework.
 - There is no explicit mention of proof techniques used or limitations/constraints of the framework in the abstract.","- ""clarification of existing programming paradigms,""
  - ""analysis of existing and proposed languages used in the DARPA community for specifying, writing, and transforming programs,""
  - ""development and implementation of tools for computer aided reasoning about and operating on programs.""
  - ""logics for reasoning about function and control abstractions;""
  - ""logics for reasoning about data mutation;""
  - ""logics for reasoning about function and control abstractions in the presence of mutable data;""",,"- The abstract mentions the ""clarification of existing programming paradigms,"" which suggests an interest in understanding and possibly integrating different paradigms. However, it does not specify any particular integration mechanisms or models.
 - The analysis of languages used in the DARPA community could imply a comparative analysis of paradigms, but again, no specific integration strategies are mentioned.
 - The development of tools for reasoning about programs might involve integrating different paradigms, but the abstract does not provide details on how this integration is achieved.
 - The focus on logics for reasoning about abstractions and data mutation indicates a theoretical approach to understanding programming paradigms, but it does not explicitly address integration.
 - Overall, while the abstract discusses aspects related to programming paradigms, it does not provide a specific integration approach or mechanisms for integrating different paradigms.","- ""development of logical formalisms for reasoning about programs that use abstractions and reflection,""
  - ""semantic framework for these notions will be the basis of an experimental system for manipulating and reasoning about programs.""
  - ""development of correct and reusable software through the use of higher order abstractions (function, control, assignment, process) and reflection.""",,"- The abstract mentions the use of ""higher order abstractions"" such as function, control, assignment, and process, which are related to generic programming concepts.
 - The development of a ""semantic framework"" and ""logical formalisms"" suggests a focus on theoretical foundations that could support generic programming.
 - The mention of ""abstractions and reflection"" indicates a focus on conceptual abstraction mechanisms.
 - However, the abstract does not explicitly mention ""generic programming"" or provide specific details on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus seems to be more on the theoretical and logical aspects rather than specific generic programming methodologies or type system discussions.","- ""This project was concerned with the development of correct and reusable software through the use of higher order abstractions (function, control, assignment, process) and reflection.""
  - ""The goals of this project were the development of logical formalisms for reasoning about programs that use abstractions and reflection,""
  - ""The accomplishments of this project fit into four categories: (1) logics for reasoning about function and control abstractions; (2) logics for reasoning about data mutation; (3) logics for reasoning about function and control abstractions in the presence of mutable data; and (4) applying methodology for reasoning about programs to the mechanical verification of hardware.""
  - ""A semantic framework for these notions will be the basis of an experimental system for manipulating and reasoning about programs.""",,"- The abstract mentions the development of ""correct and reusable software"" using ""higher order abstractions"" and ""reflection,"" which suggests a novel approach to software development by focusing on these abstractions.
 - The creation of a ""semantic framework"" for these abstractions indicates a theoretical contribution by providing a structured way to understand and manipulate programs.
 - The development of ""logical formalisms for reasoning about programs"" that use these abstractions is a theoretical advancement, as it provides a systematic way to reason about programs.
 - The four categories of accomplishments highlight specific theoretical contributions: logics for reasoning about function and control abstractions, data mutation, and their combination with mutable data, as well as applying these methodologies to hardware verification.
 - These contributions imply potential implications for programming language design by providing new ways to reason about and manipulate programs, which could lead to more efficient and reliable software development."
Towards Language Interfaces for DSLs Integration,Thomas Degueule,-,-,-,2,2015,"1. Primitive Name: Language Interfaces
  Definition: Allow abstraction of intrinsic complexity in language implementations by exposing meaningful information for specific purposes.
  Orthogonality Score: Not discussed
 2. Primitive Name: Model Types
  Definition: Interfaces on the abstract syntax of a language, linked by subtyping relations for model polymorphism.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,"- Definition of ""concept"" used: Language interfaces and model types as mechanisms for abstraction.
 - Mechanisms for representing generic abstractions: Language interfaces and model types with subtyping relations.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Model polymorphism through model typing.","- Key novel insights: Introduction of ""language interfaces"" to improve modularity and abstraction in software language engineering.
 - Theoretical advancements: Definition of language interfaces to abstract complexity and facilitate modular language definition; use of model types for model polymorphism and information filtering.
 - Potential implications: Enhanced modularity and abstraction capabilities in programming language design; improved reuse and evolution of language implementations.","- ""Language interfaces allow to abstract some of the intrinsic complexity carried in the implementation of languages, by exposing meaningful information concerning an aspect of a language (e.g., syntactical constructs) and for a specific purpose (e.g., composition, reuse or coordination) in an appropriate formalism.""
  - ""The definition of language interfaces relies on proper formalisms for expressing different kinds of interfaces and binding relations between language implementations and interfaces.""
  - ""Model types [5] are an illustration of such kind of interfaces. Model types are interfaces on the abstract syntax of a language (defined by a metamodel).""
  - ""model types are linked one to another by subtyping relations, providing model polymorphism, i.e., the ability to manipulate a model through different interfaces.""
  - ""Model types can also be used to filter the information exposed from the abstract syntax of a language.""
  - ""Model types are supported by a model-oriented type system that leverages family polymorphism [3] and structural typing to abstract the conformance relation standing between models and metamodels with a typing relation between models and model types.""",,"- The abstract discusses the concept of ""language interfaces"" as a way to abstract complexity in language implementations. This suggests that language interfaces are a conceptual primitive for reconstructing programming paradigms.
 - The definition of language interfaces involves exposing meaningful information about a language's aspects, such as syntactical constructs, for purposes like composition or reuse. This indicates that language interfaces are defined to facilitate modularity and abstraction.
 - ""Model types"" are explicitly mentioned as an example of language interfaces. They are defined as interfaces on the abstract syntax of a language, which are linked by subtyping relations to enable model polymorphism.
 - Model types are supported by a model-oriented type system that uses family polymorphism and structural typing. This suggests that these are conceptual primitives for managing the relationships between models and metamodels.
 - The abstract does not provide a specific list of conceptual primitives with explicit names and definitions beyond language interfaces and model types. However, it implies that these concepts are fundamental to the approach proposed by the study.","- ""Model types are supported by a model-oriented type system that leverages family polymorphism [3] and structural typing to abstract the conformance relation standing between models and metamodels with a typing relation between models and model types.""
  - ""The definition of language interfaces relies on proper formalisms for expressing different kinds of interfaces and binding relations between language implementations and interfaces.""
  - ""Language interfaces allow to abstract some of the intrinsic complexity carried in the implementation of languages, by exposing meaningful information concerning an aspect of a language (e.g., syntactical constructs) and for a specific purpose (e.g., composition, reuse or coordination) in an appropriate formalism.""",,"- The abstract mentions the use of ""proper formalisms"" for expressing language interfaces, which suggests a mathematical framework is involved.
 - The mention of ""model-oriented type system"" and ""family polymorphism"" indicates a type theory framework, as these terms are commonly associated with type theory.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, nor does it discuss limitations or constraints of the framework.
 - The focus on ""model types"" and ""model-oriented type system"" suggests a framework that supports abstraction and polymorphism, but specific mathematical properties or proof techniques are not detailed.","- ""Developing software-intensive systems involves many stakeholders who bring their expertise on specific concerns of the developed system.""
  - ""Model-Driven Engineering (MDE) proposes to address each concern separately with a dedicated Domain-Specific (possibly modeling) Language (DSL) closely tied to the needs of each stakeholder""
  - ""DSLs evolve as the concepts in a domain and the expert understanding of the domain evolve.""
  - ""Finally, while more and more DSLs are developed in various domains, recurrent paradigms are observed (e.g., state-transition, classifiers) with their own syntactic and semantic variation points reflecting the domain specificities""
  - ""To support modularity, DSLs designers should be able to define proper provided and required interfaces for each language component, together with composition operators.""
  - ""To improve modularity and abstraction capabilities in software language engineering and support the aforementioned scenarios, we advocate the definition of explicit language interfaces on top of language implementations.""
  - ""Language interfaces allow to abstract some of the intrinsic complexity carried in the implementation of languages, by exposing meaningful information concerning an aspect of a language (e.g., syntactical constructs) and for a specific purpose (e.g., composition, reuse or coordination) in an appropriate formalism.""
  - ""Using language interfaces, one can vary or evolve the implementation of a language while preserving tools and analyses defined over its interface.""
  - ""Language interfaces also facilitate the modular definition of languages by enabling the description of required and provided interfaces of a language (or language component).""
  - ""Syntactical or semantical composition operators can then be defined upon these interfaces.""
  - ""Model types are interfaces on the abstract syntax of a language (defined by a metamodel).""
  - ""Model types can also be used to filter the information exposed from the abstract syntax of a language.""",,"- The abstract discusses the use of Domain-Specific Languages (DSLs) and their evolution, which implies integration of different programming paradigms.
 - The concept of ""language interfaces"" is proposed as a mechanism to abstract complexity and facilitate modularity and reuse across different DSLs.
 - These interfaces enable the definition of required and provided interfaces for language components, which can be used to integrate different paradigms.
 - The use of ""composition operators"" suggests a method for integrating different language components.
 - ""Model types"" are mentioned as a specific type of interface that can be used to filter information and define language viewpoints, which could be part of an integration approach.
 - The abstract does not explicitly mention specific integration mechanisms or interaction models between paradigms, nor does it discuss constraints or novel translation techniques in detail.","- ""Language interfaces allow to abstract some of the intrinsic complexity carried in the implementation of languages, by exposing meaningful information concerning an aspect of a language (e.g., syntactical constructs) and for a specific purpose (e.g., composition, reuse or coordination) in an appropriate formalism.""
  - ""language interfaces can be thought of as a reasoning layer on top of language implementations.""
  - ""The definition of language interfaces relies on proper formalisms for expressing different kinds of interfaces and binding relations between language implementations and interfaces.""
  - ""Using language interfaces, one can vary or evolve the implementation of a language while preserving tools and analyses defined over its interface.""
  - ""Language interfaces also facilitate the modular definition of languages by enabling the description of required and provided interfaces of a language (or language component).""
  - ""Model types are interfaces on the abstract syntax of a language (defined by a metamodel).""
  - ""model types are linked one to another by subtyping relations, providing model polymorphism, i.e., the ability to manipulate a model through different interfaces.""
  - ""Model types can also be used to filter the information exposed from the abstract syntax of a language.""
  - ""Melange provides DSLs users with an action language where models are first-class typed citizens and embeds a model-oriented type system that natively provides model polymorphism through model typing.""",,"- The abstract discusses the use of ""language interfaces"" as a mechanism for abstraction, allowing for the exposure of meaningful information about a language's aspects in a formalism. This suggests a focus on abstracting complexity and facilitating modularity.
 - The concept of ""language interfaces"" is central to the study's approach to generic programming, as it enables the modular definition of languages and the description of required and provided interfaces.
 - ""Model types"" are introduced as interfaces on the abstract syntax of a language, which are linked by subtyping relations to provide model polymorphism. This indicates a mechanism for representing generic abstractions.
 - The abstract mentions a ""model-oriented type system"" that leverages family polymorphism and structural typing, which suggests a type system that supports generic programming.
 - The mention of ""model polymorphism"" and ""typing relation between models and model types"" implies a focus on static checking and optimization strategies.
 - The abstract does not explicitly mention minimal type requirements or detailed static checking strategies, but it does emphasize the role of model types and language interfaces in abstraction.","- ""To improve modularity and abstraction capabilities in software language engineering and support the aforementioned scenarios, we advocate the definition of explicit language interfaces on top of language implementations.""
  - ""Language interfaces allow to abstract some of the intrinsic complexity carried in the implementation of languages, by exposing meaningful information concerning an aspect of a language (e.g., syntactical constructs) and for a specific purpose (e.g., composition, reuse or coordination) in an appropriate formalism.""
  - ""The definition of language interfaces relies on proper formalisms for expressing different kinds of interfaces and binding relations between language implementations and interfaces.""
  - ""Using language interfaces, one can vary or evolve the implementation of a language while preserving tools and analyses defined over its interface.""
  - ""Language interfaces also facilitate the modular definition of languages by enabling the description of required and provided interfaces of a language (or language component).""
  - ""Model types can also be used to filter the information exposed from the abstract syntax of a language.""
  - ""Model types are supported by a model-oriented type system that leverages family polymorphism [3] and structural typing to abstract the conformance relation standing between models and metamodels with a typing relation between models and model types.""
  - ""We incorporated these concepts into Melange [2], a new language for DSLs designers and users.""",,"- The abstract introduces the concept of ""language interfaces"" as a novel theoretical contribution. This concept is presented as a way to improve modularity and abstraction in software language engineering.
 - The definition of language interfaces is highlighted as a key theoretical advancement, allowing for the abstraction of complexity and facilitating modular language definition.
 - The use of model types as interfaces on the abstract syntax of a language is another theoretical innovation, enabling model polymorphism and filtering of information.
 - The integration of these concepts into Melange, a new language for DSLs designers and users, suggests a practical application of these theoretical contributions.
 - The abstract emphasizes the potential implications for programming language design, particularly in terms of modularity, abstraction, and reuse."
Towards a minimal object-oriented language for distributed and concurrent programming,"Matthias Radestock, S. Eisenbach",10.1145/197917.198152,https://doi.org/10.1145/197917.198152,ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing,1,1994,Not specified (the abstract does not provide explicit definitions or a list of conceptual primitives),"- Type of mathematical framework: Milner's calculus (process calculus)
 - Specific mathematical properties guaranteed: Concurrency modeling
 - Proof techniques used: Formal methods applicable to the calculus
 - Limitations or constraints of the framework: Initially lacked expressiveness, addressed by introducing a new ""mismatch"" operator","- Specific integration mechanisms proposed: Introduction of a new operator ""mismatch"" into Milner's calculus to enhance expressiveness.
 - Interaction models between paradigms: Inter-object and intra-object concurrency.
 - Constraints or challenges in paradigm integration: Lack of expressiveness in Milner's calculus.
 - Novel translation or embedding techniques: Translation of the language into calculus and Regis for distributed execution.",Generic programming not extensively addressed,"- Novel insights: Development of a simple object model that naturally accommodates concurrency.
 - Theoretical advancements: Introduction of a new operator ""mismatch"" into Milner's calculus to enhance expressiveness.
 - Potential implications: Minimalistic language design with few constructs for easier reasoning; formal specification for implementation.","- ""we introduce a new operator called mismatch into the calculus and investigate its impact on the rest of the calculus""
  - ""High level object oriented features are not included as primitives but it is shown how these can be modelled using the existing constructs""
  - ""we rst develop a model for objects that is simple and incorporates only essential features""
  - ""It was decided to use Milner s calculus for that purpose""",,"- The abstract mentions the development of a ""model for objects that is simple and incorporates only essential features,"" which suggests that the study focuses on identifying basic conceptual primitives for object-oriented programming.
 - It is stated that ""High level object-oriented features are not included as primitives,"" indicating that the study does not explicitly define these high-level features as primitives.
 - The use of ""Milner's calculus"" suggests that the study relies on this calculus as a theoretical framework, but it does not explicitly define the primitives within this context.
 - The introduction of a ""new operator called mismatch into the calculus"" implies that this operator is a conceptual primitive, but its definition is not explicitly provided in the abstract.
 - Overall, the abstract does not provide explicit definitions or a list of conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""It was decided to use Milner s calculus for that purpose This calculus is well de ned and provides a convenient way of modelling concurrency""
  - ""However it was found that the calculus lacked the expressiveness needed to de ne the semantics of the language Therefore we introduce a new operator called mismatch into the calculus and investigate its impact on the rest of the calculus""
  - ""Formal methods that are applicable to the calculus can be employed""
  - ""Taking a look at the problems which arise when implementing a concurrent and distributed object oriented system this model is then re ned and modi ed A formal speci cation of the nal model the basis for the implementation of a system is presented""
  - ""As concurrency issues were expected to play an central role it was important to de ne the semantics in a way that enables reasoning about these issues""",,"- The abstract mentions the use of ""Milner's calculus"" as the mathematical framework for formalizing and guaranteeing properties of the conceptual primitives. This indicates that the type of mathematical framework used is Milner's calculus, which is a process calculus.
 - The abstract states that Milner's calculus is ""well defined and provides a convenient way of modelling concurrency,"" suggesting that it is used to guarantee properties related to concurrency.
 - The introduction of a new operator called ""mismatch"" into the calculus implies that there were limitations or constraints in the original framework that needed to be addressed to enhance its expressiveness.
 - The mention of ""formal methods that are applicable to the calculus"" suggests that proof techniques are employed, but the specific techniques are not detailed in the abstract.","- ""The aim of the project was to develop and implement a concurrent object oriented language for distributed programming""
  - ""It is shown how inter object and intra object concurrency arise naturally from this model""
  - ""The language has only a few constructs This minimalistic approach makes it easier to reason about it""
  - ""High level object oriented features are not included as primitives but it is shown how these can be modelled using the existing constructs""
  - ""It was decided to use Milner s calculus for that purpose""
  - ""Therefore we introduce a new operator called mismatch into the calculus and investigate its impact on the rest of the calculus""
  - ""By translating the language into Regis it thus becomes executable on a distributed system""",,"- The abstract discusses the development of a concurrent object-oriented language for distributed programming, which implies integration of object-oriented and concurrent programming paradigms.
 - The mention of ""inter-object and intra-object concurrency"" suggests an interaction model between these paradigms.
 - The use of Milner's calculus to define semantics indicates a theoretical integration strategy for handling concurrency issues.
 - The introduction of a new operator ""mismatch"" into the calculus addresses a constraint or challenge in paradigm integration by enhancing expressiveness.
 - The translation of the language into calculus and its execution using a calculus interpreter, as well as the translation into Regis for distributed execution, represent novel translation techniques for integrating these paradigms.","- ""High level object oriented features are not included as primitives but it is shown how these can be modelled using the existing constructs""
  - ""The language has only a few constructs This minimalistic approach makes it easier to reason about it""",,"- The abstract discusses the development of a minimal object-oriented language for distributed and concurrent programming, focusing on simplicity and essential features.
 - The language is described as having only a few constructs, which suggests a minimalist approach to programming, but it does not explicitly mention generic programming or abstraction mechanisms.
 - The abstract mentions that high-level object-oriented features are not included as primitives but can be modeled using existing constructs, which implies some level of abstraction but does not specify genericity.
 - The use of Milner's calculus for defining semantics indicates a focus on concurrency rather than generic programming.
 - The introduction of a new operator called ""mismatch"" into the calculus suggests an extension to handle specific issues but does not relate to generic programming or abstraction mechanisms.
 - Overall, the abstract does not extensively address generic programming or abstraction mechanisms, focusing instead on concurrency and minimal language design.","- ""The aim of the project was to develop and implement a concurrent object oriented language for distributed programming""
  - ""It is shown how inter object and intra object concurrency arise naturally from this model""
  - ""High level object oriented features are not included as primitives but it is shown how these can be modelled using the existing constructs""
  - ""It was decided to use Milner s calculus for that purpose""
  - ""The language has only a few constructs This minimalistic approach makes it easier to reason about it""",,"- The abstract describes the development of a new model for objects that is simple and incorporates only essential features, which is a novel insight into object-oriented programming.
 - The model naturally accommodates inter-object and intra-object concurrency, which is a theoretical advancement beyond existing approaches.
 - The use of a minimalistic language approach with few constructs makes it easier to reason about, which is a theoretical contribution to programming language design.
 - The introduction of a new operator called ""mismatch"" into Milner's calculus to enhance its expressiveness is a significant theoretical innovation.
 - The formal specification of the final model provides a basis for implementation, which is a theoretical contribution to the field."
Gamma and the chemical reaction model: ten years after,"Jean-Pierre Bonâtre, D. L. Métayer",10.1142/9781848161023_0001,https://doi.org/10.1142/9781848161023_0001,-,76,1996,Not specified (the abstract does not explicitly define or list conceptual primitives),Not specified (the abstract does not provide details on a mathematical framework),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Gamma describes computation as a chemical reaction, moving away from traditional sequential programming.
 - Theoretical advancements: Gamma's minimal nature and absence of sequential bias allow for exploitation in various directions, addressing limitations of traditional sequential models.
 - Potential implications: Gamma's approach addresses the increasing complexity of software applications and technological advancements, offering a new paradigm for programming language design.","- ""Gamma was originally proposed in 1986 as a formalism for the deenition of programs without artiicial sequentiality.""
  - ""The notion of sequential computation has played a central r^ ole in the design of most programming languages in the past.""
  - ""However the computer science landscape has evolved considerably since then and the limitations of the sequential view have become more and more obvious.""
  - ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""",,"- The abstract discusses the Gamma formalism, which is based on the concept of describing computation as a chemical reaction. This suggests that the conceptual primitives might relate to this chemical reaction model.
 - The abstract mentions the shift away from sequential computation, indicating that the primitives might be designed to avoid artificial sequentiality.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It provides a general overview of the Gamma formalism and its underlying ideas but lacks detailed definitions of primitives.
 - The abstract does not mention any specific names or definitions of primitives, nor does it discuss their orthogonality or level of abstraction.","- ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""
  - ""The notion of sequential computation has played a central r^ ole in the design of most programming languages in the past.""
  - ""The basic chemical reaction model""
  - ""the computer science landscape has evolved considerably since then and the limitations of the sequential view have become more and more obvious.""",,"- The abstract discusses the Gamma formalism and its underlying idea of describing computation as a chemical reaction. This suggests a conceptual framework rather than a specific mathematical framework.
 - There is no mention of a specific type of mathematical framework such as type theory or category theory.
 - The abstract does not provide details on specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the conceptual model and its implications for software engineering rather than on a mathematical framework.","- ""Gamma was originally proposed in 1986 as a formalism for the deenition of programs without artiicial sequentiality.""
  - ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""
  - ""Due to the very minimal nature of the language, and its absence of sequential bias, it has been possible to exploit this initial paradigm in various directions.""
  - ""This paper reviews most of the work done by various groups along these lines and the current perspectives of our own research on Gamma.""
  - ""For the sake of clarity we separate the contributions in three categories: (1) the relevance of the chemical reaction model for software engineering, (2) extensions of the original model and (3) implementation issues.""
  - ""The notion of sequential computation has played a central r^ ole in the design of most programming languages in the past.""
  - ""However the computer science landscape has evolved considerably since then and the limitations of the sequential view have become more and more obvious.""",,"- The abstract discusses the Gamma formalism, which is based on a chemical reaction model for computation. This suggests a focus on a specific programming paradigm rather than integration of multiple paradigms.
 - The abstract mentions the minimal nature of the language and its lack of sequential bias, which could imply flexibility in integrating with other paradigms, but it does not explicitly discuss integration mechanisms or strategies.
 - The abstract separates contributions into categories related to software engineering, extensions of the model, and implementation issues, but it does not specify how these categories address integration of different programming paradigms.
 - The abstract does not provide specific integration mechanisms, interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.","- ""Gamma was originally proposed in 1986 as a formalism for the deenition of programs without artiicial sequentiality.""
  - ""For the sake of clarity we separate the contributions in three categories: (1) the relevance of the chemical reaction model for software engineering, (2) extensions of the original model and (3) implementation issues.""
  - ""This paper reviews most of the work done by various groups along these lines and the current perspectives of our own research on Gamma.""
  - ""Due to the very minimal nature of the language, and its absence of sequential bias, it has been possible to exploit this initial paradigm in various directions.""
  - ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""",,"- The abstract discusses Gamma as a formalism that describes computation as a chemical reaction, which is a unique approach to programming.
 - It mentions the minimal nature of the language and its lack of sequential bias, which could imply a focus on genericity and abstraction.
 - However, the abstract does not explicitly mention generic programming, abstraction mechanisms, type systems, or static checking strategies.
 - The focus is more on the chemical reaction model and its applications rather than specific mechanisms for generic programming or abstraction.
 - The abstract does not provide details on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.","- ""Gamma was originally proposed in 1986 as a formalism for the deenition of programs without artiicial sequentiality.""
  - ""The basic idea underlying the formalism is to describe computation as a form of chemical reaction on a collection of individual pieces of data.""
  - ""Due to the very minimal nature of the language, and its absence of sequential bias, it has been possible to exploit this initial paradigm in various directions.""
  - ""This paper reviews most of the work done by various groups along these lines and the current perspectives of our own research on Gamma.""
  - ""For the sake of clarity we separate the contributions in three categories: (1) the relevance of the chemical reaction model for software engineering, (2) extensions of the original model and (3) implementation issues.""
  - ""The notion of sequential computation has played a central r^ ole in the design of most programming languages in the past.""
  - ""However the computer science landscape has evolved considerably since then and the limitations of the sequential view have become more and more obvious.""
  - ""These changes have been caused by the tremendous increase in the size and the complexity of real software applications and the dramatic progress in the hardware technology.""",,"- The abstract introduces Gamma as a formalism that challenges traditional sequential programming by describing computation as a chemical reaction. This is a novel insight as it moves away from sequential computation, which has been central to programming language design.
 - The abstract highlights the minimal nature and absence of sequential bias in Gamma, which allows for exploitation in various directions. This suggests a theoretical advancement beyond existing sequential models.
 - The paper reviews work done on Gamma and its extensions, indicating a comprehensive exploration of its theoretical contributions.
 - The abstract discusses the evolution of software and hardware, suggesting that Gamma's approach addresses the limitations of traditional sequential models in the face of increasing complexity and technological advancements.
 - The separation of contributions into categories related to software engineering, model extensions, and implementation issues implies a structured approach to understanding Gamma's theoretical contributions."
Multi-paradigm Declarative Languages,M. Hanus,10.1007/978-3-540-74610-2_5,https://doi.org/10.1007/978-3-540-74610-2_5,International Conference on Logic Programming,106,2007,"1. Primitive Name: Narrowing
  Definition: A constructive method to deal with replacements in functional logic programming.
  Orthogonality Score: Not explicitly discussed.
 

 2. Primitive Name: Needed Narrowing
  Definition: A narrowing strategy that advocates the use of non-most general unifiers for optimality.
  Orthogonality Score: Not explicitly discussed.
 

 3. Primitive Name: Weakly Needed Narrowing
  Definition: An extension of needed narrowing for weakly orthogonal TRSs.
  Orthogonality Score: Not explicitly discussed.
 

 4. Primitive Name: Overlapping Inductively Sequential Systems
  Definition: A method to handle nondeterministic operations by allowing multiple right-hand sides in rules.
  Orthogonality Score: Not explicitly discussed.
 

 5. Primitive Name: Conditional Rules
  Definition: Rewrite rules with conditions for applicability.
  Orthogonality Score: Not explicitly discussed.","- Type of mathematical framework: Term Rewriting Systems (TRS), Constructor-based conditional ReWriting Logic (CRWL)
 - Specific mathematical properties guaranteed: Strict equality, approximation statements
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Extending functional languages with logic features or vice versa; using syntactic sugar to translate functional notation into logic kernel language.
 - Interaction models between paradigms: Narrowing and residuation.
 - Constraints or challenges in paradigm integration: Differences in operational semantics; potential suspension of evaluation in residuation; nondeterministic evaluation in narrowing.
 - Novel translation or embedding techniques: Combining residuation with weakly needed narrowing using flexible/rigid tags in definitional trees.",Generic programming not extensively addressed,"- Novel insights: Surveying approaches to combine different declarative programming paradigms into a single language.
 - Theoretical advancements: Integration of functional and logic programming paradigms, introduction of needed narrowing as a sound and complete method, integration of narrowing and residuation principles.
 - Potential implications: Combining flexibility of logic programming with efficiency of functional programming, implications for designing more efficient and flexible programming languages.","- ""This paper surveys approaches to combine these different classes into a single programming language.""
  - ""The different declarative programming paradigms offer a variety of programming concepts to the programmer.""
  - ""For instance, functional programming emphasizes generic programming using higher-order functions and polymorphic typing, and efficient and (under particular conditions) optimal evaluation strategies using demand-driven evaluation, which contributes to modularity in programming""
  - ""Logic programming supports the computation with partial information (logic variables) and nondeterministic search for solutions, where constraint programming adds efficient constraint solving capabilities for particular domains.""
  - ""Since all these features have been shown to be useful in application programming and declarative languages are based on common grounds, it is a natural idea to combine these worlds of programming into a single multi-paradigm declarative language.""
  - ""One can find two basic approaches to amalgamate functional and logic languages: either extend a functional language with logic programming features or extend a logic language with features for functional programming.""
  - ""The important question to be answered when designing a functional logic language is: How are conditions solved and are there constructive methods to avoid a blind guessing of values for unknowns?""
  - ""Needed Narrowing. The first narrowing strategy that advocated the use of non-most general unifiers and for which optimality results have been shown is needed narrowing""
  - ""Weakly Needed Narrowing. Inductively sequential TRS are a proper subclass of (constructor-based) TRSs.""
  - ""Overlapping Inductively Sequential Systems. Inductively sequential and weakly orthogonal TRSs are confluent, i.e., each term has at most one normal form.""
  - ""Conditional Rules. The narrowing strategies presented so far are defined for rewrite rules without conditions, although some of the concrete program examples indicate that conditional rules are convenient in practice.""",,"- The paper discusses the combination of different declarative programming paradigms (functional, logic, constraint) into a single language, indicating a focus on integrating various programming concepts.
 - It highlights specific features of each paradigm: functional programming emphasizes generic programming and demand-driven evaluation, logic programming supports computation with partial information and nondeterministic search, and constraint programming adds efficient constraint solving.
 - The paper introduces narrowing as a constructive method for dealing with replacements in functional logic programming, which is a key conceptual primitive.
 - Needed narrowing and weakly needed narrowing are presented as strategies for efficient evaluation, indicating they are conceptual primitives for managing nondeterminism and optimality.
 - Overlapping inductively sequential systems are discussed as a way to handle nondeterministic operations, suggesting another conceptual primitive.
 - Conditional rules are mentioned as a convenience in practice, indicating their role as a conceptual primitive in handling conditional logic.","- ""the theoretical part uses notations from term rewriting, its mapping into the concrete programming language syntax should be obvious.""
  - ""A term rewriting system (TRS) is set of rewrite rules, where an (unconditional) rewrite rule is a pair l → r with a linear pattern l as the left-hand side (lhs) and a term r as the right-hand side (rhs).""
  - ""The formal definition of needed narrowing is based on definitional trees and can be found in [9].""
  - ""CRWL can be used as the logical foundation of functional logic languages with non-strict nondeterministic operations.""
  - ""CRWL defines the deduction of two kinds of basic statements: approximation statements e → t with the intended meaning ""the partial constructor term t approximates the value of e"", and joinability statements e 1 =:= e 2 with the intended meaning that e 1 and e 2 have a common total approximation t ∈ T (C, X ) with e 1 → t and e 2 → t, thus modeling strict equality with terms containing variables.""
  - ""CRWL can be used as the logical foundation of functional logic languages with non-strict nondeterministic operations. It is a basis for the verification of functional logic programs [27] and has been extended in various directions, e.g., higher-order operations [37], algebraic types [17], polymorphic types [35], failure [68], constraints [67] etc.""",,"- The paper discusses the use of term rewriting systems (TRS) as a mathematical framework for formalizing the operational semantics of functional logic languages. This is evident from the description of TRS and its role in defining the operational principles of these languages.
 - The paper also introduces CRWL (Constructor-based conditional ReWriting Logic) as a logical foundation for declarative programming with non-strict and nondeterministic operations. CRWL is used to formalize the semantics of functional logic languages and to provide a basis for verification.
 - CRWL is described as a framework that models strict equality and provides a logical foundation for functional logic languages, indicating its role in guaranteeing specific mathematical properties related to equality and approximation.
 - The paper mentions that CRWL has been extended in various directions, such as higher-order operations, algebraic types, and polymorphic types, suggesting that it is a flexible framework that can accommodate different mathematical properties.
 - The limitations or constraints of the framework are not explicitly discussed in the paper, but the focus on non-strict and nondeterministic operations suggests that CRWL is designed to handle these specific aspects of functional logic programming.","- ""This paper surveys approaches to combine these different classes into a single programming language.""
  - ""One can find two basic approaches to amalgamate functional and logic languages: either extend a functional language with logic programming features or extend a logic language with features for functional programming.""
  - ""Since functions can be considered as specific relations, there is a straightforward way to implement the second approach: extend a logic language with syntactic sugar to allow functional notation (e.g., defining equations, nested functional expressions) which is translated by some preprocessor into the logic kernel language.""
  - ""Extensions of functional languages with logic programming features try to retain the efficient demand-driven computation strategy for purely functional computations and add some additional mechanism for the extended features.""
  - ""The combination of variable instantiation and rewriting is called narrowing.""
  - ""Narrowing is sound and complete but requires the nondeterministic evaluation of function calls if some arguments are unknown.""
  - ""Residuation might not compute some result due to the potential suspension of evaluation but avoids guessing on functions.""
  - ""it is desirable to integrate both principles in a single framework. This has been proposed in [41] where residuation is combined with weakly needed narrowing by extending definitional trees with branches decorated with a flexible/rigid tag.""
  - ""The operational semantics is based on weakly needed narrowing with sharing and residuation.""
  - ""Narrowing and residuation are quite different approaches to integrate functional and logic programming.""",,"- The paper discusses the integration of different programming paradigms, specifically focusing on combining functional and logic programming.
 - Two main integration approaches are identified: extending functional languages with logic features or vice versa.
 - The paper describes the use of syntactic sugar to translate functional notation into logic kernel language, which is a specific integration mechanism.
 - Narrowing and residuation are presented as interaction models between paradigms, with narrowing being sound and complete but requiring nondeterministic evaluation, and residuation avoiding guessing but potentially suspending evaluation.
 - The paper highlights the challenge of integrating these paradigms due to the differences in their operational semantics.
 - A novel translation technique involves combining residuation with weakly needed narrowing by using flexible/rigid tags in definitional trees.
 - The operational semantics of the integrated language is based on weakly needed narrowing with sharing and residuation, indicating a comprehensive integration approach.","- ""functional programming emphasizes generic programming using higher-order functions and polymorphic typing, and efficient and (under particular conditions) optimal evaluation strategies using demand-driven evaluation, which contributes to modularity in programming""
  - ""modern functional languages offer more features for convenient programming. In particular, they sup-port the definition of algebraic data types by enumerating their constructors.""
  - ""The use of higher-order operations, i.e., operations that take other operations as arguments or yields them as results, is an important programming technique in functional languages so that it should be also covered by multi-paradigm declarative languages.""
  - ""More complex data structures can be obtained by recursive data types.""
  - ""Functions on Booleans can be defined by pattern matching, i.e., by providing several equations for different argument values:""",,"- The paper discusses generic programming in the context of functional programming, highlighting the use of higher-order functions and polymorphic typing as key mechanisms for genericity.
 - The definition of ""concept"" in this context seems to relate to the abstract representation of data types and operations, which are defined using algebraic data types and pattern matching.
 - Mechanisms for representing generic abstractions include higher-order functions and polymorphic typing, which allow for flexible and reusable code.
 - The paper does not explicitly mention minimal type requirements or static checking strategies, but it implies that these are part of the functional programming paradigm.
 - The paper does not extensively focus on generic programming or provide detailed discussions on type systems or abstraction mechanisms beyond what is mentioned in the context of functional programming.","- ""This paper surveys approaches to combine these different classes into a single programming language.""
  - ""The different declarative programming paradigms offer a variety of programming concepts to the programmer.""
  - ""Since all these features have been shown to be useful in application programming and declarative languages are based on common grounds, it is a natural idea to combine these worlds of programming into a single multi-paradigm declarative language.""
  - ""the interactions between the different features are complex in detail so that the concrete design of a multi-paradigm declarative language is non-trivial.""
  - ""This is demonstrated by many different proposals and a lot of research work on the semantics, operational principles, and implementation of multi-paradigm declarative languages since more than two decades.""
  - ""The important question to be answered when designing a functional logic language is: How are conditions solved and are there constructive methods to avoid a blind guessing of values for unknowns?""
  - ""Needed narrowing is sound and complete, i.e., all computed solutions are correct and for each correct solution a possibly more general one is computed, and it does not compute redundant solutions in different derivations:""
  - ""Narrowing and residuation are quite different approaches to integrate functional and logic programming.""
  - ""Therefore, it is desirable to integrate both principles in a single framework.""
  - ""The combination of functional and logic language features are exploited in [43] for the high-level programming of GUIs.""
  - ""We conclude with a summary of the advantages of combining different declarative paradigms in a single language.""
  - ""As a consequence, functional logic languages combine the flexibility of logic programming with the efficiency of functional programming.""",,"- The paper surveys approaches to combine different declarative programming paradigms, which is a novel insight into how these paradigms can be integrated.
 - The integration of functional and logic programming paradigms is highlighted as a significant theoretical contribution, as it combines the flexibility of logic programming with the efficiency of functional programming.
 - The paper discusses the complexity of designing multi-paradigm declarative languages and the need for constructive methods to solve conditions, which is a theoretical advancement beyond existing approaches.
 - The introduction of needed narrowing as a sound and complete method for solving conditions is a theoretical innovation.
 - The integration of narrowing and residuation principles is another theoretical contribution, as it provides a comprehensive framework for functional logic programming.
 - The paper's focus on the theoretical foundations and operational principles of multi-paradigm declarative languages has potential implications for programming language design, particularly in terms of efficiency and flexibility."
Position paper: practical foundations for lrogramming languages,R. Harper,10.1145/1480828.1480843,https://doi.org/10.1145/1480828.1480843,SIGP,0,2008,Not specified (the abstract does not explicitly list or define conceptual primitives),Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Programming languages are a form of expression and communication that require high rigor; the study of programming languages is about understanding what is computable.
 - Theoretical advancements: Analysis and codification of core computational concepts; introduction of the scientific theory of the computable.
 - Potential implications for programming language design: Focus on fundamental principles and their combination, akin to chemistry's periodic table.","- ""The study of programming languages is therefore a study of what is computable in the broadest sense, namely what can be programmed?""
  - ""The purpose of a course in Programming Languages (PL) in an undergraduate curriculum is to introduce the scientific theory of the computable.""
  - ""The study of programming languages is the science of computation itself, and as such lies at the heart of the discipline of Computer Science.""
  - ""The purpose of PL is to analyze and codify core computational concepts that arise in all languages, and to synthesize these concepts in the construction of tools and systems for program development.""
  - ""Through analysis we discover what computation consists of and through synthesis we learn how to compute useful things.""",,"- The abstract discusses the importance of analyzing and codifying core computational concepts, which suggests that these concepts are fundamental to understanding programming languages.
 - It mentions the purpose of a course in Programming Languages as introducing the scientific theory of the computable, indicating that these concepts are related to what can be programmed.
 - The abstract does not explicitly list specific conceptual primitives or provide definitions for them.
 - The focus is on the study of what is computable and the science of computation, but no specific primitives are identified or defined.","- ""A program is a form of expression that conveys an idea, much as does a proof in mathematics.""
  - ""The purpose of a course in Programming Languages (PL) in an undergraduate curriculum is to introduce the scientific theory of the computable.""
  - ""The study of programming languages is therefore a study of what is computable in the broadest sense, namely what can be programmed?""
  - ""Unlike natural languages, programming languages must, to be meaningful both to people and machines, must meet a very high standard of rigor unmatched in other fields, even mathematics.""
  - ""The purpose of PL is to analyze and codify core computational concepts that arise in all languages, and to synthesize these concepts in the construction of tools and systems for program development.""",,"- The abstract discusses the importance of rigor in programming languages, comparing it to the rigor in mathematics. This suggests a theoretical foundation that might involve mathematical frameworks.
 - The mention of ""proof in mathematics"" implies a connection to formal proof methodologies, which are often part of mathematical frameworks.
 - The abstract talks about the study of what is computable, which is a fundamental concept in theoretical computer science and often involves mathematical frameworks like type theory or category theory.
 - However, the abstract does not explicitly mention any specific mathematical framework, such as type theory or category theory, nor does it detail specific mathematical properties or proof techniques.
 - The focus on ""core computational concepts"" and ""scientific theory of the computable"" suggests a theoretical approach, but without explicit details on the mathematical framework used.","- ""There are two forms of answer to these questions, one empirical, the other conceptual.""
  - ""Less contentiously, can we separate core concepts from the context in which they are utilized? Are there shared principles that can be isolated and codified, or are all software systems constructions unto themselves?""
  - ""A skeptic may wonder whether there are any core concepts in computing. Is Computer Science a science, or a craft? Is there a scientific theory of programming? Or is programming a collection of methods and practices that are passed on as a kind of folk art?""
  - ""The purpose of PL is to analyze and codify core computational concepts that arise in all languages, and to synthesize these concepts in the construction of tools and systems for program development.""",,"- The abstract discusses the purpose of a course in Programming Languages (PL) as analyzing and codifying core computational concepts and synthesizing them for tool development. This suggests a focus on understanding and integrating fundamental concepts across different programming languages.
 - The analogy with the periodic table of elements implies a focus on fundamental ingredients and how they can be combined, which could relate to integrating different programming paradigms.
 - The abstract questions whether there are core concepts in computing and whether these can be separated from context, which is relevant to integrating paradigms.
 - However, the abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques for integrating different programming paradigms.
 - The abstract does not provide a detailed discussion of paradigm interactions, theoretical integration strategies, or comparative analysis sections that would typically be expected in a description of a ""Programming Paradigm Integration Approach.""","- ""A program is a form of expression that conveys an idea, much as does a proof in mathematics.""
  - ""Programming, therefore, is intrinsically about the language we use to write programs and to express the reasoning that gives rise to them.""
  - ""The study of programming languages is therefore a study of what is computable in the broadest sense, namely what can be programmed?""
  - ""The purpose of a course in Programming Languages (PL) in an undergraduate curriculum is to introduce the scientific theory of the computable.""
  - ""The purpose of PL is to analyze and codify core computational concepts that arise in all languages, and to synthesize these concepts in the construction of tools and systems for program development.""
  - ""Through analysis we discover what computation consists of and through synthesis we learn how to compute useful things.""
  - ""A skeptic may wonder whether there are any core concepts in computing. Is Computer Science a science, or a craft? Is there a scientific theory of programming?""
  - ""Less contentiously, can we separate core concepts from the context in which they are utilized? Are there shared principles that can be isolated and codified, or are all software systems constructions unto themselves?""",,"- The abstract discusses the nature of programming languages and their role in expressing computational ideas, but it does not specifically address generic programming or abstraction mechanisms.
 - The focus is on the study of programming languages as a science, analyzing and codifying core computational concepts, but there is no mention of genericity or abstraction mechanisms.
 - The abstract does not provide a definition of ""concept"" in the context of generic programming or abstraction.
 - There is no discussion of mechanisms for representing generic abstractions or minimal type requirements.
 - The abstract does not mention static checking or optimization strategies related to generic programming.
 - The overall focus is on the theoretical foundations of programming languages rather than specific methodologies like generic programming.","- ""A program is a form of expression that conveys an idea, much as does a proof in mathematics.""
  - ""Programming, therefore, is intrinsically about the language we use to write programs and to express the reasoning that gives rise to them.""
  - ""Unlike natural languages, programming languages must, to be meaningful both to people and machines, must meet a very high standard of rigor unmatched in other fields, even mathematics.""
  - ""The study of programming languages is therefore a study of what is computable in the broadest sense, namely what can be programmed?""
  - ""The purpose of a course in Programming Languages (PL) in an undergraduate curriculum is to introduce the scientific theory of the computable.""
  - ""The purpose of PL is to analyze and codify core computational concepts that arise in all languages, and to synthesize these concepts in the construction of tools and systems for program development.""
  - ""To draw a rough analogy with undergraduate Chemistry, the role of PL is to study the periodic table of elements, the fundamental ingredients, and to discuss how these may be combined to form useful substances.""
  - ""A skeptic may wonder whether there are any core concepts in computing. Is Computer Science a science, or a craft? Is there a scientific theory of programming?""
  - ""There are two forms of answer to these questions, one empirical, the other conceptual.""",,"- The abstract emphasizes the importance of programming languages as a form of expression and communication, both for humans and machines, highlighting the need for rigor in programming languages.
 - It suggests that the study of programming languages is about understanding what is computable, which is a fundamental theoretical contribution to the field.
 - The purpose of a programming languages course is to introduce the scientific theory of the computable, indicating a focus on theoretical foundations.
 - The abstract discusses the analysis and codification of core computational concepts, which is a theoretical advancement beyond mere description or classification of languages.
 - The analogy with chemistry suggests a focus on fundamental principles and their combination, which is a novel insight into how programming languages should be studied.
 - The abstract questions whether computer science is a science or a craft, and whether there is a scientific theory of programming, indicating a theoretical contribution by addressing these questions."
Institution-independent logic programming,Ionut Tutu,-,-,-,0,2015,"1. Primitive Name: Logic Program
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed
 2. Primitive Name: Clause
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed
 3. Primitive Name: Query
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed
 4. Primitive Name: Solution
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed
 5. Primitive Name: Computed Answer
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed","- Type of mathematical framework: Abstract model-theoretic framework, incorporating elements of institutional theory (category theory)
 - Specific mathematical properties guaranteed: Sound and conditionally complete procedure for computing solutions to queries
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Integration of declarative and operational aspects of logical systems.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"" used: Abstractions of notions such as logic program, clause, query, solution, and computed answer.
 - Mechanisms for representing generic abstractions: Abstract model-theoretic framework.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: Generalization of logic programming paradigm to arbitrary logical systems; abstraction of key concepts using Goguen and Burstall’s theory of institutions.
 - Theoretical advancements: Development of an abstract model-theoretic framework; variant of Herbrand’s theorem not limited to specific formalisms; sound and conditionally complete procedure for computing solutions to queries.
 - Potential implications for programming language design: Application of logic programming principles to less conventional formalisms like orchestration schemes in service-oriented computing.","- ""Our study is based on abstractions of notions such as logic program, clause, query, solution, and computed answer,""
  - ""These give rise to a series of concepts that formalize the interplay between the denotational and the operational semantics of logic programming.""
  - ""we propose an abstract model-theoretic framework that allows us to develop and conduct research into logic programming over an arbitrary logical system,""
  - ""Within this setting, we further examine two of the most fundamental aspects of the modularization of logic programs – the preservation and the re ection of solutions along morphisms of programs""
  - ""We investigate properties concerning the satisfaction of quanti ed sentences, discuss a variant of Herbrand’s theorem that is not limited in scope to any logical formalism or construction of logic programs, and de ne a sound and conditionally complete procedure for computing solutions to queries.""",,"- The abstract mentions the development of an ""abstract model-theoretic framework"" which suggests a high level of abstraction.
 - The study is based on ""abstractions of notions such as logic program, clause, query, solution, and computed answer,"" indicating these are conceptual primitives.
 - These primitives are used to formalize the interplay between denotational and operational semantics, suggesting they are fundamental to the framework.
 - The abstract does not provide explicit definitions for these primitives, but they are implied to be foundational to the study.
 - The mention of investigating properties and defining procedures suggests these primitives are used to explore deeper theoretical aspects of logic programming.","- ""we propose an abstract model-theoretic framework that allows us to develop and conduct research into logic programming over an arbitrary logical system, without concrete models, sentences, satisfaction, or deduction,""
  - ""Our study is based on abstractions of notions such as logic program, clause, query, solution, and computed answer, which we develop over Goguen and Burstall’s theory of institutions.""
  - ""These give rise to a series of concepts that formalize the interplay between the denotational and the operational semantics of logic programming.""
  - ""In essence, programming in logic amounts to giving appropriate axiomatic formalizations of computable functions, which can then be executed by means of carefully designed goal-directed deduction rules.""
  - ""We investigate properties concerning the satisfaction of quanti ed sentences, discuss a variant of Herbrand’s theorem that is not limited in scope to any logical formalism or construction of logic programs, and de ne a sound and conditionally complete procedure for computing solutions to queries.""",,"- The abstract mentions an ""abstract model-theoretic framework,"" which suggests that the mathematical framework is based on model theory.
 - The framework is described as allowing research into logic programming over an arbitrary logical system, indicating a high level of generality and flexibility.
 - The use of ""Goguen and Burstall’s theory of institutions"" suggests that the framework incorporates elements of institutional theory, which is a part of category theory.
 - The abstract discusses the formalization of the interplay between denotational and operational semantics, which is a key aspect of the framework.
 - The mention of a ""sound and conditionally complete procedure for computing solutions to queries"" indicates specific mathematical properties guaranteed by the framework.
 - The abstract does not explicitly mention limitations or constraints of the framework.","- ""Based on these, we propose an abstract model-theoretic framework that allows us to develop and conduct research into logic programming over an arbitrary logical system, without concrete models, sentences, satisfaction, or deduction, and thus to explore the logicprogramming paradigm for other, less conventional formalisms, like the logic of orchestration schemes used in the context of service-oriented computing.""
  - ""These give rise to a series of concepts that formalize the interplay between the denotational and the operational semantics of logic programming.""
  - ""Our study is based on abstractions of notions such as logic program, clause, query, solution, and computed answer, which we develop over Goguen and Burstall’s theory of institutions.""",,"- The abstract discusses the integration of declarative and operational aspects of logical systems, which is a key integration mechanism in the logic programming paradigm.
 - It mentions examining common features across different logic programming languages, which suggests a comparative analysis that could lead to integration strategies.
 - The proposal of an abstract model-theoretic framework indicates a theoretical integration strategy that allows for the exploration of logic programming over various logical systems.
 - The use of abstractions based on Goguen and Burstall’s theory of institutions suggests a novel approach to formalizing the interplay between denotational and operational semantics.
 - The abstract does not explicitly mention specific interaction models between paradigms or constraints/challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.","- ""These give rise to a series of concepts that formalize the interplay between the denotational and the operational semantics of logic programming.""
  - ""Our study is based on abstractions of notions such as logic program, clause, query, solution, and computed answer, which we develop over Goguen and Burstall’s theory of institutions.""
  - ""In this thesis, we examine common features of various conventional logicprogramming languages, ranging from the most traditional variant of the paradigm – de ned over Horn-clause logic – to rst-order and higher-order equational logic programming.""
  - ""We investigate properties concerning the satisfaction of quanti ed sentences, discuss a variant of Herbrand’s theorem that is not limited in scope to any logical formalism or construction of logic programs, and de ne a sound and conditionally complete procedure for computing solutions to queries.""
  - ""Based on these, we propose an abstract model-theoretic framework that allows us to develop and conduct research into logic programming over an arbitrary logical system, without concrete models, sentences, satisfaction, or deduction,""",,"- The abstract discusses the examination of common features across various logic programming languages, which suggests a focus on genericity by considering multiple paradigms.
 - The proposal of an ""abstract model-theoretic framework"" indicates a mechanism for representing generic abstractions, as it allows for research over arbitrary logical systems.
 - The use of ""abstractions of notions"" such as logic programs and clauses implies a conceptual abstraction mechanism.
 - The mention of ""Goguen and Burstall’s theory of institutions"" suggests a theoretical framework that could provide minimal type requirements or static checking strategies, although these are not explicitly detailed.
 - The abstract does not explicitly mention type system discussions or static checking strategies, but the focus on abstraction and generic frameworks implies some level of generic programming methodology.","- ""In this thesis, we examine common features of various conventional logicprogramming languages, ranging from the most traditional variant of the paradigm – de ned over Horn-clause logic – to rst-order and higher-order equational logic programming.""
  - ""Based on these, we propose an abstract model-theoretic framework that allows us to develop and conduct research into logic programming over an arbitrary logical system, without concrete models, sentences, satisfaction, or deduction, and thus to explore the logicprogramming paradigm for other, less conventional formalisms, like the logic of orchestration schemes used in the context of service-oriented computing.""
  - ""Our study is based on abstractions of notions such as logic program, clause, query, solution, and computed answer, which we develop over Goguen and Burstall’s theory of institutions.""
  - ""These give rise to a series of concepts that formalize the interplay between the denotational and the operational semantics of logic programming.""
  - ""We investigate properties concerning the satisfaction of quanti ed sentences, discuss a variant of Herbrand’s theorem that is not limited in scope to any logical formalism or construction of logic programs, and de ne a sound and conditionally complete procedure for computing solutions to queries.""
  - ""Within this setting, we further examine two of the most fundamental aspects of the modularization of logic programs – the preservation and the re ection of solutions along morphisms of programs – leading to results that can be applied not only to unstructured logic programs (plain sets of clauses), but also to elaborate module systems.""",,"- The abstract proposes an ""abstract model-theoretic framework"" that allows for the exploration of logic programming over arbitrary logical systems. This is a novel insight as it generalizes the logic programming paradigm beyond traditional formalisms.
 - The study develops abstractions of key concepts in logic programming using Goguen and Burstall’s theory of institutions. This is a theoretical advancement as it provides a unified framework for understanding logic programming across different systems.
 - The investigation into properties concerning the satisfaction of quantified sentences and the development of a variant of Herbrand’s theorem not limited to specific formalisms are theoretical contributions. These advancements are beyond existing approaches as they are not confined to traditional logic programming frameworks.
 - The definition of a sound and conditionally complete procedure for computing solutions to queries is a theoretical contribution, as it provides a rigorous method for solving queries in a generalized context.
 - The examination of modularization aspects, such as the preservation and reflection of solutions along morphisms of programs, is a theoretical contribution. It extends the applicability of these concepts to both unstructured and structured module systems, which is a novel insight.
 - The potential implications for programming language design include the ability to apply logic programming principles to less conventional formalisms, such as the logic of orchestration schemes in service-oriented computing. This suggests a broader applicability of logic programming principles beyond traditional domains."
Linking a “ State-rich ” Process Algebra to a “ State-free ” Process Algebra to Verify Software / Hardware Implementations,"Arshad Beg Lero, Andrew Butterfield Lero",-,-,-,0,2010,Not specified (the abstract does not mention any new conceptual primitives defined by the study),"- Type of mathematical framework: Unifying Theories of Programming (UTP) based on the theory of relations
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Formalizing key translation and refinement steps
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Developing a formally verified link between Circus and CSP by identifying key translations and formalizing them.
 - Interaction models between paradigms: Using the Unifying Theories of Programming (UTP) framework to integrate different programming paradigms.
 - Constraints or challenges in paradigm integration: Lack of a fully developed model-checker for Circus.
 - Novel translation or embedding techniques: Using UTP to unify the semantics of Circus and CSP.",Generic programming not extensively addressed,"- Novelty: Developing a formally verified link between a state-rich process algebra (Circus) and a state-free process algebra (CSP).
 - Theoretical Advancements: Integrating formal methods tools to work in an automatic or semi-automatic cyclic manner; contributing to the Grand Challenge in Computing project by enhancing the prototype collection of integrated programming tools.
 - Potential Implications: Enhancing programming language design by providing a more comprehensive and verified theory of programming through the integration of different paradigms within the UTP framework.","- ""The aim of this work is to develop a formally verified link between a state-rich process algebra i.e. ‘Circus’ to a state-free process algebra i.e. CSP.""
  - ""To achieve the research goal, the most suitable available tools are to identify.""
  - ""For developing link between targeted formal languages, we will identify the key translations required between the two languages.""
  - ""For ensuring correctness of the translation, we will formalise the key translation / refinement steps.""
  - ""The need of developing link between these two tools is due to the fact the model-checker for ‘Circus’ is still under development while there is an academically and industry-proven model-checker for ‘CSP’.""
  - ""The key motivation for developing the link is to contribute to the ‘Grand Challenge in Computing’ (GC6) project.""
  - ""the development of the link will be a contribution to the prototype collection of integrated suite of programming tools.""
  - ""The Unifying Theories of Programming (UTP) [11] proposes a unification of different programming paradigms based on the theory of relations.""
  - ""The semantics of Circus in UTP framework are explained in detail in [22]. Furthermore, the UTP semantics of CSP are discussed in [6].""",,"- The abstract discusses the development of a link between two process algebras, Circus and CSP, which are state-rich and state-free, respectively. This link is aimed at leveraging the strengths of both paradigms.
 - The methodology involves identifying suitable tools and key translations between the two languages, which suggests a focus on developing a framework for integration rather than defining new conceptual primitives.
 - The abstract mentions the use of the Unifying Theories of Programming (UTP) framework, which is a theoretical framework for unifying different programming paradigms. However, it does not specify any new conceptual primitives defined by the study.
 - The focus is on linking existing formal languages rather than proposing new primitives, indicating that the study does not define new conceptual primitives.","- ""The aim of this work is to develop a formally verified link between a state-rich process algebra i.e. ‘Circus’ to a state-free process algebra i.e. CSP.""
  - ""To achieve the research goal, the most suitable available tools are to identify.""
  - ""For developing link between targeted formal languages, we will identify the key translations required between the two languages.""
  - ""For ensuring correctness of the translation, we will formalise the key translation / refinement steps.""
  - ""These will form the theoretical core of the work and support the soundness of the link.""
  - ""The need of developing link between these two tools is due to the fact the model-checker for ‘Circus’ is still under development while there is an academically and industry-proven model-checker for ‘CSP’.""
  - ""The Unifying Theories of Programming (UTP) [11] proposes a unification of different programming paradigms based on the theory of relations.""
  - ""The semantics of Circus in UTP framework are explained in detail in [22].""
  - ""Furthermore, the UTP semantics of CSP are discussed in [6].""",,"- The abstract mentions the development of a formally verified link between Circus and CSP, which implies a focus on formal verification.
 - The use of the Unifying Theories of Programming (UTP) framework is explicitly mentioned as a basis for unifying different programming paradigms.
 - UTP is based on the theory of relations, which suggests a relational mathematical framework.
 - The abstract discusses formalizing key translation and refinement steps, which are part of the proof methodology.
 - The mention of UTP semantics for both Circus and CSP indicates that UTP is used to guarantee properties of these formal languages.
 - However, specific mathematical properties guaranteed, proof techniques used, and limitations or constraints of the framework are not explicitly detailed in the abstract.","- ""Following the development of formalisms based on data and behavioural aspects of the system, there are number of attempts in which these two formalisms are mixed together to get benefit of both paradigms.""
  - ""Circus’ being a living specification language with continuous collaboration from both academia and industry, is a combination of Z, CSP and the refinement calculus.""
  - ""The aim of this work is to develop a formally verified link between a state-rich process algebra i.e. ‘Circus’ to a state-free process algebra i.e. CSP.""
  - ""To achieve the research goal, the most suitable available tools are to identify.""
  - ""For developing link between targeted formal languages, we will identify the key translations required between the two languages.""
  - ""For ensuring correctness of the translation, we will formalise the key translation / refinement steps.""
  - ""The need of developing link between these two tools is due to the fact the model-checker for ‘Circus’ is still under development while there is an academically and industry-proven model-checker for ‘CSP’.""
  - ""The key motivation for developing the link is to contribute to the ‘Grand Challenge in Computing’ (GC6) project.""
  - ""the development of the link will be a contribution to the prototype collection of integrated suite of programming tools.""
  - ""Circus’ is a specification language that combines Z, CSP and refinement calculus constructs.""
  - ""The main difference between Circus and other ones is that the languages i.e. Z and CSP are mixed freely in a specification.""
  - ""The Unifying Theories of Programming (UTP) [11] proposes a unification of different programming paradigms based on the theory of relations.""
  - ""The semantics of Circus in UTP framework are explained in detail in [22]. Furthermore, the UTP semantics of CSP are discussed in [6].""",,"- The study aims to integrate different programming paradigms by developing a formally verified link between Circus (a state-rich process algebra) and CSP (a state-free process algebra).
 - The integration mechanism involves identifying key translations required between the two languages and formalizing these translations to ensure correctness.
 - The interaction model between paradigms is facilitated through the use of the Unifying Theories of Programming (UTP) framework, which provides a theoretical basis for integrating different programming paradigms.
 - A constraint or challenge in paradigm integration is the lack of a fully developed model-checker for Circus, necessitating the link to CSP's model-checker.
 - The study contributes to the Grand Challenge in Computing project by developing a prototype for an integrated suite of programming tools.
 - The novel translation or embedding technique involves using UTP to unify the semantics of Circus and CSP, allowing for a seamless integration of these paradigms.","- ""The aim of this work is to develop a formally verified link between a state-rich process algebra i.e. ‘Circus’ to a state-free process algebra i.e. CSP.""
  - ""To achieve the research goal, the most suitable available tools are to identify.""
  - ""For developing link between targeted formal languages, we will identify the key translations required between the two languages.""
  - ""For ensuring correctness of the translation, we will formalise the key translation / refinement steps.""
  - ""The main difference between Circus and other ones is that the languages i.e. Z and CSP are mixed freely in a specification.""
  - ""A Circus program consists of a sequence of paragraphs. These paragraphs can be a: Z paragraph, channel or channel set definition, or a process declaration.""
  - ""The Unifying Theories of Programming (UTP) [11] proposes a unification of different programming paradigms based on the theory of relations.""",,"- The abstract primarily focuses on linking two process algebras, Circus and CSP, rather than discussing generic programming or abstraction mechanisms.
 - The mention of ""key translations required between the two languages"" and ""formalise the key translation / refinement steps"" suggests a focus on language integration rather than generic programming.
 - The description of Circus as a language that mixes Z and CSP freely indicates a focus on language integration rather than genericity or abstraction mechanisms.
 - The abstract does not explicitly mention generic programming, type systems, or abstraction mechanisms, which are key components of generic programming.
 - The reference to UTP is about unifying programming paradigms, not specifically about generic programming or abstraction mechanisms.","- ""The aim of this work is to develop a formally verified link between a state-rich process algebra i.e. ‘Circus’ to a state-free process algebra i.e. CSP.""
  - ""The need of developing link between these two tools is due to the fact the model-checker for ‘Circus’ is still under development while there is an academically and industry-proven model-checker for ‘CSP’.""
  - ""The key motivation for developing the link is to contribute to the ‘Grand Challenge in Computing’ (GC6) project.""
  - ""the development of the link will be a contribution to the prototype collection of integrated suite of programming tools.""
  - ""To achieve the research goal, the most suitable available tools are to identify.""
  - ""For developing link between targeted formal languages, we will identify the key translations required between the two languages.""
  - ""For ensuring correctness of the translation, we will formalise the key translation / refinement steps.""
  - ""These will form the theoretical core of the work and support the soundness of the link.""",,"- The study aims to create a formally verified link between two different process algebras, Circus and CSP, which is a novel contribution as it integrates state-rich and state-free process algebras.
 - The motivation is to enhance the utility of formal methods tools by linking them in a way that they can work together seamlessly, which is a theoretical advancement beyond existing approaches.
 - The study contributes to the Grand Challenge in Computing project by developing a link that will be part of an integrated suite of programming tools, which has potential implications for programming language design by providing a more comprehensive and verified theory of programming.
 - The focus on formalizing translation and refinement steps ensures the correctness and soundness of the link, which is a theoretical contribution.
 - The integration of Circus and CSP within the UTP framework is a theoretical innovation as it unifies different programming paradigms based on the theory of relations."
Logical Foundations for Declarative Object-oriented Programming Logical Foundations for Declarative Object-oriented Programming ?,"C. Kreitz, K. Lau, Mario Ornaghi",-,-,-,0,1995,"1. Primitive Name: Classes as First-Order Theories
  Definition: Classes are represented as first-order theories that contain logic programs as methods.
  Orthogonality Score: Not discussed
 2. Primitive Name: Methods as Logic Programs
  Definition: Methods are logic programs that are synthesised from their specifications (in classes).
  Orthogonality Score: Not discussed
 3. Primitive Name: Inheritance and Genericity Operations
  Definition: Inheritance and genericity are represented by operations on theories that preserve consistency and correctness.
  Orthogonality Score: Not discussed
 4. Primitive Name: Correctness of Classes
  Definition: Correctness of a class is defined as its adequacy.
  Orthogonality Score: Not discussed
 5. Primitive Name: Correctness of Programs
  Definition: Correctness of a program is defined wrt a specification: a program is correct if its (initial) model coincides with the interpretation of the specification.
  Orthogonality Score: Not discussed","- Type of mathematical framework: First-order logic
 - Specific mathematical properties guaranteed: Consistency, correctness, adequacy
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Representing classes as first-order theories and methods as logic programs.
 - Interaction models between paradigms: Declarative semantics applied to object-oriented programming.
 - Constraints or challenges in paradigm integration: Conventional object-oriented programming lacks declarative semantics.
 - Novel translation or embedding techniques: Defining classes and methods declaratively for reasoning about correctness and reuse.","- Definition of ""concept"" used: Represented as first-order theories with logic programs as methods.
 - Mechanisms for representing generic abstractions: Operations on first-order theories; open classes and programs with parameters.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: Introduction of a formalism for reasoning about declarative object-oriented programs; representation of classes as first-order theories and methods as logic programs.
 - Theoretical advancements: Provision of logical foundations for formal program development; addressing the lack of suitable semantics in existing declarative object-oriented programming languages.
 - Potential implications for programming language design: Enhancing the theoretical understanding of object-oriented programming; providing a basis for constructing correct and reusable programming systems.","- ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""
  - ""Correctness of a class is deened as its adequacy, and class reuse corresponds to class composition that preserves adequacy.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Correctness of a program is deened wrt a speciication: a program is correct if its (initial) model coincides with the interpretation of the speciication in the""",,"- The abstract discusses the representation of classes as first-order theories and methods as logic programs, which suggests a conceptual primitive related to the formal representation of classes and methods.
 - The mention of inheritance and genericity being represented by operations on these theories indicates that these are conceptual primitives related to object-oriented programming concepts.
 - The definition of correctness for classes and programs provides insight into the primitives related to correctness and reuse.
 - The abstract does not explicitly list or define specific conceptual primitives in a traditional sense, but it does describe the foundational elements of their approach, such as classes as first-order theories and methods as logic programs.","- ""We present a formalism for reasoning about declarative object-oriented programs.""
  - ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Our approach provides a logical basis for the construction of correct and reusable programming systems.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""
  - ""Correctness of a class is deened as its adequacy, and class reuse corresponds to class composition that preserves adequacy.""
  - ""Correctness of a program is deened wrt a speciication: a program is correct if its (initial) model coincides with the interpretation of the speciication in the""",,"- The abstract mentions the use of ""rst-order theories"" to represent classes, which suggests a mathematical framework based on first-order logic.
 - The representation of classes as first-order theories implies that the framework involves logical reasoning and possibly model theory, as indicated by the mention of ""isoinitial semantics.""
 - The abstract discusses the preservation of consistency and correctness through operations on these theories, which aligns with formal verification techniques.
 - The focus on ""correctness"" and ""adequacy"" suggests that the framework guarantees properties related to these concepts, likely through logical proofs.
 - The abstract does not explicitly mention specific proof techniques or limitations of the framework, but it implies a logical framework with a focus on first-order theories and isoinitial semantics.","- ""We present a formalism for reasoning about declarative object-oriented programs.""
  - ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Our approach provides a logical basis for the construction of correct and reusable programming systems.""
  - ""Our main motivation is formal program development, i.e. developing programs that are formally correct wrt their formal speciications.""
  - ""Object-oriented programming is widely used for software development in industry because it is seen to meet the key requirements of modularity, reusability, and reliability.""
  - ""However, conventional object-oriented programming (e.g. 12]) is based on the imperative programming paradigm, and does not have a declarative semantics.""
  - ""Declarative object-oriented programming languages have been proposed, by both the functional and logic programming communities.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""",,"- The abstract discusses the integration of declarative and object-oriented programming paradigms by representing classes as first-order theories and methods as logic programs. This suggests a theoretical integration strategy where declarative semantics are applied to object-oriented programming.
 - The mention of ""operations on such theories which preserve the consistency of these theories as well as the correctness of the programs"" implies a specific integration mechanism that ensures consistency and correctness across paradigms.
 - The abstract highlights the challenge of conventional object-oriented programming lacking declarative semantics, which is addressed by proposing a declarative approach to object-oriented programming.
 - The integration approach involves defining classes and methods declaratively, allowing for reasoning about correctness and reuse, which is a novel translation or embedding technique.","- ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Our approach provides a logical basis for the construction of correct and reusable programming systems.""
  - ""Our main motivation is formal program development, i.e. developing programs that are formally correct wrt their formal speciications.""
  - ""Our goal in this paper is to provide the necessary logical foundations for formal program development in an object-oriented paradigm which has a suitable (declarative) semantics for this purpose.""
  - ""Correctness of a class is deened as its adequacy, and class reuse corresponds to class composition that preserves adequacy.""
  - ""Both our classes and programs may be open, i.e. they may have parameters.""",,"- The abstract mentions that ""Inheritance, genericity and related concepts are represented by operations on such theories,"" indicating that genericity is addressed in terms of operations on first-order theories.
 - The use of ""first-order theories"" suggests a formal, logical approach to representing generic abstractions.
 - The mention of ""open classes and programs"" implies that these can have parameters, which is a mechanism for representing generic abstractions.
 - The abstract does not provide specific details on minimal type requirements or static checking strategies, but it does emphasize the importance of preserving consistency and correctness, which are related to these concepts.
 - The focus on formal program development and logical foundations suggests a structured approach to abstraction, but specific mechanisms or strategies for static checking or optimization are not detailed in the abstract.","- ""We present a formalism for reasoning about declarative object-oriented programs.""
  - ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Our approach provides a logical basis for the construction of correct and reusable programming systems.""
  - ""Our main motivation is formal program development, i.e. developing programs that are formally correct wrt their formal speciications.""
  - ""Our goal in this paper is to provide the necessary logical foundations for formal program development in an object-oriented paradigm which has a suitable (declarative) semantics for this purpose.""
  - ""Declarative object-oriented programming languages have been proposed, by both the functional and logic programming communities.""
  - ""These languages, though declarative in their methods, usually lack a suitable semantics for reasoning about formal object-oriented program development.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""
  - ""Correctness of a class is deened as its adequacy, and class reuse corresponds to class composition that preserves adequacy.""
  - ""Correctness of a program is deened wrt a speciication: a program is correct if its (initial) model coincides with the interpretation of the speciication in the""",,"- The abstract introduces a novel formalism for reasoning about declarative object-oriented programs, which is a key theoretical contribution.
 - It represents classes as first-order theories and methods as logic programs, providing a logical basis for constructing correct and reusable programming systems.
 - The approach addresses the lack of suitable semantics in existing declarative object-oriented programming languages for formal program development.
 - The paper provides a new definition of classes and methods that allows for reasoning about correctness and reuse, which is a significant theoretical advancement.
 - The focus on formal program development and the provision of logical foundations for object-oriented programming are unique insights that contribute to the theoretical understanding of programming language design."
Theoretical Foundations of an Environment-Based Multiparadigm Language,"Mario Blazevic, Z. Budimac, M. Ivanović",10.3233/INF-2000-11101,https://doi.org/10.3233/INF-2000-11101,Informatica,0,2000,Not specified (the abstract does not explicitly define or list conceptual primitives),Not specified (the abstract mentions E-calculus but does not provide specific details about the mathematical framework characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of GENS, a multiparadigm language, and the E-calculus, an extension of the lambda-calculus.
 - Theoretical advancements: E-calculus as a new theoretical foundation for GENS, allowing for the integration of multiple programming paradigms.
 - Potential implications: Flexibility and versatility in programming language design by combining different paradigms in a single language.","- ""The purpose of this paper is to define and to introduce the E-calculus - theoretical foundation of GENS.""
  - ""It is based on an extension of the -calculus called E-calculus.""
  - ""The paper presents a simple programming language and rewriting system called GENS.""
  - ""GENS is a multiparadigm lan- guage: it has been used for definition of semantics and for implementation of functional, logi- cal, procedural, and object-oriented languages.""",,"- The abstract mentions that GENS is based on an extension of the -calculus called E-calculus, which suggests that E-calculus is a foundational element of GENS.
 - The abstract does not explicitly list or define specific conceptual primitives. Instead, it focuses on the theoretical foundation of GENS and its ability to implement various programming paradigms.
 - The abstract does not provide precise definitions or details about the conceptual primitives used in GENS or E-calculus.
 - There is no mention of the level of abstraction or orthogonality of any primitives.","- ""The purpose of this paper is to define and to introduce the E-calculus - theoretical foundation of GENS.""
  - ""It is based on an extension of the -calculus called E-calculus.""
  - ""The paper presents a simple programming language and rewriting system called GENS.""",,"- The abstract mentions that GENS is based on an extension of the -calculus called E-calculus, which suggests that the mathematical framework is related to lambda calculus.
 - The purpose of the paper is to define and introduce the E-calculus, indicating that it is the theoretical foundation of GENS.
 - However, the abstract does not provide specific details about the type of mathematical framework, mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The abstract does not explicitly mention type theory, category theory, or any other specific mathematical framework beyond the mention of E-calculus.","- ""The purpose of this paper is to define and to introduce the E-calculus - theoretical foundation of GENS.""
  - ""It also allows combining different programming paradigm styles in a single programming language.""
  - ""GENS is a multiparadigm lan- guage: it has been used for definition of semantics and for implementation of functional, logi- cal, procedural, and object-oriented languages.""",,"- The abstract mentions that GENS is a multiparadigm language, which implies that it integrates different programming paradigms.
 - It specifies that GENS allows combining different programming paradigm styles in a single language, indicating a form of integration.
 - The abstract does not provide specific details on the integration mechanisms, interaction models, constraints, or novel translation techniques.
 - The focus is on introducing the E-calculus as the theoretical foundation of GENS, but it does not explicitly describe how the integration of paradigms is achieved.
 - The abstract does not mention any specific integration mechanisms, interaction models, constraints, or novel translation techniques.","- ""It is based on an extension of the -calculus called E-calculus.""
  - ""The paper presents a simple programming language and rewriting system called GENS.""
  - ""It also allows combining different programming paradigm styles in a single programming language.""
  - ""The purpose of this paper is to define and to introduce the E-calculus - theoretical foundation of GENS.""
  - ""GENS is a multiparadigm lan- guage: it has been used for definition of semantics and for implementation of functional, logi- cal, procedural, and object-oriented languages.""",,"- The abstract mentions that GENS is a multiparadigm language, which implies it can handle different programming styles, but it does not specifically address generic programming or abstraction mechanisms.
 - The focus of the paper is on introducing the E-calculus as the theoretical foundation of GENS, but there is no mention of genericity or abstraction mechanisms in the abstract.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.
 - Since the abstract does not mention any specific focus on generic programming or abstraction mechanisms, it suggests that these topics are not extensively addressed in the paper.","- ""GENS is a multiparadigm lan- guage: it has been used for definition of semantics and for implementation of functional, logi- cal, procedural, and object-oriented languages.""
  - ""The purpose of this paper is to define and to introduce the E-calculus - theoretical foundation of GENS.""
  - ""The paper presents a simple programming language and rewriting system called GENS.""
  - ""It is based on an extension of the -calculus called E-calculus.""",,"- The abstract introduces a new programming language and rewriting system called GENS, which is a novel contribution in itself.
 - GENS is based on an extension of the lambda-calculus called E-calculus, which suggests a theoretical advancement beyond existing approaches by introducing a new calculus.
 - The language is described as multiparadigm, allowing for the combination of different programming styles, which is a unique feature that could potentially impact programming language design by offering flexibility and versatility.
 - The paper aims to define and introduce the E-calculus, which is the theoretical foundation of GENS, indicating a theoretical contribution by establishing a new theoretical framework.
 - The abstract mentions that the paper will show how important language constructs from different paradigms can be defined in GENS, suggesting a theoretical advancement in integrating various programming paradigms into a single language."
"Higher-order , linear , concurrent constraint programming",Vijay Saraswat Xerox,-,-,-,85,1992,"1. Primitive Name: Formula-as-agent
  Definition: Interpretation of higher-order linear logic where formulas are treated as agents.
  Orthogonality Score: Not discussed
 2. Primitive Name: Proof-as-computation
  Definition: Interpretation of higher-order linear logic where proofs are treated as computations.
  Orthogonality Score: Not discussed
 3. Primitive Name: Consumption of information by agents
  Definition: Direct modeling of indeterminate state change in a logical framework.
  Orthogonality Score: Not discussed
 4. Primitive Name: Simply-typed -terms as dataobjects
  Definition: Construction, transmission, and application of program abstractions at runtime.
  Orthogonality Score: Not discussed
 5. Primitive Name: Higher-order versions of asynchronous concurrent systems
  Definition: Integration of various asynchronous systems into the framework.
  Orthogonality Score: Not discussed
 6. Primitive Name: Layering around functional programming style
  Definition: Adding minimal logical machinery to obtain concurrency, synchronization, and indeterminism declaratively.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Linear logic, type theory
 - Specific mathematical properties guaranteed: Not explicitly mentioned
 - Proof techniques used: Operational semantics, connections between proof-theory and operational semantics, bisimulation
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Extension of concurrent constraint programming paradigm to include higher-order and linear logic elements; use of simply-typed terms as data objects.
 - Interaction models between paradigms: Integration of various asynchronous concurrent systems under a higher-order framework.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Simple and direct translations of the untyped lambda-calculus into the HLcc programming paradigm.","Generic programming not extensively addressed (the abstract mentions mechanisms for abstraction but lacks detailed information on generic programming methodology, type system discussions, or static checking strategies)","- Novel insights: Introduction of a higher-order, linear, concurrent constraint programming framework; extension of the concurrent constraint programming paradigm to model state change and program construction; unification of various asynchronous concurrent systems under a single framework; layering concurrency, synchronization, and indeterminism around the lambda-calculus.
 - Theoretical advancements: Extension of the concurrent constraint programming paradigm; presentation of higher-order versions of other asynchronous concurrent systems; direct translations of the untyped lambda-calculus into HLcc; development of operational semantics and bisimulation for HLcc.
 - Potential implications for programming language design: Provides a framework for declarative concurrency, synchronization, and indeterminism; offers a unified approach to various concurrent systems; enables the construction and transmission of program abstractions at runtime.","- ""We present a very simple and powerful framework for indeterminate, asynchronous, higher-order computation based on the formula-as-agent and proof-ascomputation interpretation of (higher-order) linear logic [Gir87].""
  - ""The framework significantly refines and extends the scope of the concurrent constraint programming paradigm [Sar89] in two fundamental ways: (1) by allowing for the consumption of information by agents it permits a direct modelling of (indeterminate) state change in a logical framework, and (2) by admitting simply-typed -terms as dataobjects, it permits the construction, transmission and application of (abstractions of) programs at run-time.""
  - ""It can also be seen as smoothly layering around the functional programming style provided by the -calculus a minimal amount of extra logical machinery needed to obtain concurrency, synchronization and indeterminism declaratively.""
  - ""Much more dramatically, however, the framework can be seen as presenting higher-order (and if desired, constraint-enriched) versions of a variety of other asynchronous concurrent systems, including the asynchronous (‘‘input guarded”) fragment of the (first-order) -calculus, Hewitt’s actors formalism, (abstract forms of) Gelernter’s Linda, asynchronous assignment-based languages, and Petri nets.""",,"- The abstract discusses a framework based on ""formula-as-agent and proof-ascomputation interpretation of (higher-order) linear logic,"" which suggests that these concepts are foundational to the framework.
 - The framework extends the concurrent constraint programming paradigm by allowing for ""consumption of information by agents"" and ""admitting simply-typed -terms as dataobjects,"" indicating these are key primitives.
 - The abstract mentions ""higher-order (and if desired, constraint-enriched) versions of a variety of other asynchronous concurrent systems,"" suggesting that these are conceptual primitives for reconstructing programming paradigms.
 - The mention of ""smoothly layering around the functional programming style provided by the -calculus"" implies that this is another conceptual primitive.","- ""based on the formula-as-agent and proof-ascomputation interpretation of (higher-order) linear logic [Gir87].""
  - ""significantly refines and extends the scope of the concurrent constraint programming paradigm [Sar89]""
  - ""by allowing for the consumption of information by agents it permits a direct modelling of (indeterminate) state change in a logical framework,""
  - ""by admitting simply-typed -terms as dataobjects, it permits the construction, transmission and application of (abstractions of) programs at run-time.""
  - ""presenting higher-order (and if desired, constraint-enriched) versions of a variety of other asynchronous concurrent systems,""
  - ""smoothly layering around the functional programming style provided by the -calculus a minimal amount of extra logical machinery needed to obtain concurrency, synchronization and indeterminism declaratively.""
  - ""a simple operational semantics for HLcc,""
  - ""establish several connections between proof-theory and operational semantics,""
  - ""develop the notion of bisimulation for HLcc, along the lines of [Tho89],""",,"- The abstract mentions that the framework is based on the ""formula-as-agent and proof-ascomputation interpretation of (higher-order) linear logic,"" which indicates that the mathematical framework is rooted in linear logic.
 - The framework extends the concurrent constraint programming paradigm, suggesting that it involves formal verification and proof techniques related to concurrency and constraint programming.
 - The mention of ""simply-typed -terms as dataobjects"" implies a type theory component, as it involves the use of typed terms in the framework.
 - The abstract discusses operational semantics and connections between proof-theory and operational semantics, indicating that these are part of the mathematical framework.
 - The development of ""bisimulation for HLcc"" suggests a focus on equivalence relations and behavioral properties, which are common in formal verification.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it specify particular mathematical properties guaranteed beyond the general context of linear logic and concurrency.","- ""The framework significantly refines and extends the scope of the concurrent constraint programming paradigm [Sar89] in two fundamental ways: (1) by allowing for the consumption of information by agents it permits a direct modelling of (indeterminate) state change in a logical framework, and (2) by admitting simply-typed -terms as dataobjects, it permits the construction, transmission and application of (abstractions of) programs at run-time.""
  - ""Additionally, there are remarkably simple and direct translations of the untyped -calculus into the higher-order linear cc (HLcc) programming paradigm.""
  - ""Much more dramatically, however, the framework can be seen as presenting higher-order (and if desired, constraint-enriched) versions of a variety of other asynchronous concurrent systems, including the asynchronous (‘‘input guarded”) fragment of the (first-order) -calculus, Hewitt’s actors formalism, (abstract forms of) Gelernter’s Linda, asynchronous assignment-based languages, and Petri nets.""
  - ""It can also be seen as smoothly layering around the functional programming style provided by the -calculus a minimal amount of extra logical machinery needed to obtain concurrency, synchronization and indeterminism declaratively.""",,"- The abstract discusses the integration of different programming paradigms by extending the concurrent constraint programming paradigm to include higher-order and linear logic elements. This is a specific integration mechanism that allows for the consumption of information by agents and the use of simply-typed terms as data objects.
 - The framework integrates various asynchronous concurrent systems, such as the asynchronous fragment of the lambda-calculus, Hewitt’s actors formalism, Gelernter’s Linda, and Petri nets, by presenting higher-order versions of these systems. This indicates an interaction model where different paradigms are unified under a higher-order framework.
 - The abstract mentions that the framework layers around the functional programming style of the lambda-calculus with minimal extra logical machinery to achieve concurrency and indeterminism. This suggests a theoretical integration strategy that combines functional programming with concurrency and indeterminism.
 - The mention of ""remarkably simple and direct translations of the untyped lambda-calculus into the higher-order linear cc (HLcc) programming paradigm"" indicates a novel translation technique that facilitates integration between different paradigms.","- ""Additionally, there are remarkably simple and direct translations of the untyped -calculus into the higher-order linear cc (HLcc) programming paradigm.""
  - ""The framework significantly refines and extends the scope of the concurrent constraint programming paradigm [Sar89] in two fundamental ways: (1) by allowing for the consumption of information by agents it permits a direct modelling of (indeterminate) state change in a logical framework, and (2) by admitting simply-typed -terms as dataobjects, it permits the construction, transmission and application of (abstractions of) programs at run-time.""
  - ""We give (1) a simple operational semantics for HLcc, (2) establish several connections between proof-theory and operational semantics, (3) develop the notion of bisimulation for HLcc, along the lines of [Tho89], (4) establish that logical""
  - ""Much more dramatically, however, the framework can be seen as presenting higher-order (and if desired, constraint-enriched) versions of a variety of other asynchronous concurrent systems,""",,"- The abstract discusses the extension of the concurrent constraint programming paradigm, which includes mechanisms for representing generic abstractions through the use of ""simply-typed -terms as dataobjects."" This suggests a focus on abstraction mechanisms.
 - The mention of ""higher-order (and if desired, constraint-enriched) versions"" indicates a level of genericity in the framework, as it can be applied to various asynchronous concurrent systems.
 - The abstract does not explicitly mention a definition of ""concept"" used or minimal type requirements identified, nor does it discuss static checking or optimization strategies.
 - The focus on ""simply-typed -terms"" and ""higher-order"" versions suggests a mechanism for representing generic abstractions, but the abstract does not provide detailed information on these aspects.","- ""We present a very simple and powerful framework for indeterminate, asynchronous, higher-order computation based on the formula-as-agent and proof-ascomputation interpretation of (higher-order) linear logic [Gir87].""
  - ""The framework significantly refines and extends the scope of the concurrent constraint programming paradigm [Sar89] in two fundamental ways: (1) by allowing for the consumption of information by agents it permits a direct modelling of (indeterminate) state change in a logical framework, and (2) by admitting simply-typed -terms as dataobjects, it permits the construction, transmission and application of (abstractions of) programs at run-time.""
  - ""Much more dramatically, however, the framework can be seen as presenting higher-order (and if desired, constraint-enriched) versions of a variety of other asynchronous concurrent systems, including the asynchronous (‘‘input guarded”) fragment of the (first-order) -calculus, Hewitt’s actors formalism, (abstract forms of) Gelernter’s Linda, asynchronous assignment-based languages, and Petri nets.""
  - ""It can also be seen as smoothly layering around the functional programming style provided by the -calculus a minimal amount of extra logical machinery needed to obtain concurrency, synchronization and indeterminism declaratively.""
  - ""Additionally, there are remarkably simple and direct translations of the untyped -calculus into the higher-order linear cc (HLcc) programming paradigm.""
  - ""We give (1) a simple operational semantics for HLcc, (2) establish several connections between proof-theory and operational semantics, (3) develop the notion of bisimulation for HLcc, along the lines of [Tho89], (4) establish that logical""",,"- The abstract introduces a new framework for higher-order, linear, concurrent constraint programming, which is a significant theoretical contribution by itself.
 - The framework extends the concurrent constraint programming paradigm in two key ways: by allowing for the consumption of information by agents and by admitting simply-typed terms as data objects. This represents a theoretical advancement in modeling state change and program construction.
 - The framework is also seen as presenting higher-order versions of various other asynchronous concurrent systems, indicating a broad theoretical contribution by unifying different approaches under a single framework.
 - The ability to layer concurrency, synchronization, and indeterminism around the functional programming style of the lambda-calculus is a novel insight, as it provides a minimal extension to achieve these features declaratively.
 - The direct translations of the untyped lambda-calculus into the HLcc paradigm suggest a theoretical contribution in terms of bridging different programming paradigms.
 - The development of operational semantics, connections between proof-theory and operational semantics, and the notion of bisimulation for HLcc are theoretical advancements that provide a solid foundation for the framework."
"Categories, Allegories and Circuit Design 5: Derived Operations on Pictures","Carolyn Brown, G. Hutton",-,-,-,0,1994,"1. Primitive Name: Pictures
  Definition: Formalized as a unitary pretabular allegory, used to represent circuit design.
  Orthogonality Score: Not discussed
 2. Primitive Name: Homomorphisms of Pictures
  Definition: Correspond to adding new wires or circuit components.
  Orthogonality Score: Not discussed
 3. Primitive Name: Relations
  Definition: Represented by pictures to determine input and output types.
  Orthogonality Score: Not discussed
 4. Primitive Name: Networks of Wires and Basic Components
  Definition: Introduced to make pictures more manageable.
  Orthogonality Score: Not discussed
 5. Primitive Name: Equational Axiomatisation of UPAs
  Definition: Provides a notion of equivalence on pictures.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Category theory (specifically, unitary pretabular allegory)
 - Specific mathematical properties guaranteed: Soundness and completeness
 - Proof techniques used: Homomorphisms between pictures
 - Limitations or constraints of the framework: Focus on unitary pretabular allegories rather than unitary tabular allegories","- Specific integration mechanisms proposed: Formalization of pictorial interpretations, introduction of networks of wires and basic components.
 - Interaction models between paradigms: Equivalence between allegories of networks and pictures.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Use of allegories to represent circuits.","- Definition of ""concept"" used: Pictures as unitary pretabular allegories.
 - Mechanisms for representing generic abstractions: Homomorphisms of pictures.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Soundness and completeness results.","- Formalization of using pictures in circuit design
 - Introduction of pictures as a unitary pretabular allegory
 - Use of homomorphisms to represent operations like adding wires or components
 - Proof of soundness and completeness for pictorial circuit derivation
 - Formalization of pictorial interpretation for Ruby terms and algebraic laws
 - Equational axiomatisation of unitary pretabular allegories for circuit equivalence
 - Potential implications for programming language design: more intuitive and efficient circuit design","- ""pictures naturally form a unitary pretabular allegory.""
  - ""We formalise this use of pictures in circuit design.""
  - ""Homomorphisms of pictures correspond to adding new wires or circuit components.""
  - ""Two pictures are mutually homomorphic if and only if they represent equal allegorical terms.""
  - ""The equational axiomatisation of upas provides a notion of equivalence on pictures of circuits which corresponds to behavioural equivalence,""
  - ""A picture determines a relation between its input type and its output type thus: any two points on the same wire are constrained to carry equal values, while components impose more complex constraints|for""",,"- The abstract discusses the use of ""pictures"" as a conceptual primitive in circuit design, which are formalized as a unitary pretabular allegory. This suggests that ""pictures"" are a fundamental concept in the study.
 - The concept of ""homomorphisms of pictures"" is introduced, which corresponds to adding new wires or circuit components. This indicates that homomorphisms are a primitive related to the manipulation of pictures.
 - The abstract mentions that pictures are used to represent relations between input and output types, which implies that ""relations"" are another conceptual primitive.
 - The notion of ""networks of wires and basic components"" is introduced as a way to make pictures more manageable, suggesting that these are also conceptual primitives.
 - The abstract discusses the ""equational axiomatisation of upas,"" which provides a notion of equivalence on pictures, indicating that these axioms are part of the theoretical framework and could be considered primitives.
 - The abstract does not explicitly list these as ""conceptual primitives,"" but they are central to the methodology and theoretical framework described.","- ""We formalise this use of pictures in circuit design.""
  - ""pictures naturally form a unitary pretabular allegory.""
  - ""Homomorphisms of pictures correspond to adding new wires or circuit components.""
  - ""We prove soundness and completeness results which guarantee that deriving circuits using pictures does not lead to errors.""
  - ""The evident notion of homomorphism between pictures corresponds naturally to simple, relatively high level operations on pictures (adding new wires and components).""
  - ""Two pictures are provably equivalent if and only if they are mutually homomorphic, which is if and only if they denote the same relation for any interpretation of their basic components.""
  - ""the allegory of networks and network homomorphisms is equivalent to the allegory of pictures and picture homomorphisms.""
  - ""Further, we prove soundness: two pictures P and P 0 denote the same relation whenever there are homomorphisms from P to P 0 and from P 0 to P; which is precisely when the pictures are provably equivalent using the axioms of a upa.""
  - ""Since any upa has a faithful representation in a power of Rel, the allegory of sets [3, 5], we obtain a completeness theorem stating that two pictures are provably equivalent if and only if, for every interpretation of their basic components, they denote the same relation.""
  - ""The notion of a upa is intermediate between an abstract allegory A and the regular category generated by A.""
  - ""This embedding provides our completeness result.""",,"- The abstract mentions the use of ""unitary pretabular allegory"" as the mathematical framework for formalizing pictures in circuit design. This indicates that category theory is the underlying mathematical framework.
 - The framework guarantees specific mathematical properties such as soundness and completeness, ensuring that deriving circuits using pictures does not lead to errors.
 - The proof techniques used involve homomorphisms between pictures, which correspond to operations like adding new wires or components. This is a key aspect of category theory.
 - The framework provides a notion of equivalence on pictures, which is crucial for ensuring that equivalent pictures represent equal relations.
 - The abstract discusses the embedding of the unitary pretabular allegory in a power of the allegory of sets, which is a characteristic of category theory and provides a completeness result.
 - The framework is limited by the focus on unitary pretabular allegories rather than the slightly stronger notion of unitary tabular allegories, which would involve additional types corresponding to recursively enumerable functions.","- ""Much informal reasoning in Ruby depends on a pictorial interpretation of a term as a network of primitive relations, and this pictorial interpretation is crucial when Ruby is used to develop circuit layouts.""
  - ""This paper formalises the pictorial interpretation of Ruby terms and algebraic laws, which has not previously been made precise.""
  - ""Allegories abstract the notion of sets and relations rather as categories abstract the notion of sets and functions.""
  - ""We view pictures of circuits as arrows in a unitary pretabular allegory (upa)""
  - ""The equational axiomatisation of upas provides a notion of equivalence on pictures of circuits which corresponds to behavioural equivalence, in the sense that equivalent pictures represent equal relations.""
  - ""In the absence of empty types, the allegory of networks and network homomorphisms is equivalent to the allegory of pictures and picture homomorphisms.""
  - ""Our results encourage the use of pictures in deriving circuits, by providing a formal foundation for that use.""
  - ""Pictures are easier and quicker to understand than syntactic terms, and so their use speeds up the process of circuit design.""",,"- The abstract discusses the use of relational languages like Ruby for deriving hardware circuits, which involves a pictorial interpretation of relational terms. This suggests an integration of relational programming with circuit design.
 - The formalization of pictorial interpretations and the use of allegories to represent circuits indicate a theoretical integration strategy.
 - The introduction of networks of wires and basic components as a way to automate pictorial reasoning suggests a specific integration mechanism.
 - The equivalence between allegories of networks and pictures implies an interaction model between these paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the use of allegories and networks.","- ""We formalise this use of pictures in circuit design.""
  - ""pictures naturally form a unitary pretabular allegory.""
  - ""Homomorphisms of pictures correspond to adding new wires or circuit components.""
  - ""Two pictures are mutually homomorphic if and only if they represent equal allegorical terms.""
  - ""We prove soundness and completeness results which guarantee that deriving circuits using pictures does not lead to errors.""
  - ""The equational axiomatisation of upas provides a notion of equivalence on pictures of circuits which corresponds to behavioural equivalence,""
  - ""Pictures are easier and quicker to understand than syntactic terms, and so their use speeds up the process of circuit design.""
  - ""The notion of a upa is intermediate between an abstract allegory A and the regular category generated by A.""
  - ""A upa is of interest because it provides a sound interpretation of the axioms we have given, and embeds faithfully in a power of the allegory of sets.""",,"- The abstract discusses the use of relational languages like Ruby to derive hardware circuits from abstract specifications, which involves a form of generic programming by abstracting away from specific implementations.
 - The concept of ""pictures"" is used to represent circuit designs, which can be seen as a form of abstraction mechanism. These pictures are formalized as unitary pretabular allegories, which provide a structured way to represent and manipulate circuit designs.
 - The mechanism for representing generic abstractions is through the use of homomorphisms of pictures, which correspond to adding new wires or circuit components. This allows for the representation of different circuit configurations in a generic manner.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does discuss the soundness and completeness of the approach, which implies a level of formal verification.
 - The focus on pictures and their equivalence provides a way to abstract away from specific implementation details, which is a key aspect of generic programming.","- ""We formalise this use of pictures in circuit design.""
  - ""We show that pictures naturally form a unitary pretabular allegory.""
  - ""Homomorphisms of pictures correspond to adding new wires or circuit components.""
  - ""Two pictures are mutually homomorphic if and only if they represent equal allegorical terms.""
  - ""We prove soundness and completeness results which guarantee that deriving circuits using pictures does not lead to errors.""
  - ""The evident notion of homomorphism between pictures corresponds naturally to simple, relatively high level operations on pictures (adding new wires and components).""
  - ""These results lead us to a simple decision procedure for equivalence of circuits""
  - ""Our results encourage the use of pictures in deriving circuits, by providing a formal foundation for that use.""
  - ""Pictures are easier and quicker to understand than syntactic terms, and so their use speeds up the process of circuit design.""
  - ""This paper formalises the pictorial interpretation of Ruby terms and algebraic laws, which has not previously been made precise.""
  - ""The equational axiomatisation of upas provides a notion of equivalence on pictures of circuits which corresponds to behavioural equivalence,""
  - ""Soundness and completeness show that we can rely on pictures when deriving circuits.""",,"- The abstract introduces the formalization of using pictures in circuit design, which is a novel approach as it provides a structured way to represent and reason about circuits.
 - The concept of pictures forming a unitary pretabular allegory is a theoretical advancement, as it provides a mathematical framework for understanding and manipulating circuit designs.
 - The use of homomorphisms to represent operations like adding wires or components is a key insight, as it connects pictorial representations with algebraic manipulations.
 - The proof of soundness and completeness ensures that the pictorial method is reliable and accurate for circuit derivation, which is a significant theoretical contribution.
 - The formalization of pictorial interpretation for Ruby terms and algebraic laws is a novel contribution, as it bridges the gap between informal pictorial reasoning and formal algebraic manipulation.
 - The equational axiomatisation of unitary pretabular allegories provides a theoretical foundation for equivalence in circuit design, which is a significant advancement.
 - The potential implications for programming language design include the use of pictures as a more intuitive and efficient way to design circuits, which could influence future language development."
The Repeated Demise of Logic Programming and Why It Will Be Reincarnated,C. Hewitt,-,-,AAAI Spring Symposium: What Went Wrong and Why: Lessons from AI Research and Applications,8,2006,"1. Primitive Name: Actors
  Definition: Universal primitives of concurrent digital computation; can make local decisions, create more Actors, send messages, and respond to messages.
  Orthogonality Score: Not discussed
 2. Primitive Name: Serializer
  Definition: An Actor that is continually open to the arrival of messages.
  Orthogonality Score: Not discussed
 3. Primitive Name: Unbounded Nondeterminism
  Definition: Property related to arbitration of shared resources, where delay in servicing requests can become unbounded.
  Orthogonality Score: Not discussed",Not specified (the abstract discusses mathematical logic and denotational semantics but does not specify a particular mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The limitations of logic programming in handling concurrent computation due to indeterminacy.
 - Theoretical advancements: Introduction of the Actor model as a framework for concurrent computation, highlighting its difference from mathematical logic.
 - Potential implications: Paradigm shift towards massive concurrency and the potential for logic programming to be reincarnated, impacting programming language design.","- ""Actors are the universal primitives of concurrent digital computation.""
  - ""Actors can be used to define the semantics of concurrent programming languages.""
  - ""A Serializer is an Actor that is continually open to the arrival of messages.""
  - ""Actor script semantics are defined by the behavior of Actors that serve as the script elements of an Actor programming language.""
  - ""In response to a message that it receives, an Actor can make local decisions, create more Actors, send more messages, and designate how to respond to the next message received.""
  - ""Unbounded nondeterminism is the property that the amount of delay in servicing a request can become unbounded as a result of arbitration of contention for shared resources while still guaranteeing that the request will eventually be serviced.""",,"- The abstract identifies ""Actors"" as the universal primitives of concurrent digital computation, which suggests that they are fundamental building blocks for reconstructing programming paradigms.
 - The definition of Actors includes their ability to make local decisions, create more Actors, send messages, and respond to messages, indicating their role in concurrent computation.
 - The concept of ""Serializer"" is introduced as a type of Actor that is always open to receiving messages, which is a specific primitive related to message handling.
 - ""Unbounded nondeterminism"" is described as a property related to the arbitration of shared resources, which is a conceptual primitive related to the handling of concurrent requests.
 - The abstract discusses how Actors define the semantics of concurrent programming languages, indicating their role in programming paradigms.
 - The mention of ""Actor script semantics"" suggests that Actors are used to define the behavior of scripts in programming languages, further emphasizing their role as primitives.","- ""Logic Programming is the proposal to implement systems using mathematical logic.""
  - ""The upshot is that the procedural approach has a different mathematical semantics (based on the denotational semantics of the Actor model) from the semantics of mathematical logic.""
  - ""Actors are the universal primitives of concurrent digital computation.""
  - ""Actor model theory provides the means to characterize all the possible computations of a closed Actor system.""
  - ""The Actor model makes use of arbitration for determining which message is next in the arrival ordering]of an Actor that is sent multiple messages concurrently.""
  - ""Physical indeterminacy in arbiters produces indeterminacy in Actors.""
  - ""The semantics of indeterminacy raises important issues for autonomy and interdependence in information.""",,"- The abstract discusses the use of mathematical logic in logic programming, indicating a theoretical foundation in mathematical logic.
 - It mentions the denotational semantics of the Actor model, which suggests a type of mathematical framework used to formalize the Actor model.
 - The Actor model is described as providing a means to characterize computations in closed systems, which implies a formal verification aspect.
 - The abstract discusses indeterminacy and arbitration, which are mathematical properties related to concurrency and message ordering.
 - However, the abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory.
 - It does not provide details on specific proof techniques or limitations of the framework.","- ""Logic Programming is the proposal to implement systems using mathematical logic.""
  - ""The question arose as what the difference was between the procedural and logical approaches.""
  - ""The upshot is that the procedural approach has a different mathematical semantics (based on the denotational semantics of the Actor model) from the semantics of mathematical logic.""
  - ""The result will be that logic programming will be reincarnated.""
  - ""Actors are the universal primitives of concurrent digital computation.""
  - ""Actor Programming Language Semantics Actors can be used to define the semantics of concurrent programming languages.""
  - ""A Limitation of Logic Programming In his 1988 paper on the early history of Prolog, Bob Kowalski published the thesis that “computation could be subsumed by deduction” and quoted with approval “Computation is controlled deduction.”""
  - ""Contrary to Kowalski and Hayes, Hewitt's thesis was that logical deduction was incapable of carrying out concurrent computation in open systems because of indeterminacy in the arrival order of messages.""
  - ""The Actor model makes use of arbitration for determining which message is next in the arrival ordering]of an Actor that is sent multiple messages concurrently.""
  - ""Actor model theory provides the means to characterize all the possible computations of a closed Actor system.""",,"- The abstract discusses the integration of logic programming with procedural approaches, specifically highlighting the difference in mathematical semantics between these paradigms.
 - It mentions the use of the Actor model as a basis for procedural semantics, which is distinct from mathematical logic.
 - The abstract does not explicitly describe specific integration mechanisms or interaction models between paradigms.
 - It does not mention any novel translation or embedding techniques for integrating different paradigms.
 - The focus is more on the limitations of logic programming in handling concurrent computation and the role of the Actor model in addressing these limitations.
 - The abstract does not provide a detailed integration approach or strategies for combining different programming paradigms.","- ""Logic Programming is the proposal to implement systems using mathematical logic.""
  - ""Planner was the first language to feature ''procedural plans'' that were called by ''pattern-directed invocation'' using ''goals'' and ''assertions''.""
  - ""the procedural approach has a different mathematical semantics (based on the denotational semantics of the Actor model) from the semantics of mathematical logic.""
  - ""Actors are the universal primitives of concurrent digital computation.""
  - ""Actor script semantics are defined by the behavior of Actors that serve as the script elements of an Actor programming language.""
  - ""A Limitation of Logic Programming""
  - ""Hewitt's thesis was that logical deduction was incapable of carrying out concurrent computation in open systems because of indeterminacy in the arrival order of messages.""
  - ""The Actor model makes use of arbitration for determining which message is next in the arrival ordering]of an Actor that is sent multiple messages concurrently.""",,"- The abstract primarily discusses the limitations and potential reincarnation of logic programming, focusing on its inability to handle concurrent computation and indeterminacy.
 - It introduces the Actor model as a basis for concurrent computation, which is distinct from traditional logic programming.
 - The abstract does not explicitly mention generic programming or abstraction mechanisms in terms of type systems or static checking.
 - The focus is on the Actor model and its implications for concurrent computation rather than generic programming or abstraction mechanisms.
 - There is no mention of minimal type requirements or static checking strategies related to generic programming.","- ""The upshot is that the procedural approach has a different mathematical semantics (based on the denotational semantics of the Actor model) from the semantics of mathematical logic.""
  - ""Also along the way a large number of logic programming experiments were carried out although none met with great success.""
  - ""Now we are in the midst of a huge paradigm shift to massive concurrency with the advent of Web Services and many-core computer architectures.""
  - ""The result will be that logic programming will be reincarnated.""
  - ""Actors are the universal primitives of concurrent digital computation.""
  - ""Indeterminacy in Concurrent Computation Hewitt [1985], Hewitt and Agha [1991], and other published work argued that mathematical models of concurrency did not determine particular concurrent computations as follows: The Actor model makes use of arbitration for determining which message is next in the arrival ordering]of an Actor that is sent multiple messages concurrently.""
  - ""The semantics of indeterminacy raises important issues for autonomy and interdependence in information.""
  - ""Actor Model and Mathematical Logic What does the mathematical theory of Actors have to say about logic programming? A closed system is defined to be one which does not communicate with the outside. Actor model theory provides the means to characterize all the possible computations of a closed Actor system.""",,"- The abstract discusses the limitations of logic programming in handling concurrent computation due to indeterminacy, which is a novel insight into the theoretical limitations of logic programming.
 - It introduces the Actor model as a theoretical framework for concurrent computation, which is a significant theoretical advancement beyond existing logic programming approaches.
 - The abstract highlights the paradigm shift towards massive concurrency and the potential for logic programming to be reincarnated, indicating potential implications for programming language design.
 - The discussion on indeterminacy and its implications for autonomy and interdependence in information systems is a theoretical contribution that goes beyond existing work.
 - The abstract contrasts Hewitt's thesis with Kowalski and Hayes, showing a theoretical advancement in understanding the limitations of logical deduction in concurrent systems."
Integrating Information Flow Analysis in Unifying Theories of Programming,"C. Mu, Guoqiang Li",10.1109/PRDC53464.2021.00018,https://doi.org/10.1109/PRDC53464.2021.00018,Pacific Rim International Symposium on Dependable Computing,1,2021,"1. Primitive Name: Non-interference (NI)
  Definition: A guarantee that no information about sensitive inputs can be obtained by observing a program's public outputs.
 2. Primitive Name: Confidentiality
  Definition: Policies requiring that secret information does not influence publicly observable information.
 3. Primitive Name: Integrity
  Definition: Policies ensuring that information is not modified without authorization.
 4. Primitive Name: t-projection of an observation
  Definition: A projection of an observation based on a security level t.
 5. Primitive Name: t-equivalent observation
  Definition: Observations are t-equivalent if their dashed parts are equal when their undashed parts are equal.
 6. Primitive Name: t-equivalent predicate
  Definition: Predicates are t-equivalent if all their observations are t-equivalent.
 7. Primitive Name: Flow secure predicate
  Definition: A predicate is t-flow secure if it satisfies the flow security condition.
 8. Primitive Name: Flow-sensitive relations
  Definition: A pair consisting of initial and final values and security types.
 9. Primitive Name: Galois connection
  Definition: A paired function mapping predicates between theories while preserving flow security.
 10. Primitive Name: Ordering of flow-sensitive predicates
  Definition: An ordering based on the security levels of predicates.","- Type of mathematical framework: Unifying Theories of Programming (UTP)
 - Specific mathematical properties guaranteed: Flow security properties through predicate calculus
 - Proof techniques used: Induction on relational structure, direct derivation from definitions
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Use of Galois connections as paired functions to link theories at different levels.
 - Interaction models between paradigms: Hierarchy structures and relationships between theories.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"- Novel framework for integrating information flow control into the Unifying Theories of Programming (UTP).
 - Construction of a flow-security-preserving connection between different levels of predicate classes.
 - Extension of the UTP theory to integrate flow control and formalization of flow security properties within the UTP semantics.
 - Preservation of flow security under refinement transformations.
 - Unified framework applicable to multiple specification languages and programming paradigms.","- ""The notion of secure information flow specifies the security requirements of the system such that secret information does not influence publicly observable information.""
  - ""An ideal flow policy called Non-interference (NI) [2] is a guarantee that no information about the sensitive inputs can be obtained by observing a program's public outputs, for any choice of its public inputs.""
  - ""The security policies can be categorised into two core principles: confidentiality and integrity.""
  - ""The confidentiality policies require that secret information does not influence publicly observable information.""
  - ""The main contribution of this work is two-fold. First, we have built the framework for reasoning about information flow in the UTP and integrated encoding flow policies into the UTP.""
  - ""Second, we have constructed a flow-security-preserving connection between different levels of predicate classes accounting for the ordering of flow-sensitive predicates.""
  - ""Definition 1 (t-projection of an observation): Given a predicate P, and a security level t ∈ L τ , the t-projections of an observation ω ∈ P is given as:""
  - ""Definition 2 (t-equivalent observation): Given a predicate P, and a security level t ∈ L τ , let ω 1 ∈ P and ω 2 ∈ P be any of two observations.""
  - ""Definition 3 (t-equivalent predicate): Given two predicates P and Q such that αP = αQ = A, and a security level t ∈ L τ , we say P and Q are t-equivalent, denoted by P ≈ t Q iff for all ω P ∈ P and ω""
  - ""Definition 4 (Flow secure predicate): Given a predicate P and a level t ∈ L τ , we say P is t-flow secure written as P |= φ t , iff""
  - ""Definition 5 (Flow-sensitive relations): A flow-sensitive relation is a pair (αP, c τ ⊢ P), where: αP = inαP ∪ outαP, in which inαP is a set of undecorated variables standing for initial values and initial security types, and outαP is a set of dashed variables standing for final values and final security types; P is a predicate containing no free variables other than those in αP; c τ ∈ L τ records the observation on the security level of the local environment (e.g., a branch of a conditional operator) of P when it starts (in order to eliminate implicit flows from the environment such as a boolean condition); c τ ⊢ P specifies the predicate calculus of P under counter level c τ""
  - ""Definition 6 (Predicate flow security condition): We say the relational predicate c τ ⊢ P is strong flow secure, written as P ⊢ s φ c τ , iff:""
  - ""Definition 7 (Flow secure design): Let P and Q be predicates, let c τ ∈ L τ , a flow secure design is a relation in the following form:""
  - ""Definition 8 (Galois connection): Let S = (S, S ) and T = (T, T ) be posets, suppose f L : S → T and f R : T → S, we say the pair ( f L , f R ) is a Galois connection between S and T if ∀s ∈ S and t ∈ T""
  - ""Definition 9 (Ordering of flow-sensitive predicates): Given two predicates P 1 and P 2 with alphabet A, we define:""
  - ""Definition 10 (A link between a pair of theories): Consider two predicates P 1 and P 2 with alphabet A, let notation P(X) denote the powerset of set X, then put:""","- ""(Page 5, Table 1) | | |
 \n|--------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
 \n| Assignment  | \( c_\tau \vdash x := e \triangleq x' = e \land x_\tau = c_\tau \vdash \tau(e) \land \cdots \land z' = z_\tau, \ \alpha(x := e) \triangleq A \) |""","- The paper focuses on integrating information flow control into the Unifying Theories of Programming (UTP) framework, which suggests that the conceptual primitives are related to information flow security and its integration into UTP.
 - The paper defines several key concepts related to information flow security, such as non-interference (NI), confidentiality, and integrity, which are foundational to understanding the primitives.
 - Definitions 1 through 10 provide specific conceptual primitives related to information flow security, such as t-projection of an observation, t-equivalent observations and predicates, flow secure predicates, flow-sensitive relations, and Galois connections.
 - These definitions collectively form a framework for reasoning about information flow in UTP, indicating that they are the conceptual primitives defined by the study.
 - The level of abstraction is high, as these primitives are theoretical constructs used to formalize and analyze information flow security in programming paradigms.
 - Orthogonality is not explicitly discussed in terms of these primitives, but they are designed to be orthogonal in the sense that they provide distinct and complementary perspectives on information flow security.","- ""This paper presents a formal approach for modelling and reasoning about information flow control in software systems under Hoare and He's Unifying Theories of Programming (UTP).""
  - ""The uniform underlying modelling framework allows the comparison and combination of constructs, notations and techniques from different theories.""
  - ""the semantics of UTP theories is denotational, with algebraic (refinement) laws being proved based on the denotational model.""
  - ""Refinement is used as the primary verification technique, and laws enable the application of complex refinement strategies.""
  - ""The UTP studies the hierarchy structures of such theories and their relationships to provide a foundation for analysis of semantic features of programming languages, towards their combination and unification.""
  - ""The proposed flow-sensitive combined theories of multiple level classes of predicates can be applied to ensure flow security in different paradigms under stepwise development.""
  - ""The signature of a programming theory defines the syntax of the programming language, i.e., the meaning of each program in the language as a predicate, with free variables restricted to the alphabet of the language.""
  - ""The relational flow-sensitive predicate calculus specified in Table II is monotone.""
  - ""The proof is obtained by applying induction on the relational structure of the predicate calculus.""
  - ""The proof is obtained directly from the definition of flow-sensitive relations (Definition 5) and the predicate calculus presented in Table II""
  - ""The proof is obtained by Theorem 1 and the definition of implication.""
  - ""The proof is directly obtained from the definition of flow-sensitive relations (Definition 5) and the predicate calculus (non-determinism) presented in Table II""
  - ""The proof is directly obtained from the definition of flow-sensitive relations (Definition 5) and the predicate calculus (conditional) presented in Table II""
  - ""The proof is obtained directly from Definition 6.""",,"- The paper uses the Unifying Theories of Programming (UTP) as its mathematical framework, which is a formal approach for modeling and reasoning about information flow control in software systems.
 - The UTP framework is based on denotational semantics, with algebraic (refinement) laws being proved based on the denotational model.
 - Refinement is used as the primary verification technique, and laws enable the application of complex refinement strategies.
 - The paper discusses the use of predicate calculus to formalize flow security properties, with specific definitions for flow-sensitive relations and predicates.
 - Proof techniques include induction on the relational structure of the predicate calculus and direct derivation from definitions.
 - Limitations or constraints of the framework are not explicitly mentioned in the paper.","- ""Our approach can therefore treat information flow analysis and control in various families of specification languages and programming paradigms in a more general way.""
  - ""Integrating flow policies into system design in the UTP setting allows us: to provide a justification of flow control mechanisms in programming languages; and to investigate combined theories of multiple levels of languages for the purpose of secure flow analysis, so that it can be applied to a family of specification languages and programming paradigms.""
  - ""The uniform underlying modelling framework allows the comparison and combination of constructs, notations and techniques from different theories.""
  - ""The UTP studies the hierarchy structures of such theories and their relationships to provide a foundation for analysis of semantic features of programming languages, towards their combination and unification.""
  - ""The set of predicates defined in theory at each level can be viewed as a subset of those of the previous theory at an upper level.""
  - ""A family of such related sub-theories at different levels of the structure are linked up.""
  - ""We propose to define a link between theories as a paired functions which maps all predicates from one into those of another with a concern of flow security property.""
  - ""Galois connection, represented as a paired function, can be used to build a link to show both the similarity and interesting mathematical distinction of them.""
  - ""We now study linking theories between a relatively abstract one (weaker) and a concrete one (stronger) accounts for flow-sensitive observations by building connection between them.""
  - ""the connection function pair ( f L , f R ) between P 2 and P 1 forms a Galois connection.""
  - ""the refinement calculus function specified by ( f L , f R ) preserves the flow security condition, i.e., if P 1 is flow secure and P 2 ( f L , f R )P 1 , then the relevant concrete one P 2 satisfies the flow security condition as well.""",,"- The paper discusses the integration of different programming paradigms through the Unifying Theories of Programming (UTP) framework, which provides a uniform underlying modeling framework for comparing and combining constructs from different theories.
 - The UTP framework allows for the study of hierarchy structures and relationships between theories, facilitating the combination and unification of programming languages.
 - The paper proposes using Galois connections as a paired function to link theories at different levels, ensuring flow security properties are preserved across these links.
 - The integration approach involves mapping predicates from one theory to another, with a focus on flow security, using Galois connections to establish these links.
 - The paper does not explicitly mention novel translation or embedding techniques but focuses on the theoretical integration strategies using Galois connections.","- ""The uniform underlying modelling framework allows the comparison and combination of constructs, notations and techniques from different theories.""
  - ""The UTP studies the hierarchy structures of such theories and their relationships to provide a foundation for analysis of semantic features of programming languages, towards their combination and unification.""
  - ""The notion of secure information flow specifies the security requirements of the system such that secret information does not influence publicly observable information.""
  - ""The proposed flow-sensitive combined theories of multiple level classes of predicates can be applied to ensure flow security in different paradigms under stepwise development.""
  - ""We propose to define a link between theories as a paired functions which maps all predicates from one into those of another with a concern of flow security property.""
  - ""Galois connection, represented as a paired function, can be used to build a link to show both the similarity and interesting mathematical distinction of them.""","- ""(Page 5, Table 1) | | |
 \n|--------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
 \n| Assignment  | \( c_\tau \vdash x := e \triangleq x' = e \land x_\tau = c_\tau \vdash \tau(e) \land \cdots \land z' = z_\tau, \ \alpha(x := e) \triangleq A \) |""","- The paper primarily focuses on integrating information flow control into the Unifying Theories of Programming (UTP) framework, rather than generic programming or abstraction mechanisms.
 - The UTP framework is described as a way to unify different programming paradigms, which implies a level of abstraction, but this is not explicitly related to generic programming.
 - The paper discusses the use of predicates and Galois connections to link theories, which could be seen as a form of abstraction, but again, this is not directly related to generic programming.
 - There is no specific section or discussion on generic programming methodology, type systems, or abstraction mechanisms in the context of generic programming.
 - The tables at the end of the paper provide syntax and semantics for a flow-sensitive predicate calculus, which is relevant to the paper's focus on information flow control but not to generic programming.","- ""The main contribution of this work is two-fold. First, we have built the framework for reasoning about information flow in the UTP and integrated encoding flow policies into the UTP. Second, we have constructed a flow-security-preserving connection between different levels of predicate classes accounting for the ordering of flow-sensitive predicates.""
  - ""However, those works have not placed the foundations for reasoning about information flow in a unifying theory setting, and can not be deployed over a various families of specification languages and programming paradigms as the approach delineated in this work.""
  - ""Integrating flow policies into system design in the UTP setting allows us: to provide a justification of flow control mechanisms in programming languages; and to investigate combined theories of multiple levels of languages for the purpose of secure flow analysis, so that it can be applied to a family of specification languages and programming paradigms.""
  - ""We have presented a unified framework in the UTP setting for specifying and developing flow secure software. Specifically, we formalise and integrate flow security properties with the UTP semantics, present semantic enforcing rules to ensure the flow security condition in an abstract system design.""
  - ""Comparing with these works, we focused on extending the UTP theory to integrating flow control, results regarding possible operations are formalised, flow security property is naturally coordinated and integrated in the UTP semantics.""
  - ""We also studied the problem of preserving flow security under refining the flow security relations: we extended the definition of design to flow secure design in the refinement calculus to ensure the flow security condition, and constructed a link between multiple level theories under flow secure refinement relation.""",,"- The paper introduces a novel framework for integrating information flow control into the Unifying Theories of Programming (UTP), which is a significant theoretical contribution. This framework allows for the reasoning about information flow in a unified semantic setting, which is not addressed by previous works.
 - The construction of a flow-security-preserving connection between different levels of predicate classes is a unique theoretical advancement. This connection enables the preservation of flow security across different levels of abstraction, which is crucial for secure software development.
 - The extension of the UTP theory to integrate flow control and the formalization of flow security properties within the UTP semantics are key theoretical contributions. These advancements provide a foundation for secure software design and development across various programming paradigms.
 - The paper's focus on preserving flow security under refinement transformations is another significant contribution. This ensures that the flow security properties are maintained as the design is refined, which is essential for secure software development.
 - The paper's approach is distinct from existing works in that it provides a unified framework applicable to multiple specification languages and programming paradigms, which has potential implications for programming language design by ensuring flow security across different paradigms."
Proceedings of the 7th ACM SIGPLAN international conference on Principles and practice of declarative programming,"P. Barahona, A. Felty",-,-,-,0,2005,Not specified (the abstract discusses topics of interest but does not explicitly define conceptual primitives),Not specified (the abstract does not provide specific details about the mathematical framework characteristics),"No specific integration approach described (the abstract discusses bringing together different paradigms and stimulating cross-fertilization, but does not provide specific integration mechanisms or models)",Generic programming not extensively addressed,"- Key novel insights: Integration of different declarative programming paradigms to stimulate cross-fertilization.
 - Theoretical advancements: Enhancements to logical formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis; fuller exploitation of the programming-as-proof-search framework.
 - Potential implications for programming language design: Use of logic-based principles in tool design for program development, analysis, and verification.","- ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""
  - ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""
  - ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""
  - ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""",,"- The abstract discusses the aim of PPDP 2005 to bring together different declarative programming communities, which suggests a focus on integrating various programming paradigms.
 - It mentions the use of ""logical formalisms and methods"" for specifying and analyzing computations, indicating a focus on logical principles as a foundational element.
 - The abstract highlights ""enhancements to such formalisms"" with specific mechanisms like mobility, modularity, concurrency, object-orientation, and static analysis, which could be considered as conceptual primitives for enhancing declarative programming paradigms.
 - The mention of ""programming-as-proof-search framework"" suggests another conceptual primitive related to the exploitation of this framework.
 - However, the abstract does not explicitly define these as ""conceptual primitives"" or provide precise definitions for them. It discusses them as topics of interest rather than defined primitives.","- ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""
  - ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""
  - ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""
  - ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""",,"- The abstract mentions the use of ""logical formalisms"" and ""logic-based principles,"" which suggests a focus on logical frameworks.
 - The mention of ""programming-as-proof-search framework"" indicates a connection to proof methodology, which is a key aspect of mathematical frameworks in programming.
 - The abstract does not specify a particular type of mathematical framework such as type theory or category theory.
 - There is no explicit mention of specific mathematical properties guaranteed or proof techniques used.
 - The abstract does not discuss limitations or constraints of the framework.","- ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""
  - ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""
  - ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""
  - ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""",,"- The abstract mentions the integration of different programming paradigms by stating that PPDP 2005 aims to bring together communities working in logic, constraint, and functional programming paradigms. This suggests a focus on cross-fertilization and integration.
 - The goal of stimulating research in logical formalisms and cross-fertilization implies an interest in integrating different paradigms through shared methods and principles.
 - The mention of enhancements to formalisms with mechanisms like mobility, modularity, concurrency, object-orientation, and static analysis suggests specific integration mechanisms.
 - The use of logic-based principles in tool design for all declarative paradigms indicates a theoretical integration strategy.
 - However, the abstract does not explicitly mention specific interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.","- ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""
  - ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""
  - ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""
  - ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""",,"- The abstract discusses the focus of the PPDP 2005 symposium on declarative programming paradigms, which includes logic, constraint, and functional programming. However, it does not specifically mention generic programming or abstraction mechanisms.
 - The abstract mentions ""enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis,"" which could relate to genericity and abstraction, but it does not provide specific details or definitions.
 - There is no explicit mention of a ""definition of 'concept' used,"" ""mechanisms for representing generic abstractions,"" ""minimal type requirements identified,"" or ""static checking or optimization strategies"" in the abstract.
 - The abstract does not focus on generic programming or conceptual abstraction; it is more about the symposium's goals and topics of interest.","- ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""
  - ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""
  - ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""
  - ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""",,"- The abstract discusses the aim of PPDP 2005 to bring together different communities in declarative programming, which suggests a focus on cross-fertilization and integration of ideas across different paradigms.
 - The goal of stimulating research in logical formalisms and methods indicates a theoretical contribution in advancing these formalisms for computation specification and analysis.
 - The mention of enhancements to formalisms with mechanisms like mobility, modularity, concurrency, object-orientation, and static analysis suggests theoretical advancements in these areas.
 - The focus on the programming-as-proof-search framework and its fuller exploitation implies a theoretical contribution in this area.
 - The use of logic-based principles in tool design for program development, analysis, and verification suggests a theoretical contribution in methodology."
Transitioning from structural to nominal code with efficient gradual typing,"Fabian Muehlboeck, R. Tate",10.1145/3485504,https://doi.org/10.1145/3485504,Proc. ACM Program. Lang.,7,2021,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework used),"- Specific integration mechanisms proposed: Mixing untyped ""structural"" code with typed ""nominal"" code in an object-oriented language; allowing ""structural"" objects to dynamically acquire nominal types (interfaces).
 - Interaction models between paradigms: ""Structural"" objects can be treated as ""nominal"" objects, and vice versa; ""structural"" objects can dynamically acquire nominal types.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Extending gradual typing to change both types and programming patterns; allowing ""structural"" objects to dynamically acquire nominal types (interfaces).
 - Theoretical advancements: Providing formal guarantees for type and pattern changes; enabling ""cross-paradigm"" code migration and interoperation.
 - Potential implications: Enhancing programming language design by integrating typed and untyped code more flexibly and reliably.","- ""We present a calculus that supports such ""cross-paradigm"" code migration and interoperation in a manner satisfying both the static and dynamic gradual guarantees, and demonstrate that the calculus can be implemented efficiently.""
  - ""This paper investigates how to extend these established gradual-typing concepts to give formal guarantees not only about how to change types as code evolves but also about how to change such programming patterns as well.""
  - ""But whereas previous work only allowed ""nominal"" objects to be treated as ""structural"" objects, we also allow ""structural"" objects to dynamically acquire certain nominal types, namely interfaces.""
  - ""In particular, we explore mixing untyped ""structural"" code with typed ""nominal"" code in an object-oriented language.""
  - ""Gradual typing is a principled means for mixing typed and untyped code.""",,"- The abstract discusses gradual typing as a means to mix typed and untyped code, which is a conceptual framework rather than a specific primitive.
 - The focus is on extending gradual typing concepts to change programming patterns, which suggests a theoretical framework rather than specific primitives.
 - The abstract mentions mixing ""structural"" and ""nominal"" code, which are programming patterns rather than conceptual primitives.
 - The mention of ""structural"" objects acquiring ""nominal"" types (interfaces) is a feature of the system rather than a conceptual primitive.
 - The abstract does not explicitly define any conceptual primitives; it discusses theoretical frameworks and programming patterns.","- ""This paper investigates how to extend these established gradual-typing concepts to give formal guarantees not only about how to change types as code evolves but also about how to change such programming patterns as well.""
  - ""We present a calculus that supports such ""cross-paradigm"" code migration and interoperation in a manner satisfying both the static and dynamic gradual guarantees, and demonstrate that the calculus can be implemented efficiently.""
  - ""Gradual typing is a principled means for mixing typed and untyped code.""",,"- The abstract mentions ""gradual typing"" as a concept, which is often formalized using type theory. However, it does not explicitly state that type theory is the mathematical framework used.
 - The mention of ""formal guarantees"" suggests that some form of mathematical framework is involved, but the abstract does not specify the type of framework or the specific mathematical properties guaranteed.
 - The term ""calculus"" is used, which could imply a mathematical framework, but again, the abstract does not provide details on the type of calculus or its properties.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework in the abstract.","- ""In particular, we explore mixing untyped ""structural"" code with typed ""nominal"" code in an object-oriented language.""
  - ""But whereas previous work only allowed ""nominal"" objects to be treated as ""structural"" objects, we also allow ""structural"" objects to dynamically acquire certain nominal types, namely interfaces.""
  - ""Gradual typing is a principled means for mixing typed and untyped code.""
  - ""This paper investigates how to extend these established gradual-typing concepts to give formal guarantees not only about how to change types as code evolves but also about how to change such programming patterns as well.""
  - ""We present a calculus that supports such ""cross-paradigm"" code migration and interoperation in a manner satisfying both the static and dynamic gradual guarantees, and demonstrate that the calculus can be implemented efficiently.""",,"- The abstract discusses the integration of different programming paradigms through gradual typing, which is a method for mixing typed and untyped code.
 - The study extends gradual typing concepts to provide formal guarantees for changing programming patterns, indicating a focus on integrating different patterns.
 - The integration mechanism proposed involves mixing untyped ""structural"" code with typed ""nominal"" code in an object-oriented language.
 - A novel aspect is the ability for ""structural"" objects to dynamically acquire nominal types, specifically interfaces, which is a new interaction model between paradigms.
 - The abstract mentions a calculus that supports ""cross-paradigm"" code migration and interoperation, suggesting a theoretical integration strategy.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it detail any novel translation or embedding techniques beyond the dynamic acquisition of interfaces.","- ""This paper investigates how to extend these established gradual-typing concepts to give formal guarantees not only about how to change types as code evolves but also about how to change such programming patterns as well.""
  - ""We present a calculus that supports such ""cross-paradigm"" code migration and interoperation in a manner satisfying both the static and dynamic gradual guarantees, and demonstrate that the calculus can be implemented efficiently.""
  - ""But whereas previous work only allowed ""nominal"" objects to be treated as ""structural"" objects, we also allow ""structural"" objects to dynamically acquire certain nominal types, namely interfaces.""
  - ""In particular, we explore mixing untyped ""structural"" code with typed ""nominal"" code in an object-oriented language.""
  - ""Gradual typing is a principled means for mixing typed and untyped code.""",,"- The abstract discusses gradual typing and its application to mixing typed and untyped code, which is related to type systems but does not explicitly mention generic programming or abstraction mechanisms.
 - The focus is on gradual typing and its extension to support changes in programming patterns, rather than generic programming or abstraction mechanisms.
 - The abstract mentions the exploration of mixing structural and nominal code, which involves type systems, but does not provide details on genericity or abstraction mechanisms.
 - The mention of ""interfaces"" suggests some form of abstraction, but it is not explicitly linked to generic programming or abstraction mechanisms.
 - The abstract does not provide specific information on the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies related to generic programming.","- ""We present a calculus that supports such ""cross-paradigm"" code migration and interoperation in a manner satisfying both the static and dynamic gradual guarantees,""
  - ""But whereas previous work only allowed ""nominal"" objects to be treated as ""structural"" objects, we also allow ""structural"" objects to dynamically acquire certain nominal types, namely interfaces.""
  - ""In particular, we explore mixing untyped ""structural"" code with typed ""nominal"" code in an object-oriented language.""
  - ""This paper investigates how to extend these established gradual-typing concepts to give formal guarantees not only about how to change types as code evolves but also about how to change such programming patterns as well.""
  - ""Gradual typing is a principled means for mixing typed and untyped code.""",,"- The abstract discusses the extension of gradual typing concepts to provide formal guarantees for changing both types and programming patterns as code evolves. This indicates a theoretical advancement in how gradual typing is applied.
 - The paper explores mixing untyped ""structural"" code with typed ""nominal"" code, which is a novel approach in the context of object-oriented languages.
 - A key novelty is the ability to allow ""structural"" objects to dynamically acquire nominal types, specifically interfaces. This is a departure from previous work that only allowed ""nominal"" objects to be treated as ""structural"" objects.
 - The presentation of a calculus that supports ""cross-paradigm"" code migration and interoperation suggests a theoretical contribution in terms of providing a framework for integrating different programming paradigms.
 - The focus on satisfying both static and dynamic gradual guarantees implies a theoretical advancement in ensuring the reliability and flexibility of the proposed approach."
Extensional Semantics of Program Behaviour : Case for Support In,-,-,-,-,0,2008,"1. Primitive Name: Games
  Definition: A way of characterizing programming languages and logical calculi intensionally by interpreting proofs or programs as strategies for interacting with the environment.
  Orthogonality Score: Not discussed
 2. Primitive Name: Stability
  Definition: A candidate notion for characterizing higher-order sequentiality.
  Orthogonality Score: Not discussed
 3. Primitive Name: Strong Stability
  Definition: A candidate notion for characterizing higher-order sequentiality.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Game semantics, potentially linked to type theory and category theory
 - Specific mathematical properties guaranteed: Full abstraction or full completeness for various programming languages and logics
 - Proof techniques used: Algorithmic game semantics, equational reasoning about strategies
 - Limitations or constraints of the framework: Difficulty in reasoning mathematically about games and strategies, specific nature of information flow, challenges in representing non-deterministic languages without state","- Specific integration mechanisms proposed: Insights from game semantics used to enhance domain theory models.
 - Interaction models between paradigms: Combining game semantics with domain theory.
 - Constraints or challenges in paradigm integration: Difficulty in modeling imperative and concurrent features with domain theory.
 - Any novel translation or embedding techniques: Representing games as ""sets with structure"" and strategies as functions.",Generic programming not extensively addressed,"- Key novel insights: The flexibility and precision of game semantics in modeling various programming languages and features; the application of algorithmic game semantics to discover new techniques for reasoning about programming languages.
 - Theoretical advancements beyond existing approaches: Integration of domain theory and game semantics to leverage the strengths of both; representing games as ""sets with structure"" and strategies as functions to discover new kinds of game semantics.
 - Potential implications for programming language design: Enhanced precision in modeling imperative and concurrent features; potential for new paradigms in programming language design by combining domain theory and game semantics.","- ""Games can capture precisely the behaviour of higher-order programs in sequential languages, in a fashion which is very difficult or impossible for traditional forms of denotational semantics.""
  - ""On the one hand, the insights gained by the exciting discoveries in game semantics in the area of computational effects could be used to construct and study domain theoretic models in a way which retained the advantages of domain theory, while enjoying the precision afforded by games.""
  - ""This is the main objective of this research project; to capture intensional aspects of program behaviour using extensional models.""",,"- The abstract discusses the use of game semantics to model programming languages, particularly focusing on its ability to capture higher-order programs and imperative features like references, continuations, and exceptions. This suggests that these features are conceptual primitives in the context of game semantics.
 - The mention of ""stability"" and ""strong stability"" as candidate notions for characterizing higher-order sequentiality indicates that these are also conceptual primitives being explored in the study.
 - The abstract does not provide explicit definitions for these primitives but implies their role in reconstructing programming paradigms.
 - The study aims to integrate insights from game semantics into domain theory, suggesting a focus on using these primitives to enhance domain theoretic models.","- ""Games can capture precisely the behaviour of higher-order programs in sequential languages, in a fashion which is very difficult or impossible for traditional forms of denotational semantics.""
  - ""A remarkable feature of game semantics is its flexibility: games have been used to give fully abstract or fully complete models not only of complete logics such as linear logic [4] and functional languages such as PCF [5, 17, 29], but also languages with powerful imperative features such as references [2, 3], continuations [18] and exceptions [19].""
  - ""As the subject matures, games are being applied successfully to discover new techniques for reasoning about programming languages, such as algorithmic game semantics, initiated by Ghica and McCusker [15].""
  - ""Barriers to the adoption of games as a general theory of program semantics still exist, such as the difficulty of reasoning mathematically about games and strategies (which leads to difficulty in using game semantics to reason about programs) and the rather technical and specific nature of some of the constructions used.""
  - ""Moreover, the notion of information flow implicit in most games models is rather specific; interaction is represented as a sequence of actions, rendering it difficult to represent non-deterministic languages in the absence of state, for example.""
  - ""The search for order-theoretic characterizations of higher-order sequentiality has led to the discovery of several candidate notions, such as stability [7] and strong stability [9].""
  - ""On the one hand, the insights gained by the exciting discoveries in game semantics in the area of computational effects could be used to construct and study domain theoretic models in a way which retained the advantages of domain theory, while enjoying the precision afforded by games.""
  - ""On the other, if games can be represented as “sets with structure” and strategies as functions, then this opens the possibility of discovering new kinds of game semantics, perhaps embodying different notions of sequentiality, and new ways of reasoning about games and strategies (for instance, equational reasoning about strategies using simple algebraic manipulations).""",,"- The abstract discusses game semantics as a mathematical framework for characterizing programming languages and logical calculi. It highlights the flexibility and precision of game semantics in capturing the behavior of higher-order programs.
 - The framework is described as providing fully abstract or fully complete models for various programming languages and logics, indicating a focus on type theory and category theory principles.
 - The abstract mentions the difficulty of reasoning mathematically about games and strategies, suggesting limitations in the current framework.
 - It also discusses the specific nature of information flow in games models and the challenges in representing non-deterministic languages without state.
 - The abstract references order-theoretic characterizations and notions like stability and strong stability, indicating a connection to domain theory.
 - The potential for representing games as ""sets with structure"" and strategies as functions suggests a link to algebraic manipulations and equational reasoning.","- ""On the one hand, the insights gained by the exciting discoveries in game semantics in the area of computational effects could be used to construct and study domain theoretic models in a way which retained the advantages of domain theory, while enjoying the precision afforded by games.""
  - ""However, a significant obstacle to the use of domains to reason about programming languages has been a lack of accurate models of imperative and concurrent features of the sort provided by game semantics.""
  - ""Thus it seems likely that a more profound understanding of the relationship between domain theory and game semantics would be mutually beneficial.""
  - ""On the other, if games can be represented as “sets with structure” and strategies as functions, then this opens the possibility of discovering new kinds of game semantics, perhaps embodying different notions of sequentiality, and new ways of reasoning about games and strategies""
  - ""Games can capture precisely the behaviour of higher-order programs in sequential languages, in a fashion which is very difficult or impossible for traditional forms of denotational semantics.""",,"- The abstract discusses the integration of different programming paradigms through the lens of game semantics and domain theory. It highlights the flexibility of game semantics in modeling various programming paradigms, including functional languages like PCF and imperative features like references and exceptions.
 - The abstract suggests that game semantics can provide accurate models for imperative and concurrent features, which are challenging for domain theory. This implies a potential integration mechanism where insights from game semantics are used to enhance domain theory models.
 - The abstract mentions the possibility of representing games as ""sets with structure"" and strategies as functions, which could lead to new kinds of game semantics and ways of reasoning about them. This suggests a novel translation or embedding technique.
 - The abstract does not explicitly describe specific integration mechanisms or interaction models between paradigms but implies a theoretical integration strategy by combining insights from game semantics and domain theory.","- ""This is the main objective of this research project; to capture intensional aspects of program behaviour using extensional models.""
  - ""Games can capture precisely the behaviour of higher-order programs in sequential languages, in a fashion which is very difficult or impossible for traditional forms of denotational semantics.""
  - ""G ame semantics is a way of characterizing programming languages and logical calculi intensionally by interpreting proofs or programs as strategies for interacting with the environment; this process of interaction can be thought of as playing a two-person game.""
  - ""On the one hand, the insights gained by the exciting discoveries in game semantics in the area of computational effects could be used to construct and study domain theoretic models in a way which retained the advantages of domain theory, while enjoying the precision afforded by games.""",,"- The abstract discusses game semantics as a method for characterizing programming languages, which involves interpreting programs as strategies in a game. This is an intensional approach, focusing on the behavior of programs rather than their structure.
 - The abstract mentions the flexibility of game semantics in modeling various programming features, but it does not explicitly address generic programming or abstraction mechanisms.
 - There is no mention of a specific definition of ""concept"" used in the context of generic programming.
 - The abstract does not discuss mechanisms for representing generic abstractions or minimal type requirements.
 - There is no mention of static checking or optimization strategies related to generic programming.
 - The focus of the abstract is on the relationship between game semantics and domain theory, rather than on generic programming or abstraction mechanisms.","- ""As the subject matures, games are being applied successfully to discover new techniques for reasoning about programming languages, such as algorithmic game semantics, initiated by Ghica and McCusker""
  - ""However, a significant obstacle to the use of domains to reason about programming languages has been a lack of accurate models of imperative and concurrent features of the sort provided by game semantics.""
  - ""Thus it seems likely that a more profound understanding of the relationship between domain theory and game semantics would be mutually beneficial.""
  - ""On the one hand, the insights gained by the exciting discoveries in game semantics in the area of computational effects could be used to construct and study domain theoretic models in a way which retained the advantages of domain theory, while enjoying the precision afforded by games.""
  - ""On the other, if games can be represented as “sets with structure” and strategies as functions, then this opens the possibility of discovering new kinds of game semantics, perhaps embodying different notions of sequentiality, and new ways of reasoning about games and strategies""
  - ""This is the main objective of this research project; to capture intensional aspects of program behaviour using extensional models.""",,"- The abstract highlights the flexibility and precision of game semantics in modeling various programming languages and features, which is a key theoretical contribution.
 - The mention of algorithmic game semantics and its application to discover new techniques for reasoning about programming languages indicates a novel insight into how game semantics can be used to advance programming language design.
 - The discussion of the relationship between domain theory and game semantics suggests a theoretical advancement beyond existing approaches by potentially integrating the strengths of both theories.
 - The idea of representing games as ""sets with structure"" and strategies as functions opens up new possibilities for game semantics, which is a theoretical innovation.
 - The main objective of capturing intensional aspects of program behavior using extensional models is a unique theoretical contribution that aims to bridge the gap between different semantic approaches."
TopHat: A formal foundation for task-oriented programming,"Tim Steenvoorden, Nico Naus, M. Klinik",10.1145/3354166.3354182,https://doi.org/10.1145/3354166.3354182,ACM-SIGPLAN International Conference on Principles and Practice of Declarative Programming,12,2019,"1. Primitive Name: Task Combinators
  Definition: Express ways in which people can work together; include step, parallel, and choice.
  Orthogonality Score: Not discussed
 2. Primitive Name: Modularity
  Definition: Tasks are composed of smaller ones, are first-class, and can be values of other tasks.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory (simply typed lambda-calculus with extensions)
 - Specific mathematical properties guaranteed: Type preservation under evaluation, normalisation, and handling; Progress under handling
 - Proof techniques used: Induction over expressions
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Separation of task language and host language, use of simply typed lambda-calculus as a base language.
 - Interaction models between paradigms: Driven by user input.
 - Constraints or challenges in paradigm integration: Complexity of dealing with parallelism, user interaction, and references.
 - Novel translation or embedding techniques: Implementation of TopHat in Haskell and integration with iTasks.",Generic programming not extensively addressed,"- Key novel insights: Formal foundation for task-oriented programming (TOP) by decomposing its features into elementary language elements.
 - Theoretical advancements: Development of TopHat, a language for modular interactive workflows based on a simply typed lambda-calculus; layered semantics including big-step evaluations and labelled transition systems; separation of task language and host language.
 - Potential implications for programming language design: Focus on collaboration patterns; differences from process algebras and functional reactive programming; proven type safety and progress.","- ""The central objective of top is to coordinate collaboration. The basic building blocks of top for expressing collaboration are task combinators. They express ways in which people can work together.""
  - ""Tasks can be executed after each other, at the same time, or conditionally. This motivates the combinators step, parallel, and choice.""
  - ""There are three ways in which tasks are modular. First, larger tasks are composed of smaller ones. Second, tasks are first-class, they can be arguments and results of functions. Third, tasks can be values of other tasks.""
  - ""Users can work together in a number of ways, and this is reflected in top by task compositions. There is sequential composition, parallel composition, and choice.""
  - ""The sole purpose of editors is to interact with users by remembering the last value that has been sent to them.""
  - ""The semantics of top requires all updates to shared data and all enabled internal steps to be processed before any further communication with the environment can take place.""",,"- The paper discusses task-oriented programming (TOP) and its focus on collaboration patterns. It identifies task combinators as the basic building blocks for expressing collaboration.
 - The combinators mentioned are step, parallel, and choice, which are used to express different ways tasks can be composed and executed.
 - The paper also highlights the modularity of tasks, which includes composition, first-class tasks, and tasks as values of other tasks.
 - Editors are mentioned as a means of interaction with users, but they are not explicitly defined as conceptual primitives.
 - The paper does not provide a specific list of conceptual primitives or explicitly define them in a separate section. However, the task combinators and modularity aspects can be inferred as conceptual primitives for reconstructing programming paradigms.","- ""We use the simply typed lambda-calculus, extended with pairs and references, as a base language.""
  - ""We describe TopHat by means of a layered semantics.""
  - ""The semantics of top requires all updates to shared data and all enabled internal steps to be processed before any further communication with the environment can take place.""
  - ""The host language evaluates expressions using a big-step semantics.""
  - ""The normalisation semantics is responsible for reducing expressions of type Task until they are ready to handle input.""
  - ""We prove progress and type preservation for top.""
  - ""We show that the following three preservation Theorems hold.""
  - ""Theorem 6.1 (Type preservation under evaluation).""
  - ""Theorem 6.2 (Type preservation under normalisation).""
  - ""Theorem 6.3 (Type preservation under handling).""
  - ""Theorem 6.4 (Progress under handling).""
  - ""Theorem 6.5 (Failing means no interaction possible).""
  - ""Theorem 6.6 (Inputs function is sound and complete).""",,"- The paper uses a ""simply typed lambda-calculus, extended with pairs and references"" as the base mathematical framework for formalizing TopHat. This indicates a type theory framework.
 - The paper describes a ""layered semantics"" for TopHat, which includes big-step semantics for evaluation and normalisation, and interaction semantics for handling user inputs. This suggests a structured approach to formal verification.
 - The paper guarantees specific mathematical properties such as type preservation under evaluation, normalisation, and handling, as well as progress under handling. These are key properties in ensuring the correctness and safety of the TopHat language.
 - The proof techniques used include induction over expressions to prove type preservation and progress theorems.
 - The limitations or constraints of the framework are not explicitly mentioned in the paper, but the focus on type preservation and progress suggests a careful consideration of how the framework supports these properties.","- ""Task-oriented programming (TOP) is a programming paradigm that aims to provide the desired level of abstraction while still being expressive enough to describe real world collaboration.""
  - ""TOP has been around for more than a decade, in the forms of iTasks and mTasks, which are tailored for real-world usability.""
  - ""We use the simply typed lambda-calculus, extended with pairs and references, as a base language. On top of this language, we develop TopHat, a language for modular interactive workflows.""
  - ""The host language is a simply typed λ-calculus, extended with some basic types and ml-style references.""
  - ""The task language and the host language are clearly separated, to make explicit where the boundaries are.""
  - ""The semantics of the task layer is driven by user input.""
  - ""We have implemented the semantic rules of TopHat in Haskell, and the task layer on top of the iTasks framework.""
  - ""The work presented in this paper lies on the boundary of many areas of study. People have looked at the problem of how to model and coordinate collaboration from many different perspectives.""",,"- The paper discusses the integration of task-oriented programming (TOP) with other programming paradigms by using a simply typed lambda-calculus as a base language and extending it with pairs and references to create TopHat.
 - The separation of the task language and the host language is a key integration mechanism, allowing for clear boundaries between different paradigms.
 - The interaction model is driven by user input, which is a novel approach in integrating different paradigms by focusing on user interaction rather than traditional communication methods.
 - The paper does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the complexity of dealing with parallelism, user interaction, and references.
 - The implementation of TopHat in Haskell and its integration with iTasks demonstrates a novel translation or embedding technique, showing how TOP can be integrated with existing frameworks.","- ""iTasks uses the generic programming facilities of Clean to derive rich client and server applications from a single source.""
  - ""The host language is a simply typed λ-calculus, extended with some basic types and ml-style references.""
  - ""The grammar in Fig. 2 defines the syntax of the host language.""
  - ""The typing rules for pretasks are given in Fig. 5""
  - ""Most typing rules lift the type of their subexpressions into the Tasktype.""
  - ""References, and therefore shared editors, can only be of a basic type so they do not introduce implicit recursion (T-Update).""
  - ""The semantics of top requires all updates to shared data and all enabled internal steps to be processed before any further communication with the environment can take place.""",,"- The paper mentions the use of generic programming facilities in iTasks, which is a framework implementing task-oriented programming (TOP). This suggests that generic programming is used to derive applications from a single source, but it does not provide detailed mechanisms or definitions.
 - The host language is described as a simply typed λ-calculus with extensions, which implies a focus on type safety and abstraction. However, the paper does not delve into specific mechanisms for generic abstractions or minimal type requirements.
 - The typing rules and syntax are discussed, but these are more related to the type system and semantics rather than generic programming mechanisms.
 - The paper does not provide explicit strategies for static checking or optimization related to generic programming.","- ""In this paper we give a description of the TOP paradigm and then decompose its rich features into elementary language elements, which makes them suitable for formal treatment.""
  - ""We use the simply typed lambda-calculus, extended with pairs and references, as a base language. On top of this language, we develop TopHat, a language for modular interactive workflows.""
  - ""We describe TopHat by means of a layered semantics. These layers consist of multiple big-step evaluations on expressions, and two labelled transition systems, handling user inputs.""
  - ""With TopHat we prepare a way to formally reason about TOP languages and programs.""
  - ""Our contributions to workflow modelling, functional programming language design, and rapid application development are as follows.""
  - ""We describe the essential concepts of task-oriented programming.""
  - ""We present a formal language for modelling declarative workflows, called top, embedded in a simply typed λ-calculus.""
  - ""We develop a layered operational semantics for top that is driven by user input.""
  - ""We prove progress and type preservation for top.""
  - ""We show that the following three preservation Theorems hold.""
  - ""The main motive to formalise this paradigm, is to be able to reason about tasks.""
  - ""In this paper we have identified and intuitively described the essence of task-oriented programming. We then formalised this essence by developing a domain-specific language for declarative interactive workflows, called top.""
  - ""The task language and the host language are clearly separated, to make explicit where the boundaries are.""
  - ""The semantics of the task layer is driven by user input.""
  - ""We have compared top with workflow modelling languages, process algebras, functional reactive programming and session types to point out differences and similarities.""
  - ""Finally, we have proven type safety and progress for our language.""",,"- The paper introduces a formal foundation for task-oriented programming (TOP) by decomposing its features into elementary language elements, making it suitable for formal treatment. This is a key novel insight as it provides a structured approach to understanding TOP.
 - The development of TopHat, a language for modular interactive workflows, is a significant theoretical contribution. It is based on a simply typed lambda-calculus extended with pairs and references, which is a novel combination for workflow modeling.
 - The layered semantics of TopHat, including big-step evaluations and labelled transition systems, is a theoretical advancement. It provides a structured way to handle user inputs and internal steps, which is unique compared to existing workflow modeling languages.
 - The paper proves progress and type preservation for TopHat, which are essential theoretical contributions for ensuring the language's safety and reliability.
 - The separation of the task language and host language is a theoretical innovation, as it clarifies the boundaries between workflow modeling and general programming concepts.
 - The comparison with existing work highlights the unique focus of TopHat on collaboration patterns and its differences from process algebras and functional reactive programming, indicating potential implications for programming language design."
Deenite Clause Grammars for Lan- Guage Analysis | a Survey of the Formalism and a Comparison with Term Rewriting Although Term Rewriting Consists of Logical Components,J. Leeuwen,-,-,-,0,2007,Not specified (the abstract discusses theoretical foundations and programming paradigms but does not explicitly define conceptual primitives),Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Prolog implements term rewriting engine; conditional rules provide interface to Prolog programs.
 - Interaction models between paradigms: Term rewriting integrated with logic programming; flexibility in evaluation strategies in functional programming.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Simplification of Stickel's Prolog Technology Term Rewriter.","Generic programming not extensively addressed (the abstract focuses on the integration of term rewriting with logic programming and discusses abstraction mechanisms in terms of DCGs and conditional rules, but does not explicitly address generic programming concepts or mechanisms)","- Key novel insights: Integration of term rewriting with logic programming for a deeper theoretical foundation and expressive programming language.
 - Theoretical advancements: Use of Prolog for term rewriting engines, encapsulation of programming patterns with DCGs, simplification of complex programs, and flexible evaluation strategies in functional programming.
 - Potential implications: Integration of term rewriting with logic programming could lead to more expressive and standardized programming languages.","- ""viewing term rewriting in the context of logic programming gives a deeper theoretical foundation in combination with an expressive and standardized programming language.""
  - ""conditional rules also provide a natural interface to arbitrary Prolog programs.""
  - ""Without DCGs a certain common programming pattern would have to be reinvented repeatedly and in a laborious fashion.""
  - ""There are other, more complex, programming patterns that are not captured by DCGs and therefore still have to be reinvented repeatedly and in a laborious fashion.""
  - ""For a small example, the program in the collection 6] for constructing SLD trees is typical of a class of programs that becomes much easier and shorter when done in the RET paradigm.""
  - ""Having that built in saves a lot of minor, low-level grief.""
  - ""The tension between innermost and outer-most evaluation plays an important role in functional programming.""
  - ""We discovered an implementation that not only allows the choice from program to program, but within a program from function to function, and within a function from argument place to argument place.""",,"- The abstract discusses the integration of term rewriting with logic programming, which suggests a conceptual framework rather than specific primitives.
 - The mention of ""conditional rules"" and ""DCGs"" (Definite Clause Grammars) implies that these are part of the theoretical foundation, but they are not explicitly defined as conceptual primitives.
 - The abstract highlights the benefits of using these frameworks, such as simplifying programming patterns and reducing complexity, but does not explicitly list or define specific conceptual primitives.
 - The discussion on functional programming and the choice between innermost and outermost evaluation suggests a focus on programming paradigms rather than specific primitives.
 - The abstract does not provide explicit definitions or lists of conceptual primitives as requested by the question.","- ""Not only does Prolog implement the term rewriting engine, but conditional rules also provide a natural interface to arbitrary Prolog programs.""
  - ""viewing term rewriting in the context of logic programming gives a deeper theoretical foundation in combination with an expressive and standardized programming language.""
  - ""Regular algebra""
  - ""Functional programming""
  - ""Prolog programming methodology""",,"- The abstract discusses the integration of term rewriting with logic programming, which suggests a theoretical foundation in logic programming.
 - The mention of ""Prolog implement[s] the term rewriting engine"" and ""conditional rules"" indicates a focus on logic programming as a framework.
 - The abstract does not explicitly mention a specific mathematical framework like type theory or category theory.
 - There is no detailed discussion of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The abstract focuses more on the application and benefits of combining term rewriting with logic programming rather than detailing a mathematical framework.","- ""viewing term rewriting in the context of logic programming gives a deeper theoretical foundation in combination with an expressive and standardized programming language.""
  - ""Not only does Prolog implement the term rewriting engine, but conditional rules also provide a natural interface to arbitrary Prolog programs.""
  - ""Without DCGs a certain common programming pattern would have to be reinvented repeatedly and in a laborious fashion.""
  - ""For a small example, the program in the collection 6] for constructing SLD trees is typical of a class of programs that becomes much easier and shorter when done in the RET paradigm.""
  - ""For a substantial example, Stickel's Prolog Technology Term Rewriter is quite drastically simpliied in our approach.""
  - ""The tension between innermost and outer-most evaluation plays an important role in functional programming.""
  - ""We discovered an implementation that not only allows the choice from program to program, but within a program from function to function, and within a function from argument place to argument place.""",,"- The abstract discusses the integration of term rewriting with logic programming, specifically highlighting how viewing term rewriting in the context of logic programming provides a deeper theoretical foundation and an expressive programming language.
 - Prolog is used to implement the term rewriting engine, and conditional rules serve as an interface to other Prolog programs, indicating a mechanism for integrating term rewriting with logic programming.
 - The abstract mentions that certain programming patterns are simplified or made more efficient through this integration, suggesting that the integration approach involves leveraging the strengths of both paradigms to improve programming efficiency.
 - The mention of simplifying Stickel's Prolog Technology Term Rewriter suggests a novel translation or embedding technique.
 - The discussion of functional programming and the choice between innermost and outermost evaluation indicates flexibility in the integration approach, allowing for different evaluation strategies within a program.
 - However, the abstract does not explicitly detail specific interaction models or constraints/challenges in paradigm integration beyond these points.","- ""viewing term rewriting in the context of logic programming gives a deeper theoretical foundation in combination with an expressive and standardized programming language.""
  - ""conditional rules also provide a natural interface to arbitrary Prolog programs.""
  - ""Without DCGs a certain common programming pattern would have to be reinvented repeatedly and in a laborious fashion.""
  - ""There are other, more complex, programming patterns that are not captured by DCGs and therefore still have to be reinvented repeatedly and in a laborious fashion.""
  - ""For a small example, the program in the collection 6] for constructing SLD trees is typical of a class of programs that becomes much easier and shorter when done in the RET paradigm.""
  - ""Having that built in saves a lot of minor, low-level grief.""
  - ""The tension between innermost and outer-most evaluation plays an important role in functional programming.""
  - ""We discovered an implementation that not only allows the choice from program to program, but within a program from function to function, and within a function from argument place to argument place.""",,"- The abstract discusses the integration of term rewriting with logic programming, which suggests a focus on theoretical foundations and expressive programming languages. This could imply a level of abstraction and genericity in programming methodologies.
 - The mention of ""conditional rules"" and their interface with Prolog programs suggests a mechanism for representing generic abstractions, as these rules can be applied across different programs.
 - The discussion of DCGs (Definite Clause Grammars) and their role in encapsulating programming patterns indicates a mechanism for abstraction, as these patterns can be reused and named.
 - The abstract does not explicitly define a ""concept"" or discuss minimal type requirements, static checking, or optimization strategies in the context of generic programming.
 - The focus on functional programming and the choice between innermost and outermost evaluation suggests flexibility in programming approaches, which could be related to genericity and abstraction.","- ""In this paper we have shown that viewing term rewriting in the context of logic programming gives a deeper theoretical foundation in combination with an expressive and standardized programming language.""
  - ""Not only does Prolog implement the term rewriting engine, but conditional rules also provide a natural interface to arbitrary Prolog programs.""
  - ""Without DCGs a certain common programming pattern would have to be reinvented repeatedly and in a laborious fashion.""
  - ""There are other, more complex, programming patterns that are not captured by DCGs and therefore still have to be reinvented repeatedly and in a laborious fashion.""
  - ""For a small example, the program in the collection 6] for constructing SLD trees is typical of a class of programs that becomes much easier and shorter when done in the RET paradigm.""
  - ""Having that built in saves a lot of minor, low-level grief.""
  - ""For a substantial example, Stickel's Prolog Technology Term Rewriter is quite drastically simpliied in our approach.""
  - ""We discovered an implementation that not only allows the choice from program to program, but within a program from function to function, and within a function from argument place to argument place.""",,"- The abstract highlights a novel theoretical contribution by integrating term rewriting with logic programming, providing a deeper theoretical foundation and an expressive programming language.
 - The use of Prolog to implement term rewriting engines and the interface with arbitrary Prolog programs is a key theoretical advancement, as it offers a standardized and expressive way to handle term rewriting.
 - The abstract mentions that without Definite Clause Grammars (DCGs), certain programming patterns would need to be reinvented, indicating that DCGs offer a unique theoretical contribution by encapsulating these patterns.
 - The simplification of complex programs, such as Stickel's Prolog Technology Term Rewriter, suggests a theoretical advancement in terms of efficiency and simplicity.
 - The ability to choose between innermost and outermost evaluation within a program or function is a novel theoretical contribution, as it provides flexibility and efficiency in functional programming.
 - The potential implications for programming language design include the integration of term rewriting with logic programming, which could lead to more expressive and standardized languages."
Proceedings of the 7th ACM SIGPLAN international conference on Principles and practice of declarative programming,-,10.1145/1069774,https://doi.org/10.1145/1069774,-,0,2005,Not specified (the abstract does not explicitly define conceptual primitives or provide their definitions),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),No specific integration approach described (the abstract discusses the goal of integration and stimulating research but does not detail specific mechanisms or techniques),Generic programming not extensively addressed,"- Key novel insights: Integration of different declarative programming paradigms to stimulate cross-fertilization.
 - Theoretical advancements: Enhancements to formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis; fuller exploitation of the programming-as-proof-search framework.
 - Potential implications for programming language design: Use of logic-based principles in tool design for program development, analysis, and verification.","- ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""
  - ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""
  - ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""
  - ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""",,"- The abstract discusses the aim of PPDP 2005 to bring together different declarative programming communities, which suggests a focus on integrating various programming paradigms.
 - It mentions the use of ""logical formalisms and methods"" for specifying and analyzing computations, indicating a focus on logical principles.
 - The abstract highlights enhancements to formalisms with mechanisms like mobility, modularity, concurrency, object-orientation, and static analysis, which could be considered conceptual primitives in the context of declarative programming.
 - However, these are not explicitly defined as ""conceptual primitives"" in the abstract. They are more like topics of interest rather than specifically defined primitives.
 - The abstract does not provide explicit definitions or orthogonality scores for these concepts, nor does it explicitly label them as ""conceptual primitives.""","- ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""
  - ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""
  - ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""",,"- The abstract mentions the use of ""logical formalisms and methods"" for specifying and analyzing computations, which suggests a focus on logical frameworks.
 - The mention of ""enhancements to such formalisms"" indicates an interest in improving these frameworks, possibly with mechanisms like mobility, modularity, concurrency, object-orientation, and static analysis.
 - The ""programming-as-proof-search framework"" suggests a connection to proof methodology, but specific details about the type of mathematical framework or proof techniques are not provided.
 - The abstract does not specify the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no explicit mention of proof techniques or limitations/constraints of the framework.","- ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""
  - ""the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""
  - ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""
  - ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""",,"- The abstract mentions the integration of different programming paradigms by stating that PPDP 2005 aims to bring together communities working in logic, constraint, and functional programming paradigms. This suggests a focus on cross-fertilization and interaction between these paradigms.
 - The goal of stimulating research in logical formalisms and methods implies an interest in theoretical integration strategies that could apply across these paradigms.
 - The mention of enhancements to formalisms with mechanisms like mobility, modularity, concurrency, object-orientation, and static analysis suggests specific integration mechanisms that could facilitate interaction between paradigms.
 - The use of logic-based principles in tool design for program development, analysis, and verification indicates a novel approach to integrating these paradigms by leveraging common logical foundations.
 - However, the abstract does not explicitly describe specific interaction models, constraints, or novel translation/embedding techniques. It focuses more on the general goal of integration and stimulating research rather than detailing specific integration approaches.","- ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""
  - ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""
  - ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""
  - ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""",,"- The abstract discusses the focus of the PPDP 2005 symposium, which includes declarative programming communities such as logic, constraint, and functional programming paradigms. However, it does not specifically mention generic programming or abstraction mechanisms.
 - The abstract mentions ""enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis,"" which could relate to abstraction mechanisms, but it does not explicitly address generic programming or conceptual abstraction.
 - There is no mention of a definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements identified, or static checking or optimization strategies related to generic programming.
 - The abstract does not provide specific details on generic programming methodology, type system discussions, or abstraction mechanism explanations.","- ""The goal is to stimulate research in the use of logical formalisms and methods for specifying, performing, and analyzing computations, and to stimulate cross-fertilization by including work from one community that could be of particular interest and relevance to the others.""
  - ""PPDP 2005 aims to provide a forum that brings together those in the declarative programming communities, including those working in the logic, constraint, and functional programming paradigms.""
  - ""At the level of methodology, the use of logic-based principles in the design of tools for program development, analysis, and verification relative to all declarative paradigms is of interest.A""
  - ""Topics of more specific interest include enhancements to such formalisms with mechanisms for mobility, modularity, concurrency, object-orientation, and static analysis, as well as the fuller exploitation of the programming-as-proof-search framework through new designs and improved implementation methods.""",,"- The abstract mentions the aim of PPDP 2005 to bring together different declarative programming communities, which suggests a focus on cross-fertilization and integration of ideas across paradigms. This could imply novel insights from combining different approaches.
 - The goal of stimulating research in logical formalisms and methods indicates a focus on theoretical advancements in these areas.
 - The mention of enhancements to formalisms with mechanisms like mobility, modularity, concurrency, object-orientation, and static analysis suggests theoretical contributions in these areas.
 - The exploitation of the programming-as-proof-search framework through new designs and improved implementation methods implies theoretical advancements in this area.
 - The use of logic-based principles in tool design for program development, analysis, and verification suggests theoretical contributions in methodology."
"Functional Programming Languages and Computer Architecture: Portland, Oregon, USA, September 14-16, 1987. Proceedings",G. Kahn,-,-,-,2,1987,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: Category theory, type theory, attribute grammars
 - Specific mathematical properties guaranteed: Formalization of stack semantics, handling of functions with variable arity, modeling of parallelism using pomsets
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Novel insights: Control of parallelism in the Manchester dataflow machine, GRIP - a high-performance architecture for parallel graph reduction, SIGNAL: A declarative language for synchronous programming of real-time systems.
 - Theoretical advancements: Categorical multi-combinators, Attribute grammars as a functional programming paradigm, The planar topology of functional programs, A theory for natural modelisation and implementation of functions with variable arity, Pomset interpretations of parallel functional programs.
 - Potential implications for programming language design: Clean - A language for functional graph rewriting, Projections for strictness analysis.","- ""Control of parallelism in the Manchester dataflow machine.-""
  - ""The D-RISC-An architecture for use in multiprocessors.-""
  - ""Tim: A simple, lazy abstract machine to execute supercombinators.-""
  - ""The G-machine as a representation of stack semantics.-""
  - ""Categorical multi-combinators.-""
  - ""GRIP - a high-performance architecture for parallel graph reduction.-""
  - ""Matrix algebra and applicative programming.-""
  - ""Attribute grammars as a functional programming paradigm.-""
  - ""The planar topology of functional programs.-""
  - ""Functional programming with sets.-""
  - ""A theory for natural modelisation and implementation of functions with variable arity.-""
  - ""Pomset interpretations of parallel functional programs.-""
  - ""SIGNAL: A declarative language for synchronous programming of real-time systems.-""
  - ""Controlling the behaviour of functional language systems.-""
  - ""A standard ML compiler.-""
  - ""Performance polymorphism.-""
  - ""Mapping a single-assignment language onto the warp systolic array.-""
  - ""Clean - A language for functional graph rewriting.-""
  - ""Projections for strictness analysis.-""
  - ""Detecting sharing of partial applications in functional programs.-""
  - ""Finding fixed points in finite lattices.-""
  - ""Evaluation transformers - A model for the parallel evaluation of functional languages (extended abstract).""",,"- The abstract lists various topics related to functional programming languages and computer architecture, but it does not explicitly define conceptual primitives.
 - The abstract mentions several architectural and programming concepts, such as dataflow machines, abstract machines, and graph reduction, but these are not explicitly defined as conceptual primitives.
 - There is no mention of specific conceptual primitives or their definitions in the abstract.
 - The abstract appears to be a collection of topics rather than a detailed description of conceptual primitives.","- ""Categorical multi-combinators.-""
  - ""The G-machine as a representation of stack semantics.-""
  - ""Attribute grammars as a functional programming paradigm.-""
  - ""A theory for natural modelisation and implementation of functions with variable arity.-""
  - ""Pomset interpretations of parallel functional programs.-""
  - ""Evaluation transformers - A model for the parallel evaluation of functional languages (extended abstract).""",,"- The abstract mentions ""Categorical multi-combinators,"" which suggests the use of category theory as a mathematical framework. Category theory is often used to formalize and guarantee properties of conceptual primitives in functional programming.
 - The mention of ""The G-machine as a representation of stack semantics"" implies a focus on stack semantics, which is a theoretical foundation for understanding the behavior of functional programming languages. This could be related to type theory or operational semantics.
 - ""Attribute grammars as a functional programming paradigm"" suggests the use of attribute grammars, which are a formal method for specifying the syntax and semantics of programming languages. This could be part of the mathematical framework for formalizing language properties.
 - ""A theory for natural modelisation and implementation of functions with variable arity"" indicates a theoretical framework for handling functions with variable numbers of arguments, which could involve type theory or other mathematical structures.
 - ""Pomset interpretations of parallel functional programs"" suggests the use of partial order sets (pomsets) to model parallelism, which is a mathematical framework for understanding concurrent execution.
 - ""Evaluation transformers - A model for the parallel evaluation of functional languages"" implies a mathematical model for evaluating functional languages in parallel, which could involve type theory or other formal methods.","- ""Attribute grammars as a functional programming paradigm.-""
  - ""Functional programming with sets.-""
  - ""A theory for natural modelisation and implementation of functions with variable arity.-""
  - ""Clean - A language for functional graph rewriting.-""
  - ""Projections for strictness analysis.-""
  - ""Detecting sharing of partial applications in functional programs.-""",,"- The abstract mentions several topics related to functional programming, such as attribute grammars, functional programming with sets, and a theory for functions with variable arity. These could be considered as different aspects or paradigms within functional programming.
 - The mention of ""Clean - A language for functional graph rewriting"" suggests a focus on graph rewriting, which could be seen as integrating different programming paradigms, specifically functional programming and graph rewriting.
 - ""Projections for strictness analysis"" and ""Detecting sharing of partial applications in functional programs"" might imply some interaction or integration between different functional programming techniques, but they do not explicitly describe an integration approach.
 - There is no explicit mention of specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques in the abstract.","- ""Evaluation transformers - A model for the parallel evaluation of functional languages (extended abstract).""
  - ""Projections for strictness analysis.-""
  - ""A theory for natural modelisation and implementation of functions with variable arity.-""
  - ""Categorical multi-combinators.-""
  - ""The G-machine as a representation of stack semantics.-""",,"- The abstract mentions several topics related to functional programming and computer architecture, but it does not explicitly address generic programming or abstraction mechanisms in detail.
 - The mention of ""The G-machine as a representation of stack semantics"" could relate to abstraction mechanisms, but it does not specifically address genericity.
 - ""Categorical multi-combinators"" might imply some form of abstraction, but again, it does not explicitly discuss generic programming.
 - ""A theory for natural modelisation and implementation of functions with variable arity"" could be related to genericity, as it involves functions with variable arity, which is a form of generic programming. However, the abstract does not provide further details on this topic.
 - ""Projections for strictness analysis"" and ""Evaluation transformers - A model for the parallel evaluation of functional languages"" are more related to optimization and evaluation strategies rather than generic programming or abstraction mechanisms.
 - Overall, while the abstract touches on concepts that could be related to generic programming and abstraction, it does not extensively address these topics.","- ""Control of parallelism in the Manchester dataflow machine.-""
  - ""The D-RISC-An architecture for use in multiprocessors.-""
  - ""Tim: A simple, lazy abstract machine to execute supercombinators.-""
  - ""The G-machine as a representation of stack semantics.-""
  - ""Categorical multi-combinators.-""
  - ""GRIP - a high-performance architecture for parallel graph reduction.-""
  - ""Matrix algebra and applicative programming.-""
  - ""Attribute grammars as a functional programming paradigm.-""
  - ""The planar topology of functional programs.-""
  - ""Functional programming with sets.-""
  - ""A theory for natural modelisation and implementation of functions with variable arity.-""
  - ""Pomset interpretations of parallel functional programs.-""
  - ""SIGNAL: A declarative language for synchronous programming of real-time systems.-""
  - ""Controlling the behaviour of functional language systems.-""
  - ""A standard ML compiler.-""
  - ""Performance polymorphism.-""
  - ""Mapping a single-assignment language onto the warp systolic array.-""
  - ""Clean - A language for functional graph rewriting.-""
  - ""Projections for strictness analysis.-""
  - ""Detecting sharing of partial applications in functional programs.-""
  - ""Finding fixed points in finite lattices.-""
  - ""Evaluation transformers - A model for the parallel evaluation of functional languages (extended abstract).""",,"- The abstract lists several topics related to functional programming languages and computer architecture, indicating a focus on theoretical contributions in these areas.
 - The mention of ""Control of parallelism in the Manchester dataflow machine"" and ""GRIP - a high-performance architecture for parallel graph reduction"" suggests novel insights into parallel processing and graph reduction, which are key areas in functional programming.
 - Theoretical advancements are implied by the discussion of ""Categorical multi-combinators,"" ""Attribute grammars as a functional programming paradigm,"" and ""The planar topology of functional programs,"" which are advanced theoretical concepts in functional programming.
 - The mention of ""A theory for natural modelisation and implementation of functions with variable arity"" and ""Pomset interpretations of parallel functional programs"" indicates theoretical contributions to the modeling and interpretation of functional programs.
 - The abstract also mentions ""SIGNAL: A declarative language for synchronous programming of real-time systems,"" which could imply a novel approach to real-time system programming.
 - Theoretical contributions to programming language design are suggested by the mention of ""Clean - A language for functional graph rewriting"" and ""Projections for strictness analysis,"" which are related to language design and optimization."
A multi-paradigm foundation for model transformation language engineering,Eugene Syriani,-,-,-,32,2011,"Not specified (the abstract mentions T-Core as a collection of transformation language primitives but does not provide specific names, definitions, or details on abstraction and orthogonality)",Not specified (the abstract does not provide details on the mathematical framework used to formalize and guarantee properties of the conceptual primitives),"- Specific integration mechanisms proposed: Merging T-Core with DEVS to create MoTif.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"" used: Models at different levels of abstraction
 - Mechanisms for representing generic abstractions: T-Core, a collection of transformation language primitives; semi-automatic generation of model transformation languages
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Novel framework for designing transformation languages tailored to specific problems
 - Introduction of T-Core as a collection of transformation language primitives
 - Semi-automatic generation of model transformation languages adapted to the application domain
 - Integration of T-Core with DEVS to introduce time in model transformation
 - Exploration of exception handling in model transformation for improved robustness and dependability","- ""We introduce T-Core, a collection of transformation language primitives for model transformation.""
  - ""A Python implementation of T-Core is developed. It offers an API of primitive transformation operations that act on models represented as graphs.""
  - ""After thoroughly analyzing the uses of model transformation and their supporting languages, we extract what is common to approaches and express model transformation at the level of their primitive building blocks.""",,"- The abstract mentions that the study involves extracting common elements from model transformation approaches to define primitive building blocks. This suggests that the study identifies conceptual primitives for model transformation.
 - The introduction of T-Core is highlighted as a collection of transformation language primitives. This indicates that T-Core is a set of conceptual primitives defined by the study.
 - The abstract does not provide specific names or definitions for each primitive within T-Core, nor does it discuss the level of abstraction or orthogonality of these primitives.
 - The mention of a Python implementation and an API for primitive transformation operations implies that these primitives are operational and can be applied to models represented as graphs, but again, specific details are not provided.","- ""Despite a robust theoretical foundation, model transformation still suffers from scaling and correctness problems.""
  - ""This thesis contributes to the engineering of model transformation languages at the foundation level, following MPM principles.""
  - ""It proposes a framework for designing transformation languages tailored to the problem to be solved.""
  - ""After thoroughly analyzing the uses of model transformation and their supporting languages, we extract what is common to approaches and express model transformation at the level of their primitive building blocks.""
  - ""We introduce T-Core, a collection of transformation language primitives for model transformation.""
  - ""The approach semi-automatically generates model transformation languages adapted to the application domain.""
  - ""MoTif is another model transformation language engineered with this framework. Its syntax and semantics are completely modelled, as well as its execution engine.""",,"- The abstract mentions a ""robust theoretical foundation"" but does not specify the type of mathematical framework used.
 - It discusses the engineering of model transformation languages and the introduction of T-Core, which is a collection of transformation language primitives, but does not provide details on the mathematical framework used to formalize these primitives.
 - The abstract does not mention any specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the engineering and application of model transformation languages rather than the mathematical framework itself.","- ""Multi-Paradigm Modelling (MPM) promotes modelling all parts of the system, at the most appropriate level(s) of abstraction, using the most appropriate formalism(s), to reduce accidental complexity.""
  - ""MPM principles state that transformations too should be modelled explicitly.""
  - ""It proposes a framework for designing transformation languages tailored to the problem to be solved.""
  - ""The aim is to increase the modeller’s productivity, by raising the level of abstraction at which transformations can be specified and by lowering the mismatch between model transformation languages and their application domain.""
  - ""After thoroughly analyzing the uses of model transformation and their supporting languages, we extract what is common to approaches and express model transformation at the level of their primitive building blocks.""
  - ""We introduce T-Core, a collection of transformation language primitives for model transformation.""
  - ""MoTif is another model transformation language engineered with this framework. Its syntax and semantics are completely modelled, as well as its execution engine.""
  - ""MoTif is the result of merging T-Core with DEVS, a discrete-event simulation formalism.""",,"- The abstract discusses the use of Multi-Paradigm Modelling (MPM) to integrate different formalisms and levels of abstraction, which suggests an approach to integrating different programming paradigms.
 - The framework proposed in the study is designed to tailor transformation languages to specific problems, which implies a mechanism for integrating different paradigms based on the problem domain.
 - The introduction of T-Core as a collection of transformation language primitives suggests a common set of building blocks that can be used across different paradigms.
 - The merging of T-Core with DEVS to create MoTif demonstrates a specific integration mechanism where different formalisms are combined to introduce new capabilities, such as the notion of time in model transformation.
 - The abstract does not explicitly mention interaction models or constraints/challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the integration of T-Core and DEVS.","- ""Model-Driven Engineering (MDE) attempts to solve the issues related to complexity through the use of models to describe systems at different levels of abstraction.""
  - ""Multi-Paradigm Modelling (MPM) promotes modelling all parts of the system, at the most appropriate level(s) of abstraction, using the most appropriate formalism(s), to reduce accidental complexity.""
  - ""The aim is to increase the modeller’s productivity, by raising the level of abstraction at which transformations can be specified and by lowering the mismatch between model transformation languages and their application domain.""
  - ""After thoroughly analyzing the uses of model transformation and their supporting languages, we extract what is common to approaches and express model transformation at the level of their primitive building blocks.""
  - ""We introduce T-Core, a collection of transformation language primitives for model transformation.""
  - ""The approach semi-automatically generates model transformation languages adapted to the application domain.""",,"- The abstract discusses the use of models at different levels of abstraction, which is a key aspect of genericity and abstraction mechanisms in software engineering.
 - The mention of Multi-Paradigm Modelling (MPM) and its focus on using appropriate formalisms at the right level of abstraction suggests a mechanism for representing generic abstractions.
 - The introduction of T-Core as a collection of transformation language primitives indicates a method for representing generic abstractions, as it provides a foundational set of operations that can be adapted to various contexts.
 - The semi-automatic generation of model transformation languages adapted to the application domain implies a mechanism for abstraction, as it allows for the creation of tailored languages that fit specific needs.
 - However, the abstract does not explicitly discuss minimal type requirements or static checking/optimization strategies, which are typically part of generic programming methodologies.","- ""This thesis contributes to the engineering of model transformation languages at the foundation level, following MPM principles.""
  - ""It proposes a framework for designing transformation languages tailored to the problem to be solved.""
  - ""As a result, model transformation languages engineered in this framework maximally constrain the modeller to only use the constructs needed.""
  - ""After thoroughly analyzing the uses of model transformation and their supporting languages, we extract what is common to approaches and express model transformation at the level of their primitive building blocks.""
  - ""We introduce T-Core, a collection of transformation language primitives for model transformation.""
  - ""The approach semi-automatically generates model transformation languages adapted to the application domain.""
  - ""MoTif is another model transformation language engineered with this framework.""
  - ""MoTif is the result of merging T-Core with DEVS, a discrete-event simulation formalism.""
  - ""It thus introduces the notion of time in model transformation.""
  - ""Finally, the notion of exception handling in model transformation is explored to strengthen the robustness and dependability of the software built using this technology.""",,"- The abstract discusses a novel framework for designing transformation languages that are tailored to specific problems, which is a key theoretical contribution.
 - The introduction of T-Core as a collection of transformation language primitives is a significant theoretical advancement, as it provides a foundational level for model transformation languages.
 - The semi-automatic generation of model transformation languages adapted to the application domain is a theoretical innovation that enhances the flexibility and applicability of model transformation languages.
 - The integration of T-Core with DEVS to introduce the notion of time in model transformation is a unique theoretical contribution, as it enables the modeling of reactive systems and their optimization.
 - The exploration of exception handling in model transformation is a theoretical advancement that aims to improve the robustness and dependability of software built using this technology."
Putting curry-howard to work,T. Sheard,10.1145/1088348.1088356,https://doi.org/10.1145/1088348.1088356,ACM SIGPLAN Symposium/Workshop on Haskell,25,2005,"1. Primitive Name: Generalized Algebraic Datatypes
  Definition: Not specified
  Orthogonality Score: Not discussed
 2. Primitive Name: Extensible Kind Systems
  Definition: Not specified
  Orthogonality Score: Not discussed
 3. Primitive Name: Generation, propagation, and discharging of Static Propositions
  Definition: Not specified
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Addition of Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions to functional programming languages like Haskell.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.","- Definition of ""concept"" used: Not explicitly defined
 - Mechanisms for representing generic abstractions: Generalized Algebraic Datatypes, Extensible Kind Systems
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: The proposal of Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions to address limitations in current functional languages.
 - Theoretical advancements: These features enable a new programming paradigm that allows for stating and enforcing interesting program properties using the type system, while maintaining backward compatibility.
 - Potential implications: Enhancing programming language design by providing a way to express complex properties without disrupting existing functional programming styles.","- ""To alleviate this problem, we propose the addition of three new features to functional programming languages such as Haskell: Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions.""
  - ""These three new features are backward compatible with existing features, and combine to enable a new programming paradigm for functional programmers.""
  - ""The Curry-Howard isomorphism states that types are propositions and that programs are proofs.""",,"- The abstract discusses the Curry-Howard isomorphism, which is a theoretical framework that equates types with propositions and programs with proofs. This is a foundational concept rather than a specific primitive.
 - The abstract proposes three new features for functional programming languages: Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions. These are the conceptual primitives defined in the study.
 - The abstract does not provide explicit definitions for these primitives beyond their names, nor does it discuss their orthogonality.
 - The level of abstraction is high, as these features are intended to enable a new programming paradigm.","- ""This allows programmers to state and enforce invariants of programs by using types.""
  - ""This paradigm makes it possible to state and enforce interesting properties of programs using the type system, and it does this in manner that leaves intact the functional programming style, known and loved by functional programmers everywhere.""
  - ""The Curry-Howard isomorphism states that types are propositions and that programs are proofs.""
  - ""To alleviate this problem, we propose the addition of three new features to functional programming languages such as Haskell: Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions.""
  - ""These three new features are backward compatible with existing features, and combine to enable a new programming paradigm for functional programmers.""",,"- The abstract mentions the Curry-Howard isomorphism, which is a fundamental concept in type theory. This suggests that the mathematical framework used is based on type theory.
 - The abstract discusses the use of types to state and enforce invariants of programs, which aligns with the principles of type theory.
 - The proposed features (Generalized Algebraic Datatypes, Extensible Kind Systems, and Static Propositions) are related to type systems and are used to formalize and guarantee properties of programs.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, nor does it discuss limitations or constraints of the framework.
 - The focus is on the application of type theory to enable a new programming paradigm, rather than detailing the theoretical foundations or proof methodology.","- ""we propose the addition of three new features to functional programming languages such as Haskell: Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions.""
  - ""This paradigm makes it possible to state and enforce interesting properties of programs using the type system, and it does this in manner that leaves intact the functional programming style, known and loved by functional programmers everywhere.""
  - ""Unfortunately, the type systems of today's functional languages cannot directly express interesting properties of programs.""
  - ""The Curry-Howard isomorphism states that types are propositions and that programs are proofs.""
  - ""These three new features are backward compatible with existing features, and combine to enable a new programming paradigm for functional programmers.""",,"- The abstract discusses the Curry-Howard isomorphism, which relates types to propositions and programs to proofs. This is a theoretical foundation for integrating programming paradigms by leveraging type systems.
 - The proposal of adding Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions to functional programming languages like Haskell suggests a specific integration mechanism. These features are designed to enhance the type system's ability to express program properties.
 - The abstract mentions that these new features are backward compatible with existing features, indicating a strategy for integrating new capabilities into existing programming paradigms without disrupting them.
 - The abstract does not explicitly discuss interaction models between paradigms or specific constraints or challenges in paradigm integration. It focuses on the enhancement of the type system within functional programming.
 - There is no mention of novel translation or embedding techniques in the abstract.","- ""This paradigm makes it possible to state and enforce interesting properties of programs using the type system, and it does this in manner that leaves intact the functional programming style, known and loved by functional programmers everywhere.""
  - ""Unfortunately, the type systems of today's functional languages cannot directly express interesting properties of programs.""
  - ""we propose the addition of three new features to functional programming languages such as Haskell: Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions.""
  - ""These three new features are backward compatible with existing features, and combine to enable a new programming paradigm for functional programmers.""
  - ""The Curry-Howard isomorphism states that types are propositions and that programs are proofs.""",,"- The abstract discusses the Curry-Howard isomorphism, which relates types to propositions and programs to proofs. This suggests a focus on using types to express program properties, which is a form of abstraction.
 - The mention of ""Generalized Algebraic Datatypes"" and ""Extensible Kind Systems"" indicates mechanisms for representing generic abstractions. These features are likely to enhance the type system's ability to express complex properties.
 - The abstract does not explicitly define what a ""concept"" is in this context, but it implies that concepts are related to the properties of programs that can be expressed through types.
 - The abstract does not specify minimal type requirements or detailed static checking or optimization strategies. It focuses more on the introduction of new features rather than their specific implementation details.
 - The abstract does not provide a detailed methodology for generic programming or extensive discussions on abstraction mechanisms beyond the introduction of new features.","- ""This paradigm makes it possible to state and enforce interesting properties of programs using the type system, and it does this in manner that leaves intact the functional programming style, known and loved by functional programmers everywhere.""
  - ""These three new features are backward compatible with existing features, and combine to enable a new programming paradigm for functional programmers.""
  - ""we propose the addition of three new features to functional programming languages such as Haskell: Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions.""
  - ""Unfortunately, the type systems of today's functional languages cannot directly express interesting properties of programs.""
  - ""The Curry-Howard isomorphism states that types are propositions and that programs are proofs.""",,"- The abstract discusses the Curry-Howard isomorphism, which is a foundational concept in programming language theory. However, it highlights a limitation in current functional languages: they cannot directly express interesting program properties.
 - The novelty lies in the proposal of three new features: Generalized Algebraic Datatypes, Extensible Kind Systems, and the generation, propagation, and discharging of Static Propositions. These are presented as solutions to the limitation mentioned.
 - These features are significant because they are backward compatible, meaning they do not disrupt existing programming practices. This is a key theoretical contribution as it suggests a way to enhance current systems without requiring a complete overhaul.
 - The abstract mentions that these features enable a new programming paradigm. This implies a theoretical advancement beyond existing approaches by providing a new way to state and enforce program properties using the type system.
 - The potential implications for programming language design are substantial. By allowing for the expression of interesting properties and maintaining the functional programming style, these features could lead to more robust and expressive programming languages."
Structural Operational Semantics as a Basis for Formal Methods,"P. Degano, C. Priami",-,-,-,0,1996,Not specified (the abstract does not explicitly define conceptual primitives),"Not specified (the abstract does not provide explicit details about the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework)","- Specific integration mechanisms proposed: Structural operational semantics (SOS) as a modular and language-independent method.
 - Interaction models between paradigms: SOS specifies behavior rather than language-specific semantics.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed (the abstract focuses on the integration and abstraction capabilities of SOS but does not provide detailed mechanisms for generic programming or type requirements),"- Key novel insights: SOS is a good candidate for large-scale projects due to its integration capabilities across various programming paradigms.
 - Theoretical advancements: SOS is modular and language-independent, allowing for unified specification and verification across multiple paradigms.
 - Potential implications for programming language design: SOS enables flexibility in system design and verification by allowing any aspect of a system to be treated with the most appropriate language.","- ""Structural operational semantics enjoys the same main characteristic that a kernel of a formal method should have.""
  - ""The SOS semantics of many programming languages, in virtually all paradigms (imperative, functional, logic, objectoriented, etc.), can be easily integrated with each other.""",,"- The abstract discusses the use of Structural Operational Semantics (SOS) as a basis for formal methods, indicating its role in specifying behavior across different programming paradigms.
 - It mentions that SOS can be applied to various programming languages and paradigms, suggesting a level of abstraction and flexibility.
 - The abstract does not explicitly define specific conceptual primitives but emphasizes the method's ability to integrate different paradigms and provide a uniform semantic description.
 - The focus is on the method's applicability and integration capabilities rather than on specific primitives.","- ""This is the case of structural operational semantics which is a method to specify behaviour, rather than a method to specify the semantics of a xed language.""
  - ""The mathematics behind SOS is basic and only amounts to some symbol pushing.""
  - ""Structural operational semantics enjoys the same main characteristic that a kernel of a formal method should have.""
  - ""Structural operational techniques are described in many books [24, 15, 22, 23] that enhance comprehension and assist developers during the project.""",,"- The abstract mentions ""Structural operational semantics"" as a key concept, which is a type of mathematical framework used for formalizing and guaranteeing properties of systems.
 - The phrase ""The mathematics behind SOS is basic and only amounts to some symbol pushing"" suggests that the mathematical framework is not overly complex, but it does not specify the type of mathematical framework or specific properties guaranteed.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used within the structural operational semantics framework.
 - The mention of structural operational techniques being described in various books implies that there is a body of literature supporting this framework, but again, no specific details about the mathematical framework are provided.
 - The abstract does not discuss limitations or constraints of the framework.","- ""The explosion of Web and the Internet navigators calls for an integration of di erent applications from di erent sites. Each application is potentially written with languages based on di erent programming paradigms.""
  - ""A uniform view of the whole system is thus retrieved at the level of semantic description on which proofs and veri cations can be carried out.""
  - ""As a consequence, any aspect of a system can be treated with the most appropriate language.""
  - ""This is the case of structural operational semantics which is a method to specify behaviour, rather than a method to specify the semantics of a xed language.""
  - ""Therefore, the specication/veri cation techniques must be modular and language independent.""",,"- The abstract discusses the need for integrating different applications written in various programming paradigms due to the growth of the web and internet.
 - It suggests that structural operational semantics (SOS) is a method that can facilitate this integration by being modular and language-independent.
 - SOS is described as a method that specifies behavior rather than being tied to a specific language, which implies it can handle different paradigms.
 - The abstract mentions that any aspect of a system can be treated with the most appropriate language, indicating flexibility in paradigm integration.
 - It concludes that SOS provides a uniform view of the system at the semantic level, which is crucial for integration and verification.","- ""The SOS semantics of many programming languages, in virtually all paradigms (imperative, functional, logic, objectoriented, etc.), can be easily integrated with each other.""
  - ""Structural operational semantics enjoys the same main characteristic that a kernel of a formal method should have.""",,"- The abstract discusses the use of structural operational semantics (SOS) as a basis for formal methods, which implies a focus on abstraction mechanisms.
 - The mention of SOS being applicable to ""virtually all paradigms"" suggests a level of genericity in its approach, as it can be integrated with various programming languages.
 - The need for ""modular and language independent"" techniques indicates a focus on abstraction mechanisms that can handle different programming paradigms.
 - The abstract does not explicitly define ""concept"" or discuss minimal type requirements or static checking strategies, but it emphasizes the integration and abstraction capabilities of SOS.
 - The focus on treating ""any aspect of a system with the most appropriate language"" suggests a flexible abstraction mechanism, but it does not delve into specific mechanisms for representing generic abstractions or type requirements.","- ""It is thus a good candidate for use in large scale projects.""
  - ""The mathematics behind SOS is basic and only amounts to some symbol pushing.""
  - ""As a consequence, any aspect of a system can be treated with the most appropriate language.""
  - ""Structural operational semantics enjoys the same main characteristic that a kernel of a formal method should have.""
  - ""The SOS semantics of many programming languages, in virtually all paradigms (imperative, functional, logic, objectoriented, etc.), can be easily integrated with each other.""",,"- The abstract highlights that structural operational semantics (SOS) is a good candidate for large-scale projects due to its ability to integrate with various programming paradigms, which is a novel insight into its applicability.
 - The ease of integration of SOS with different programming languages is a theoretical advancement, as it allows for a unified approach across multiple paradigms.
 - The abstract mentions that SOS is modular and language-independent, which is a significant theoretical contribution as it enables the specification and verification of systems without being tied to specific languages.
 - The ability to treat any aspect of a system with the most appropriate language is a key theoretical advancement, as it provides flexibility in system design and verification.
 - The abstract suggests that SOS can handle the integration of different applications from different sites, which is a novel insight into its potential for managing complex, heterogeneous systems."
A presentation of the Curry-Howard Correspondance,Chantal Berline,-,-,-,1,1997,Not specified (the abstract does not explicitly define or list conceptual primitives),"- Type of mathematical framework: Lambda calculus, related to type theory through the Curry-Howard correspondence
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The λ-calculus allows functions and functionals to be passed as arguments, and its terms can be viewed as proofs as well as programs.
 - Theoretical advancements: The Curry-Howard Isomorphism provides a deep correspondence between proof theory and programming theory.
 - Potential implications: Facilitates exchanges between computer science, proof theory, and mathematics, potentially influencing programming language design.","- ""The other main conceptual contribution of-calculus to Programming Theory comes from the fact that its terms can be viewed as proofs as well as programs""
  - ""In functional languages functions and functionals may be passed as arguments to a program as easily as concrete datas, which is not the case with imperative languages""
  - ""The programming with proofs paradigm is a topic in active progress, and the present developments of the Curry Howard Correspondence generate beautiful and deep exchanges of intuitions and problems between Computer Science , Proof Theory and Mathematics.""
  - ""0.1-calculus as a foundation for Programming Theory.-calculus""",,"- The abstract discusses the use of λ-calculus as a foundation for programming theory, which suggests that λ-calculus itself is a conceptual primitive in this context.
 - The ability to pass functions and functionals as arguments is highlighted as a key feature of functional languages, which could be considered a conceptual primitive related to functional programming.
 - The abstract mentions that λ-calculus terms can be viewed as both proofs and programs, which aligns with the Curry-Howard Isomorphism and suggests that this duality is a conceptual primitive.
 - The abstract does not provide explicit definitions or a list of conceptual primitives, nor does it discuss the level of abstraction or orthogonality of these primitives.","- ""the mathematical expression of the Curry Howard Isomorphismm, which is a very deep correspondence between proof theory, i.e. the mathematical analysis of mathematical reasoning, and concrete programming theory.""
  - ""The programming with proofs paradigm is a topic in active progress, and the present developments of the Curry Howard Correspondence generate beautiful and deep exchanges of intuitions and problems between Computer Science , Proof Theory and Mathematics.""
  - ""The other main conceptual contribution of-calculus to Programming Theory comes from the fact that its terms can be viewed as proofs as well as programs""
  - ""0.1-calculus as a foundation for Programming Theory.-calculus""
  - ""In functional languages functions and functionals may be passed as arguments to a program as easily as concrete datas, which is not the case with imperative languages""",,"- The abstract mentions the use of ""0.1-calculus as a foundation for Programming Theory,"" which suggests that the mathematical framework is based on lambda calculus.
 - The ability to view terms as both proofs and programs indicates a connection to type theory, as this is a characteristic of the Curry-Howard correspondence.
 - The mention of the Curry-Howard Isomorphism suggests that the framework involves a correspondence between proof theory and programming theory, which is a key aspect of type theory.
 - The abstract does not specify any particular mathematical properties guaranteed by the framework, nor does it mention specific proof techniques or limitations.
 - The focus on the Curry-Howard correspondence and the programming with proofs paradigm suggests that the framework is related to type theory, but specific details about the mathematical properties or proof techniques are not provided.","- ""The programming with proofs paradigm is a topic in active progress, and the present developments of the Curry Howard Correspondence generate beautiful and deep exchanges of intuitions and problems between Computer Science , Proof Theory and Mathematics.""
  - ""The other main conceptual contribution of-calculus to Programming Theory comes from the fact that its terms can be viewed as proofs as well as programs :-calculus allows the mathematical expression of the Curry Howard Isomorphismm, which is a very deep correspondence between proof theory, i.e. the mathematical analysis of mathematical reasoning, and concrete programming theory.""
  - ""In functional languages functions and functionals may be passed as arguments to a program as easily as concrete datas, which is not the case with imperative languages (Fortran, Pascal, C)""
  - ""0.1-calculus as a foundation for Programming Theory.-calculus came back to the front of the scene in the sixties with the development of Computer Science, under the impulse of Landin 21] and Backus (cf. 1]) and generated the family of functional languages (Lisp McCarthy 1960], Haskell, Miranda, ML, Caml,""",,"- The abstract discusses the role of λ-calculus in programming theory, particularly its influence on functional programming languages.
 - It highlights the difference between functional and imperative programming paradigms, noting that functional languages can pass functions as arguments more easily.
 - The Curry-Howard Isomorphism is mentioned as a deep correspondence between proof theory and programming theory, suggesting a theoretical integration strategy.
 - The abstract does not explicitly describe specific integration mechanisms, interaction models, constraints, or novel translation techniques for integrating different programming paradigms.
 - The focus is more on the theoretical contributions of λ-calculus and the Curry-Howard Isomorphism rather than practical integration approaches.","- ""In functional languages functions and functionals may be passed as arguments to a program as easily as concrete datas, which is not the case with imperative languages""
  - ""0.1-calculus as a foundation for Programming Theory.-calculus""
  - ""The programming with proofs paradigm is a topic in active progress, and the present developments of the Curry Howard Correspondence generate beautiful and deep exchanges of intuitions and problems between Computer Science , Proof Theory and Mathematics.""
  - ""The other main conceptual contribution of-calculus to Programming Theory comes from the fact that its terms can be viewed as proofs as well as programs""",,"- The abstract discusses the role of λ-calculus in programming theory, particularly its use in functional languages. This suggests a focus on functional programming, which often involves generic programming concepts.
 - The mention of functions and functionals being passed as arguments indicates a level of abstraction, which is a key aspect of generic programming.
 - The abstract highlights the Curry-Howard Correspondence, which relates proof theory to programming theory. This correspondence is about viewing terms as both proofs and programs, which can be seen as a form of abstraction.
 - However, the abstract does not explicitly mention ""genericity and abstraction mechanisms"" or provide specific details on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus is more on the conceptual contributions of λ-calculus and the Curry-Howard Correspondence rather than specific mechanisms or methodologies for generic programming.","- ""In functional languages functions and functionals may be passed as arguments to a program as easily as concrete datas, which is not the case with imperative languages""
  - ""The other main conceptual contribution of-calculus to Programming Theory comes from the fact that its terms can be viewed as proofs as well as programs""
  - ""0.1-calculus as a foundation for Programming Theory.-calculus""
  - ""The programming with proofs paradigm is a topic in active progress, and the present developments of the Curry Howard Correspondence generate beautiful and deep exchanges of intuitions and problems between Computer Science , Proof Theory and Mathematics.""",,"- The abstract discusses the role of λ-calculus as a foundation for programming theory, which is a key theoretical contribution. It highlights how λ-calculus allows functions and functionals to be passed as arguments, a feature not present in imperative languages.
 - The abstract emphasizes the Curry-Howard Isomorphism, which is a deep correspondence between proof theory and programming theory. This is a significant theoretical advancement as it bridges mathematical reasoning with programming.
 - The mention of the ""programming with proofs paradigm"" suggests a novel insight into how programming can be viewed through the lens of mathematical proofs, which is an innovative theoretical perspective.
 - The abstract implies that these developments have potential implications for programming language design by facilitating exchanges between computer science, proof theory, and mathematics."
Science of Computer Programming,"G. Salvaneschi, Carlo Ghezzi, Matteo Pradella",-,-,-,0,2015,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework used),"- Specific integration mechanisms proposed: Seamless integration of adaptive abstractions with distribution and concurrency in ContextErlang.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"- Novel insights: Integration of adaptive abstractions with distribution and concurrency in ContextErlang.
 - Theoretical advancements: Formal semantics and support for formal proofs of safety requirements in ContextErlang.
 - Potential implications: Demonstrates feasibility of integrating adaptive features with concurrency and distribution, applicable to designing contextual extensions of other languages.","- ""We present ContextErlang , a COP programming language in which adaptive abstractions are seamlessly integrated with distribution and concurrency.""
  - ""COP mostly focuses on run time adaptation of the application’s behavior by supporting modular descriptions of behavioral variations.""
  - ""Context-oriented programming (COP) has been recently proposed as a specialized programming paradigm for context-aware and adaptive systems.""",,"- The abstract discusses Context-Oriented Programming (COP) as a paradigm for adaptive systems, which suggests that COP is a conceptual framework rather than a specific set of primitives.
 - The focus on ""run time adaptation of the application’s behavior"" and ""modular descriptions of behavioral variations"" indicates that these are key concepts within COP, but they are not explicitly defined as primitives.
 - The mention of ""adaptive abstractions"" in ContextErlang suggests that these are part of the language's design, but again, they are not explicitly listed as primitives.
 - The abstract does not provide specific names or definitions for conceptual primitives, nor does it discuss their orthogonality or level of abstraction.","- ""We deﬁne ContextErlang ’s formal semantics, validated through an executable prototype, and we show how it supports formal proofs that the language design ensures satisfaction of certain safety requirements.""",,"- The abstract mentions the definition of ""ContextErlang ’s formal semantics,"" which suggests the use of a mathematical framework to formalize the language.
 - It also mentions ""formal proofs"" and ""satisfaction of certain safety requirements,"" indicating that the framework is used to guarantee specific properties.
 - However, the abstract does not specify the type of mathematical framework used (e.g., type theory, category theory).
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations/constraints of the framework.
 - The abstract does not provide explicit details about the mathematical framework, so it is not possible to extract specific characteristics.","- ""We present ContextErlang , a COP programming language in which adaptive abstractions are seamlessly integrated with distribution and concurrency.""
  - ""Context-oriented programming (COP) has been recently proposed as a specialized programming paradigm for context-aware and adaptive systems.""
  - ""We also show how the same design principles that lead to the development of ContextErlang can be followed to systematically design contextual extensions of other languages. A concrete example is presented concerning ContextScala""
  - ""We deﬁne ContextErlang ’s formal semantics, validated through an executable prototype, and we show how it supports formal proofs that the language design ensures satisfaction of certain safety requirements.""
  - ""COP mostly focuses on run time adaptation of the application’s behavior by supporting modular descriptions of behavioral variations.""",,"- The abstract discusses the integration of context-oriented programming (COP) with other programming paradigms, specifically mentioning the integration of adaptive abstractions with distribution and concurrency in ContextErlang.
 - The integration mechanism proposed is the seamless integration of these features within the ContextErlang language, which suggests a holistic design approach.
 - The abstract does not explicitly mention specific interaction models between paradigms or constraints/challenges in paradigm integration, but it implies that the integration is designed to ensure safety requirements.
 - The mention of ContextScala as an example suggests that the design principles used for ContextErlang can be applied to other languages, indicating a potential for systematic integration of COP with other paradigms.
 - There is no explicit mention of novel translation or embedding techniques in the abstract.","- ""We present ContextErlang , a COP programming language in which adaptive abstractions are seamlessly integrated with distribution and concurrency.""
  - ""Context-oriented programming (COP) has been recently proposed as a specialized programming paradigm for context-aware and adaptive systems.""
  - ""COP mostly focuses on run time adaptation of the application’s behavior by supporting modular descriptions of behavioral variations.""",,"- The abstract discusses Context-Oriented Programming (COP) as a paradigm for adaptive systems, which implies a focus on dynamic adaptation rather than generic programming.
 - The mention of ""adaptive abstractions"" suggests a focus on dynamic behavior rather than generic programming concepts.
 - The abstract does not explicitly mention generic programming, type systems, or static checking strategies, which are key components of genericity and abstraction mechanisms.
 - The focus is on the integration of adaptive abstractions with distribution and concurrency, rather than on generic programming methodologies or type system discussions.","- ""Context-oriented programming (COP) has been recently proposed as a specialized programming paradigm for context-aware and adaptive systems.""
  - ""COP mostly focuses on run time adaptation of the application’s behavior by supporting modular descriptions of behavioral variations.""
  - ""Addressing these issues at the language level requires a holistic design that covers all aspects and takes into account the possibly cumbersome interaction of those features, for example concurrency and dynamic change.""
  - ""We present ContextErlang , a COP programming language in which adaptive abstractions are seamlessly integrated with distribution and concurrency.""
  - ""We provide empirical evidence that ContextErlang is an effective solution through case studies and a performance assessment.""
  - ""We also show how the same design principles that lead to the development of ContextErlang can be followed to systematically design contextual extensions of other languages.""",,"- The abstract introduces Context-oriented Programming (COP) as a paradigm for adaptive systems, which is a novel approach in itself.
 - The integration of adaptive abstractions with distribution and concurrency in ContextErlang represents a theoretical advancement by addressing complex interactions between these features.
 - The formal semantics of ContextErlang and the ability to support formal proofs for safety requirements are significant theoretical contributions, as they provide a rigorous foundation for the language.
 - The empirical evidence and performance assessment suggest that ContextErlang is effective, which has implications for programming language design by demonstrating the feasibility of integrating adaptive features with concurrency and distribution.
 - The abstract also mentions that the design principles of ContextErlang can be applied to other languages, indicating a broader theoretical contribution to the field of programming language design."
On Traits and Types in a Java-like Setting,"V. Bono, Ferruccio Damiani, Elena Giachino",10.1007/978-0-387-09680-3_25,https://doi.org/10.1007/978-0-387-09680-3_25,IFIP TCS,34,2008,"1. Primitive Name: Interfaces
  Definition: Pure types
  Orthogonality Score: Not explicitly scored
 

 2. Primitive Name: Traits
  Definition: Pure units of behavior reuse
  Orthogonality Score: Not explicitly scored
 

 3. Primitive Name: Classes
  Definition: Pure generators of instances
  Orthogonality Score: Not explicitly scored","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Soundness of the type system w.r.t. operational semantics, subtyping relation defined by reflexive and transitive closure
 - Proof techniques used: Theorem proving, flattening translation, reduction semantics
 - Limitations or constraints of the framework: Focus on type soundness and operational semantics","- Specific integration mechanisms proposed: Separation of roles for interfaces, traits, and classes; composition and extension of traits and classes.
 - Interaction models between paradigms: Composition and extension of traits and classes; interfaces extend other interfaces.
 - Constraints or challenges in paradigm integration: Ensuring type soundness with a hybrid nominal/structural type system.
 - Novel translation or embedding techniques: Flattening translation to preserve type soundness.",Generic programming not extensively addressed,"- Novel principle: Each software structuring construct should have exactly one role.
 - Theoretical advancement: Separation of object type, behavior, and generator declarations.
 - Hybrid nominal/structural type system for isolated trait typechecking.
 - Insight into competing roles of unit of reuse and type.
 - Stateless traits with field renaming for enhanced reuse potential.","- ""Interfaces, as pure types.""
  - ""Classes are defined by composing traits, implementing interfaces, and defining fields.""
  - ""Interfaces can be defined by extending other interfaces (the interface hierarchy induces subtyping).""
  - ""Traits can be defined by composing other traits.""
  - ""Classes, as pure generators of instances.""
  - ""Traits, as pure units of behavior reuse.""
  - ""We propose programming language features that separate completely the declarations of object type, behavior and generator.""",,"- The paper discusses the need to separate the roles of software structuring constructs to improve reuse and simplicity in object-oriented programming.
 - It proposes three conceptual primitives: Interfaces, Traits, and Classes, each with a specific role.
 - Interfaces are defined as ""pure types,"" indicating they are used for type definitions and subtyping.
 - Traits are described as ""pure units of behavior reuse,"" suggesting they are used for composing behavior.
 - Classes are defined as ""pure generators of instances,"" indicating they are used for creating instances.
 - The paper explains how these primitives interact: Interfaces can extend other interfaces, Traits can compose other traits, and Classes can implement interfaces and compose traits.
 - The level of abstraction is high as these primitives are fundamental concepts in the proposed programming paradigm.
 - Orthogonality is implied as each primitive has a distinct role, but it is not explicitly scored in the paper.","- ""We illustrate our proposal through a core calculus and prove the soundness of the type system w.r.t. the operational semantics.""
  - ""We propose programming language features that separate completely the declarations of object type, behavior and generator.""
  - ""The FRJ type system combines nominal and structural typing.""
  - ""The type soundness result comes in two parts: first it relates the typing of expressions with the typing of runtime expressions, then it proves the type soundness with respect to the runtime expression typing.""
  - ""Theorem 2 (Well-typed FFRJ expressions are well-typed runtime expression with a more specific type). If • e : η, then • e : η for some η such that η <: η.""
  - ""The semantics of FRJ is specified by means of a flattening translation that maps a FRJ program into a FFRJ program and of a reduction semantics for FFRJ programs.""
  - ""The flattening translation preserves the type of programs.""",,"- The paper discusses the use of a ""core calculus"" to formalize the language features, which suggests a type theory framework.
 - The mention of ""nominal and structural typing"" indicates that the mathematical framework involves type theory, specifically combining these two types of typing.
 - The paper proves the ""soundness of the type system w.r.t. the operational semantics,"" which is a common goal in type theory to ensure that the type system is consistent with the operational behavior of the language.
 - The ""subtyping relation"" is defined using reflexive and transitive closure, which is a mathematical property guaranteed by the framework.
 - The ""type soundness result"" is proven using a theorem that relates typing of expressions to runtime expressions, indicating a formal verification technique.
 - The ""flattening translation"" and ""reduction semantics"" are used to specify the semantics of the language, which are typical techniques in type theory to ensure soundness and consistency.
 - The framework is limited by its focus on type soundness and operational semantics, but it does not explicitly mention limitations or constraints beyond this.","- ""Interfaces can be defined by extending other interfaces (the interface hierarchy induces subtyping). Traits can be defined by composing other traits. Classes are defined by composing traits, implementing interfaces, and defining fields.""
  - ""We propose programming language features that separate completely the declarations of object type, behavior and generator.""
  - ""The semantics of FRJ is specified by means of a flattening translation that maps a FRJ program into a FFRJ program and of a reduction semantics for FFRJ programs.""
  - ""We argue that, in order to support the development of reusable program components, object oriented programming languages should be designed according to the principle that each software structuring construct must have exactly one role.""
  - ""The flattening translation preserves the type of programs.""
  - ""The FRJ type system combines nominal and structural typing.""",,"- The paper discusses the integration of different programming paradigms by proposing a separation of roles within object-oriented programming languages. This is a theoretical integration strategy aimed at improving code reuse.
 - The specific integration mechanisms proposed include the use of interfaces, traits, and classes, each with a distinct role: interfaces as pure types, traits as pure units of behavior reuse, and classes as pure generators of instances.
 - The interaction model between these paradigms is based on composition and extension. Traits can be composed, and classes can implement interfaces and compose traits.
 - The paper mentions the challenge of ensuring type soundness in this integrated paradigm, which is addressed through a hybrid nominal/structural type system.
 - The flattening translation technique is a novel approach to embedding the proposed paradigm into a more traditional setting, ensuring type preservation.","- ""We propose programming language features that separate completely the declarations of object type, behavior and generator.""
  - ""The FRJ type system combines nominal and structural typing.""
  - ""Interfaces can be defined by extending other interfaces (the interface hierarchy induces subtyping). Traits can be defined by composing other traits. Classes are defined by composing traits, implementing interfaces, and defining fields.""",,"- The paper discusses the separation of object type, behavior, and generator, which is a form of abstraction mechanism but does not specifically focus on generic programming.
 - The type system described combines nominal and structural typing, which is relevant to abstraction but not explicitly generic programming.
 - The paper mentions extending the type system to deal with generics in future work, indicating that generic programming is not a focus of this study.
 - There is no detailed discussion on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies related to generic programming.","- ""We argue that, in order to support the development of reusable program components, object oriented programming languages should be designed according to the principle that each software structuring construct must have exactly one role.""
  - ""We propose programming language features that separate completely the declarations of object type, behavior and generator.""
  - ""We developed a hybrid nominal/structural type system that allows to typecheck traits in isolation and proved its soundness.""
  - ""The competing roles played by the same software structuring construct complicate the semantics and limits the reuse potential in mainstream object-oriented class-based programming languages.""
  - ""We claim also that the roles of unit of reuse and type are competing""
  - ""we propose to increase both the simplicity and the flexibility of the object-oriented paradigm by adopting programming language features that separate completely the declarations of object type, behavior, and generator.""
  - ""Our traits are stateless, however, since they can have required fields, it is possible to avoid the same kind of duplication of code that motivated the introduction of stateful traits.""
  - ""As byproducts, since required field renaming works synergically with method renaming, exclusion, aliasing, and duplication, we obtain more reuse potential.""",,"- The paper introduces a novel principle that each software structuring construct should have exactly one role, which is a significant theoretical contribution to the design of object-oriented programming languages.
 - The proposal to separate completely the declarations of object type, behavior, and generator is a theoretical advancement beyond existing approaches, as it addresses the issue of competing roles within traditional class-based inheritance.
 - The development of a hybrid nominal/structural type system that allows for typechecking traits in isolation is a theoretical innovation, as it enhances the flexibility and simplicity of the object-oriented paradigm.
 - The paper highlights the competing roles of unit of reuse and type, which is a key insight into the limitations of current programming languages and suggests a new direction for language design.
 - The discussion on stateless traits and their potential to avoid code duplication through field renaming and other operations is a theoretical contribution, as it offers an alternative to stateful traits and enhances reuse potential."
Automatic unrestricted independent and-parallelism in declarative multiparadigm languages,"G. Heileman, Amadeo Casas",-,-,-,2,2008,"1. Primitive Name: Logic Variables
  Definition: Used in declarative languages to preserve parallelism
  Orthogonality Score: Not discussed
 2. Primitive Name: New Parallel Execution Primitives
  Definition: Simpler and more flexible than fork-join parallel operator
  Orthogonality Score: Not discussed
 3. Primitive Name: Concurrency-related Primitives
  Definition: Handle locking, thread, and stack set management
  Orthogonality Score: Not discussed
 4. Primitive Name: Function Application
  Definition: Part of syntactic functional extension to ISO-standard Prolog
  Orthogonality Score: Not discussed
 5. Primitive Name: Predefined Evaluable Functors
  Definition: Part of syntactic functional extension to ISO-standard Prolog
  Orthogonality Score: Not discussed
 6. Primitive Name: Functional Definitions
  Definition: Part of syntactic functional extension to ISO-standard Prolog
  Orthogonality Score: Not discussed
 7. Primitive Name: Quoting
  Definition: Part of syntactic functional extension to ISO-standard Prolog
  Orthogonality Score: Not discussed
 8. Primitive Name: Lazy Evaluation
  Definition: Part of syntactic functional extension to ISO-standard Prolog
  Orthogonality Score: Not discussed",Not specified (the abstract does not mention a specific mathematical framework or theoretical foundations),"- Specific integration mechanisms proposed: Syntactic functional extension to ISO-standard Prolog systems, which includes function application, predefined evaluable functors, functional definitions, quoting, and lazy evaluation.
 - Interaction models between paradigms: Integration of logic and functional programming paradigms through the use of declarative languages.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Raising core parts to the source language level to simplify implementation.",Generic programming not extensively addressed,"- Key novel insights: The use of declarative languages for parallel performance; nondeterminism and partially instantiated data structures in logic programming provide expressive power beyond functional programming.
 - Theoretical advancements: Automatic goal-level parallelization techniques; alternative approach to implementing and-parallel logic programming languages by simplifying low-level machinery.
 - Potential implications for programming language design: Development of a syntactic functional extension to ISO-standard Prolog systems that integrates functional programming features into logic programming.","- ""The high-level nature of these languages, in addition to their relatively simple semantics and the use of logic variables, preserves more of the original parallelism to be uncovered by an automatic parallelization.""
  - ""Different alternatives for performing automatic goal-level, unrestricted independent and-parallelization of logic programs through source-to-source transformations are studied in this work, which use as targets new parallel execution primitives which are simpler and more flexible than the well-known fork-join parallel operator,""
  - ""A significant portion of the implementation mechanisms of parallel execution is handled directly at the Prolog level with the help of a comparatively small number of concurrency-related primitives that take care of simpler low-level tasks such as locking, and thread and stack set management.""
  - ""Moreover, in order to extend this work to different paradigms, a syntactic functional extension to ISO-standard Prolog systems has been developed, which covers function application, predefined evaluable functors, functional definitions, quoting, and lazy evaluation, and is composable with higher-order and other extensions to ISO-Prolog, such as constraints.""",,"- The abstract discusses the use of ""logic variables"" and ""simple semantics"" as part of the high-level nature of declarative languages, which suggests these are conceptual primitives in terms of preserving parallelism.
 - The mention of ""new parallel execution primitives"" indicates that these are conceptual primitives for parallelization, but the abstract does not specify their exact names or definitions.
 - The abstract refers to ""concurrency-related primitives"" such as ""locking, and thread and stack set management,"" which are likely conceptual primitives for handling parallel execution at the Prolog level.
 - The syntactic functional extension to ISO-standard Prolog systems includes primitives like ""function application, predefined evaluable functors, functional definitions, quoting, and lazy evaluation,"" which are conceptual primitives for extending the paradigm.","- ""The use of declarative languages is considered to be a valid approach for increasing performance through the execution of parallel programs.""
  - ""nondeterminism and partially instantiated data structures give logic programming expressive power beyond that of functional programming.""
  - ""The high-level nature of these languages, in addition to their relatively simple semantics and the use of logic variables, preserves more of the original parallelism to be uncovered by an automatic parallelization.""
  - ""Different alternatives for performing automatic goal-level, unrestricted independent and-parallelization of logic programs through source-to-source transformations are studied in this work,""
  - ""An alternative approach for implementing and-parallel logic programming languages has also been explored, which tames the complexity of the low-level machinery required by most of the previous implementations by raising core parts to the source language level.""
  - ""A significant portion of the implementation mechanisms of parallel execution is handled directly at the Prolog level with the help of a comparatively small number of concurrency-related primitives that take care of simpler low-level tasks such as locking, and thread and stack set management.""",,"- The abstract discusses the use of declarative languages and their potential for parallelism, but it does not explicitly mention a mathematical framework or theoretical foundations.
 - The focus is on the capabilities and features of declarative languages, particularly logic programming, but there is no mention of a specific mathematical framework like type theory or category theory.
 - The abstract does not provide details on proof methodology or formal verification discussions, which are typically associated with a mathematical framework.
 - The emphasis is on the practical implementation and features of parallel execution in logic programming languages, rather than on a theoretical or mathematical framework.","- ""Moreover, in order to extend this work to different paradigms, a syntactic functional extension to ISO-standard Prolog systems has been developed, which covers function application, predefined evaluable functors, functional definitions, quoting, and lazy evaluation, and is composable with higher-order and other extensions to ISO-Prolog, such as constraints.""
  - ""However, functional programming often provides convenient syntactic features, such as having a designated implicit output argument, which allow function call nesting and sometimes results in more compact code, and also sometimes a more direct encoding of lazy evaluation, with its ability to deal with infinite data structures.""
  - ""In particular, nondeterminism and partially instantiated data structures give logic programming expressive power beyond that of functional programming.""
  - ""The use of declarative languages is considered to be a valid approach for increasing performance through the execution of parallel programs.""
  - ""An alternative approach for implementing and-parallel logic programming languages has also been explored, which tames the complexity of the low-level machinery required by most of the previous implementations by raising core parts to the source language level.""",,"- The abstract discusses the integration of different programming paradigms by mentioning the use of declarative languages, which include both logic and functional programming.
 - It highlights the strengths of logic programming, such as nondeterminism and partially instantiated data structures, which provide expressive power beyond functional programming.
 - The abstract also notes the benefits of functional programming, such as convenient syntactic features and the ability to handle infinite data structures.
 - An alternative approach is mentioned that simplifies the implementation of and-parallel logic programming by raising core parts to the source language level, which could be seen as a mechanism for integrating logic programming with other paradigms.
 - A specific integration mechanism is described as a syntactic functional extension to ISO-standard Prolog systems, which includes features like function application and lazy evaluation. This extension is composable with other extensions to ISO-Prolog, indicating a strategy for integrating different paradigms.","- ""The use of declarative languages is considered to be a valid approach for increasing performance through the execution of parallel programs.""
  - ""nondeterminism and partially instantiated data structures give logic programming expressive power beyond that of functional programming.""
  - ""functional programming often provides convenient syntactic features, such as having a designated implicit output argument, which allow function call nesting and sometimes results in more compact code, and also sometimes a more direct encoding of lazy evaluation, with its ability to deal with infinite data structures.""
  - ""The high-level nature of these languages, in addition to their relatively simple semantics and the use of logic variables, preserves more of the original parallelism to be uncovered by an automatic parallelization.""
  - ""An alternative approach for implementing and-parallel logic programming languages has also been explored, which tames the complexity of the low-level machinery required by most of the previous implementations by raising core parts to the source language level.""
  - ""A significant portion of the implementation mechanisms of parallel execution is handled directly at the Prolog level with the help of a comparatively small number of concurrency-related primitives that take care of simpler low-level tasks such as locking, and thread and stack set management.""
  - ""a syntactic functional extension to ISO-standard Prolog systems has been developed, which covers function application, predefined evaluable functors, functional definitions, quoting, and lazy evaluation, and is composable with higher-order and other extensions to ISO-Prolog, such as constraints.""",,"- The abstract discusses the use of declarative languages and their expressive power, particularly in logic programming, which suggests a focus on abstraction mechanisms.
 - The mention of ""nondeterminism and partially instantiated data structures"" indicates a mechanism for representing generic abstractions, as these features allow for more flexible and abstract programming.
 - The abstract highlights the simplicity of semantics and the use of logic variables, which are mechanisms for preserving parallelism and could be related to genericity.
 - The development of a ""syntactic functional extension to ISO-standard Prolog systems"" suggests a mechanism for representing generic abstractions, as it includes features like function application and lazy evaluation.
 - However, there is no explicit mention of generic programming methodology, type system discussions, or specific minimal type requirements, which are key components of genericity and abstraction mechanisms.
 - The abstract does not provide detailed information on static checking or optimization strategies related to generic programming.","- ""The use of declarative languages is considered to be a valid approach for increasing performance through the execution of parallel programs.""
  - ""nondeterminism and partially instantiated data structures give logic programming expressive power beyond that of functional programming.""
  - ""The high-level nature of these languages, in addition to their relatively simple semantics and the use of logic variables, preserves more of the original parallelism to be uncovered by an automatic parallelization.""
  - ""Different alternatives for performing automatic goal-level, unrestricted independent and-parallelization of logic programs through source-to-source transformations are studied in this work,""
  - ""An alternative approach for implementing and-parallel logic programming languages has also been explored, which tames the complexity of the low-level machinery required by most of the previous implementations by raising core parts to the source language level.""
  - ""A significant portion of the implementation mechanisms of parallel execution is handled directly at the Prolog level with the help of a comparatively small number of concurrency-related primitives""
  - ""a syntactic functional extension to ISO-standard Prolog systems has been developed, which covers function application, predefined evaluable functors, functional definitions, quoting, and lazy evaluation, and is composable with higher-order and other extensions to ISO-Prolog, such as constraints.""",,"- The abstract highlights the use of declarative languages as a valid approach for increasing performance through parallel execution, which is a key insight into the potential of these languages for parallel programming.
 - The mention of nondeterminism and partially instantiated data structures in logic programming suggests a theoretical advancement beyond functional programming, as it provides expressive power that is not available in functional programming.
 - The high-level nature and simple semantics of these languages are noted as preserving original parallelism, which is a theoretical contribution to understanding how these languages can be effectively parallelized.
 - The study of different alternatives for automatic goal-level parallelization and the exploration of an alternative approach to implementing and-parallel logic programming languages indicate theoretical advancements in parallelization techniques.
 - The development of a syntactic functional extension to ISO-standard Prolog systems that is composable with other extensions suggests a theoretical contribution to the design of programming languages, particularly in integrating functional programming features into logic programming frameworks."
Reusable Specification of Agent-Based Models,David Fisher,10.1109/WETICE.2010.30,https://doi.org/10.1109/WETICE.2010.30,2010 19th IEEE International Workshops on Enabling Technologies: Infrastructures for Collaborative Enterprises,1,2010,Not specified (the abstract does not explicitly list or define specific conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),No specific integration approach described,"- Definition of ""concept"" used: Not explicitly mentioned
 - Mechanisms for representing generic abstractions: Use of property-based types for abstract specification
 - Minimal type requirements identified: Not explicitly mentioned
 - Static checking or optimization strategies: Not explicitly mentioned","- Key novel insights: Identification of impediments to reusable agent-based models; use of property-based types to overcome object-oriented paradigm limitations.
 - Theoretical advancements: Introduction of a new class of programming languages for abstract specification and automated simulation construction; property-based approach for independent model validation and flexible model modification.
 - Potential implications for programming language design: Development of programming languages that incorporate property-based types for more flexible and efficient model construction and validation.","- ""A property-based approach enables independent validation of constituent models, abstract specification of actors independent of their simulations, and certain modifications to model without revalidation.""
  - ""It describes a new class of programming languages that address these problems by allowing abstract specification of incomplete but accurate models and by enabling automated construction of agent-based simulations from models.""
  - ""The primary innovation underlying this approach is the use of property-based types to avoid modeling limitations inherent in the object-oriented paradigm.""
  - ""This paper identifies and characterizes several important impediments to reusable agent-based models.""",,"- The abstract mentions the use of ""property-based types"" as a primary innovation, which suggests a shift from traditional object-oriented programming paradigms.
 - The term ""property-based types"" implies a focus on defining models based on properties rather than objects, which could be considered a conceptual primitive.
 - The abstract does not explicitly list or define specific conceptual primitives, but it does highlight the property-based approach as a key concept.
 - The level of abstraction is high, as it involves abstract specification and automated construction of simulations.
 - Orthogonality is not explicitly discussed in the abstract.","- ""The primary innovation underlying this approach is the use of property-based types to avoid modeling limitations inherent in the object-oriented paradigm.""
  - ""A property-based approach enables independent validation of constituent models, abstract specification of actors independent of their simulations, and certain modifications to model without revalidation.""
  - ""It describes a new class of programming languages that address these problems by allowing abstract specification of incomplete but accurate models and by enabling automated construction of agent-based simulations from models.""
  - ""This paper identifies and characterizes several important impediments to reusable agent-based models.""",,"- The abstract mentions the use of ""property-based types"" as a primary innovation, which suggests a type theory framework.
 - The abstract does not explicitly mention any specific mathematical properties guaranteed by this framework.
 - There is no mention of proof techniques or methodologies used in the abstract.
 - The abstract does not discuss any limitations or constraints of the framework.
 - The abstract does not provide explicit details about the theoretical foundations, proof methodology, or formal verification discussions related to the mathematical framework.","- ""A property-based approach enables independent validation of constituent models, abstract specification of actors independent of their simulations, and certain modifications to model without revalidation.""
  - ""It describes a new class of programming languages that address these problems by allowing abstract specification of incomplete but accurate models and by enabling automated construction of agent-based simulations from models.""
  - ""The primary innovation underlying this approach is the use of property-based types to avoid modeling limitations inherent in the object-oriented paradigm.""
  - ""This paper identifies and characterizes several important impediments to reusable agent-based models.""",,"- The abstract discusses the use of a new class of programming languages to address impediments in agent-based models, which implies a focus on integrating different programming paradigms.
 - The primary innovation mentioned is the use of ""property-based types,"" which suggests a shift away from the object-oriented paradigm, indicating a form of integration or alternative approach.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques. It focuses on the property-based approach as a solution to limitations in object-oriented programming.
 - The abstract does not provide detailed discussion on paradigm interactions, theoretical integration strategies, or comparative analysis sections that would typically be expected in a description of a programming paradigm integration approach.","- ""The primary innovation underlying this approach is the use of property-based types to avoid modeling limitations inherent in the object-oriented paradigm.""
  - ""A property-based approach enables independent validation of constituent models, abstract specification of actors independent of their simulations, and certain modifications to model without revalidation.""
  - ""It describes a new class of programming languages that address these problems by allowing abstract specification of incomplete but accurate models and by enabling automated construction of agent-based simulations from models.""
  - ""This paper identifies and characterizes several important impediments to reusable agent-based models.""",,"- The abstract discusses the use of ""property-based types"" as a primary innovation, which suggests a focus on generic programming and abstraction mechanisms.
 - The mention of ""abstract specification of incomplete but accurate models"" indicates a mechanism for representing generic abstractions.
 - The use of ""property-based types"" implies a type system discussion, which is relevant to minimal type requirements and static checking or optimization strategies.
 - The abstract does not explicitly mention ""minimal type requirements"" or ""static checking or optimization strategies,"" but the focus on property-based types suggests an approach to these aspects.
 - The abstract does not provide a specific definition of ""concept"" used in the study, but it implies a conceptual abstraction through the use of property-based types.","- ""This paper identifies and characterizes several important impediments to reusable agent-based models.""
  - ""It describes a new class of programming languages that address these problems by allowing abstract specification of incomplete but accurate models and by enabling automated construction of agent-based simulations from models.""
  - ""The primary innovation underlying this approach is the use of property-based types to avoid modeling limitations inherent in the object-oriented paradigm.""
  - ""A property-based approach enables independent validation of constituent models, abstract specification of actors independent of their simulations, and certain modifications to model without revalidation.""",,"- The abstract identifies ""important impediments to reusable agent-based models,"" which suggests a novel insight into the challenges faced by current models.
 - It introduces a ""new class of programming languages"" that addresses these impediments, indicating a theoretical advancement in programming language design.
 - The use of ""property-based types"" is highlighted as a primary innovation, which is a theoretical contribution as it moves away from the limitations of the object-oriented paradigm.
 - The property-based approach allows for ""independent validation of constituent models"" and ""abstract specification of actors independent of their simulations,"" which are key novel insights into how models can be more flexibly and accurately constructed.
 - The ability to make ""certain modifications to model without revalidation"" suggests a significant theoretical advancement in terms of model adaptability and efficiency."
Naturally Embedded Query Languages,"V. Tannen, P. Buneman, L. Wong",10.1007/3-540-56039-4_38,https://doi.org/10.1007/3-540-56039-4_38,International Conference on Database Theory,211,1992,"1. Primitive Name: First-order lambda abstraction and application
  Definition: Constructs for manipulating functions
  Orthogonality Score: High (orthogonal combination)
 2. Primitive Name: Tuples (pairing and projection)
  Definition: Constructs for manipulating tuples
  Orthogonality Score: High (orthogonal combination)
 3. Primitive Name: Sets (operations of the set monad)
  Definition: Constructs for manipulating sets
  Orthogonality Score: High (orthogonal combination)","- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Equational theories, monad identities, natural transformations
 - Proof techniques used: Equational reasoning, provability within equational theories
 - Limitations or constraints of the framework: Not explicitly mentioned, but further axiomatization is needed for some languages","- Specific integration mechanisms proposed: Use of structural recursion as a common computational engine; application of category theory for organizing semantics and syntax.
 - Interaction models between paradigms: Equivalence between different formalisms (e.g., M A ( C ) and M C ( C )); use of monads for semantic organization.
 - Constraints or challenges in paradigm integration: Ensuring semantic consistency across different languages; validating optimizing transformations through equational theories.
 - Novel translation or embedding techniques: Use of monads for organizing semantics and syntax; equivalence between calculus and algebra formalisms.","- Definition of ""concept"" used: Orthogonality principle for combining product and set constructions.
 - Mechanisms for representing generic abstractions: Use of category theory, monads, and polymorphic expressions.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned, but implied through the use of category theory and polymorphic expressions.","- Novel approach using structural recursion on sets as the main computational engine.
 - Uniform characterization of nested relational and complex-object algebras using simple operators.
 - Use of category theory to organize semantics and syntax.
 - Emphasis on equational theories and derivation of identities for optimizations.
 - New perspective on examining relationships among languages and embedding query languages in programming languages.","- ""Our core language (subsection 2.1) combines in an orthogonal fashion constructs for manipulating functionsfirst-order lambda abstraction and application, tuples-pairing and projection, and sets-the operations of the set monad in ""extension form"".""
  - ""The result is that a small number of semantic ideas are sufficient for explaining and analyzing the expressive power of remarkably rich languages.""
  - ""We have also found it very profitable to use some basic ideas of category theory in organizing the semantics and even the syntax of our languages.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""The idea of the passage from flat relations to nested relations/complex objects is t o let product and set constructions combine in every possible way, an orthogonality principle.""
  - ""we have found it rewarding to use an orthogonality principle not only in the description of the structure of the data but also in the choice of fundamental operations that manipulate the data.""",,"- The paper discusses the use of a small number of semantic ideas to explain and analyze the expressive power of languages, indicating a focus on conceptual primitives.
 - The core language is described as combining constructs in an orthogonal fashion, which suggests that these constructs are conceptual primitives.
 - The paper mentions the use of category theory in organizing semantics and syntax, which implies that these theoretical concepts are foundational to the primitives.
 - The orthogonality principle is highlighted as a key concept in both data structure description and operation choice, indicating its role in defining primitives.
 - The specific constructs mentioned as part of the core language are first-order lambda abstraction and application, tuples (pairing and projection), and sets (operations of the set monad), which are likely the conceptual primitives.","- ""We have also found it very profitable to use some basic ideas of category theory in organizing the semantics and even the syntax of our languages.""
  - ""In particular, structural recursion comes out of certain adjunctions, and the core of the sublanguages we consider is based on monads.""
  - ""The hope is that this perspective will prove to be equally significant, and that it will interact fruitfully with the other two.""
  - ""the algebraic perspective emphasizes equational theories, and provability in these theories can make both checking optimizations, and the search for optimizations more systematic, with a potential for partial automation.""
  - ""The axioms of M A are listed below. The reflexivity, symmetry, transitivity, and congruence identities have been omitted. The above are the monad identities, where map() is the action on morphisms of the set monad functor and 17 and p are natural transformations.""
  - ""The monad is made into a strong monad with a natural transformation p2 using the above identities.""
  - ""We leave the equational axiomatization of Mu(=, c o n d ) , A&B, and SR for a future paper.""",,"- The paper explicitly mentions the use of ""category theory"" as a mathematical framework to organize the semantics and syntax of the languages discussed.
 - The concept of ""monads"" is central to the framework, indicating that the mathematical framework is based on category theory, specifically using monads to structure the languages.
 - The paper discusses the use of ""equational theories"" and ""provability"" within these theories, suggesting that the framework involves formal verification through equational reasoning.
 - The mention of ""monad identities"" and ""natural transformations"" further supports the use of category theory as the mathematical framework.
 - The paper does not explicitly mention limitations or constraints of the framework, but it does indicate that further work is needed to fully axiomatize certain aspects of the languages.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""We have also found it very profitable to use some basic ideas of category theory in organizing the semantics and even the syntax of our languages.""
  - ""The idea that monads could be used to organize semantics of programming constructs is due to Moggi""
  - ""We conclude that M A ( C ) and M C ( C ) are equally expressive, written Actually, there is a deeper result that shows that there exists an intimate connections between the equational theories for the calculus and the algebra""
  - ""The result is a very rich, semantically sound, equational theory in which optimizing transformations can be validated.""
  - ""We now turn to other operations suggested by (nested) relational algebra.""
  - ""The authors claim that Mu(=, cond) may be profitably considered as the ""right"" nested relational algebra.""
  - ""We have not discussed operational semantics for the languages we have considered, but clearly such expressions suggest exponential algorithms for these queries (when in fact the queries are obviously polynomial).""",,"- The paper discusses the integration of different programming paradigms by focusing on structural recursion as a common computational engine.
 - The use of category theory is highlighted as a mechanism for organizing semantics and syntax across different languages.
 - The paper describes the equivalence between different formalisms (e.g., M A ( C ) and M C ( C )), indicating a theoretical integration strategy.
 - The discussion of monads and their role in organizing semantics and syntax suggests a novel translation or embedding technique.
 - The paper addresses the integration of query languages into programming languages, emphasizing the benefits of a unified framework for optimization and syntax.
 - The authors mention the use of equational theories to validate optimizing transformations, which is a constraint or challenge in paradigm integration.","- ""The idea of the passage from flat relations to nested relations/complex objects is t o let product and set constructions combine in every possible way, an orthogonality principle.""
  - ""We have also found it very profitable to use some basic ideas of category theory in organizing the semantics and even the syntax of our languages.""
  - ""The syntax and semantics of some of the sublanguages we shall consider are inspired by the categorical notion of a monad.""
  - ""We say that cardinality is polymorphically definable if there exists a polymorphic expression card : {a) -t nut, where a is a type variable, such that for each o-type u , the expression card[u/a] : {u} -+ nut denotes the cardinality function from {a) to IN.""
  - ""It appears that this generalizes all the identities about ""pushing map(.) through"" that we have so far seen to be used in optimizations, including a couple we proposed in 141.""
  - ""These results extend t o structural recursion. This is the place to emphasize that the queries definable in our languages are automatically order-independent.""",,"- The paper discusses the use of category theory to organize semantics and syntax, which is a key aspect of generic programming and abstraction mechanisms.
 - The concept of ""orthogonality principle"" suggests a method for combining different constructs in a generic way, which is a mechanism for representing generic abstractions.
 - The paper mentions the use of type variables and polymorphic expressions, which are essential for generic programming. The definition of polymorphic cardinality indicates a focus on genericity.
 - The discussion on monads and their use in organizing syntax and semantics suggests a mechanism for abstraction.
 - The mention of order-independence and the generalization of identities for optimizations implies a focus on generic programming principles.
 - The paper does not explicitly discuss minimal type requirements or static checking strategies, but the emphasis on category theory and polymorphic expressions suggests a structured approach to generic programming.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators;and""
  - ""ideas of category theory can be profitably used to organize semantics and syntax,""
  - ""our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""
  - ""The hope is that this perspective will prove to be equally significant, and that it will interact fruitfully with the other two.""
  - ""we bring out an algebraic perspective, that is, our languages come with equational theories,""
  - ""The authors claim that Mu(=, cond) may be profitably considered as the ""right"" nested relational algebra.""
  - ""We have obtained further results that are not included here and which we hope to publish shortly:""",,"- The paper introduces a novel approach by using structural recursion on sets as the main computational engine, which is a unique theoretical contribution.
 - It provides a uniform characterization of nested relational and complex-object algebras using simple operators, which is an advancement beyond existing approaches.
 - The use of category theory to organize semantics and syntax is a theoretical innovation that offers a new perspective on query languages.
 - The emphasis on equational theories and the derivation of identities for optimizations is a significant theoretical contribution.
 - The paper suggests a new way of examining relationships among languages and provides insights into embedding query languages in programming languages, which are potential implications for programming language design."
Abstract Interpretation as a Programming Language,Mads Rosendahl,10.4204/EPTCS.129.7,https://doi.org/10.4204/EPTCS.129.7,Festschrift for Dave Schmidt,4,2013,Not specified (the abstract does not provide explicit definitions or names for conceptual primitives),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed (the abstract focuses on abstract interpretation as a programming paradigm but does not provide detailed mechanisms or type requirements for generic programming),"- Key novel insights: Application of higher-order strictness analysis as fixpoint operators for higher-order functions over lattices.
 - Theoretical advancements: Provides a technique for immediate implementation of a large class of abstract interpretations.
 - Potential implications for programming language design: Introduces a new programming paradigm allowing for circular programming style.","- ""The main focus in this paper is to show that results from higher-order strictness analysis may be used more generally as fixpoint operators for higher-order functions over lattices and thus provide a technique for immediate implementation of a large class of abstract interpretations.""
  - ""Abstract interpretation is primarily a technique for derivation and specification of program analysis.""
  - ""The semantics itself can be seen as a program and one may examine different programming styles and ways to represent states.""
  - ""Furthermore, it may be seen as a programming paradigm and be used to write programs in a circular style.""",,"- The abstract discusses the use of denotational semantics and abstract interpretation as programming languages, which suggests a focus on conceptual primitives related to these areas.
 - The mention of ""different programming styles and ways to represent states"" implies that the study may explore various conceptual primitives related to programming paradigms.
 - The abstract highlights the use of ""higher-order strictness analysis"" and ""fixpoint operators for higher-order functions over lattices,"" which could be considered as conceptual primitives for abstract interpretation.
 - The abstract does not provide explicit definitions or names for these primitives, nor does it discuss their orthogonality or level of abstraction.
 - The abstract does not specify any explicit conceptual primitives or their definitions, so the answer is ""Not specified.""","- ""Abstract interpretation is primarily a technique for derivation and specification of program analysis.""
  - ""In David Schmidt's PhD work he explored the use of denotational semantics as a programming language.""
  - ""The semantics itself can be seen as a program and one may examine different programming styles and ways to represent states.""
  - ""The main focus in this paper is to show that results from higher-order strictness analysis may be used more generally as fixpoint operators for higher-order functions over lattices and thus provide a technique for immediate implementation of a large class of abstract interpretations.""",,"- The abstract mentions ""denotational semantics"" and ""abstract interpretation,"" which are both related to formal methods in programming language theory. However, it does not explicitly mention a specific mathematical framework like type theory or category theory.
 - The focus on ""higher-order strictness analysis"" and ""fixpoint operators for higher-order functions over lattices"" suggests a mathematical framework involving lattice theory and possibly fixpoint theory, but this is not explicitly stated as a mathematical framework.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework in the abstract.
 - The abstract does not provide details about theoretical foundations, proof methodology, or formal verification discussions that would typically be associated with a mathematical framework.","- ""In David Schmidt's PhD work he explored the use of denotational semantics as a programming language.""
  - ""The semantics itself can be seen as a program and one may examine different programming styles and ways to represent states.""
  - ""Abstract interpretation is primarily a technique for derivation and specification of program analysis.""
  - ""As with denotational semantics we may also view abstract interpretations as programs and examine the implementation.""
  - ""The main focus in this paper is to show that results from higher-order strictness analysis may be used more generally as fixpoint operators for higher-order functions over lattices and thus provide a technique for immediate implementation of a large class of abstract interpretations.""
  - ""Furthermore, it may be seen as a programming paradigm and be used to write programs in a circular style.""",,"- The abstract discusses the use of denotational semantics and abstract interpretation as programming languages, which suggests a blending of different programming paradigms.
 - The mention of examining different programming styles and ways to represent states implies a consideration of how different paradigms might interact.
 - The use of higher-order strictness analysis as fixpoint operators for higher-order functions over lattices could be seen as a mechanism for integrating different paradigms by providing a common framework for implementation.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques, but it does suggest a paradigmatic approach by viewing abstract interpretations as programs.
 - The abstract does not provide detailed discussion or analysis of paradigm interactions, theoretical integration strategies, or comparative analysis sections that would typically be expected in a discussion of paradigm integration.","- ""In David Schmidt's PhD work he explored the use of denotational semantics as a programming language.""
  - ""The semantics itself can be seen as a program and one may examine different programming styles and ways to represent states.""
  - ""Abstract interpretation is primarily a technique for derivation and specification of program analysis.""
  - ""As with denotational semantics we may also view abstract interpretations as programs and examine the implementation.""
  - ""The main focus in this paper is to show that results from higher-order strictness analysis may be used more generally as fixpoint operators for higher-order functions over lattices and thus provide a technique for immediate implementation of a large class of abstract interpretations.""
  - ""Furthermore, it may be seen as a programming paradigm and be used to write programs in a circular style.""",,"- The abstract discusses the use of denotational semantics and abstract interpretation as programming languages, which implies a focus on conceptual abstraction.
 - The mention of ""different programming styles and ways to represent states"" suggests an exploration of abstraction mechanisms.
 - The use of ""higher-order strictness analysis"" and ""fixpoint operators for higher-order functions over lattices"" indicates a focus on generic programming methodologies, as these are techniques that can be applied broadly across different programs.
 - The abstract does not explicitly mention ""minimal type requirements"" or ""static checking or optimization strategies,"" which are typically discussed in the context of generic programming.
 - The abstract does not provide a clear definition of ""concept"" or detailed mechanisms for representing generic abstractions, nor does it explicitly address type system discussions or abstraction mechanism explanations.","- ""The main focus in this paper is to show that results from higher-order strictness analysis may be used more generally as fixpoint operators for higher-order functions over lattices and thus provide a technique for immediate implementation of a large class of abstract interpretations.""
  - ""Furthermore, it may be seen as a programming paradigm and be used to write programs in a circular style.""",,"- The abstract mentions that the paper shows how results from higher-order strictness analysis can be used as fixpoint operators for higher-order functions over lattices. This suggests a novel application of existing techniques to a broader context, which is a theoretical advancement.
 - The use of these results as fixpoint operators provides a technique for the immediate implementation of a large class of abstract interpretations. This indicates a theoretical contribution by offering a new method for implementing abstract interpretations.
 - The abstract also suggests that this approach can be seen as a programming paradigm, allowing for the writing of programs in a circular style. This implies a potential implication for programming language design, as it introduces a new way of programming.
 - Overall, the novelty and theoretical contribution of the study lie in the application of higher-order strictness analysis to abstract interpretations and the introduction of a new programming paradigm."
A Formal Basis for the Perception of Programming as a Language Design Activity,"P. Bailes, T. Chorvat, I. Peake",-,-,-,3,1994,Not specified (the abstract discusses theoretical frameworks and programming principles but does not explicitly define conceptual primitives),Not specified (the abstract mentions denotational semantics but does not provide specific details about the mathematical framework characteristics),No specific integration approach described (the abstract discusses the integration of language design with functional programming but does not provide specific mechanisms or models),Generic programming not extensively addressed,"- Key novel insights: Recognizing language design as a valid programming paradigm.
 - Theoretical advancements: Pragmatic justification through matching usage patterns, formal justification through denotational semantics, and restructuring denotational equations to align with programming principles.
 - Potential implications: Development of CASE tools, emphasizing modularity and abstraction in language design.","- ""Then, when the denotational equations are restructured in better accord with these programming principles, it emerges that the semantics of a centrepiece of programmer activity declarations are evidently language extensions.""
  - ""Language design as incarnated in the production of a denotational semantics is evidently functional programming, with all the concerns for modularity and abstraction that should also be the concerns of applications programmers.""
  - ""The formal justification derives from an examination of denotational semantics.""
  - ""The pragmatic justification derives from matching the patterns of usage and quality assessment of programming languages on the one hand, with corresponding patterns for the output of the ‘‘programming’’ activity.""
  - ""Recognising language design as a valid programming paradigm should have widespread benefits e.g. for the development of CASE tools.""",,"- The abstract discusses the recognition of language design as a programming paradigm, which suggests a conceptual framework rather than specific primitives.
 - The pragmatic justification involves matching patterns of usage and quality assessment, but this does not explicitly define conceptual primitives.
 - The formal justification is based on denotational semantics, which is a theoretical framework, but again, no specific primitives are mentioned.
 - The mention of functional programming and concerns for modularity and abstraction suggests a focus on programming principles rather than specific conceptual primitives.
 - The restructuring of denotational equations to align with programming principles implies a methodological approach but does not specify conceptual primitives.","- ""Then, when the denotational equations are restructured in better accord with these programming principles, it emerges that the semantics of a centrepiece of programmer activity declarations are evidently language extensions.""
  - ""Language design as incarnated in the production of a denotational semantics is evidently functional programming, with all the concerns for modularity and abstraction that should also be the concerns of applications programmers.""
  - ""The formal justification derives from an examination of denotational semantics.""",,"- The abstract mentions the use of ""denotational semantics"" as the formal basis for justifying language design as a programming paradigm. This indicates that the mathematical framework used is related to denotational semantics.
 - Denotational semantics is a type of mathematical framework used in programming language theory to describe the meaning of programming languages. It is based on mathematical concepts such as functions and domains.
 - The abstract does not specify any particular type of mathematical framework like type theory or category theory, nor does it mention specific mathematical properties guaranteed or proof techniques used.
 - The focus on ""modularity and abstraction"" suggests that these are concerns within the framework, but it does not explicitly state them as mathematical properties.
 - The abstract does not discuss limitations or constraints of the framework.","- ""Then, when the denotational equations are restructured in better accord with these programming principles, it emerges that the semantics of a centrepiece of programmer activity declarations are evidently language extensions.""
  - ""Language design as incarnated in the production of a denotational semantics is evidently functional programming, with all the concerns for modularity and abstraction that should also be the concerns of applications programmers.""
  - ""The formal justification derives from an examination of denotational semantics.""
  - ""The pragmatic justification derives from matching the patterns of usage and quality assessment of programming languages on the one hand, with corresponding patterns for the output of the ‘‘programming’’ activity.""
  - ""Recognising language design as a valid programming paradigm should have widespread benefits e.g. for the development of CASE tools.""",,"- The abstract discusses the recognition of language design as a valid programming paradigm, which implies an integration of language design with other programming paradigms.
 - The pragmatic justification involves matching patterns of usage and quality assessment, suggesting a comparison or integration of different paradigms based on their usage and quality.
 - The formal justification through denotational semantics indicates a theoretical integration strategy, focusing on functional programming principles.
 - The restructuring of denotational equations to align with programming principles suggests a novel approach to integrating language design with functional programming.
 - However, the abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques beyond the general alignment with functional programming principles.","- ""it emerges that the semantics of a centrepiece of programmer activity declarations are evidently language extensions.""
  - ""Language design as incarnated in the production of a denotational semantics is evidently functional programming, with all the concerns for modularity and abstraction that should also be the concerns of applications programmers.""",,"- The abstract discusses language design as a programming paradigm, focusing on its formal justification through denotational semantics.
 - It mentions that language design is ""evidently functional programming,"" which implies a focus on modularity and abstraction, key concepts in generic programming.
 - The mention of ""modularity and abstraction"" suggests that these are concerns in the study, but it does not explicitly define these concepts or provide mechanisms for representing generic abstractions.
 - There is no specific mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies in the abstract.
 - The abstract does not explicitly address generic programming methodology or type system discussions, nor does it provide detailed explanations of abstraction mechanisms.","- ""Recognising language design as a valid programming paradigm should have widespread benefits e.g. for the development of CASE tools.""
  - ""Language design as incarnated in the production of a denotational semantics is evidently functional programming, with all the concerns for modularity and abstraction that should also be the concerns of applications programmers.""
  - ""The pragmatic justification derives from matching the patterns of usage and quality assessment of programming languages on the one hand, with corresponding patterns for the output of the ‘‘programming’’ activity.""
  - ""Then, when the denotational equations are restructured in better accord with these programming principles, it emerges that the semantics of a centrepiece of programmer activity declarations are evidently language extensions.""
  - ""The formal justification derives from an examination of denotational semantics.""",,"- The abstract suggests that recognizing language design as a valid programming paradigm is a novel insight, as it implies a shift in perspective on how programming is perceived and executed.
 - The pragmatic justification by matching usage and quality assessment patterns indicates a theoretical advancement in understanding the relationship between language design and programming activities.
 - The formal justification through denotational semantics provides a theoretical framework for understanding language design as functional programming, emphasizing modularity and abstraction.
 - The restructuring of denotational equations to align with programming principles and the identification of declarations as language extensions represent theoretical advancements in understanding the semantics of programming activities.
 - The potential implications for programming language design include the development of CASE tools, which suggests a practical application of these theoretical contributions."
Классификация парадигм программирования в контексте теоретического программирования,Ирина Андреевна Кудрявцева,-,-,-,0,2015,Not specified (the abstract does not provide explicit definitions or details about the conceptual primitives),Not specified (the abstract mentions mathematical subjects but does not specify a particular type of mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Classification of programming paradigms based on mathematical subjects (algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory).
 - Theoretical advancements: Emphasis on mathematical bases and programming languages, not technologies; shift towards functional programming paradigm.
 - Potential implications: Could influence understanding and design of programming languages by focusing on theoretical foundations.","- ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""The author presents a classification of programming paradigms in the context of theoretical programming, based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""
  - ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""",,"- The abstract mentions that the classification of programming paradigms is based on several mathematical subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, and automata theory. These subjects are likely the conceptual primitives used for the classification.
 - The abstract does not provide explicit definitions for these primitives, nor does it mention their level of abstraction or orthogonality.
 - The focus on mathematical bases and programming languages suggests that these are key components of the classification, but again, no specific definitions or scores for orthogonality are provided.
 - The abstract does not explicitly list or define any specific conceptual primitives beyond the mention of these mathematical subjects.","- ""classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""
  - ""based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""",,"- The abstract mentions several mathematical subjects that form the basis of the classification of programming paradigms: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, and automata theory. These subjects suggest a broad mathematical framework but do not specify a particular type of mathematical framework like type theory or category theory.
 - The classification is based on the level of mathematical bases and programming languages, indicating that the mathematical framework is used to formalize and understand these aspects.
 - The abstract does not provide specific details about the mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The emphasis on a functional programming paradigm suggests a focus on functional programming, but again, no specific mathematical framework characteristics are detailed.","- ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""
  - ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""The author presents a classification of programming paradigms in the context of theoretical programming, based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""",,"- The abstract discusses a classification of programming paradigms based on mathematical subjects, which suggests a focus on theoretical foundations rather than practical integration mechanisms.
 - There is no mention of specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques in the abstract.
 - The emphasis on a functional programming paradigm does not imply an integration approach but rather a shift in focus within theoretical programming.
 - The abstract does not provide any information on how different paradigms are integrated or interact with each other.","- ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""
  - ""The author presents a classification of programming paradigms in the context of theoretical programming, based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""",,"- The abstract discusses a classification of programming paradigms in the context of theoretical programming, focusing on mathematical bases and programming languages.
 - It mentions the emphasis on functional programming, which often involves generic programming and abstraction mechanisms.
 - However, the abstract does not explicitly mention ""genericity and abstraction mechanisms,"" nor does it provide details on the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The abstract does not contain a ""Generic programming methodology section,"" ""Type system discussions,"" or ""Abstraction mechanism explanations"" that would typically address these topics.","- ""The author presents a classification of programming paradigms in the context of theoretical programming, based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""
  - ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""",,"- The abstract mentions a classification of programming paradigms based on mathematical subjects, which suggests a novel approach to categorizing programming paradigms.
 - The classification is based on mathematical bases and programming languages, indicating a theoretical contribution by focusing on these foundational aspects rather than technologies.
 - The shift towards a functional programming paradigm is highlighted, which could imply a theoretical advancement in understanding the role of functional programming in theoretical programming contexts.
 - The abstract does not provide explicit details on how this classification or shift contributes to existing work or what implications it has for programming language design, but it suggests a theoretical contribution by emphasizing the shift towards functional programming."
Codata in Action,"P. Downen, Zachary J. Sullivan, Z. Ariola, S. Jones",10.1007/978-3-030-17184-1_5,https://doi.org/10.1007/978-3-030-17184-1_5,European Symposium on Programming,12,2019,"1. Primitive Name: Codata
  Definition: A general-purpose programming abstraction that bridges functional and object-oriented paradigms.
  Orthogonality Score: Not discussed
 2. Primitive Name: Procedural Abstraction
  Definition: Captured by codata through observation-based interfaces, message-passing, and dynamic dispatch.
  Orthogonality Score: Not discussed
 3. Primitive Name: Visitor Pattern
  Definition: A method for inter-compiling data to codata.
  Orthogonality Score: Not discussed
 4. Primitive Name: Tabulation
  Definition: A method for inter-compiling codata to data.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Existential quantification, Curry-Howard correspondence
 - Proof techniques used: Inter-compilation techniques, formal verification
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Use of codata as a common ground, visitor pattern for extending object-oriented languages with data types, and reduction of codata types to data types for functional languages.
 - Interaction models between paradigms: Compilation between data and codata types to integrate functional and object-oriented programming.
 - Constraints or challenges in paradigm integration: Manual delay or force of computations for correct semantics in different evaluation strategies.
 - Novel translation or embedding techniques: Visitor pattern and reduction of codata to data types for compilation.","- Definition of ""concept"" used: Not explicitly defined in the context of generic programming.
 - Mechanisms for representing generic abstractions: Observation-based interfaces, message-passing, dynamic dispatch, codata types, and indexed data/codata types.
 - Minimal type requirements identified: Polymorphic types and type indexes.
 - Static checking or optimization strategies: Use of GADTs and indexed codata types for static verification; visitor pattern and tabulation translation for inter-compilation.","- Novel insight: Codata as a general-purpose programming abstraction applicable across different paradigms and languages.
 - Theoretical advancement: Codata as a bridge between functional and object-oriented programming, providing a common ground.
 - Potential implications: Easy integration into existing languages, generalization to more expressive type systems, and clarification of programming language theory and practice.","- ""Our goal is to demonstrate the benefits of codata as a general-purpose programming abstraction independent of any specific language: eager or lazy, statically or dynamically typed, and functional or object-oriented.""
  - ""Codata is a bridge between the functional and object-oriented paradigms; a common denominator between the two very different approaches to programming.""
  - ""Codata can be used to solve other problems in programming besides representing infinite objects and processes like streams and servers""
  - ""Codata exactly captures the essence of procedural abstraction, as achieved with λ-abstractions and objects, with a logically founded formalism""
  - ""The combination of observation-based interfaces, message-passing, and dynamic dispatch are exactly the tools needed for procedural abstraction.""
  - ""Specifying a codata type is giving an interface-between an implementation and a client-so that instances of the type (implementations) can respond to requests (clients).""
  - ""The visitor pattern has the net effect of inverting the orientation of a data declaration (wherein construction comes first) into codata declarations (wherein destruction comes first).""
  - ""Data can be represented by codata via the visitor pattern (V). Codata can be represented by data by tabulating the possible answers of objects (T).""
  - ""The presented inter-compilation techniques are correct for the call-by-name semantics of the calculi.""",,"- The paper discusses codata as a general-purpose programming abstraction that bridges functional and object-oriented paradigms, indicating it as a conceptual primitive.
 - Codata is described as capturing procedural abstraction, which is a fundamental concept in programming.
 - The paper highlights the use of observation-based interfaces, message-passing, and dynamic dispatch as tools for procedural abstraction, suggesting these as conceptual primitives.
 - The visitor pattern and tabulation are mentioned as methods for inter-compiling data and codata, indicating these as conceptual primitives for reconstructing programming paradigms.
 - The paper does not explicitly list these as ""conceptual primitives,"" but they are central to the discussion of codata and its role in programming paradigms.","- ""Functional programming enjoys a beautiful connection to logic, known as the Curry-Howard correspondence, or proofs as programs principle [22]; results and notions about a language are translated to those about proofs, and vice-versa [17].""
  - ""The typing rules for modules are even more cryptic, but knowing that they correspond exactly to the rules for existential quantification certainly gives us more confidence that they are correct!""
  - ""The two-sided, interactive view appears all over the study of programming languages, where data is concerned about how values are constructed and codata is concerned about how they are used [15].""
  - ""In proof theory, codata has had an impact on theorem proving [5] and on the foundation of computation via polarity [29,45].""
  - ""The combination of observation-based interfaces, message-passing, and dynamic dispatch are exactly the tools needed for procedural abstraction.""
  - ""The extension of data types with indexes (a.k.a. generalized algebraic data types) has proven useful to statically verify a data structure's invariant, like for redblack trees [43].""
  - ""With indexed data types, the programmer can inform the static type system that a particular value of a data type satisfies some additional conditions by constraining the way in which it was constructed.""
  - ""In Sect. 2.1, we illustrated how to convert a data type representing trees into a codata type. This encoding corresponds to a rephrasing of the object-oriented visitor pattern to avoid unnecessary side-effects.""
  - ""We saw previously examples of using codata types to replicate well-known encodings of data types into the λ-calculus.""
  - ""We present the syntax and semantics of the base language and the two extensions λ data and λ codata""
  - ""The Base Language. We will base both our core languages of interest on a common starting point: the polymorphic λ-calculus as shown in Fig. 1 .2 This is the standard simply typed λ-calculus extended with impredicative polymorphism (a.k.a. generics).""
  - ""The presented inter-compilation techniques are correct for the call-by-name semantics of the calculi.""
  - ""The solution to this problem is straightforward: we must manually delay computations that are lifted out of (object or λ) abstractions, and manually force computations before their results are hidden underneath abstractions.""
  - ""In the world of types, we have so far only formally addressed inter-compilation between languages with simple and polymorphic types.""
  - ""It turns out some of the compilation techniques we have discussed so far extend to type indexes without further effort, whereas others need some extra help.""
  - ""The idea is that a constructor with a more specific return type can be replaced with a conventional constructor that is parameterized by type equalities that prove that the normal return type must be the more specific one.""",,"- The paper discusses the Curry-Howard correspondence, which is a fundamental connection between type theory and logic. This suggests that the mathematical framework is rooted in type theory.
 - The mention of existential quantification and its correspondence to typing rules indicates a focus on type theory and its application to programming languages.
 - The use of the polymorphic λ-calculus as a base language further supports the use of type theory as the mathematical framework.
 - The paper discusses the use of indexed data types and generalized algebraic data types, which are concepts within type theory that help in verifying invariants and properties.
 - The inter-compilation techniques and the focus on call-by-name semantics suggest a formal verification approach within the type theory framework.
 - The paper does not explicitly mention category theory or other mathematical frameworks, so it seems that type theory is the primary framework used.","- ""Our goal is to demonstrate the benefits of codata as a general-purpose programming abstraction independent of any specific language: eager or lazy, statically or dynamically typed, and functional or object-oriented.""
  - ""Codata is a bridge between the functional and object-oriented paradigms; a common denominator between the two very different approaches to programming.""
  - ""We believe codata is a common ground between the functional and object-oriented paradigms; ultimately, we hope to utilize the Curry-Howard isomorphism to further bridge the gap.""
  - ""While codata types can be seen in the shadows behind many examples of programming-often hand-compiled away by the programmer-not many functional languages have native support for them.""
  - ""To this end, we demonstrate a pair of simple compilation techniques between a typical core functional language (with data types) and one with codata.""
  - ""One direction-based on the well-known visitor pattern from object-oriented programming-simultaneously shows how to extend an object-oriented language with data types (as is done by Scala) and how to compile core functional programs to a more object-oriented setting (e.g. targeting a backend like JavaScript or the JVM).""
  - ""The other shows how to add native codata types to functional languages by reducing them to commonlysupported data types and how to compile a ""pure"" object-oriented style of programming to a functional setting.""
  - ""The presented inter-compilation techniques are correct for the call-by-name semantics of the calculi.""
  - ""The solution to this problem is straightforward: we must manually delay computations that are lifted out of (object or λ) abstractions, and manually force computations before their results are hidden underneath abstractions.""
  - ""Our work follows in spirit of Amin et al.'s [3] desire to provide a minimal theory that can model type parameterization, modules, objects and classes.""
  - ""This paper works toward the goal of providing common ground between the functional and object-oriented paradigms; as future work, we would like to extend the core with other features of full-fledged functional and objectoriented languages.""",,"- The paper discusses the integration of functional and object-oriented programming paradigms through the use of codata, which is presented as a common ground between these paradigms.
 - The authors propose two specific integration mechanisms: one based on the visitor pattern to extend object-oriented languages with data types and another to add native codata types to functional languages.
 - The interaction model involves compiling between data and codata types, allowing for the integration of functional and object-oriented programming styles.
 - Constraints or challenges include the need to manually delay or force computations to ensure correct semantics in different evaluation strategies.
 - Novel translation techniques include the use of the visitor pattern and the reduction of codata types to data types for compilation purposes.
 - The paper also mentions future work in extending the core with other features of full-fledged functional and object-oriented languages, indicating ongoing efforts in paradigm integration.","- ""The combination of observation-based interfaces, message-passing, and dynamic dispatch are exactly the tools needed for procedural abstraction.""
  - ""Specifying a codata type is giving an interface-between an implementation and a client-so that instances of the type (implementations) can respond to requests (clients).""
  - ""The extension of data types with indexes (a.k.a. generalized algebraic data types) has proven useful to statically verify a data structure's invariant, like for redblack trees""
  - ""indexed codata types are dual and allow the creator of an object to constrain the way it is going to be used, thereby adding pre-and post-conditions to the observations of the object.""
  - ""The presented inter-compilation techniques are correct for the call-by-name semantics of the calculi.""
  - ""the visitor-pattern-based translation V can just be applied straightforwardly to indexed data types:""
  - ""the tabulation translation T does not correctly capture the semantics of indexed codata types, if applied naïvely.""
  - ""The idea is that a constructor with a more specific return type can be replaced with a conventional constructor that is parameterized by type equalities that prove that the normal return type must be the more specific one.""
  - ""The same idea can be applied to indexed codata types as well.""
  - ""The supported backends include functional ones-Haskell (call-by-need, static types), OCaml (call-by-value, static types), and Racket (call-by-value, dynamic types)-as well as the object-oriented JavaScript.""",,"- The paper discusses procedural abstraction through observation-based interfaces, message-passing, and dynamic dispatch, which are mechanisms for representing generic abstractions.
 - The use of codata types and their interfaces is a key mechanism for abstraction, allowing for the specification of how objects respond to requests.
 - Indexed data and codata types are used for static verification of data structure invariants, indicating a focus on static checking.
 - The paper mentions the use of generalized algebraic data types (GADTs) and indexed codata types, which are related to generic programming.
 - The visitor pattern and tabulation translation are discussed as methods for inter-compilation between data and codata types, which are relevant to generic programming.
 - The paper does not explicitly define a ""concept"" in the context of generic programming, but it does discuss abstraction mechanisms and type systems.
 - The minimal type requirements are not explicitly stated, but the paper discusses the use of polymorphic types and type indexes.
 - Static checking is implied through the use of type indexes and GADTs, but specific optimization strategies are not detailed.","- ""Our goal is to demonstrate the benefits of codata as a general-purpose programming abstraction independent of any specific language: eager or lazy, statically or dynamically typed, and functional or object-oriented.""
  - ""We believe codata is a common ground between the functional and object-oriented paradigms; ultimately, we hope to utilize the Curry-Howard isomorphism to further bridge the gap.""
  - ""Our claim is that codata is a universal programming feature that has been thus-far missing or diminished in today's functional programming languages.""
  - ""Fortunately, it is easy for most mainstream languages to add or bring out codata today without a radical change to their implementation.""
  - ""To conclude, we show how the languages and encodings can be generalized to more expressive type systems, which include features like existential types and indexed types (a.k.a. generalized algebraic data types and guarded methods).""
  - ""We have shown here how codata can be put to use to capture several practical programming idioms and applications, besides just modeling infinite structures.""
  - ""This paper works toward the goal of providing common ground between the functional and object-oriented paradigms; as future work, we would like to extend the core with other features of full-fledged functional and objectoriented languages.""
  - ""A better understanding of codata clarifies both the theory and practice of programming languages.""",,"- The paper introduces codata as a general-purpose programming abstraction that can be applied across different programming paradigms and languages, which is a novel insight.
 - It highlights codata as a bridge between functional and object-oriented programming, which is a theoretical advancement beyond existing approaches that often focus on one paradigm.
 - The paper demonstrates how codata can be easily integrated into existing languages without significant changes, which has implications for programming language design by providing a common ground for different paradigms.
 - The generalization of codata to more expressive type systems, such as those with existential and indexed types, is a theoretical contribution that expands the applicability of codata.
 - The paper's focus on using codata to capture practical programming idioms beyond just infinite structures is a novel application of codata, showing its versatility.
 - The potential for codata to clarify both the theory and practice of programming languages suggests a deeper theoretical contribution to the field."
Common sense for concurrency and strong paraconsistency using unstratified inference and reflection,C. Hewitt,-,-,arXiv.org,8,2008,"1. Primitive Name: Direct Logic
  Definition: A strongly paraconsistent formalism that incorporates the mathematics of Computer Science and allows unstratified inference and reflection.
  Orthogonality Score: Not specified
 2. Primitive Name: Unstratified Inference
  Definition: Allows for inference without stratification.
  Orthogonality Score: Not specified
 3. Primitive Name: Mutual Reflection
  Definition: Enables reflection among code, documentation, and use cases.
  Orthogonality Score: Not specified
 4. Primitive Name: ActorScript
  Definition: A concurrent programming language defined meta-circularly.
  Orthogonality Score: Not specified","- Type of mathematical framework: Paraconsistent logic
 - Specific mathematical properties guaranteed: Strongly paraconsistent theory is self-provably incomplete; semi-classical mathematical fragment is consistent but reflective theories are self-provably inconsistent
 - Proof techniques used: Mathematical induction
 - Limitations or constraints of the framework: Overcomes traditional Tarskian framework limitations; Logic Programming is not computationally universal within Direct Logic",No specific integration approach described,Generic programming not extensively addressed,"- Development of Direct Logic, a strongly paraconsistent formalism that allows unstratified inference and reflection.
 - Overcoming limitations of the Tarskian framework by enabling mutual reflection among inconsistent elements.
 - Generalization of the Godel/Rosser incompleteness theorem to show that strongly paraconsistent theories are self-provably incomplete.
 - Demonstration that Logic Programming is not computationally universal.
 - Introduction of ActorScript, a meta-circularly defined concurrent programming language suitable for massive concurrency.","- ""This paper also proves that Logic Programming is not computationally universal in that there are concurrent programs for which there is no equivalent in Direct Logic.""
  - ""Direct Logic allows mutual reflection among the mutually chock full of inconsistencies code, documentation, and use cases of large software systems thereby overcoming the limitations of the traditional Tarskian framework of stratified metatheories.""
  - ""This paper develops a strongly paraconsistent formalism (called Direct Logic™) that incorporates the mathematics of Computer Science and allows unstratified inference and reflection using mathematical induction for almost all of classical logic to be used.""
  - ""Thus the paper defines a concurrent programming language ActorScript™ (that is suitable for expressing massive concurrency in large software systems) meta-circularly in terms of itself.""
  - ""This paper proves a generalization of the Godel/Rosser incompleteness theorem: a strongly paraconsistent theory is self-provably incomplete.""",,"- The abstract mentions the development of ""Direct Logic,"" which is described as a ""strongly paraconsistent formalism."" This suggests that Direct Logic is a conceptual primitive, as it is a foundational framework for the study.
 - The abstract discusses the ability of Direct Logic to allow ""unstratified inference and reflection,"" which implies that these are conceptual primitives within the framework of Direct Logic.
 - The mention of ""mutual reflection among the mutually chock full of inconsistencies code, documentation, and use cases"" suggests that these elements are also conceptual primitives, as they are integral to the functionality of Direct Logic.
 - The abstract introduces ""ActorScript,"" a concurrent programming language defined meta-circularly, which could be considered a conceptual primitive in the context of programming paradigms.
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality or level of abstraction in detail.","- ""This paper develops a strongly paraconsistent formalism (called Direct Logic™)""
  - ""incorporates the mathematics of Computer Science and allows unstratified inference and reflection using mathematical induction for almost all of classical logic to be used.""
  - ""overcoming the limitations of the traditional Tarskian framework of stratified metatheories.""
  - ""proves a generalization of the Godel/Rosser incompleteness theorem: a strongly paraconsistent theory is self-provably incomplete.""
  - ""Although the semi-classical mathematical fragment of Direct Logic is evidently consistent, since the Godelian paradoxical proposition is self-provable, every reflective strongly paraconsistent theory in Direct Logic is self-provably inconsistent!""
  - ""proves that Logic Programming is not computationally universal in that there are concurrent programs for which there is no equivalent in Direct Logic.""",,"- The abstract mentions the development of a ""strongly paraconsistent formalism"" called Direct Logic, which suggests that the mathematical framework is based on paraconsistent logic.
 - The framework incorporates ""the mathematics of Computer Science"" and uses ""unstratified inference and reflection using mathematical induction,"" indicating a focus on computational aspects and mathematical induction as a proof technique.
 - The mention of overcoming the ""traditional Tarskian framework of stratified metatheories"" implies that Direct Logic addresses limitations in traditional logical frameworks by allowing for unstratified inference.
 - The abstract discusses the generalization of the Godel/Rosser incompleteness theorem, which is a mathematical property guaranteed by the framework, specifically that a strongly paraconsistent theory is self-provably incomplete.
 - The framework is described as having a ""semi-classical mathematical fragment"" that is consistent, but reflective theories within it are self-provably inconsistent, highlighting a specific mathematical property.
 - The abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) or specific limitations or constraints beyond the incompleteness theorem.","- ""This paper also proves that Logic Programming is not computationally universal in that there are concurrent programs for which there is no equivalent in Direct Logic.""
  - ""Thus the paper defines a concurrent programming language ActorScript™ (that is suitable for expressing massive concurrency in large software systems) meta-circularly in terms of itself.""
  - ""Consequently the Logic Programming paradigm is strictly less general than the Procedural Embedding of Knowledge paradigm.""
  - ""Direct Logic allows mutual reflection among the mutually chock full of inconsistencies code, documentation, and use cases of large software systems thereby overcoming the limitations of the traditional Tarskian framework of stratified metatheories.""",,"- The abstract discusses the integration of different programming paradigms by mentioning that Direct Logic allows for mutual reflection among code, documentation, and use cases, which suggests a mechanism for integrating different components of software systems.
 - It highlights that Logic Programming is not computationally universal compared to Direct Logic, indicating a comparison between paradigms but not a specific integration mechanism.
 - The abstract states that the Logic Programming paradigm is less general than the Procedural Embedding of Knowledge paradigm, which implies a comparison rather than an integration strategy.
 - The definition of ActorScript as a concurrent programming language that is meta-circularly defined suggests a novel approach to expressing concurrency, but it does not explicitly describe an integration approach between different paradigms.","- ""This paper also proves that Logic Programming is not computationally universal in that there are concurrent programs for which there is no equivalent in Direct Logic.""
  - ""Thus the paper defines a concurrent programming language ActorScript™ (that is suitable for expressing massive concurrency in large software systems) meta-circularly in terms of itself.""
  - ""Direct Logic allows mutual reflection among the mutually chock full of inconsistencies code, documentation, and use cases of large software systems thereby overcoming the limitations of the traditional Tarskian framework of stratified metatheories.""
  - ""This paper develops a strongly paraconsistent formalism (called Direct Logic™) that incorporates the mathematics of Computer Science and allows unstratified inference and reflection using mathematical induction for almost all of classical logic to be used.""",,"- The abstract discusses the development of Direct Logic, a formalism that allows for unstratified inference and reflection, which suggests a focus on logical and computational aspects rather than generic programming.
 - The mention of ""unstratified inference and reflection"" and ""mutual reflection"" indicates a focus on handling inconsistencies and complex systems, but does not directly address generic programming or abstraction mechanisms.
 - The abstract does not provide any specific information about generic programming methodology, type systems, or abstraction mechanisms.
 - The focus on proving the limitations of Logic Programming and defining ActorScript does not imply a focus on generic programming or abstraction mechanisms.
 - The abstract does not mention any specific mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.","- ""This paper develops a strongly paraconsistent formalism (called Direct Logic™) that incorporates the mathematics of Computer Science and allows unstratified inference and reflection using mathematical induction for almost all of classical logic to be used.""
  - ""Direct Logic allows mutual reflection among the mutually chock full of inconsistencies code, documentation, and use cases of large software systems thereby overcoming the limitations of the traditional Tarskian framework of stratified metatheories.""
  - ""This paper proves a generalization of the Godel/Rosser incompleteness theorem: a strongly paraconsistent theory is self-provably incomplete.""
  - ""Although the semi-classical mathematical fragment of Direct Logic is evidently consistent, since the Godelian paradoxical proposition is self-provable, every reflective strongly paraconsistent theory in Direct Logic is self-provably inconsistent!""
  - ""This paper also proves that Logic Programming is not computationally universal in that there are concurrent programs for which there is no equivalent in Direct Logic.""
  - ""Consequently the Logic Programming paradigm is strictly less general than the Procedural Embedding of Knowledge paradigm.""
  - ""Thus the paper defines a concurrent programming language ActorScript™ (that is suitable for expressing massive concurrency in large software systems) meta-circularly in terms of itself.""",,"- The abstract introduces a novel formalism called Direct Logic, which is a strongly paraconsistent system. This is a key theoretical contribution as it allows for unstratified inference and reflection, which is a departure from traditional stratified metatheories.
 - Direct Logic overcomes the limitations of the Tarskian framework by enabling mutual reflection among inconsistent elements, which is a significant theoretical advancement.
 - The paper provides a generalization of the Godel/Rosser incompleteness theorem, showing that a strongly paraconsistent theory is self-provably incomplete. This is a novel insight into the nature of paraconsistent theories.
 - The abstract also highlights that every reflective strongly paraconsistent theory in Direct Logic is self-provably inconsistent, which has implications for understanding the limits of such theories.
 - The paper demonstrates that Logic Programming is not computationally universal, which is a theoretical contribution that challenges existing paradigms.
 - The introduction of ActorScript as a concurrent programming language that is meta-circularly defined is another theoretical innovation, as it provides a new approach to expressing concurrency in software systems."
A new task paradigm for reusability,"J. Leathrum, Joyce L. Tokar",-,-,-,0,1988,Not specified (the abstract does not provide explicit names or definitions for the conceptual primitives),Not specified,"- Specific integration mechanisms proposed: Unification of process models by removing syntactic details and generalizing functional details.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Production of an Interface Description Language (IDL) representation.","- Definition of ""concept"" used: Abstract process model
 - Mechanisms for representing generic abstractions: Interface Description Language (IDL) representation
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: Identification of an underlying unification of process models in concurrent programming languages.
 - Theoretical advancements: Unified model enables reuse of concurrent specifications by abstracting away syntactic details and generalizing functional details.
 - Potential implications: Standardized IDL representation could influence programming language design by promoting interoperability and reusability.","- ""The primary thesis of this research is that there exists an underlying unification of the various process models used in concurrent programming languages which forms a basis for developing an abstract process model.""
  - ""A secondary thesis of this research is that reuse of concurrent specifications is made possible by providing the unified model.""
  - ""In developing our model we remove the syntactic details which distinguish the various concurrent languages and we generalize the functional details of generating and coordinating concurrent processes.""
  - ""Simultaneously, we produce an Interface Description Language (IDL) representation of our model to be employed in the production of reusable concurrent specifications.""",,"- The abstract discusses the development of an ""abstract process model"" which suggests a high level of abstraction.
 - The process of removing syntactic details and generalizing functional details implies a focus on conceptual primitives that are orthogonal to specific language syntax.
 - The mention of an ""Interface Description Language (IDL) representation"" suggests that the primitives might be related to interface description, but no specific primitives are explicitly listed or defined in the abstract.
 - The abstract does not provide explicit names or definitions for the conceptual primitives, nor does it discuss their orthogonality score.","- ""We provide several classical concurrent programming examples which verify our theses.""
  - ""Simultaneously, we produce an Interface Description Language (IDL) representation of our model to be employed in the production of reusable concurrent specifications.""
  - ""In developing our model we remove the syntactic details which distinguish the various concurrent languages and we generalize the functional details of generating and coordinating concurrent processes.""
  - ""A secondary thesis of this research is that reuse of concurrent specifications is made possible by providing the unified model.""
  - ""The primary thesis of this research is that there exists an underlying unification of the various process models used in concurrent programming languages which forms a basis for developing an abstract process model.""",,"- The abstract discusses the development of an abstract process model and its application in reusing concurrent specifications, but it does not mention any specific mathematical framework used to formalize or guarantee properties of the conceptual primitives.
 - There is no mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract.
 - The focus is on the unification of process models and the use of an Interface Description Language (IDL) for reusable specifications, but no mathematical framework is explicitly described.
 - The abstract does not provide details on the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""A secondary thesis of this research is that reuse of concurrent specifications is made possible by providing the unified model.""
  - ""Simultaneously, we produce an Interface Description Language (IDL) representation of our model to be employed in the production of reusable concurrent specifications.""
  - ""In developing our model we remove the syntactic details which distinguish the various concurrent languages and we generalize the functional details of generating and coordinating concurrent processes.""
  - ""The primary thesis of this research is that there exists an underlying unification of the various process models used in concurrent programming languages which forms a basis for developing an abstract process model.""",,"- The abstract discusses the unification of various process models in concurrent programming languages, which suggests an integration approach by identifying commonalities across different models.
 - The removal of syntactic details and generalization of functional details indicate a mechanism for integrating different programming paradigms by focusing on common functional aspects rather than language-specific syntax.
 - The production of an Interface Description Language (IDL) representation is a novel technique for embedding or translating between paradigms, as it provides a standardized interface for different concurrent specifications.
 - The abstract does not explicitly mention interaction models between paradigms or specific constraints or challenges in paradigm integration, but it implies a theoretical integration strategy by unifying process models.","- ""The primary thesis of this research is that there exists an underlying unification of the various process models used in concurrent programming languages which forms a basis for developing an abstract process model.""
  - ""In developing our model we remove the syntactic details which distinguish the various concurrent languages and we generalize the functional details of generating and coordinating concurrent processes.""
  - ""A secondary thesis of this research is that reuse of concurrent specifications is made possible by providing the unified model.""
  - ""Simultaneously, we produce an Interface Description Language (IDL) representation of our model to be employed in the production of reusable concurrent specifications.""",,"- The abstract discusses the development of an ""abstract process model"" which suggests a focus on abstraction mechanisms. This is relevant to conceptual abstraction.
 - The removal of syntactic details and generalization of functional details indicate a process of abstraction, which is a key aspect of generic programming.
 - The use of an Interface Description Language (IDL) representation suggests a mechanism for representing generic abstractions, as IDLs are often used to define interfaces that can be implemented by multiple components.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, which are typically discussed in the context of type systems and generic programming methodologies.
 - The focus on unification and reuse implies a generic programming approach, but the abstract does not provide detailed information on type systems or specific strategies for static checking or optimization.","- ""The primary thesis of this research is that there exists an underlying unification of the various process models used in concurrent programming languages which forms a basis for developing an abstract process model.""
  - ""Simultaneously, we produce an Interface Description Language (IDL) representation of our model to be employed in the production of reusable concurrent specifications.""
  - ""In developing our model we remove the syntactic details which distinguish the various concurrent languages and we generalize the functional details of generating and coordinating concurrent processes.""
  - ""A secondary thesis of this research is that reuse of concurrent specifications is made possible by providing the unified model.""
  - ""We provide several classical concurrent programming examples which verify our theses.""",,"- The primary novelty of this research is the identification of an underlying unification of process models in concurrent programming languages, which suggests a theoretical contribution by proposing a unified framework that transcends individual language specifics.
 - The secondary thesis indicates that this unified model enables the reuse of concurrent specifications, which is a significant theoretical advancement as it addresses a common challenge in concurrent programming: the lack of reusability across different languages.
 - The process of removing syntactic details and generalizing functional details implies a theoretical contribution by abstracting away from specific language implementations, focusing on the core principles of concurrent process management.
 - The development of an IDL representation of the model further supports the theoretical contribution by providing a standardized interface for reusable specifications, which could influence programming language design by promoting interoperability and reusability.
 - The verification of these theses through classical examples suggests that the theoretical contributions are grounded in practical applications, reinforcing their potential impact on programming language design and concurrent programming practices."
Constraint imperative programming,B. Freeman-Benson,-,-,-,30,1992,"1. Primitive Name: Explicit control flow
  Definition: Taken from the imperative paradigm
  Orthogonality Score: Not specified
 2. Primitive Name: Destructive assignment
  Definition: Taken from the imperative paradigm
  Orthogonality Score: Not specified
 3. Primitive Name: Explicit, system-maintained constraints
  Definition: Taken from the declarative paradigm; refers to data relations
  Orthogonality Score: Not specified",Not specified (the abstract does not provide explicit details about the mathematical framework used),"- Specific integration mechanisms proposed: Integration of explicit control flow and destructive assignment from the imperative paradigm, and explicit, system-maintained constraints from the declarative paradigm.
 - Interaction models between paradigms: Combination of features to allow each concept to be expressed in the most suitable paradigm.
 - Constraints or challenges in paradigm integration: Clean, well-defined semantics and reasonable efficiency in implementation.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Integration of imperative and declarative paradigms in Constraint Imperative Programming.
 - Theoretical advancements: Clean, well-defined semantics; more expressive than purely imperative or purely constraint languages.
 - Potential implications: More flexible and expressive programming languages; allows concepts to be expressed in the most suitable paradigm.","- ""Explicit control flow and destructive assignment are taken from the imperative paradigm.""
  - ""Explicit, system-maintained constraints (i.e., data relations) are taken from the declarative paradigm.""",,"- The abstract mentions two key features that are integrated into the Constraint Imperative Programming framework: ""Explicit control flow and destructive assignment"" from the imperative paradigm, and ""Explicit, system-maintained constraints (i.e., data relations)"" from the declarative paradigm.
 - These features can be considered as conceptual primitives because they are fundamental elements that are being integrated to form a new programming language framework.
 - The abstract does not provide a detailed definition of these primitives beyond their origin in the respective paradigms, nor does it discuss their orthogonality or level of abstraction explicitly.
 - The abstract does not mention any other conceptual primitives beyond these two.","- ""This dissertation includes a semantic definition of Constraint imperative Programming (CIP), a discussion of the design issues for CIP languages, and a proof-of-concept implementation: Kaleidoscope 90.""
  - ""This dissertation claims that this integrated framework has a clean, well-defined semantics, and that languages in this framework can be implemented with reasonable efficiency.""
  - ""This dissertation presents an integration of specific features from the imperative and declarative paradigms in a new programming language framework: Constraint Imperative Programming.""",,"- The abstract mentions the integration of imperative and declarative paradigms into a new framework called Constraint Imperative Programming (CIP), which suggests a focus on programming language design rather than a specific mathematical framework.
 - The mention of ""clean, well-defined semantics"" implies some level of formalization, but it does not specify the type of mathematical framework used.
 - The abstract includes a ""semantic definition of Constraint imperative Programming (CIP),"" which could imply some form of mathematical formalization, but again, it does not specify the type of framework.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.
 - The abstract does not provide explicit details about the mathematical framework used to formalize and guarantee properties of the conceptual primitives.","- ""This dissertation presents an integration of specific features from the imperative and declarative paradigms in a new programming language framework: Constraint Imperative Programming.""
  - ""Explicit control flow and destructive assignment are taken from the imperative paradigm.""
  - ""Explicit, system-maintained constraints (i.e., data relations) are taken from the declarative paradigm.""
  - ""This dissertation claims that this integrated framework has a clean, well-defined semantics, and that languages in this framework can be implemented with reasonable efficiency.""
  - ""This dissertation further claims that these languages are more expressive than purely imperative or purely constraint languages, because they allow each concept to be expressed in whichever fundamental paradigm is most suitable, rather than forcing them all into a single paradigm.""
  - ""This dissertation includes a semantic definition of Constraint imperative Programming (CIP), a discussion of the design issues for CIP languages, and a proof-of-concept implementation: Kaleidoscope 90.""",,"- The abstract describes the integration of features from both imperative and declarative paradigms into a new framework called Constraint Imperative Programming (CIP).
 - Specific integration mechanisms include taking explicit control flow and destructive assignment from the imperative paradigm and explicit, system-maintained constraints from the declarative paradigm.
 - The interaction model between paradigms is implied by the combination of these features, allowing for a more expressive language that can utilize the most suitable paradigm for each concept.
 - The abstract mentions that the integrated framework has a clean, well-defined semantics and can be implemented with reasonable efficiency, suggesting that these are constraints or challenges addressed in the integration.
 - There is no explicit mention of novel translation or embedding techniques in the abstract.","- ""This dissertation presents an integration of specific features from the imperative and declarative paradigms in a new programming language framework: Constraint Imperative Programming.""
  - ""Explicit control flow and destructive assignment are taken from the imperative paradigm.""
  - ""Explicit, system-maintained constraints (i.e., data relations) are taken from the declarative paradigm.""
  - ""This dissertation claims that this integrated framework has a clean, well-defined semantics, and that languages in this framework can be implemented with reasonable efficiency.""
  - ""This dissertation further claims that these languages are more expressive than purely imperative or purely constraint languages, because they allow each concept to be expressed in whichever fundamental paradigm is most suitable, rather than forcing them all into a single paradigm.""
  - ""This dissertation includes a semantic definition of Constraint imperative Programming (CIP), a discussion of the design issues for CIP languages, and a proof-of-concept implementation: Kaleidoscope 90.""",,"- The abstract discusses the integration of imperative and declarative paradigms, focusing on the combination of explicit control flow and system-maintained constraints.
 - It mentions that the framework allows concepts to be expressed in the most suitable paradigm, which implies a form of abstraction.
 - However, there is no specific mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract.
 - The abstract does not provide details on mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The focus is on the integration of paradigms and the expressiveness of the language, rather than on generic programming or abstraction mechanisms.","- ""This dissertation presents an integration of specific features from the imperative and declarative paradigms in a new programming language framework: Constraint Imperative Programming.""
  - ""Explicit control flow and destructive assignment are taken from the imperative paradigm.""
  - ""Explicit, system-maintained constraints (i.e., data relations) are taken from the declarative paradigm.""
  - ""This dissertation claims that this integrated framework has a clean, well-defined semantics, and that languages in this framework can be implemented with reasonable efficiency.""
  - ""This dissertation further claims that these languages are more expressive than purely imperative or purely constraint languages, because they allow each concept to be expressed in whichever fundamental paradigm is most suitable, rather than forcing them all into a single paradigm.""
  - ""This dissertation includes a semantic definition of Constraint imperative Programming (CIP), a discussion of the design issues for CIP languages, and a proof-of-concept implementation: Kaleidoscope 90.""",,"- The abstract introduces a new programming language framework called ""Constraint Imperative Programming,"" which integrates features from both imperative and declarative paradigms. This integration is a novel insight as it combines the strengths of both paradigms.
 - The integration of explicit control flow and destructive assignment from the imperative paradigm with explicit, system-maintained constraints from the declarative paradigm is a theoretical advancement. It allows for a more flexible and expressive programming language.
 - The claim that this framework has a ""clean, well-defined semantics"" suggests a theoretical contribution in terms of providing a clear and consistent foundation for programming languages.
 - The assertion that languages in this framework are more expressive than purely imperative or purely constraint languages indicates a theoretical advancement in terms of expressiveness and flexibility.
 - The inclusion of a semantic definition and discussion of design issues for CIP languages further supports the theoretical contribution by providing a structured approach to understanding and implementing this framework."
A Sorted Semantic Framework for Applied Process Calculi,"Johannes Borgström, Ramunas Gutkovas, J. Parrow, B. Victor, Johannes Åman Pohjola",10.2168/LMCS-12(1:8)2016,https://doi.org/10.2168/LMCS-12(1:8)2016,Log. Methods Comput. Sci.,13,2013,"1. Primitive Name: Pattern Matching
  Definition: A function match that takes a term N, a sequence of names x, and a pattern X, returning a set of sequences of terms.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Sorting
  Definition: A user-defined sort system on names, terms, and patterns, with an equivariant sorting function and compatibility predicates.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Formal verification using Nominal Isabelle, likely involving type theory or similar formal systems.
 - Specific mathematical properties guaranteed: Strong bisimulation, preservation of well-formedness.
 - Proof techniques used: Machine-checked proofs using Nominal Isabelle.
 - Limitations or constraints of the framework: Limited to calculi with a single name sort for machine-checked proofs.","- Specific integration mechanisms proposed: Unified framework to represent different process calculi.
 - Interaction models between paradigms: Accommodating various existing process calculi.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Strong criteria for representation, stronger than standard encoding correspondences.","- Definition of ""concept"" used: A unified framework for representing different process calculi and notions of computation.
 - Mechanisms for representing generic abstractions: Novel abstract patterns and pattern matching, user-defined sort system, well-sorted substitutions.
 - Minimal type requirements identified: Well-sorted substitutions to avoid ""junk"" terms.
 - Static checking or optimization strategies: Machine-checked proofs in Isabelle.","- Novel framework unifying different process calculi
 - Extension of psi-calculi with abstract patterns and pattern matching
 - Addition of sorts to ensure subject reduction and well-formedness
 - Accommodation of existing process calculi with isomorphic transition systems
 - Machine-checked proofs in Nominal Isabelle for theoretical rigor
 - Stronger criteria for representation than standard encoding correspondences
 - Demonstration of various notions of computation for programming language design","- ""Our goal is a unified framework to represent different process calculi and notions of computation.""
  - ""we extend our previous work on psi-calculi with novel abstract patterns and pattern matching, and add sorts to the data term language, giving sufficient criteria for subject reduction to hold.""
  - ""The generalized pattern matching is a new contribution that holds general interest; here it allows us to directly capture computation on data in advanced process calculi, without elaborate encodings.""
  - ""we admit a user-defined sort system on names, terms and patterns. Substitutions are only well-defined if they conform to the sorting discipline.""
  - ""The psi-calculus parameters for pattern-matching include the nominal data type X of (input) patterns, ranged over by X, Y , and the two equivariant operators match : T × N * × X → P fin (T * ) Pattern matching vars : X → P fin (P fin (N)) Pattern variables""
  - ""The psi-calculus parameters for sorting include the equivariant sorting function sort : N⊎T⊎X → S, and the four compatibility predicates ∝ ⊆ S × S can be used to receive, ∝ ⊆ S × S can be used to send, ⊆ S × S can be substituted by, S ν ⊆ S N can be bound by name restriction.""
  - ""The agents, ranged over by P, Q, . . ., are of the following forms.""",,"- The paper introduces a unified framework for representing different process calculi, which suggests the use of conceptual primitives to achieve this goal.
 - The extension of psi-calculi with novel abstract patterns and pattern matching indicates a focus on pattern matching as a primitive.
 - The addition of sorts to the data term language and the emphasis on a user-defined sort system suggest that sorting is another primitive.
 - The paper defines specific parameters for pattern matching and sorting, which are likely the conceptual primitives used in the framework.
 - The agents are defined in terms of these primitives, indicating their role in constructing the framework.","- ""Our goal is a unified framework to represent different process calculi and notions of computation.""
  - ""Our framework can accommodate several existing process calculi; the resulting transition systems are isomorphic to the originals up to strong bisimulation.""
  - ""Substantial parts of the meta-theory of sorted psi-calculi have been machine-checked using Nominal Isabelle.""
  - ""The proof scripts are adapted from Bengtson's formalisation of psi calculi [Ben10]. The same technical lemmas hold and the proof scripts are essentially identical, save for the input cases of inductive proofs, a more detailed treatment of structural congruence, and the addition of sorts and compatibility relations.""
  - ""Isabelle is an LCF-style theorem prover, where the only trusted component is a small kernel that implements the inference rules of the logic and checks that they are correctly applied.""
  - ""The meta-theoretic results carry over from the original psi formulations, and have been machine-checked in Isabelle for the case of a single name sort""",,"- The paper discusses a unified framework for representing different process calculi, indicating a focus on a theoretical foundation for process calculi.
 - The use of Nominal Isabelle for machine-checking parts of the meta-theory suggests that the mathematical framework involves formal verification techniques, specifically using theorem proving.
 - The mention of ""sorted psi-calculi"" and ""strong bisimulation"" implies that the framework is based on process calculi theory, which is a branch of theoretical computer science.
 - The adaptation of proof scripts from Bengtson's formalization and the use of Isabelle indicate that the framework relies on formal proof techniques, likely involving type theory or similar formal systems.
 - The paper does not explicitly mention a specific mathematical framework like type theory or category theory, but the use of Isabelle and formal verification suggests a formal system akin to type theory.","- ""Our goal is a unified framework to represent different process calculi and notions of computation.""
  - ""Our framework can accommodate several existing process calculi; the resulting transition systems are isomorphic to the originals up to strong bisimulation.""
  - ""We evaluate our framework by providing instances that correspond to standard calculi, and instances that use several different notions of computation.""
  - ""We define strong criteria for a psi-calculus to represent another process calculus, meaning that they are for all practical purposes one and the same.""
  - ""A representation is significantly stronger than standard correspondences, such as the approach to encodability proposed by Gorla""
  - ""We establish that our formulations enjoy a strong operational correspondence with the original calculus, under trivial mappings that merely specialise the original concrete syntax""",,"- The paper discusses a unified framework for representing different process calculi, which implies an integration approach.
 - The framework accommodates various existing process calculi, suggesting a mechanism for integrating different paradigms.
 - The paper mentions strong criteria for representation, which are stronger than standard encoding correspondences, indicating a novel translation or embedding technique.
 - The framework provides instances that correspond to standard calculi, showing interaction models between paradigms.
 - The paper does not explicitly mention constraints or challenges in paradigm integration, but the focus on strong operational correspondence suggests a theoretical integration strategy.","- ""Our goal is a unified framework to represent different process calculi and notions of computation.""
  - ""we extend our previous work on psi-calculi with novel abstract patterns and pattern matching, and add sorts to the data term language, giving sufficient criteria for subject reduction to hold.""
  - ""Our framework can accommodate several existing process calculi; the resulting transition systems are isomorphic to the originals up to strong bisimulation.""
  - ""we introduce a novel generalization of pattern matching, decoupled from the definition of substitution, and add sorts for data terms and names.""
  - ""The generalized pattern matching is a new contribution that holds general interest; here it allows us to directly capture computation on data in advanced process calculi, without elaborate encodings.""
  - ""We evaluate our framework by providing instances that correspond to standard calculi, and instances that use several different notions of computation.""
  - ""We define strong criteria for a psi-calculus to represent another process calculus, meaning that they are for all practical purposes one and the same.""
  - ""Representation is stronger than the standard encoding correspondences e.g. by Gorla [Gor10], which define criteria for one language to encode the behaviour of another.""
  - ""The representations that we provide of other standard calculi advance our previous work, where we had to resort to nontrivial encodings with an unclear formal correspondence to the source calculus.""
  - ""To represent such calculi, we admit a user-defined sort system on names, terms and patterns. Substitutions are only well-defined if they conform to the sorting discipline.""
  - ""The restriction to well-sorted substitution also allows to avoid ""junk"": terms that exist solely to make substitutions total.""
  - ""We obtain criteria that ensure that wellformedness is preserved by transitions, and apply these to the original psi-calculi [BJPV11] (Theorem 2.7) and to pattern-matching spi calculus [HJ06] (Lemma 5.3).""
  - ""The meta-theoretic results carry over from the original psi formulations, and have been machine-checked in Isabelle for the case of a single name sort (e.g. the calculi PPI, LINDA and PSPI in Section 4, and the calculi PMSPI and NDLAM in Section 5).""
  - ""We have also added sorts to an existing tool for psi-calculi [BGRV15], the Psi-calculi Workbench (Pwb), which provides an interactive simulator and automatic bisimulation checker.""
  - ""Users of the tool need only implement the parameters of their psi-calculus instances, supported by a core library.""
  - ""In the tool we currently support only tuple patterns, similarly to the PPI calculus of Section 4.1.""",,"- The paper discusses a unified framework for representing different process calculi, which implies a focus on generic programming and abstraction.
 - The introduction of novel abstract patterns and pattern matching, along with the addition of sorts to the data term language, suggests mechanisms for representing generic abstractions.
 - The framework accommodates various existing process calculi, indicating a high level of genericity and abstraction.
 - The use of a user-defined sort system and well-sorted substitutions suggests minimal type requirements for ensuring well-formedness and avoiding ""junk"" terms.
 - The paper mentions machine-checked proofs in Isabelle, which could imply static checking or optimization strategies.
 - The Psi-calculi Workbench tool supports implementing parameters for psi-calculus instances, which suggests a mechanism for abstraction and generic programming.","- ""Our goal is a unified framework to represent different process calculi and notions of computation.""
  - ""we extend our previous work on psi-calculi with novel abstract patterns and pattern matching, and add sorts to the data term language, giving sufficient criteria for subject reduction to hold.""
  - ""Our framework can accommodate several existing process calculi; the resulting transition systems are isomorphic to the originals up to strong bisimulation.""
  - ""We also demonstrate different notions of computation on data terms, including cryptographic primitives and a lambda-calculus with erratic choice.""
  - ""Substantial parts of the meta-theory of sorted psi-calculi have been machine-checked using Nominal Isabelle.""
  - ""The generalized pattern matching is a new contribution that holds general interest; here it allows us to directly capture computation on data in advanced process calculi, without elaborate encodings.""
  - ""The restriction to well-sorted substitution also allows to avoid ""junk"": terms that exist solely to make substitutions total.""
  - ""We obtain criteria that ensure that wellformedness is preserved by transitions, and apply these to the original psi-calculi [BJPV11] (Theorem 2.7) and to pattern-matching spi calculus [HJ06] (Lemma 5.3).""
  - ""The meta-theoretic results carry over from the original psi formulations, and have been machine-checked in Isabelle for the case of a single name sort (e.g. the calculi PPI, LINDA and PSPI in Section 4, and the calculi PMSPI and NDLAM in Section 5).""
  - ""The critera for representation (rather than encoding) are stronger than standard correspondences e.g. by Gorla, and mean that the psi-calculus and the process calculus that it represents are for all practical purposes one and the same.""",,"- The paper introduces a novel framework that unifies different process calculi, which is a significant theoretical contribution.
 - The extension of psi-calculi with abstract patterns and pattern matching is highlighted as a new contribution, allowing for direct capture of computations without elaborate encodings.
 - The addition of sorts to the data term language ensures subject reduction, which is a theoretical advancement in maintaining well-formedness.
 - The framework accommodates existing process calculi with isomorphic transition systems, indicating a strong theoretical foundation.
 - The use of machine-checked proofs in Nominal Isabelle adds to the theoretical rigor and reliability of the framework.
 - The criteria for representation are stronger than standard encoding correspondences, suggesting a more robust theoretical contribution.
 - The paper demonstrates various notions of computation, including cryptographic primitives and lambda-calculus, which are potential implications for programming language design."
A Brief Overview of the Pawns Programming Language,Lee Naish,10.48550/arXiv.2409.03152,https://doi.org/10.48550/arXiv.2409.03152,Software,0,2024,"1. Primitive Name: Algebraic Data Types
  Definition: Used in pure functional programming to represent data.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Higher-Order Programming
  Definition: Used in pure functional programming to enable functions as first-class citizens.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Parametric Polymorphism
  Definition: Used in pure functional programming to allow generic types.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Pointers
  Definition: Used in imperative programming for memory management.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Destructive Update
  Definition: Used in imperative programming to modify data in place.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Annotations on Statements and Type Signatures
  Definition: Used to declare sharing and updates.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Extensive Sharing Analysis
  Definition: Used by the compiler to ensure correctness and safety of updates.
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Supporting both pure functional programming and lower-level imperative programming with pointers and destructive updates.
 - Interaction models between paradigms: Using annotations on statements and in type signatures to declare sharing and updates.
 - Constraints or challenges in paradigm integration: Addressed through the compiler's extensive sharing analysis.
 - Any novel translation or embedding techniques: Use of sharing analysis to encapsulate destructive updates.","- Definition of ""concept"" used: Not explicitly mentioned
 - Mechanisms for representing generic abstractions: Parametric polymorphism, algebraic data types, higher-order programming
 - Minimal type requirements identified: Type signatures must declare sharing between arguments and results
 - Static checking or optimization strategies: Extensive sharing analysis by the compiler","- Key novel insights: Combination of functional and imperative programming paradigms, use of annotations for destructive updates, and extensive sharing analysis.
 - Theoretical advancements: Encapsulation of destructive updates within functions, support for constrained global variables, and safe updates of polymorphic types.
 - Potential implications: Enhances programming language design by providing a safer and more transparent way to combine different programming paradigms.","- ""It supports pure functional programming (including algebraic data types, higher-order programming and parametric polymorphism), where the representation of values need not be considered.""
  - ""It also supports lower-level C-like imperative programming with pointers and the destructive update of all fields of the structs used to represent the algebraic data types.""
  - ""Type signatures must also declare sharing between any arguments and result that may be updated.""
  - ""All destructive update of variables is made obvious in Pawns code, via annotations on statements and in type signatures.""
  - ""This analysis allows destructive update to be encapsulated: a function with no update annotations in its type signature is guaranteed to behave as a pure function, even though the value returned may have been constructed using destructive update within the function.""
  - ""This paper describes the Pawns programming language, currently under development, which uses several novel features to combine the functional and imperative programming paradigms.""
  - ""The compiler performs extensive sharing analysis to check that the declarations and annotations are correct.""",,"- The abstract discusses the Pawns programming language, which combines functional and imperative programming paradigms. This suggests that the conceptual primitives are related to these paradigms.
 - The language supports ""pure functional programming"" with features like ""algebraic data types, higher-order programming, and parametric polymorphism."" These are conceptual primitives related to functional programming.
 - It also supports ""lower-level C-like imperative programming with pointers and the destructive update of all fields of the structs used to represent the algebraic data types."" This indicates primitives related to imperative programming, specifically the use of pointers and destructive updates.
 - The abstract mentions ""annotations on statements and in type signatures"" and ""type signatures must also declare sharing between any arguments and result that may be updated."" These are primitives related to ensuring the correctness and safety of updates.
 - The ""extensive sharing analysis"" performed by the compiler is a primitive related to ensuring the encapsulation of destructive updates and the safety of global variables.","- ""This paper describes the Pawns programming language, currently under development, which uses several novel features to combine the functional and imperative programming paradigms.""
  - ""It supports pure functional programming (including algebraic data types, higher-order programming and parametric polymorphism), where the representation of values need not be considered.""
  - ""It also supports lower-level C-like imperative programming with pointers and the destructive update of all fields of the structs used to represent the algebraic data types.""
  - ""All destructive update of variables is made obvious in Pawns code, via annotations on statements and in type signatures.""
  - ""Type signatures must also declare sharing between any arguments and result that may be updated.""
  - ""The compiler performs extensive sharing analysis to check that the declarations and annotations are correct.""
  - ""This analysis allows destructive update to be encapsulated: a function with no update annotations in its type signature is guaranteed to behave as a pure function, even though the value returned may have been constructed using destructive update within the function.""
  - ""Additionally, the sharing analysis helps support a constrained form of global variables that also allows destructive update to be encapsulated and safe update of variables with polymorphic types to be performed.""",,"- The abstract discusses the Pawns programming language, which combines functional and imperative programming paradigms. This suggests a theoretical foundation that might involve type theory, given the mention of ""algebraic data types, higher-order programming and parametric polymorphism.""
 - The language supports ""pure functional programming,"" which is often formalized using type theory.
 - The abstract mentions ""extensive sharing analysis"" performed by the compiler, which could imply a formal verification process, possibly using type theory to ensure correctness.
 - The abstract does not explicitly mention a specific mathematical framework like type theory or category theory, nor does it detail specific mathematical properties guaranteed or proof techniques used.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""This paper describes the Pawns programming language, currently under development, which uses several novel features to combine the functional and imperative programming paradigms.""
  - ""It supports pure functional programming (including algebraic data types, higher-order programming and parametric polymorphism), where the representation of values need not be considered.""
  - ""It also supports lower-level C-like imperative programming with pointers and the destructive update of all fields of the structs used to represent the algebraic data types.""
  - ""All destructive update of variables is made obvious in Pawns code, via annotations on statements and in type signatures.""
  - ""Type signatures must also declare sharing between any arguments and result that may be updated.""
  - ""The compiler performs extensive sharing analysis to check that the declarations and annotations are correct.""
  - ""This analysis allows destructive update to be encapsulated: a function with no update annotations in its type signature is guaranteed to behave as a pure function, even though the value returned may have been constructed using destructive update within the function.""
  - ""Additionally, the sharing analysis helps support a constrained form of global variables that also allows destructive update to be encapsulated and safe update of variables with polymorphic types to be performed.""",,"- The abstract describes the Pawns programming language as combining functional and imperative programming paradigms, indicating an integration approach.
 - The integration mechanisms include supporting both pure functional programming and lower-level imperative programming with pointers and destructive updates.
 - The interaction model involves using annotations on statements and in type signatures to declare sharing and updates, ensuring that destructive updates are encapsulated.
 - Constraints or challenges are addressed through the compiler's extensive sharing analysis, which checks the correctness of declarations and annotations.
 - A novel technique is the use of sharing analysis to encapsulate destructive updates, allowing functions to behave as pure functions despite internal updates.
 - The abstract does not mention any specific novel translation or embedding techniques beyond the use of annotations and sharing analysis.","- ""This paper describes the Pawns programming language, currently under development, which uses several novel features to combine the functional and imperative programming paradigms.""
  - ""It supports pure functional programming (including algebraic data types, higher-order programming and parametric polymorphism), where the representation of values need not be considered.""
  - ""It also supports lower-level C-like imperative programming with pointers and the destructive update of all fields of the structs used to represent the algebraic data types.""
  - ""Type signatures must also declare sharing between any arguments and result that may be updated.""
  - ""The compiler performs extensive sharing analysis to check that the declarations and annotations are correct.""
  - ""This analysis allows destructive update to be encapsulated: a function with no update annotations in its type signature is guaranteed to behave as a pure function, even though the value returned may have been constructed using destructive update within the function.""",,"- The abstract mentions ""parametric polymorphism,"" which is a key concept in generic programming. This suggests that Pawns supports generic abstractions through parametric polymorphism.
 - The mention of ""algebraic data types"" and ""higher-order programming"" indicates mechanisms for representing generic abstractions, as these are common tools in functional programming for creating generic data structures and functions.
 - The requirement for type signatures to declare sharing between arguments and results implies a mechanism for ensuring type safety and encapsulation, which is relevant to generic programming.
 - The extensive sharing analysis performed by the compiler suggests a static checking strategy to ensure the correctness of generic abstractions and their usage.
 - The abstract does not explicitly define a ""concept"" used in generic programming, but it does discuss mechanisms and type requirements that are relevant to genericity and abstraction.","- ""This paper describes the Pawns programming language, currently under development, which uses several novel features to combine the functional and imperative programming paradigms.""
  - ""It supports pure functional programming (including algebraic data types, higher-order programming and parametric polymorphism), where the representation of values need not be considered.""
  - ""It also supports lower-level C-like imperative programming with pointers and the destructive update of all fields of the structs used to represent the algebraic data types.""
  - ""All destructive update of variables is made obvious in Pawns code, via annotations on statements and in type signatures.""
  - ""Type signatures must also declare sharing between any arguments and result that may be updated.""
  - ""The compiler performs extensive sharing analysis to check that the declarations and annotations are correct.""
  - ""This analysis allows destructive update to be encapsulated: a function with no update annotations in its type signature is guaranteed to behave as a pure function, even though the value returned may have been constructed using destructive update within the function.""
  - ""Additionally, the sharing analysis helps support a constrained form of global variables that also allows destructive update to be encapsulated and safe update of variables with polymorphic types to be performed.""",,"- The abstract describes the Pawns programming language as combining functional and imperative programming paradigms, which is a novel approach.
 - The language supports both pure functional programming and lower-level imperative programming, which is a unique combination.
 - The use of annotations to make destructive updates obvious and the requirement for type signatures to declare sharing are novel features that enhance transparency and safety.
 - The compiler's extensive sharing analysis is a theoretical advancement that ensures the correctness of these annotations and declarations.
 - The encapsulation of destructive updates within functions, even when they appear to behave as pure functions, is a significant theoretical contribution.
 - The support for constrained global variables and safe updates of polymorphic types further extends the theoretical contributions by addressing complex programming challenges."
Programming in Persistent Higher-Order Languages,"R. Connor, R. Morrison, M. Atkinson, F. Matthes, Joachim W. Schmidt",10.1007/978-3-642-78565-8_24,https://doi.org/10.1007/978-3-642-78565-8_24,-,1,1993,Not specified (the paper discusses concepts and methodologies related to persistence and type systems but does not explicitly define conceptual primitives),"- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Data protection and integrity through type enforcement
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Orthogonal persistence, type-safe permanent data, new binding paradigms.
 - Interaction models between paradigms: Integration of security and data integrity through type systems.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Hyper-programming, binding persistent values into source and executable code.","- Definition of ""concept"" used: Modelling and protection provided by the type system.
 - Mechanisms for representing generic abstractions: Subtyping, procedural encapsulation (1st-order information hiding), existential data types (2nd-order information hiding).
 - Minimal type requirements identified: Flexible and enforceable type system for transient and permanent data.
 - Static checking or optimization strategies: Static checking through type systems to enforce protection and prevent undesirable accesses.","- Novel insights: Application of type system features in persistent programming languages; universality of persistent type systems for modeling and protection; provision of type-safe permanent data; new binding paradigms for persistent values.
 - Theoretical advancements: Use of subtype inheritance, procedural encapsulation, and existential data types for protection; hyper-programming for interactive program composition.
 - Potential implications: Integration of persistence into language design for hyper-programming and enhanced protection mechanisms.","- ""The combination of these means that the kind of sophisticated typing commonly used in programs which operate over short-term data may be extended to all data manipulated by a long-lived system.""
  - ""The benefits of orthogonal persistence have been described extensively in the literature and can be summarised as:
 

 • improving programming productivity from simpler semantics;
 

 • removing ad hoc arrangements for data translation and long term data storage; and • providing protection mechanisms over the whole environment.""
  - ""The persistence abstraction is widely recognised as the appropriate underlying technology for long lived, concurrently accessed and potentially large bodies of data and programs.""
  - ""The goal of persistence research is to allow these socially and economically important persistent application systems to be more sophisticated and more economically viable.""
  - ""Type systems are historically viewed as mechanisms which impose static safety constraints upon a program. Within a persistent environment, however, the type system takes on a wider role.""
  - ""The universality of the persistent type system has consequences in terms of both the modelling and protection provided by the type system.""
  - ""The presence of persistent data in the software construction environment allows the introduction of new binding paradigms, in particular the ability to bind persistent values directly into both source and executable code.""
  - ""The primary motivation for providing a hyper-programming system is to allow the programmer to compose programs interactively, navigating the persistent store and selecting data items to be incorporated into the programs.""",,"- The paper discusses the concept of orthogonal persistence and its benefits, which include improving programming productivity and providing protection mechanisms. These are not explicitly defined as conceptual primitives but are foundational concepts.
 - The paper highlights the role of type systems in persistent environments, which is a key conceptual framework. However, it does not explicitly define specific primitives related to type systems.
 - The paper introduces the concept of hyper-programming, which involves binding persistent values into source and executable code. This is a methodology rather than a set of conceptual primitives.
 - The paper does not explicitly list or define specific conceptual primitives for reconstructing programming paradigms. It focuses on the implications and applications of persistence and type systems rather than defining new primitives.","- ""The combination of these means that the kind of sophisticated typing commonly used in programs which operate over short-term data may be extended to all data manipulated by a long-lived system.""
  - ""the type system of a single language may be used to enforce protection upon both transient and permanent data.""
  - ""The universality of the persistent type system has consequences in terms of both the modelling and protection provided by the type system.""
  - ""the type system takes on a wider role.""
  - ""the type system strictly enforces any future access to them by other programs.""
  - ""The use of these mechanisms in persistent languages relies upon the ability of values of these types to be kept for arbitrary lifetimes, and the binding of new programs to them to be strongly typed.""
  - ""The presence of persistent data in the software construction environment allows the introduction of new binding paradigms, in particular the ability to bind persistent values directly into both source and executable code.""
  - ""The fact that attributes of a type may be absolutely relied upon for the lifetime the data it describes gives some new methodologies for the programming of activities normally associated with untyped, operating system support systems.""
  - ""The mechanisms of subtype inheritance, procedural encapsulation, and existential data types have been discussed with relation to the programming of protection within a persistent system.""",,"- The paper discusses the use of type systems as a fundamental mathematical framework for ensuring properties in persistent programming languages.
 - The type system is described as being able to enforce protection and ensure the integrity of data across its lifetime, which suggests a focus on type theory.
 - The paper mentions the use of subtype inheritance, procedural encapsulation, and existential data types, which are concepts typically associated with type theory.
 - The emphasis on the role of the type system in enforcing protection and ensuring data integrity suggests that type theory is the primary mathematical framework used.
 - The paper does not explicitly mention other mathematical frameworks like category theory or specific proof techniques, so it appears that type theory is the main focus.
 - The paper does not provide detailed proof techniques or limitations of the framework, but it does highlight the importance of type theory in ensuring data protection and integrity.","- ""Persistent programming languages differ from traditional languages in that data of arbitrary lifetimes is fully governed by the type system.""
  - ""The combination of these means that the kind of sophisticated typing commonly used in programs which operate over short-term data may be extended to all data manipulated by a long-lived system.""
  - ""The benefits of orthogonal persistence have been described extensively in the literature and can be summarised as:
 

 • improving programming productivity from simpler semantics;
 

 • removing ad hoc arrangements for data translation and long term data storage; and • providing protection mechanisms over the whole environment.""
  - ""The persistence abstraction is widely recognised as the appropriate underlying technology for long lived, concurrently accessed and potentially large bodies of data and programs.""
  - ""The goal of persistence research is to allow these socially and economically important persistent application systems to be more sophisticated and more economically viable.""
  - ""This paper surveys some programming methodologies and styles that have been developed after the extensive use of persistent languages in the construction of medium scale software systems.""
  - ""The provision of type-safe permanent data provides one kind of control that is not available in a non-persistent model.""
  - ""The presence of persistent data in the software construction environment allows the introduction of new binding paradigms, in particular the ability to bind persistent values directly into both source and executable code.""
  - ""The primary motivation for providing a hyper-programming system is to allow the programmer to compose programs interactively, navigating the persistent store and selecting data items to be incorporated into the programs.""",,"- The paper discusses the integration of programming paradigms by focusing on the use of persistent programming languages, which integrate data management and programming through a type system that governs data of arbitrary lifetimes.
 - The concept of orthogonal persistence is highlighted as a key integration mechanism, allowing for simpler semantics and removing ad hoc data translation arrangements.
 - The paper mentions the integration of protection mechanisms over the whole environment, which suggests an interaction model where security and data integrity are integrated into the programming paradigm.
 - The introduction of new binding paradigms, such as binding persistent values into source and executable code, is a novel technique that integrates different programming paradigms.
 - The concept of hyper-programming is discussed as a way to integrate interactive program composition with persistent data, which is a novel approach to integrating different programming paradigms.","- ""The combination of these means that the kind of sophisticated typing commonly used in programs which operate over short-term data may be extended to all data manipulated by a long-lived system.""
  - ""The universality of the persistent type system has consequences in terms of both the modelling and protection provided by the type system.""
  - ""With respect to modelling, the persistent type system must be sufficiently flexible to allow the modelling of activities normally provided by untyped support systems.""
  - ""Subtyping achieves protection by removing type information, causing the static failure of programs which may try to perform undesirable accesses.""
  - ""1st-order information hiding prevents the protected data from being named by an untrusted program, allowing access only through a procedural interface.""
  - ""2nd-order information hiding does not restrict access to the protected values, but instead abstracts over the type of the protected value to restrict operations allowed on it.""
  - ""One mechanism which allows 2nd-order information hiding is the existential data type as described in [MP88].""
  - ""The presence of persistent data in the software construction environment allows the introduction of new binding paradigms, in particular the ability to bind persistent values directly into both source and executable code.""",,"- The paper discusses the use of type systems in persistent programming languages, which is relevant to generic programming and abstraction mechanisms.
 - The concept of ""concept"" used in the paper relates to the modelling and protection provided by the type system, which is a form of abstraction.
 - Mechanisms for representing generic abstractions include subtyping, procedural encapsulation (1st-order information hiding), and existential data types (2nd-order information hiding).
 - Minimal type requirements are not explicitly identified, but the paper implies that the type system must be flexible and enforceable for both transient and permanent data.
 - Static checking is implied through the use of type systems to enforce protection and prevent undesirable accesses.
 - The paper does not explicitly discuss optimization strategies, but the focus on type systems suggests a reliance on static checking for safety and correctness.","- ""This paper exposes some of the ways in which well-known type system features may be powerfully used in contexts normally associated with operating systems and database management systems.""
  - ""The universality of the persistent type system has consequences in terms of both the modelling and protection provided by the type system.""
  - ""The provision of type-safe permanent data provides one kind of control that is not available in a non-persistent model.""
  - ""The presence of persistent data in the software construction environment allows the introduction of new binding paradigms, in particular the ability to bind persistent values directly into both source and executable code.""
  - ""The primary motivation for providing a hyper-programming system is to allow the programmer to compose programs interactively, navigating the persistent store and selecting data items to be incorporated into the programs.""
  - ""The fact that attributes of a type may be absolutely relied upon for the lifetime the data it describes gives some new methodologies for the programming of activities normally associated with untyped, operating system support systems.""
  - ""The mechanisms of subtype inheritance, procedural encapsulation, and existential data types have been discussed with relation to the programming of protection within a persistent system.""
  - ""Protection in database systems is normally provided by viewing mechanisms. These allow database programmers to set up different interfaces over the same data, so that users with different privileges may perform different operations.""
  - ""The last consequence of strongly typed persistent data presented is the ability to safely allow the style of programming known as hyper-programming.""",,"- The paper introduces the concept of using well-known type system features in the context of persistent programming languages, which is a novel application of these features.
 - The universality of the persistent type system is highlighted as a key theoretical contribution, as it provides a unified approach to modeling and protection.
 - The paper discusses the provision of type-safe permanent data as a unique control mechanism not available in non-persistent models, which is a theoretical advancement.
 - The introduction of new binding paradigms, such as binding persistent values directly into source and executable code, is a novel insight that expands programming methodologies.
 - The concept of hyper-programming is presented as a theoretical contribution, allowing for interactive program composition and direct links to persistent values.
 - The paper discusses the use of subtype inheritance, procedural encapsulation, and existential data types for protection in persistent systems, which are theoretical advancements beyond existing approaches.
 - The potential implications for programming language design include the integration of persistence into language design to support hyper-programming and enhanced protection mechanisms."
Proceedings Workshop on Generic Programming (WGP2000),J. Jeuring,-,-,-,0,2000,Not specified (the abstract does not explicitly define conceptual primitives for reconstructing programming paradigms),Not specified (the abstract does not provide details on a specific mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed (the abstract provides a general overview of generic programming but does not detail specific mechanisms or strategies for abstraction),"- Key novel insights: Generic programming makes programs more adaptable by making them more general; non-traditional polymorphism and rich structural parameters.
 - Theoretical advancements: Bird-Meertens style of generic programming; theory of datatypes leading to generic programs and language extensions.
 - Potential implications: Influence on programming language design through generic programming language extensions.","- ""Generic programming is about making programs more adaptable by making them more general.""
  - ""Generic programs often embody non-traditional kinds of polymorphism; ordinary programs are obtained from them by suitably instantiating their parameters.""
  - ""In contrast with normal programs, the parameters of a generic program are often quite rich in structure.""
  - ""For example they may be other programs, types or type constructors, kinds, or even programming paradigms.""
  - ""The papers presented at WGP2000 are mainly about the Bird-Meertens style of generic programming.""
  - ""The theory of datatypes developed in the groups around Bird and Meertens has led to generic (or polytypic) programs, theory about generic programs, and generic programming language extensions.""",,"- The abstract discusses the concept of generic programming and its focus on making programs more adaptable and general.
 - It mentions that generic programs often involve non-traditional polymorphism and richly structured parameters, which can include other programs, types, type constructors, kinds, or programming paradigms.
 - The abstract references the Bird-Meertens style of generic programming, which is associated with the theory of datatypes and the development of generic programs and language extensions.
 - However, the abstract does not explicitly define specific conceptual primitives for reconstructing programming paradigms. It provides a general overview of the field and the focus of the workshop but does not detail specific primitives or their definitions.","- ""the parameters of a generic program are often quite rich in structure.""
  - ""The theory of datatypes developed in the groups around Bird and Meertens has led to generic (or polytypic) programs, theory about generic programs, and generic programming language extensions.""
  - ""Generic programs often embody non-traditional kinds of polymorphism; ordinary programs are obtained from them by suitably instantiating their parameters.""
  - ""Generic programming is about making programs more adaptable by making them more general.""",,"- The abstract discusses the concept of generic programming and its focus on making programs more adaptable and general.
 - It mentions the use of non-traditional polymorphism and richly structured parameters, which are key aspects of generic programming.
 - The abstract references the theory of datatypes developed by Bird and Meertens, which is related to generic programming.
 - However, there is no explicit mention of a specific mathematical framework, such as type theory or category theory, nor are there details about specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The abstract does not provide information on theoretical foundations, proof methodology, or formal verification discussions related to a mathematical framework.","- ""Generic programming is about making programs more adaptable by making them more general.""
  - ""Generic programs often embody non-traditional kinds of polymorphism; ordinary programs are obtained from them by suitably instantiating their parameters.""
  - ""In contrast with normal programs, the parameters of a generic program are often quite rich in structure.""
  - ""For example they may be other programs, types or type constructors, kinds, or even programming paradigms.""
  - ""The papers presented at WGP2000 are mainly about the Bird-Meertens style of generic programming.""
  - ""Generic programming is also studied in the context of the C++ Standard Template Library and Adaptive Object-Oriented Programming, amongst others, but we received few submissions from these fields.""",,"- The abstract discusses generic programming as a method to make programs more adaptable and general, which involves non-traditional polymorphism and richly structured parameters.
 - It mentions that these parameters can include other programs, types, or even programming paradigms, suggesting a potential for integration.
 - The focus of the workshop is on the Bird-Meertens style of generic programming, which implies a theoretical approach to generic programs and language extensions.
 - The abstract does not provide specific details on integration mechanisms, interaction models, constraints, or novel translation techniques related to programming paradigm integration.
 - The mention of the C++ Standard Template Library and Adaptive Object-Oriented Programming suggests other contexts where generic programming is studied, but it does not elaborate on how these are integrated or interact.","- ""The theory of datatypes developed in the groups around Bird and Meertens has led to generic (or polytypic) programs, theory about generic programs, and generic programming language extensions.""
  - ""Generic programming is about making programs more adaptable by making them more general.""
  - ""The papers presented at WGP2000 are mainly about the Bird-Meertens style of generic programming.""
  - ""In contrast with normal programs, the parameters of a generic program are often quite rich in structure.""
  - ""Generic programs often embody non-traditional kinds of polymorphism; ordinary programs are obtained from them by suitably instantiating their parameters.""",,"- The abstract defines generic programming as making programs more adaptable by making them more general, which aligns with the concept of abstraction.
 - It mentions that generic programs embody non-traditional kinds of polymorphism, which is a mechanism for representing generic abstractions.
 - The abstract notes that the parameters of generic programs are rich in structure, which could imply a focus on abstraction mechanisms.
 - The mention of the Bird-Meertens style suggests a specific methodology for generic programming, which might include mechanisms for abstraction.
 - However, the abstract does not explicitly mention minimal type requirements, static checking, or optimization strategies.
 - The focus on the Bird-Meertens style and the theory of datatypes suggests a conceptual approach to abstraction, but specific mechanisms or strategies are not detailed.","- ""The theory of datatypes developed in the groups around Bird and Meertens has led to generic (or polytypic) programs, theory about generic programs, and generic programming language extensions.""
  - ""The papers presented at WGP2000 are mainly about the Bird-Meertens style of generic programming.""
  - ""the parameters of a generic program are often quite rich in structure.""
  - ""Generic programs often embody non-traditional kinds of polymorphism; ordinary programs are obtained from them by suitably instantiating their parameters.""
  - ""Generic programming is about making programs more adaptable by making them more general.""",,"- The abstract discusses the concept of generic programming and its focus on making programs more adaptable and general. This is a key insight into the nature of generic programming.
 - It highlights the non-traditional polymorphism and rich structural parameters of generic programs, which is a theoretical advancement beyond traditional programming approaches.
 - The mention of the Bird-Meertens style of generic programming indicates a specific theoretical framework that has led to developments in generic programs and language extensions. This suggests a theoretical contribution in the form of a structured approach to generic programming.
 - The abstract does not explicitly mention new insights or advancements beyond existing approaches, but it implies that the Bird-Meertens style and the theory of datatypes are significant theoretical contributions.
 - The potential implications for programming language design are suggested by the mention of generic programming language extensions, which could influence future language development."
Functional and predictive programming in OODB's,"C. Beeri, Tova Milo",10.1145/137097.137863,https://doi.org/10.1145/137097.137863,ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems,25,1992,Not specified (the abstract does not explicitly define conceptual primitives),Not specified,No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Extension of relational model paradigms to object-oriented data models.
 - Theoretical advancements: Generalization of nested relations/complex object models to support complex values and ADT definitions; re-examination of existing results like Codd’s equivalence in the context of complex object models.
 - Potential implications for programming language design: Focus on declarative languages for object-oriented models.","- ""The relational model supports three query language paradigms: algebra, calculus and logic programming.""
  - ""The object oriented paradigm offers a rich set of data structuring and manipulation facilities.""
  - ""These have been extended in the late 80’s to the nested relations/complex object models, by adding operations and predicates for dealing with sets (such as z c S) and new algebraic operations such as nest, unnest, powerset""
  - ""Extensions of these paradigms to full object-oriented models are now being investigated""",,"- The abstract discusses the object-oriented paradigm and its data structuring and manipulation facilities, but it does not explicitly define any conceptual primitives.
 - It mentions the relational model's query language paradigms (algebra, calculus, and logic programming) and their extensions to nested relations/complex object models, but these are not explicitly defined as conceptual primitives in the context of reconstructing programming paradigms.
 - The abstract does not provide specific names or definitions for conceptual primitives, nor does it discuss their level of abstraction or orthogonality.
 - The focus of the abstract is on the extension of paradigms rather than the definition of conceptual primitives.","- ""The object oriented paradigm offers a rich set of data structuring and manipulation facilities.""
  - ""Object oriented data models generalize the nested relations/complex object models, that support the construction of complex values using trqde, set and other constructors, and those that support ADT definitions [2, 3, 4, 9, 10, 17, 20].""
  - ""Recently, much attention is paid to declarative languages for these models.""
  - ""The relational model supports three query language paradigms: algebra, calculus and logic programming.""
  - ""These have been extended in the late 80’s to the nested relations/complex object models, by adding operations and predicates for dealing with sets (such as z c S) and new algebraic operations such as nest, unnest, powerset [1].""
  - ""Extensions of these paradigms to full object-oriented models are now being investigated [6, 13, 16].""
  - ""A lot of work has been done on comparing the expressive power of languages for the relational model; the most famous is Codd’s result about the equivalence of the algebra and the calculus.""
  - ""Many of these results have been re-examined in the context of complex object models, and in particular, the algebra-calculus""",,"- The abstract discusses the object-oriented paradigm and its data structuring facilities, but it does not explicitly mention a specific mathematical framework used to formalize or guarantee properties.
 - It mentions the extension of relational model paradigms (algebra, calculus, logic programming) to object-oriented models, but this is more about language paradigms rather than a mathematical framework.
 - The abstract references Codd’s result on the equivalence of algebra and calculus, which is a theoretical foundation, but it does not specify a mathematical framework like type theory or category theory.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of a framework.","- ""Many of these results have been re-examined in the context of complex object models, and in particular, the algebra-calculus""
  - ""Extensions of these paradigms to full object-oriented models are now being investigated""
  - ""These have been extended in the late 80’s to the nested relations/complex object models, by adding operations and predicates for dealing with sets (such as z c S) and new algebraic operations such as nest, unnest, powerset""
  - ""The relational model supports three query language paradigms: algebra, calculus and logic programming.""
  - ""The object oriented paradigm offers a rich set of data structuring and manipulation facilities.""",,"- The abstract discusses the extension of relational model paradigms (algebra, calculus, logic programming) to object-oriented data models, indicating a focus on integrating these paradigms.
 - The mention of adding operations and predicates for dealing with sets and new algebraic operations suggests a mechanism for integrating relational paradigms with object-oriented models.
 - The abstract does not explicitly describe specific integration mechanisms, interaction models, constraints, or novel translation techniques, but it implies that these are being investigated.
 - The focus on re-examining results in the context of complex object models suggests a theoretical integration strategy, but details are not provided.","- ""Extensions of these paradigms to full object-oriented models are now being investigated""
  - ""The relational model supports three query language paradigms: algebra, calculus and logic programming.""
  - ""Object oriented data models generalize the nested relations/complex object models, that support the construction of complex values using trqde, set and other constructors, and those that support ADT definitions""
  - ""Recently, much attention is paid to declarative languages for these models.""
  - ""The object oriented paradigm offers a rich set of data structuring and manipulation facilities.""",,"- The abstract discusses the object-oriented paradigm and its data structuring facilities, which could relate to genericity and abstraction mechanisms.
 - It mentions object-oriented data models that support complex values and ADT definitions, which are relevant to abstraction mechanisms.
 - The focus on declarative languages and query language paradigms suggests a discussion on programming methodologies, but it does not explicitly mention generic programming or abstraction mechanisms.
 - The abstract does not provide specific details on generic programming methodology, type system discussions, or abstraction mechanism explanations.
 - The abstract does not mention minimal type requirements or static checking/optimization strategies.","- ""The object oriented paradigm offers a rich set of data structuring and manipulation facilities.""
  - ""Object oriented data models generalize the nested relations/complex object models, that support the construction of complex values using trqde, set and other constructors, and those that support ADT definitions""
  - ""Recently, much attention is paid to declarative languages for these models.""
  - ""The relational model supports three query language paradigms: algebra, calculus and logic programming.""
  - ""These have been extended in the late 80’s to the nested relations/complex object models, by adding operations and predicates for dealing with sets (such as z c S) and new algebraic operations such as nest, unnest, powerset""
  - ""Extensions of these paradigms to full object-oriented models are now being investigated""
  - ""A lot of work has been done on comparing the expressive power of languages for the relational model; the most famous is Codd’s result about the equivalence of the algebra and the calculus.""
  - ""Many of these results have been re-examined in the context of complex object models, and in particular, the algebra-calculus""",,"- The abstract discusses the extension of relational model paradigms (algebra, calculus, logic programming) to object-oriented data models, which is a key theoretical contribution.
 - It highlights the generalization of nested relations/complex object models to support complex values and ADT definitions, indicating a theoretical advancement.
 - The mention of re-examining results like Codd’s equivalence in the context of complex object models suggests a theoretical contribution by applying existing theories to new contexts.
 - The focus on declarative languages for object-oriented models indicates a novel insight into programming language design.
 - The abstract does not explicitly state new theoretical contributions beyond these extensions and re-examinations, but these are significant theoretical advancements."
Strikte Verfahren zyklischer Berechnung,Baltasar Trancón y Widemann,10.14279/DEPOSITONCE-1771,https://doi.org/10.14279/DEPOSITONCE-1771,-,1,2008,"1. Primitive Name: Coalgebra
  Definition: Replaces traditional algebraic meta-theory to handle cyclic data.
  Orthogonality Score: Not discussed
 2. Primitive Name: Nonnal Coalgebras
  Definition: Describe actual representations in machine memory.
  Orthogonality Score: Not discussed
 3. Primitive Name: Primitively Corecursive Functions
  Definition: Specified as families of coalgebras for recursion.
  Orthogonality Score: Not discussed
 4. Primitive Name: Algorithm for Corecursive Functions
  Definition: Corresponds to the unique morphism into the final coalgebra.
  Orthogonality Score: Not discussed
 5. Primitive Name: Virtual Machine
  Definition: Operational semantics for supporting coalgebraic methods.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Category theory, specifically coalgebra
 - Specific mathematical properties guaranteed: Terminating computations under strict semantics, handling of cyclical data
 - Proof techniques used: Bisimilarity, unique morphism into the nal coalgebra
 - Limitations or constraints of the framework: Not explicitly mentioned, but designed to handle cyclical data effectively","- Specific integration mechanisms proposed: Alignment of operational semantics with traditional strict functional, imperative, or object-oriented languages; use of coalgebras to describe recursion steps in memory.
 - Interaction models between paradigms: Virtual machine caters to both higher-order functional programming and cycle detection.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Specification of corecursive functions in terms of coalgebras.",Generic programming not extensively addressed (the abstract focuses on coalgebraic approaches for cyclic data but does not provide detailed mechanisms or definitions for generic programming),"- Key novel insights: Distinguishing cyclicity from infinity using coalgebraic semantics.
 - Theoretical advancements: Replacing algebraic meta-theory with coalgebra, providing algorithms for cyclic data under strict evaluation, integrating coalgebraic semantics with operational semantics.
 - Potential implications for programming language design: Offering a new framework for handling cyclic data, bridging declarative and functional programming paradigms.","- ""we replace the common meta-theory of algebra by its categorial dual coalgebra.""
  - ""Actual representations in machine memory are described as elements of nonnal coalgebras, as well.""
  - ""any primitively corecursive function can be speci ed as a family of coalgebras, each describing a recursion step on a single state of memory.""
  - ""An algorithm is given that corresponds up to bisimilarity to the unique morphism into the nal coalgebra, namely the induced corecursive function.""
  - ""We also reduce the decision procedure for predicates by depthrst search, like it is used in the resolution strategy of Prolog, to a coalgebraic representation.""
  - ""We give another algorithm that decides the inclusion of formulae in one xpoint model, given proper parametrization.""
  - ""Both algorithmic methods are presented in a way that allows implementation with the same technical means of cycle detection.""
  - ""Following a detailed analysis of the technical constraints, we de ne a virtual machine as operational semantics for supporting the presented methods in a programming language.""",,"- The abstract discusses the use of coalgebra as a conceptual primitive to replace traditional algebraic meta-theory. This suggests that coalgebra is a fundamental concept in the study.
 - The mention of ""nonnal coalgebras"" indicates that these are used to describe actual representations in machine memory, which could be considered a conceptual primitive for handling cyclic data.
 - The specification of ""primitively corecursive functions"" as families of coalgebras implies that these functions are conceptual primitives for handling recursion.
 - The algorithm for corecursive functions and the reduction of decision procedures to coalgebraic representations suggest that these algorithms are conceptual primitives for processing cyclic data.
 - The virtual machine defined for operational semantics could be seen as a conceptual primitive for implementing these methods in a programming language.","- ""Contrary to the non-well-founded approaches forming the foundations of socalled lazy programming languages like Haskell or Clean, in which in nitely descending subterm chains are allowed, we replace the common meta-theory of algebra by its categorial dual coalgebra.""
  - ""The most successful coalgebraic approach so far lead to the development of the language Charity that employs category-theoretic constructs for both denotational and operational semantics.""
  - ""We pursue a contrary approach, gearing operational semantics more towards traditional strict functional, imperative or object-oriented languages.""
  - ""Actual representations in machine memory are described as elements of nonnal coalgebras, as well.""
  - ""An algorithm is given that corresponds up to bisimilarity to the unique morphism into the nal coalgebra, namely the induced corecursive function.""
  - ""This algorithm terminates even under strict evaluation rules on all nite input states, subsuming real encodings of data graphs in memory.""
  - ""We also reduce the decision procedure for predicates by depthrst search, like it is used in the resolution strategy of Prolog, to a coalgebraic representation.""
  - ""We give another algorithm that decides the inclusion of formulae in one xpoint model, given proper parametrization.""
  - ""Both algorithmic methods are presented in a way that allows implementation with the same technical means of cycle detection.""
  - ""Following a detailed analysis of the technical constraints, we de ne a virtual machine as operational semantics for supporting the presented methods in a programming language.""",,"- The abstract mentions the use of ""coalgebra"" as a mathematical framework, which is a dual to algebraic approaches. This indicates that the mathematical framework is based on category theory, specifically coalgebra.
 - The framework is used to formalize and guarantee properties of cyclical data, allowing for terminating computations under strict semantics.
 - The abstract discusses the use of coalgebraic constructs for both denotational and operational semantics, which suggests that these are key mathematical properties guaranteed by the framework.
 - The mention of ""bisimilarity"" and ""unique morphism into the nal coalgebra"" implies the use of proof techniques related to category theory and coalgebra.
 - The framework is designed to handle cyclical predicates and data graphs, which are limitations or constraints of traditional algebraic approaches.
 - The abstract does not explicitly mention limitations or constraints of the coalgebraic framework itself, but it does highlight its ability to handle cyclical data effectively.","- ""We pursue a contrary approach, gearing operational semantics more towards traditional strict functional, imperative or object-oriented languages.""
  - ""This approach is not restricted to using just nal coalgebra as the structure of semantical elements. Actual representations in machine memory are described as elements of nonnal coalgebras, as well.""
  - ""In this framework, any primitively corecursive function can be speci ed as a family of coalgebras, each describing a recursion step on a single state of memory.""
  - ""Following a detailed analysis of the technical constraints, we de ne a virtual machine as operational semantics for supporting the presented methods in a programming language.""
  - ""This machine is modeled after standard examples like the Java machine. But it also caters for the needs of higher-order functional programming on the one hand and of cycle detection and handling on the other.""
  - ""The given implementation is t for usage as a programming system on its own, or as a reference for the integration of similar methods into other systems and paradigms.""",,"- The abstract discusses an approach that integrates operational semantics with traditional programming paradigms such as strict functional, imperative, or object-oriented languages. This suggests a mechanism for integrating different paradigms by aligning operational semantics with these traditional paradigms.
 - The use of coalgebras to describe recursion steps in memory indicates a novel translation technique, as it allows for the specification of corecursive functions in terms of coalgebras.
 - The development of a virtual machine that caters to both higher-order functional programming and cycle detection suggests an interaction model between these paradigms, as it accommodates the needs of both.
 - The abstract mentions that the implementation can be used as a reference for integrating similar methods into other systems and paradigms, indicating a strategy for integration.
 - The abstract does not explicitly mention specific constraints or challenges in paradigm integration, but it implies that the approach is designed to overcome traditional limitations by providing a coalgebraic framework.","- ""This present work investigates theory and techniques of declarative and functional construction and processing of cyclical data.""
  - ""Contrary to the non-well-founded approaches forming the foundations of socalled lazy programming languages like Haskell or Clean, in which in nitely descending subterm chains are allowed, we replace the common meta-theory of algebra by its categorial dual coalgebra.""
  - ""The most successful coalgebraic approach so far lead to the development of the language Charity that employs category-theoretic constructs for both denotational and operational semantics.""
  - ""We pursue a contrary approach, gearing operational semantics more towards traditional strict functional, imperative or object-oriented languages.""
  - ""Actual representations in machine memory are described as elements of nonnal coalgebras, as well.""
  - ""An algorithm is given that corresponds up to bisimilarity to the unique morphism into the nal coalgebra, namely the induced corecursive function.""
  - ""We also reduce the decision procedure for predicates by depthrst search, like it is used in the resolution strategy of Prolog, to a coalgebraic representation.""
  - ""Following a detailed analysis of the technical constraints, we de ne a virtual machine as operational semantics for supporting the presented methods in a programming language.""
  - ""This machine is modeled after standard examples like the Java machine. But it also caters for the needs of higher-order functional programming on the one hand and of cycle detection and handling on the other.""",,"- The abstract discusses the use of coalgebraic approaches for handling cyclical data, which suggests a focus on abstracting away from specific data structures to handle cyclic computations.
 - The mention of ""category-theoretic constructs"" and ""coalgebraic representation"" indicates a high level of abstraction, which is typical in generic programming.
 - The approach of using coalgebras to represent cyclic data and the development of algorithms for handling these data structures implies a mechanism for representing generic abstractions.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on operational semantics and the development of a virtual machine suggests some level of type consideration.
 - The abstract does not provide a clear definition of ""concept"" or detailed mechanisms for generic programming, but it implies a focus on abstracting cyclic computations.","- ""This present work investigates theory and techniques of declarative and functional construction and processing of cyclical data.""
  - ""Contrary to the non-well-founded approaches forming the foundations of socalled lazy programming languages like Haskell or Clean, in which in nitely descending subterm chains are allowed, we replace the common meta-theory of algebra by its categorial dual coalgebra.""
  - ""This allows to distinguish cylicity as a particular phenomenon from proper in nity.""
  - ""The most successful coalgebraic approach so far lead to the development of the language Charity that employs category-theoretic constructs for both denotational and operational semantics.""
  - ""We pursue a contrary approach, gearing operational semantics more towards traditional strict functional, imperative or object-oriented languages.""
  - ""Actual representations in machine memory are described as elements of nonnal coalgebras, as well.""
  - ""An algorithm is given that corresponds up to bisimilarity to the unique morphism into the nal coalgebra, namely the induced corecursive function.""
  - ""This algorithm terminates even under strict evaluation rules on all nite input states, subsuming real encodings of data graphs in memory.""
  - ""We also reduce the decision procedure for predicates by depthrst search, like it is used in the resolution strategy of Prolog, to a coalgebraic representation.""
  - ""We give another algorithm that decides the inclusion of formulae in one xpoint model, given proper parametrization.""
  - ""Both algorithmic methods are presented in a way that allows implementation with the same technical means of cycle detection.""
  - ""This work provides exhaustive and self-contained foundations for the formal speci cation and e ective implementation of cyclical computations.""",,"- The abstract introduces a novel approach by replacing the traditional algebraic meta-theory with coalgebra, which is a significant theoretical contribution. This allows for distinguishing between cyclicity and infinity, a key insight in handling cyclic data.
 - The use of coalgebraic semantics is a departure from existing approaches like those in Haskell or Clean, which are based on lazy programming and allow infinitely descending subterm chains. This is a theoretical advancement beyond existing methods.
 - The work provides algorithms that can handle cyclic data under strict evaluation rules, which is a novel contribution as it addresses a limitation in traditional frameworks.
 - The integration of coalgebraic semantics with operational semantics geared towards traditional programming languages is a unique theoretical contribution, as it bridges the gap between declarative and functional programming paradigms.
 - The abstract mentions the development of algorithms for decision procedures and the inclusion of formulae in xpoint models, which are theoretical advancements in handling cyclic predicates.
 - The work provides a foundation for the formal specification and effective implementation of cyclic computations, which has potential implications for programming language design by offering a new framework for handling cyclic data."
Explorer Naturally Embedded Query Languages,"V. Tannen, P. Buneman, L. Wong",-,-,-,0,2014,"Not specified (the abstract implies conceptual primitives related to structural recursion, simple operators, and category theory, but does not explicitly define them)","- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Cartesian category with a strong monad
 - Proof techniques used: Equational theories, categorical ideas to derive identities
 - Limitations or constraints of the framework: Not specified","No specific integration approach described (the abstract discusses hierarchical derivation of sublanguages and use of category theory, but lacks explicit integration mechanisms or interaction models)",Generic programming not extensively addressed (the abstract discusses structural recursion and category theory but lacks specific details on genericity and abstraction mechanisms),"- Novel approach to programming language based on structural recursion on sets.
 - Progression of sublanguages with increasing expressive power and conceptual restrictions.
 - Absence of ""impedance mismatch problem"" due to shared semantic foundation.
 - Uniform characterization of nested relational and complex-object algebras using simple operators.
 - Use of category theory to organize semantics and syntax.
 - Algebraic perspective with equational theories for optimizations.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""",,"- The abstract discusses a programming language based on structural recursion on sets, which is a conceptual primitive in itself.
 - The progression of sublanguages with increasing expressive power suggests that these sublanguages are built upon conceptual primitives related to structural recursion.
 - The mention of ""surprisingly simple operators"" for characterizing nested relational and complex-object algebras implies that these operators are conceptual primitives.
 - The use of category theory to organize semantics and syntax suggests that categorical concepts, such as cartesian categories and strong monads, are also conceptual primitives.
 - The abstract does not provide explicit names or definitions for these primitives, but they are implied through the discussion of structural recursion, simple operators, and category theory concepts.","- ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""",,"- The abstract mentions the use of ""structural recursion on sets"" as the main computational engine, which suggests a focus on recursive functions and set theory.
 - The mention of ""category theory"" indicates that this is a key mathematical framework used in the paper. Category theory is a branch of mathematics that studies the commonalities and patterns between different mathematical structures.
 - The abstract describes the minimal language as a ""cartesian category with a strong monad on it,"" which are specific mathematical properties guaranteed by the framework. Cartesian categories are used to describe the structure of sets and functions, while strong monads are used to manage effects in programming languages.
 - The abstract also mentions ""equational theories"" and the use of categorical ideas to derive identities, which suggests that these are part of the proof techniques used.
 - There is no explicit mention of limitations or constraints of the framework in the abstract.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""First, there is no ""impedance mismatch problem; the query languages are already there, so they share common semantic foundation with the general language.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Third, we exhibit differences in expressive power that are not always based on complexity arguments, but use the idea that a query in one language may not be polymorphically expressible in another.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""",,"- The abstract discusses the integration of different programming paradigms by describing a progression of sublanguages with increasing expressive power. This suggests a hierarchical integration approach where more specific query languages are derived from a more general programming language.
 - The mention of ""no 'impedance mismatch problem'"" indicates that the integration approach avoids common issues of semantic mismatch between different paradigms, as they share a common semantic foundation.
 - The use of category theory to organize semantics and syntax provides a theoretical framework for integrating different paradigms, suggesting a structured approach to paradigm integration.
 - The abstract does not explicitly mention specific integration mechanisms or interaction models between paradigms, nor does it discuss constraints or challenges in paradigm integration.
 - The focus on equational theories and categorical ideas suggests novel translation or embedding techniques, but these are not explicitly described as integration mechanisms.","- ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""",,"- The abstract discusses the use of structural recursion on sets as the main computational engine, which suggests a focus on generic programming methodologies.
 - The mention of a ""progression of sublanguages"" with ""increasing expressive power"" and ""robust conceptual restrictions"" implies a mechanism for representing generic abstractions by gradually adding more expressive power.
 - The use of category theory to organize semantics and syntax, particularly the mention of a ""cartesian category with a strong monad,"" suggests a mechanism for abstraction.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the use of equational theories and categorical ideas for optimizations implies some form of static checking or optimization strategy.
 - The abstract does not provide a clear definition of ""concept"" used in the study, nor does it explicitly address minimal type requirements or detailed static checking strategies.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""First, there is no ""impedance mismatch problem; the query languages are already there, so they share common semantic foundation with the general language.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Third, we exhibit differences in expressive power that are not always based on complexity arguments, but use the idea that a query in one language may not be polymorphically expressible in another.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""",,"- The study introduces a novel approach by investigating a programming language based on structural recursion on sets, which is a unique theoretical contribution.
 - The progression of sublanguages with increasing expressive power and conceptual restrictions is a key novel insight, as it provides a framework for understanding query languages.
 - The absence of an ""impedance mismatch problem"" due to the shared semantic foundation between the general language and query languages is a significant theoretical advancement.
 - The uniform characterization of nested relational and complex-object algebras using simple operators is a theoretical innovation that simplifies comparisons of expressiveness.
 - The use of category theory to organize semantics and syntax, particularly with the minimal language being a cartesian category with a strong monad, is a theoretical contribution.
 - The algebraic perspective and the derivation of general identities for optimizations are additional theoretical advancements.
 - These contributions have potential implications for programming language design by providing a more integrated and theoretically sound framework for query languages."
Wherefore thou art … Semantics of Computation?,F. Honsell,-,-,-,0,2015,Not specified (the abstract discusses theoretical frameworks and methodologies but does not explicitly list specific conceptual primitives),"- Type of mathematical framework: Denotational Semantics, Type Theory, Category Theory
 - Specific mathematical properties guaranteed: Compositional-ity, Extensional and Referentially Transparent Semantics, Natural definitions of recursive objects, Fixed Point Induction
 - Proof techniques used: Fixed Point Induction
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The abstract provides a comprehensive overview of the quest for a ""Final Semantics"" in computing, emphasizing the need for formal semantics to ensure software correctness.
 - Theoretical advancements: It discusses the use of Denotational Semantics and the importance of compositional-ity and extensional semantics, which are significant theoretical approaches.
 - Potential implications: The methodology of Program Synthesis through Program Equivalence suggests potential implications for programming language design by capitalizing on the understanding of semantics as an equivalence relation.","- ""The power of digital simulation combined with the elementary simplicity of Universal Computational Models (e.g. Turing Machines, Church's λ-calculus, Curry's Combinatory Logic, cellular automata,""
  - ""To achieve correct software, i.e. software which meets its specifications, we need to establish a formal correspondence between low level peculiarities and higher level conceptual un-derstandings.""
  - ""This amounts to defining formal Semantics of programming languages [26] and addressing the related critical issue of adequacy of formalizations and encodings, which are ultimately irreducible to formalization [11, 12, 18].""
  - ""The initial paradigm, since the 60's, was that of Denotational Semantics: the meaning of a program is a function (an algorithm being a total function), whose behavior is captured by certain logical invariants called types or by observations.""
  - ""Every language component received a functional interpretation.""
  - ""Categorically speaking, this approach is syntax directed and can be termed initial semantics, in that the interpretation function is an initial algebra-morphism which maps uniquely the algebraic structure of the syntax, of the programming language, to a set of abstract entities called denotations.""
  - ""The crucial property of the interpretation function is compositional-ity, namely the (algebraic) inductive structure of the syntax is reflected by the semantics, which therefore must feature a similar, but conceptually independent, algebraic structure.""
  - ""Hence this semantics is extensional and referentially transparent.""
  - ""Denotations are usually morphisms in suitable categories such as, possibly higher order, topological spaces, or domains [24, 21, 22, 25].""
  - ""The added value of domains comes from the fact that they are endowed with an enriched structure.""
  - ""Semantics is, ultimately, just an equivalence relation, in fact a congruence relation.""",,"- The abstract discusses the importance of establishing formal semantics for programming languages to ensure software correctness.
 - It mentions the use of Denotational Semantics as a paradigm since the 1960s, which interprets programs as functions with behaviors captured by logical invariants like types or observations.
 - The abstract describes the interpretation function as an initial algebra-morphism that maps syntax to denotations, emphasizing compositional-ity and extensional semantics.
 - It highlights the role of domains in providing an enriched structure for recursive objects and approximations.
 - The abstract does not explicitly list specific conceptual primitives but discusses theoretical frameworks and methodologies related to semantics.","- ""The power of digital simulation combined with the elementary simplicity of Universal Computational Models (e.g. Turing Machines, Church's λ-calculus, Curry's Combinatory Logic, cellular automata,""
  - ""To achieve correct software, i.e. software which meets its specifications, we need to establish a formal correspondence between low level peculiarities and higher level conceptual un-derstandings.""
  - ""This amounts to defining formal Semantics of programming languages [26] and addressing the related critical issue of adequacy of formalizations and encodings, which are ultimately irreducible to formalization [11, 12, 18].""
  - ""The initial paradigm, since the 60's, was that of Denotational Semantics: the meaning of a program is a function (an algorithm being a total function), whose behavior is captured by certain logical invariants called types or by observations.""
  - ""This approach used λ-calculus, which is a theory of functions, as the canonical computational model.""
  - ""Categorically speaking, this approach is syntax directed and can be termed initial semantics, in that the interpretation function is an initial algebra-morphism which maps uniquely the algebraic structure of the syntax, of the programming language, to a set of abstract entities called denotations.""
  - ""The crucial property of the interpretation function is compositional-ity, namely the (algebraic) inductive structure of the syntax is reflected by the semantics, which therefore must feature a similar, but conceptually independent, algebraic structure.""
  - ""Hence this semantics is extensional and referentially transparent.""
  - ""Denotations are usually morphisms in suitable categories such as, possibly higher order, topological spaces, or domains [24, 21, 22, 25].""
  - ""The added value of domains comes from the fact that they are endowed with an enriched structure.""
  - ""This allows for natural definitions of recursive objects, since all endomorphisms have fixed points and for approximations, and hence for new proof principles for reasoning on programs, such as Fixed Point Induction.""
  - ""Semantics is, ultimately, just an equivalence relation, in fact a congruence relation.""
  - ""The methodology of Program Synthesis through Program Equivalence capitalizes on this understanding of semantics.""",,"- The abstract discusses the use of ""Universal Computational Models"" such as Turing Machines and λ-calculus, indicating a theoretical foundation in these models.
 - The mention of ""Denotational Semantics"" suggests a type of mathematical framework focused on assigning meanings to programs as functions.
 - The use of λ-calculus as a ""canonical computational model"" implies a reliance on type theory.
 - The abstract describes the framework as ""syntax directed"" and ""initial semantics,"" which aligns with category theory, as it involves mapping syntax to abstract entities called denotations.
 - The framework is characterized by ""compositional-ity,"" which is a key property in ensuring that the semantics reflect the algebraic structure of the syntax.
 - The abstract mentions that denotations are morphisms in categories such as topological spaces or domains, indicating the use of category theory.
 - The framework allows for ""natural definitions of recursive objects"" and ""new proof principles for reasoning on programs,"" such as Fixed Point Induction, which are specific mathematical properties guaranteed by the framework.
 - The abstract does not explicitly mention limitations or constraints of the framework.","- ""The power of digital simulation combined with the elementary simplicity of Universal Computational Models (e.g. Turing Machines, Church's λ-calculus, Curry's Combinatory Logic, cellular automata,""
  - ""To achieve correct software, i.e. software which meets its specifications, we need to establish a formal correspondence between low level peculiarities and higher level conceptual un-derstandings.""
  - ""This amounts to defining formal Semantics of programming languages [26] and addressing the related critical issue of adequacy of formalizations and encodings, which are ultimately irreducible to formalization [11, 12, 18].""
  - ""The initial paradigm, since the 60's, was that of Denotational Semantics: the meaning of a program is a function (an algorithm being a total function), whose behavior is captured by certain logical invariants called types or by observations.""
  - ""Categorically speaking, this approach is syntax directed and can be termed initial semantics, in that the interpretation function is an initial algebra-morphism which maps uniquely the algebraic structure of the syntax, of the programming language, to a set of abstract entities called denotations.""
  - ""Semantics is, ultimately, just an equivalence relation, in fact a congruence relation.""
  - ""The methodology of Program Synthesis through Program Equivalence capitalizes on this understanding of semantics.""",,"- The abstract discusses the use of Universal Computational Models and the need for formal semantics to ensure correct software. This suggests a focus on theoretical integration strategies rather than specific integration mechanisms or interaction models between paradigms.
 - The mention of Denotational Semantics and its syntax-directed approach indicates a theoretical framework for understanding programming languages, but it does not explicitly address the integration of different programming paradigms.
 - The abstract does not provide specific integration mechanisms, interaction models, constraints, or novel translation techniques related to paradigm integration.
 - The focus on semantics and program equivalence suggests a theoretical approach to understanding programming languages, but it does not explicitly describe an integration approach for different paradigms.","- ""The power of digital simulation combined with the elementary simplicity of Universal Computational Models (e.g. Turing Machines, Church's λ-calculus, Curry's Combinatory Logic, cellular automata,""
  - ""To achieve correct software, i.e. software which meets its specifications, we need to establish a formal correspondence between low level peculiarities and higher level conceptual un-derstandings.""
  - ""This amounts to defining formal Semantics of programming languages [26] and addressing the related critical issue of adequacy of formalizations and encodings, which are ultimately irreducible to formalization [11, 12, 18].""
  - ""The initial paradigm, since the 60's, was that of Denotational Semantics: the meaning of a program is a function (an algorithm being a total function), whose behavior is captured by certain logical invariants called types or by observations.""
  - ""Every language component received a functional interpretation.""
  - ""Categorically speaking, this approach is syntax directed and can be termed initial semantics, in that the interpretation function is an initial algebra-morphism which maps uniquely the algebraic structure of the syntax, of the programming language, to a set of abstract entities called denotations.""
  - ""The crucial property of the interpretation function is compositional-ity, namely the (algebraic) inductive structure of the syntax is reflected by the semantics, which therefore must feature a similar, but conceptually independent, algebraic structure.""
  - ""Hence this semantics is extensional and referentially transparent.""
  - ""Denotations are usually morphisms in suitable categories such as, possibly higher order, topological spaces, or domains [24, 21, 22, 25].""
  - ""The added value of domains comes from the fact that they are endowed with an enriched structure.""
  - ""This allows for natural definitions of recursive objects, since all endomorphisms have fixed points and for approximations, and hence for new proof principles for reasoning on programs, such as Fixed Point Induction.""",,"- The abstract discusses the use of denotational semantics, which involves interpreting the meaning of a program as a function. This is a form of abstraction where the focus is on the functional behavior rather than the specific implementation details.
 - The mention of ""types or by observations"" suggests a mechanism for representing generic abstractions, as types can be used to define generic interfaces or behaviors.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does discuss the compositional nature of the interpretation function, which implies a structured approach to abstraction.
 - The use of domains and their enriched structure suggests a mechanism for representing generic abstractions, as domains can provide a framework for defining recursive objects and approximations.
 - The abstract does not explicitly address generic programming methodology or type system discussions in detail, but it does provide insights into abstraction mechanisms through denotational semantics.","- ""The power of digital simulation combined with the elementary simplicity of Universal Computational Models (e.g. Turing Machines, Church's λ-calculus, Curry's Combinatory Logic, cellular automata, …) is apparently the Pythagorean dream made true, but because of the remoteness and gratuitousness of Computational Models it is also the original sin of Computing.""
  - ""To achieve correct software, i.e. software which meets its specifications, we need to establish a formal correspondence between low level peculiarities and higher level conceptual un-derstandings.""
  - ""This amounts to defining formal Semantics of programming languages [26] and addressing the related critical issue of adequacy of formalizations and encodings, which are ultimately irreducible to formalization [11, 12, 18].""
  - ""I will try to outline a brief history of the quest for a Final Semantics in Computing.""
  - ""The initial paradigm, since the 60's, was that of Denotational Semantics: the meaning of a program is a function (an algorithm being a total function), whose behavior is captured by certain logical invariants called types or by observations.""
  - ""Categorically speaking, this approach is syntax directed and can be termed initial semantics, in that the interpretation function is an initial algebra-morphism which maps uniquely the algebraic structure of the syntax, of the programming language, to a set of abstract entities called denotations.""
  - ""The crucial property of the interpretation function is compositional-ity, namely the (algebraic) inductive structure of the syntax is reflected by the semantics, which therefore must feature a similar, but conceptually independent, algebraic structure.""
  - ""Hence this semantics is extensional and referentially transparent.""
  - ""Semantics is, ultimately, just an equivalence relation, in fact a congruence relation.""
  - ""The methodology of Program Synthesis through Program Equivalence capitalizes on this understanding of semantics.""",,"- The abstract discusses the need for formal semantics in programming languages to ensure software correctness, which is a key theoretical contribution.
 - It outlines the history of the quest for a ""Final Semantics"" in computing, indicating a comprehensive theoretical framework.
 - The abstract highlights the use of Denotational Semantics as an initial paradigm, which is a significant theoretical approach.
 - The emphasis on compositional-ity and the extensional nature of semantics suggests a theoretical advancement in understanding how programming languages are interpreted.
 - The mention of semantics as an equivalence relation and the methodology of Program Synthesis through Program Equivalence indicates a novel insight into how programs can be synthesized and compared.
 - The abstract does not explicitly mention new theoretical contributions beyond existing approaches, but it implies a deepening understanding of existing theoretical frameworks."
Structural Recursion as a Query Language,"V. Tannen, P. Buneman, S. Naqvi",-,-,International Workshop/Symposium on Database Programming Languages,182,1992,"1. Primitive Name: Structural Recursion
  Definition: Main computational engine using structural recursion on sets.
  Orthogonality Score: Not specified
 2. Primitive Name: Typed Lambda Calculus
  Definition: Programming within a ""nicely"" typed lambda calculus.
  Orthogonality Score: Not specified
 3. Primitive Name: Query Implementation
  Definition: Emphasis on how queries are implemented.
  Orthogonality Score: Not specified
 4. Primitive Name: Scalability to Complex-Object Models
  Definition: Ability to scale up to complex-object models.
  Orthogonality Score: Not specified
 5. Primitive Name: Efficient Set Operations
  Definition: Efficient programs for operations like transitive closure.
  Orthogonality Score: Not specified","- Type of mathematical framework: Type theory (lambda calculus)
 - Specific mathematical properties guaranteed: Total map taking finite relations to finite relations
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Structural recursion on sets as the main computational engine.
 - Interaction models between paradigms: Scaling up to handle complex-object models.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Combining semantic simplicity of relational algebra with expressive power of unrestricted programming languages.
 - Theoretical advancements: Structural recursion on sets as the main computational engine; restricted class of programs with the same expressive power as relational algebra; scalability to complex-object models.
 - Potential implications for programming language design: Finer grain programming leading to better optimization.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a “nicely” typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The same programming paradigm scales up, yielding query languages for the complex-object model [AB89].""
  - ""Beyond that, there are, for example, efficient programs for transitive closure and we are also able to write programs that move out of sets, and then perhaps back to sets, as long as we stay within a (quite flexible) type system.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""In fact, structural recursion yields finer grain programming therefore we expect that lower-level, and therefore better optimization will be feasible.""",,"- The abstract discusses a programming paradigm that combines the simplicity of relational algebra with the expressiveness of unrestricted programming languages. This suggests a focus on structural recursion as a key conceptual primitive.
 - Structural recursion on sets is explicitly mentioned as the main computational engine, indicating it is a fundamental primitive in this paradigm.
 - The use of a ""nicely"" typed lambda calculus suggests another primitive related to typing, which is crucial for ensuring semantic simplicity and expressiveness.
 - The emphasis on how queries are implemented and the ability to scale up to complex-object models implies that these are also conceptual primitives, as they define how the paradigm operates and its scope.
 - The mention of efficient programs for transitive closure and moving out of sets suggests additional primitives related to set operations and type flexibility.
 - The abstract does not provide explicit definitions or orthogonality scores for these primitives, but they are implied as foundational elements of the proposed paradigm.","- ""All programming is done within a “nicely” typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""As in relational algebra, the meaning of any relation transformer is guaranteed to be a total map taking finite relations to finite relations.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming therefore we expect that lower-level, and therefore better optimization will be feasible.""",,"- The abstract mentions that all programming is done within a ""nicely"" typed lambda calculus, which suggests that the mathematical framework used is type theory.
 - The mention of ""nicely"" typed lambda calculus indicates a focus on ensuring that programs are well-typed, which is a characteristic of type theory.
 - The abstract guarantees that the meaning of any relation transformer is a total map taking finite relations to finite relations, which is a specific mathematical property related to relational algebra.
 - The abstract does not explicitly mention proof techniques or limitations of the framework, but it does suggest that the framework is designed to ensure certain properties like total maps and expressive power.
 - The abstract does not provide detailed information on proof methodology or formal verification discussions, but it implies a focus on structural recursion and type theory.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a “nicely” typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The same programming paradigm scales up, yielding query languages for the complex-object model [AB89].""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""",,"- The abstract discusses a programming paradigm that integrates elements from relational algebra and unrestricted programming languages, aiming for both simplicity and expressive power.
 - The main integration mechanism proposed is structural recursion on sets, which is used as the computational engine.
 - The use of a ""nicely"" typed lambda calculus suggests a theoretical integration strategy that ensures type consistency across different programming paradigms.
 - The paradigm scales up to handle complex-object models, indicating an interaction model where structural recursion is applied across different data models.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.
 - The focus on optimization suggests that the integration approach is designed to facilitate better optimization, but specific techniques or challenges are not detailed.","- ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a “nicely” typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The same programming paradigm scales up, yielding query languages for the complex-object model [AB89].""
  - ""Beyond that, there are, for example, efficient programs for transitive closure and we are also able to write programs that move out of sets, and then perhaps back to sets, as long as we stay within a (quite flexible) type system.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""In fact, structural recursion yields finer grain programming therefore we expect that lower-level, and therefore better optimization will be feasible.""",,"- The abstract discusses the use of structural recursion on sets as the main computational engine, which suggests a focus on recursive programming rather than generic programming.
 - The mention of programming within a ""nicely"" typed lambda calculus indicates a structured approach to programming, but it does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not provide a definition of ""concept"" used in the context of generic programming.
 - There is no explicit mention of mechanisms for representing generic abstractions or minimal type requirements.
 - The abstract does not discuss static checking or optimization strategies in the context of generic programming.
 - The focus is on structural recursion and its expressive power rather than on generic programming or abstraction mechanisms.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The same programming paradigm scales up, yielding query languages for the complex-object model""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming therefore we expect that lower-level, and therefore better optimization will be feasible.""",,"- The abstract introduces a new programming paradigm that combines the simplicity of relational algebra with the expressiveness of unrestricted programming languages, which is a novel insight.
 - The use of structural recursion on sets as the main computational engine is a theoretical advancement, as it provides a new way to approach programming.
 - The fact that a restricted class of programs using structural recursion has the same expressive power as relational algebra is a significant theoretical contribution, as it bridges two different programming paradigms.
 - The scalability of this paradigm to complex-object models is another theoretical advancement, as it expands the applicability of the approach.
 - The potential for better optimization due to finer grain programming is a key implication for programming language design, suggesting that this paradigm could lead to more efficient programming practices."
Embedding an object calculus in the unifying theories of programming,J. Gibbons,-,-,-,0,2010,"1. Primitive Name: Object-based object orientation
  Definition: An extension to the UTP to include object-based object orientation, contrasting with existing class-based models.
  Orthogonality Score: Not discussed
 2. Primitive Name: Value- and reference-based objects
  Definition: Objects that can be represented as both value-based and reference-based in the UTP.
  Orthogonality Score: Not discussed
 3. Primitive Name: Fully abstract model of references
  Definition: An alternative model of pointers (references) that supports both value-based compound values and references.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Relational predicate logic (UTP)
 - Specific mathematical properties guaranteed: Fully abstract model of references
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Embedding of Abadi-Cardelli-style object calculus into the UTP; extension of UTP with object-based object orientation; alternative model of pointers (references) supporting value-based and reference-based objects.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Embedding of Abadi-Cardelli-style object calculus into the UTP.",Generic programming not extensively addressed,"- Key novel insights: Embedding an Abadi-Cardelli-style object calculus in the UTP to address the gap in object-based object-orientation.
 - Theoretical advancements: Extending the UTP with object-based object orientation, providing an alternative model of pointers that supports both value-based and reference-based compound values, and modeling an Abadi-Cardelli notion of an object in the UTP.
 - Potential implications: Enhancing the UTP as a unifying theory for programming language design by incorporating object-based object-orientation and improving the model of references.","- ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent
 

 programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""",,"- The abstract discusses the Unifying Theories of Programming (UTP) and its extension to include object-based object orientation, which is a conceptual primitive.
 - The study embeds an Abadi--Cardelli-style object calculus in the UTP, which is another conceptual primitive.
 - The abstract mentions ""value- and reference-based objects"" and ""a fully abstract model of references,"" which are specific conceptual primitives related to object orientation.
 - The contributions include extending the UTP with object-based object orientation and providing an alternative model of pointers, which are conceptual primitives.
 - The abstract does not provide explicit definitions for these primitives in terms of mathematical or formal definitions, but they are described in terms of their functionality and role in the UTP framework.","- ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent
 

 programming (or reactive systems), class-based object-orientation, and transaction processing.""",,"- The abstract mentions the use of the Unifying Theories of Programming (UTP) as a mathematical framework, which is based on relational predicates. This indicates that the type of mathematical framework used is relational predicate logic.
 - The UTP is described as providing a rich model for various programming formalisms, suggesting that it is a comprehensive framework for formalizing programming concepts.
 - The abstract discusses the embedding of an object calculus within the UTP, which implies that the framework is capable of supporting object-based object orientation with value- and reference-based objects.
 - The mention of a ""fully abstract model of references"" suggests that the framework guarantees specific mathematical properties related to references and object modeling.
 - The abstract does not explicitly mention specific proof techniques or limitations of the framework, but it does highlight the extension and unification of object formalisms within the UTP.","- ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent
 

 programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We believe that the UTP ought to be able to represent all significant computer programming language formalisms, in order for it to be considered a unifying theory.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""",,"- The abstract discusses the integration of different programming paradigms within the Unifying Theories of Programming (UTP) framework.
 - The UTP is described as a framework that can model various programming formalisms, indicating a broad integration approach.
 - The study specifically addresses the integration of object-based object-orientation by embedding an Abadi-Cardelli-style object calculus into the UTP.
 - The abstract mentions extending the UTP with object-based object orientation, which is a specific integration mechanism.
 - The study provides an alternative model of pointers (references) that supports both value-based and reference-based objects, which is another integration mechanism.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration.
 - The novel translation or embedding technique is the embedding of the Abadi-Cardelli-style object calculus into the UTP.","- ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent
 

 programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""",,"- The abstract discusses the Unifying Theories of Programming (UTP) and its extension to include object-based object orientation, which is a form of abstraction.
 - The focus is on embedding an object calculus into the UTP, which involves modeling programs as objects and references, indicating a form of conceptual abstraction.
 - The abstract mentions extending the UTP with object-based object orientation and providing an alternative model of pointers, which suggests mechanisms for representing generic abstractions.
 - However, there is no explicit mention of generic programming methodology, type system discussions, or specific mechanisms for genericity and abstraction beyond the object calculus embedding.
 - The abstract does not provide details on minimal type requirements or static checking/optimization strategies related to generic programming.","- ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""",,"- The abstract identifies a gap in the Unifying Theories of Programming (UTP) regarding object-based object-orientation, which is addressed by embedding an Abadi-Cardelli-style object calculus into the UTP. This is a key novel insight as it extends the UTP to include object-based object-orientation.
 - The theoretical advancement is the extension of the UTP with object-based object orientation, contrasting with existing class-based models. This is a significant theoretical contribution as it broadens the scope of the UTP.
 - The provision of an alternative model of pointers (references) that supports both value-based and reference-based compound values is another theoretical advancement. This contrasts with existing UTP models that only support reference-based compound values.
 - The modeling of an Abadi-Cardelli notion of an object in the UTP demonstrates its ability to unify different object formalisms, which is a theoretical innovation.
 - The potential implications for programming language design include a more comprehensive framework for modeling various programming paradigms and features, enhancing the UTP's role as a unifying theory."
Multiparadigm Programming in Oz,"Martin Müller, Tobias M. Muller, Peter German",-,-,-,23,1995,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),"- Specific integration mechanisms proposed: Oz language provides a common underlying foundation for multiple programming styles.
 - Interaction models between paradigms: Illustrated with paradigmatical code examples.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: The lack of a strong foundation for programming paradigms outside Prolog's declarative subset.
 - Theoretical advancements: Providing a foundation for multiparadigm programming and using a simple formal model in the concurrent constraint paradigm to unify multiple programming styles.
 - Potential implications: More versatile and integrated programming languages that support multiple paradigms.","- ""The foundation of Prolog's success is the high abstraction level of its declarative subset, namely rst-order Horn clause logic with SLDNF resolution.""
  - ""We illustrate the integrative programming model with paradigmatical code examples.""
  - ""We give a foundation for multiparadigmprogramming and we show how it is realized in the Oz language and system.""
  - ""Oz naturally encompasses multiple styles of programming, including (constraint) logic, functional, and concurrent object-oriented programming, by providing a common underlying foundation for these styles through a simple formal model in the concurrent constraint paradigm.""
  - ""We argue that multiparadigmprogramming can remedy this lack.""",,"- The abstract discusses the foundation of Prolog and its limitations, suggesting that multiparadigm programming is a solution.
 - It mentions that the Oz language provides a common underlying foundation for multiple programming styles, which implies a conceptual framework or primitives.
 - The abstract refers to a ""simple formal model in the concurrent constraint paradigm,"" which could be considered a conceptual primitive.
 - However, the abstract does not explicitly list or define specific conceptual primitives.
 - The focus is on the integration of programming paradigms rather than detailing specific primitives.","- ""The foundation of Prolog's success is the high abstraction level of its declarative subset, namely rst-order Horn clause logic with SLDNF resolution.""
  - ""Oz naturally encompasses multiple styles of programming, including (constraint) logic, functional, and concurrent object-oriented programming, by providing a common underlying foundation for these styles through a simple formal model in the concurrent constraint paradigm.""
  - ""We give a foundation for multiparadigmprogramming and we show how it is realized in the Oz language and system.""",,"- The abstract mentions the ""high abstraction level of its declarative subset, namely rst-order Horn clause logic with SLDNF resolution,"" which suggests a theoretical foundation related to logic programming.
 - It states that the authors ""give a foundation for multiparadigmprogramming,"" indicating that there is some form of theoretical or mathematical framework being discussed.
 - The mention of ""a simple formal model in the concurrent constraint paradigm"" suggests that the mathematical framework is related to concurrent constraint programming.
 - However, the abstract does not specify the type of mathematical framework (e.g., type theory, category theory), nor does it detail specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The abstract focuses more on the conceptual and programming aspects rather than providing explicit details about the mathematical framework.","- ""Oz naturally encompasses multiple styles of programming, including (constraint) logic, functional, and concurrent object-oriented programming, by providing a common underlying foundation for these styles through a simple formal model in the concurrent constraint paradigm.""
  - ""We give a foundation for multiparadigmprogramming and we show how it is realized in the Oz language and system.""
  - ""We illustrate the integrative programming model with paradigmatical code examples.""
  - ""We argue that multiparadigmprogramming can remedy this lack.""",,"- The abstract mentions that multiparadigm programming is proposed as a solution to the limitations of Prolog, indicating an integration approach.
 - It states that a foundation for multiparadigm programming is provided, suggesting a theoretical integration strategy.
 - The Oz language is described as encompassing multiple programming styles, including logic, functional, and concurrent object-oriented programming, through a common underlying foundation. This implies a specific integration mechanism.
 - The use of a ""simple formal model in the concurrent constraint paradigm"" suggests a theoretical integration strategy.
 - The mention of ""paradigmatical code examples"" implies interaction models between paradigms, but specific details are not provided in the abstract.
 - There is no explicit mention of constraints or challenges in paradigm integration, nor are there details on novel translation or embedding techniques.","- ""The foundation of Prolog's success is the high abstraction level of its declarative subset, namely rst-order Horn clause logic with SLDNF resolution.""
  - ""What's missing from Prolog is that little attempt is made to give the same foundation to anything outside the declarative subset.""
  - ""We argue that multiparadigmprogramming can remedy this lack.""
  - ""We give a foundation for multiparadigmprogramming and we show how it is realized in the Oz language and system.""
  - ""Oz naturally encompasses multiple styles of programming, including (constraint) logic, functional, and concurrent object-oriented programming, by providing a common underlying foundation for these styles through a simple formal model in the concurrent constraint paradigm.""
  - ""We illustrate the integrative programming model with paradigmatical code examples.""",,"- The abstract discusses the high abstraction level of Prolog's declarative subset but notes that this abstraction is not extended beyond this subset.
 - It suggests that multiparadigm programming can address this limitation, implying a broader approach to abstraction.
 - The Oz language is presented as a solution that provides a common foundation for multiple programming styles, which could be related to generic programming.
 - However, the abstract does not explicitly mention generic programming or provide details on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus is on multiparadigm programming and its realization in Oz, rather than specific generic programming methodologies or type system discussions.","- ""The foundation of Prolog's success is the high abstraction level of its declarative subset, namely rst-order Horn clause logic with SLDNF resolution.""
  - ""What's missing from Prolog is that little attempt is made to give the same foundation to anything outside the declarative subset.""
  - ""Oz naturally encompasses multiple styles of programming, including (constraint) logic, functional, and concurrent object-oriented programming, by providing a common underlying foundation for these styles through a simple formal model in the concurrent constraint paradigm.""
  - ""We give a foundation for multiparadigmprogramming and we show how it is realized in the Oz language and system.""
  - ""We argue that multiparadigmprogramming can remedy this lack.""",,"- The abstract identifies a limitation in Prolog, which is the lack of a strong foundation for programming paradigms outside its declarative subset. This is a key insight into the current state of programming languages.
 - The authors propose multiparadigm programming as a solution to this limitation, which is a novel approach to integrating different programming styles.
 - The abstract mentions that they provide a foundation for multiparadigm programming, which is a theoretical advancement beyond existing approaches that typically focus on a single paradigm.
 - The use of a simple formal model in the concurrent constraint paradigm to unify multiple programming styles is a theoretical innovation, as it provides a common underlying foundation for different styles.
 - The potential implications for programming language design are significant, as this approach could lead to more versatile and integrated programming languages that support multiple paradigms."
Logical reconstruction of programming language paradigms,D. Lauc,-,-,-,0,2013,"1. Primitive Name: Imperative Paradigm
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 2. Primitive Name: Function Paradigm
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 3. Primitive Name: Logical Paradigm
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 4. Primitive Name: Degree of Modularity
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed",Not specified (the abstract does not provide explicit details about the mathematical framework used),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The use of logical reconstruction to model programming paradigms, visualization of programming languages as a prism with specific dimensions.
 - Theoretical advancements: Providing a structured framework for understanding programming paradigms, categorizing languages based on imperative, function, logical paradigms, and modularity.
 - Potential implications: Offering a comprehensive framework for designing new programming languages or evaluating existing ones based on completeness and modularity.","- ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""
  - ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""
  - ""Finally, the model is evaluated for completeness with regard to existing programming languages.""
  - ""Actual programming languages are represented as occupying some space in such a model.""",,"- The abstract mentions the use of ""original logical models of computation"" to model programming paradigms, which suggests that these models are conceptual primitives.
 - The ""space of the programming languages"" is visualized as a prism with edges representing ""imperative, function and logical paradigms,"" indicating these are basic models or primitives.
 - The ""depth axis as degree of modularity of languages"" suggests another primitive related to modularity.
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality.
 - The study seems to focus on these paradigms and modularity as conceptual primitives for reconstructing programming paradigms.","- ""Finally, the model is evaluated for completeness with regard to existing programming languages.""
  - ""Actual programming languages are represented as occupying some space in such a model.""
  - ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""
  - ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""",,"- The abstract mentions the use of ""logical reconstruction"" and ""original logical models of computation,"" which suggests a focus on logical frameworks.
 - The visualization of programming languages as a prism with specific axes (imperative, function, logical paradigms, and modularity) implies a structured approach to modeling, but it does not explicitly mention a specific mathematical framework like type theory or category theory.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations/constraints of the framework in the abstract.
 - The abstract does not provide details about the theoretical foundations, proof methodology, or formal verification discussions, which are typically where mathematical framework characteristics would be described.","- ""Finally, the model is evaluated for completeness with regard to existing programming languages.""
  - ""Actual programming languages are represented as occupying some space in such a model.""
  - ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""
  - ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""",,"- The abstract discusses the modeling of programming paradigms using logical reconstruction, which suggests a theoretical approach to understanding how different paradigms relate to each other.
 - The visualization of the programming language space as a prism with edges representing different paradigms (imperative, function, and logical) implies a framework for understanding how these paradigms interact or integrate.
 - The mention of ""degree of modularity of languages"" as a depth axis suggests a consideration of how modular different languages are, which could relate to integration challenges or mechanisms.
 - However, the abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques. It focuses more on the modeling and visualization of paradigms rather than their integration.","- ""Finally, the model is evaluated for completeness with regard to existing programming languages.""
  - ""Actual programming languages are represented as occupying some space in such a model.""
  - ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""
  - ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""",,"- The abstract discusses the concept of programming language paradigms and their logical reconstruction, which suggests a focus on conceptual abstraction.
 - The use of ""logical models of computation"" and ""paradigms of programming language paradigms"" implies a method for representing abstractions, but it does not specifically address generic programming or type systems.
 - The visualization of programming languages as a prism with edges representing different paradigms and a depth axis for modularity suggests a mechanism for conceptual abstraction, but again, it does not explicitly mention generic programming or type requirements.
 - There is no mention of generic programming methodology, type system discussions, or specific mechanisms for representing generic abstractions in the abstract.
 - The abstract does not provide information on minimal type requirements or static checking/optimization strategies related to generic programming.","- ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""
  - ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""
  - ""Finally, the model is evaluated for completeness with regard to existing programming languages.""
  - ""Actual programming languages are represented as occupying some space in such a model.""",,"- The abstract mentions that the current understanding of programming language paradigms is ""chaotic,"" indicating a need for a new approach to clarify and organize these concepts.
 - The use of ""logical reconstruction"" to model programming paradigms suggests a novel theoretical contribution by providing a structured framework for understanding these paradigms.
 - The visualization of programming languages as a prism with specific dimensions (imperative, function, logical paradigms, and modularity) offers a unique theoretical insight into how these languages can be categorized and understood.
 - The representation of actual programming languages within this model implies a theoretical advancement in how these languages are conceptualized and compared.
 - The evaluation of the model for completeness regarding existing programming languages suggests a potential implication for programming language design, as it could provide a comprehensive framework for designing new languages or evaluating existing ones."
Embedding an object calculus in the unifying theories of programming,M. Smith,-,-,-,0,2010,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Unifying Theories of Programming (UTP) based on relational predicates
 - Specific mathematical properties guaranteed: Ability to model value- and reference-based objects, fully abstract model of references
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Embedding of Abadi-Cardelli-style object calculus into the UTP.
 - Interaction models between paradigms: Extending UTP with object-based object orientation, contrasting with class-based models.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Alternative model of pointers supporting value-based and reference-based objects.",Generic programming not extensively addressed,"- Key novel insights: Embedding an Abadi--Cardelli-style object calculus in the UTP to address the gap in object-based object-orientation.
 - Theoretical advancements: Extending the UTP with object-based object orientation, providing an alternative model of pointers that supports both value-based and reference-based objects, and modeling an Abadi-Cardelli notion of an object.
 - Potential implications for programming language design: Enhancing the UTP's ability to model various programming paradigms, providing a more comprehensive framework for programming language design.","- ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""",,"- The abstract discusses the Unifying Theories of Programming (UTP) and its ability to model various programming paradigms.
 - It highlights a gap in the UTP regarding object-based object-orientation and addresses this by embedding an Abadi--Cardelli-style object calculus.
 - The abstract mentions extending the UTP with object-based object orientation, which includes value- and reference-based objects and a fully abstract model of references.
 - The contributions include extending the UTP with object-based object orientation, providing an alternative model of pointers, and modeling an Abadi-Cardelli notion of an object.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It discusses the integration of object-based object orientation and alternative models of pointers but does not provide a detailed list of primitives.","- ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""",,"- The abstract mentions the use of the Unifying Theories of Programming (UTP) as a mathematical framework, which is based on relational predicates. This indicates the type of mathematical framework used.
 - The UTP is described as providing models for various programming formalisms, suggesting its versatility and ability to formalize different programming paradigms.
 - The abstract discusses the embedding of an object calculus within the UTP, which implies the use of formal verification techniques to ensure the properties of these conceptual primitives.
 - The mention of extending the UTP with object-based object orientation and providing an alternative model of pointers suggests specific mathematical properties being guaranteed, such as the ability to model value- and reference-based objects.
 - The abstract does not explicitly mention specific proof techniques or limitations of the framework, but it does highlight the contributions made to the UTP, which include extending its capabilities and providing a fully abstract model of references.","- ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We believe that the UTP ought to be able to represent all significant computer programming language formalisms, in order for it to be considered a unifying theory.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""",,"- The abstract discusses the integration of different programming paradigms through the Unifying Theories of Programming (UTP), which is designed to provide a single framework for modeling various programming formalisms.
 - The UTP already includes models for several paradigms such as imperative, higher-order, concurrent, class-based object-orientation, and transaction processing.
 - The study addresses a gap in the UTP by embedding an object-based object-orientation (Abadi-Cardelli-style object calculus) into the UTP, which is a specific integration mechanism.
 - The interaction model involves extending the UTP with object-based object orientation, contrasting with existing class-based models.
 - The study provides an alternative model of pointers (references) that supports both value-based and reference-based objects, which is a novel translation or embedding technique.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the extension and unification of different formalisms as contributions.","- ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""",,"- The abstract discusses the Unifying Theories of Programming (UTP) and its extension with object-based object orientation, which involves modeling programs as relational predicates and embedding an object calculus.
 - The focus is on integrating object-based object orientation into the UTP, which is a form of abstraction but not specifically generic programming.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanisms specifically related to genericity.
 - The abstract does not provide information on mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""",,"- The abstract identifies a gap in the Unifying Theories of Programming (UTP) regarding object-based object-orientation, which is addressed by embedding an Abadi--Cardelli-style object calculus into the UTP. This is a key novel insight as it extends the UTP's capabilities.
 - The first contribution is extending the UTP with object-based object orientation, which contrasts with existing class-based models. This is a theoretical advancement as it provides a new perspective within the UTP framework.
 - The second contribution involves providing an alternative model of pointers that supports both value-based and reference-based objects. This is a theoretical innovation as it enhances the UTP's ability to model complex programming concepts.
 - The third contribution is modeling an Abadi-Cardelli notion of an object within the UTP, demonstrating its ability to unify different object formalisms. This has potential implications for programming language design by providing a more comprehensive framework for modeling various programming paradigms.
 - These contributions collectively represent a significant theoretical advancement beyond existing approaches by enhancing the UTP's scope and applicability to different programming formalisms."
Semantic and Logical Properties of Stateful Programming,Cristiano Calcagno,-,-,-,5,2002,"1. Primitive Name: Component Substitution
  Definition: A device to address aliasing and dangling pointers, allowing for the development of axioms for memory allocation and disposal.
  Orthogonality Score: Not discussed
 2. Primitive Name: Region Calculus
  Definition: A formalism for automatic memory management.
  Orthogonality Score: Not discussed
 3. Primitive Name: Closed Type
  Definition: A generalization of closed type-constructor, ensuring values of closed type are not necessarily closed but their free variables must be dead code.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Hoare logic, region calculus
 - Specific mathematical properties guaranteed: soundness, type safety, full abstraction
 - Proof techniques used: stratified semantics, direct proof of type safety
 - Limitations or constraints of the framework: Not explicitly mentioned",No specific integration approach described,Generic programming not extensively addressed,"- Novel use of component substitution to devise axioms for memory allocation and disposal.
 - Analysis of garbage-insensitive propositions and soundness of Hoare logic rules for garbage collecting semantics.
 - Introduction of two simpler approaches for proving type safety.
 - Concept of ""closed type"" as a generalization of ""closed type-constructor"" with the property that values of closed type do not necessarily have to be closed but must have dead code as free variables.
 - Theoretical advancements in multi-staged programming with ML-style references.","- ""we identify the major sources of difficulty as aliasing and dangling pointers, and examine the device of component substitution (dating back to Morris) to address them; a novel use of component substitution allows us to devise axioms for operations that allocate and dispose of memory.""
  - ""Our main contribution here is the introduction of the notion of closed type as a generalization of closed type-constructor.""
  - ""Part III is a study of multi-staged programming – a paradigm providing support for building, combining and executing code at runtime – in the presence of ML-style references.""
  - ""We propose two approaches, simpler than previous ones, for proving type safety.""
  - ""Part II is dedicated to the study of a particular formalism for automatic memory management: the region calculus of Tofte and Talpin.""
  - ""Our main results include an analysis of propositions that are garbage insensitive, soundness of Hoare logic rules for a garbage collecting semantics, and full abstraction results connecting partial and total correctness to two natural notions of observational equivalence between programs.""
  - ""This thesis studies various aspects of the theory of programming languages with imperative operations on a global store.""",,"- The abstract discusses several key concepts related to programming languages, particularly focusing on imperative operations and memory management.
 - The mention of ""aliasing and dangling pointers"" and the use of ""component substitution"" suggests these are conceptual primitives related to memory management.
 - The ""region calculus of Tofte and Talpin"" is another conceptual framework discussed, which is a formalism for automatic memory management.
 - The introduction of the ""notion of closed type as a generalization of closed type-constructor"" in the context of multi-staged programming is a conceptual primitive related to ensuring code safety and execution.
 - These concepts are not explicitly labeled as ""conceptual primitives"" in the abstract, but they represent fundamental ideas and frameworks used in the study.","- ""This thesis studies various aspects of the theory of programming languages with imperative operations on a global store.""
  - ""we present and study a number of problems that arise when reasoning about imperative languages with pointers, with special emphasis on program logic in the style of Hoare.""
  - ""a novel use of component substitution allows us to devise axioms for operations that allocate and dispose of memory.""
  - ""Our main results include an analysis of propositions that are garbage insensitive, soundness of Hoare logic rules for a garbage collecting semantics, and full abstraction results connecting partial and total correctness to two natural notions of observational equivalence between programs.""
  - ""Part II is dedicated to the study of a particular formalism for automatic memory management: the region calculus of Tofte and Talpin.""
  - ""We propose two approaches, simpler than previous ones, for proving type safety.""
  - ""The first approach is based on the idea of stratified semantics: a high-level semantics dealing with the conceptual issues of the calculus, and a low-level one to remain close to the actual implementation; high-level type safety is easy, and an appropriate relation between the two semantics implies type safety of the low-level one.""
  - ""The second approach is about proving type safety directly, avoiding the burden of having two semantics at the expense of a bit of extra complexity.""
  - ""Part III is a study of multi-staged programming – a paradigm providing support for building, combining and executing code at runtime – in the presence of ML-style references.""
  - ""The main property is that values of closed type are not necessarily closed, but their free variables must be dead code.""
  - ""The main technical results are type safety, and conservative extension with respect to a conventional language with only one stage.""",,"- The abstract discusses the use of ""program logic in the style of Hoare,"" which suggests a type of mathematical framework related to Hoare logic, a formal system for reasoning about the correctness of programs.
 - The mention of ""axioms for operations that allocate and dispose of memory"" indicates the use of formal axioms, which are part of a mathematical framework.
 - The abstract refers to ""soundness of Hoare logic rules for a garbage collecting semantics,"" which implies the use of Hoare logic as a mathematical framework to guarantee properties like soundness.
 - The ""region calculus of Tofte and Talpin"" is mentioned as a formalism for automatic memory management, which is a type of mathematical framework.
 - The abstract discusses ""stratified semantics"" and ""proving type safety directly,"" which are proof techniques used within the framework.
 - The abstract does not explicitly mention limitations or constraints of the framework, but it does discuss the complexity and flexibility of the approaches used.","- ""Our main contribution here is the introduction of the notion of closed type as a generalization of closed type-constructor.""
  - ""Part III is a study of multi-staged programming – a paradigm providing support for building, combining and executing code at runtime – in the presence of ML-style references.""
  - ""Part II is dedicated to the study of a particular formalism for automatic memory management: the region calculus of Tofte and Talpin.""
  - ""In Part I we present and study a number of problems that arise when reasoning about imperative languages with pointers, with special emphasis on program logic in the style of Hoare.""
  - ""This thesis studies various aspects of the theory of programming languages with imperative operations on a global store.""",,"- The abstract discusses the study of programming languages with imperative operations and pointers, which is a focus on a specific paradigm rather than integration of different paradigms.
 - Part II focuses on the region calculus for automatic memory management, which is a specific formalism rather than an integration approach.
 - Part III discusses multi-staged programming with ML-style references, which involves a specific paradigm but does not explicitly mention integration with other paradigms.
 - There is no explicit mention of integration mechanisms, interaction models, constraints, or novel translation techniques for integrating different programming paradigms.","- ""This thesis studies various aspects of the theory of programming languages with imperative operations on a global store.""
  - ""In Part I we present and study a number of problems that arise when reasoning about imperative languages with pointers, with special emphasis on program logic in the style of Hoare.""
  - ""Part II is dedicated to the study of a particular formalism for automatic memory management: the region calculus of Tofte and Talpin.""
  - ""We propose two approaches, simpler than previous ones, for proving type safety.""
  - ""Part III is a study of multi-staged programming – a paradigm providing support for building, combining and executing code at runtime – in the presence of ML-style references.""
  - ""Our main contribution here is the introduction of the notion of closed type as a generalization of closed type-constructor.""",,"- The abstract primarily focuses on the theory of programming languages with imperative operations, program logic, and memory management, rather than generic programming.
 - There is no mention of generic programming methodology or mechanisms for representing generic abstractions in the abstract.
 - The abstract discusses type safety and introduces the concept of ""closed type,"" but this is not explicitly related to generic programming.
 - The focus on multi-staged programming and ML-style references does not directly address genericity or abstraction mechanisms in the context of generic programming.
 - The abstract does not provide any information on minimal type requirements or static checking strategies related to generic programming.","- ""a novel use of component substitution allows us to devise axioms for operations that allocate and dispose of memory.""
  - ""Our main results include an analysis of propositions that are garbage insensitive, soundness of Hoare logic rules for a garbage collecting semantics, and full abstraction results connecting partial and total correctness to two natural notions of observational equivalence between programs.""
  - ""We propose two approaches, simpler than previous ones, for proving type safety.""
  - ""The second approach is about proving type safety directly, avoiding the burden of having two semantics at the expense of a bit of extra complexity.""
  - ""The main property is that values of closed type are not necessarily closed, but their free variables must be dead code.""
  - ""The main technical results are type safety, and conservative extension with respect to a conventional language with only one stage.""",,"- The abstract mentions a ""novel use of component substitution"" to address issues with memory allocation and disposal, which is a key theoretical contribution.
 - The study provides an analysis of garbage-insensitive propositions and soundness of Hoare logic rules for garbage collecting semantics, which are theoretical advancements beyond existing approaches.
 - The introduction of two simpler approaches for proving type safety is a theoretical innovation, as it simplifies previous complex analyses.
 - The concept of ""closed type"" as a generalization of ""closed type-constructor"" is a novel insight, particularly with the property that values of closed type do not necessarily have to be closed but must have dead code as free variables.
 - The study's focus on multi-staged programming with ML-style references and the introduction of ""closed type"" contribute to theoretical advancements in programming language design."
A framework for programming denotational semantics in C++,N. Papaspyrou,10.1145/242903.242913,https://doi.org/10.1145/242903.242913,SIGP,3,1996,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not provide details on a specific mathematical framework or its characteristics),"No specific integration approach described (the abstract mentions integration of functional characteristics into C++ but lacks specific details on mechanisms, models, constraints, or techniques)","- Definition of ""concept"" used: Not mentioned
 - Mechanisms for representing generic abstractions: Integration of functional characteristics such as high-order functions
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Not mentioned","- Key novel insights: Implementing denotational semantics in C++ using object-oriented programming.
 - Theoretical advancements: Adapting functional programming concepts to C++ for type-safe frameworks.
 - Potential implications: Investigating extensions to C++ for better support of denotational semantics.","- ""we describe how the denotational semantics of programming languages can be implemented in C++, by exploiting the object-oriented programming paradigm.""
  - ""a type-safe framework, implemented in pure C++, that integrates functional characteristics such as high-order functions and is capable of naturally expressing denotational descriptions.""",,"- The abstract discusses the implementation of denotational semantics in C++ using object-oriented programming and integrating functional characteristics.
 - It mentions a ""type-safe framework"" that includes ""high-order functions,"" which are functional characteristics.
 - However, the abstract does not explicitly list or define specific conceptual primitives for reconstructing programming paradigms.
 - The focus is on the framework and its capabilities rather than on defining specific primitives.
 - The abstract does not provide precise definitions or orthogonality scores for any conceptual primitives.","- ""we suggest a type-safe framework, implemented in pure C++, that integrates functional characteristics such as high-order functions and is capable of naturally expressing denotational descriptions.""
  - ""we describe how the denotational semantics of programming languages can be implemented in C++, by exploiting the object-oriented programming paradigm.""",,"- The abstract discusses the implementation of denotational semantics in C++ using object-oriented programming, which suggests a focus on programming paradigms rather than a specific mathematical framework.
 - The mention of a ""type-safe framework"" and ""functional characteristics"" indicates some theoretical underpinnings, but these are more related to programming language design than a specific mathematical framework like type theory or category theory.
 - There is no explicit mention of a mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.
 - The abstract does not provide details on theoretical foundations, proof methodology, or formal verification discussions, which are key components of a mathematical framework.","- ""we describe how the denotational semantics of programming languages can be implemented in C++, by exploiting the object-oriented programming paradigm.""
  - ""by comparing our approach to possible implementations using functional languages, we investigate extensions to C++ that would be valuable in this problem domain.""
  - ""we suggest a type-safe framework, implemented in pure C++, that integrates functional characteristics such as high-order functions and is capable of naturally expressing denotational descriptions.""",,"- The abstract mentions the use of the object-oriented programming paradigm in C++ to implement denotational semantics, which is typically associated with functional programming.
 - It suggests a type-safe framework that integrates functional characteristics, such as high-order functions, into C++. This indicates an integration of functional programming elements into an object-oriented language.
 - The comparison with functional languages and investigation of extensions to C++ implies a consideration of how to bridge the gap between object-oriented and functional programming paradigms.
 - However, the abstract does not provide specific details on the integration mechanisms, interaction models, constraints, or novel translation techniques. It only mentions the integration of functional characteristics into C++.","- ""we describe how the denotational semantics of programming languages can be implemented in C++, by exploiting the object-oriented programming paradigm.""
  - ""we suggest a type-safe framework, implemented in pure C++, that integrates functional characteristics such as high-order functions and is capable of naturally expressing denotational descriptions.""
  - ""we investigate extensions to C++ that would be valuable in this problem domain.""",,"- The abstract mentions the use of the object-oriented programming paradigm in C++ to implement denotational semantics, which suggests a focus on abstraction mechanisms.
 - The mention of a ""type-safe framework"" indicates attention to type safety, which is a part of generic programming.
 - The integration of ""functional characteristics such as high-order functions"" suggests a mechanism for representing generic abstractions, as high-order functions are a key feature of functional programming and can be used to abstract over different types.
 - The abstract does not explicitly mention ""minimal type requirements"" or ""static checking or optimization strategies,"" but the focus on a ""type-safe framework"" implies some level of type checking.
 - The abstract does not provide a specific definition of ""concept"" used in the study, nor does it explicitly discuss generic programming methodology or type system discussions in detail.","- ""we describe how the denotational semantics of programming languages can be implemented in C++, by exploiting the object-oriented programming paradigm.""
  - ""we suggest a type-safe framework, implemented in pure C++, that integrates functional characteristics such as high-order functions and is capable of naturally expressing denotational descriptions.""
  - ""by comparing our approach to possible implementations using functional languages, we investigate extensions to C++ that would be valuable in this problem domain.""",,"- The abstract describes a novel approach to implementing denotational semantics in C++, which is not typically considered a natural fit for this task. This suggests a key novel insight into how object-oriented programming can be leveraged for denotational semantics.
 - The mention of a ""type-safe framework"" that integrates ""functional characteristics"" indicates a theoretical advancement beyond existing approaches, as it adapts functional programming concepts to an object-oriented language.
 - The comparison with functional languages and the investigation of extensions to C++ imply potential implications for programming language design, particularly in how languages can be adapted or extended to better support denotational semantics."
Deenitional Trees,S. Antoy,-,-,-,42,1992,"1. Primitive Name: Hierarchical Structure
  Definition: A hierarchical structure representing control at a high level of abstraction.
  Orthogonality Score: Not specified
 2. Primitive Name: Degree of Parallelism
  Definition: A notion of degree of parallelism of an operation.
  Orthogonality Score: Not specified
 3. Primitive Name: And-Or Relation
  Definition: The elements of a necessary set of redexes are related by an and-or relation.
  Orthogonality Score: Not specified",Not specified (the abstract does not provide explicit details about the mathematical framework used),No specific integration approach described,"- Definition of ""concept"" used: Hierarchical structure representing control at a high level of abstraction.
 - Mechanisms for representing generic abstractions: Introduction of a hierarchical structure.
 - Minimal type requirements identified: Not mentioned.
 - Static checking or optimization strategies: Detection of sequential computations in parallel environments to minimize overheads and optimize execution.","- Introduction of a hierarchical structure to represent control at a high level of abstraction.
 - Development of a framework that provides a notion of degree of parallelism of an operation.
 - Identification of an and-or relation among elements of a necessary set of redexes.
 - Ability to detect sequential computations and optimize execution.
 - Ability to identify when inherently sequential computations can be executed in parallel without unnecessary rewrites.","- ""We introduce a hierarchical structure representing, at a high level of abstraction, a form of control.""
  - ""Our framework provides a notion of degree of parallelism of an operation and shows that the elements of a necessary set of redexes are related by an and-or relation.""",,"- The abstract mentions the introduction of a ""hierarchical structure"" which is a conceptual primitive representing control at a high level of abstraction. This suggests that the hierarchical structure is a primitive used to reconstruct programming paradigms.
 - The abstract also discusses the ""degree of parallelism of an operation"" and the ""and-or relation"" among redexes, which are conceptual primitives related to parallelism and control in rewriting systems.
 - The level of abstraction is described as ""high,"" indicating that these primitives are abstract concepts rather than specific implementation details.
 - The orthogonality of these primitives is not explicitly discussed in the abstract, so it cannot be determined from the provided text.","- ""In an environment in which computations can be executed in parallel we are able to detect sequential computations in order to minimize overheads and/or optimize execution.""
  - ""Our framework provides a notion of degree of parallelism of an operation and shows that the elements of a necessary set of redexes are related by an and-or relation.""
  - ""We introduce a hierarchical structure representing, at a high level of abstraction, a form of control.""",,"- The abstract mentions the introduction of a ""hierarchical structure"" which suggests a structured approach to control, but it does not specify the type of mathematical framework used (e.g., type theory, category theory).
 - The mention of ""degree of parallelism"" and ""and-or relation"" implies some mathematical properties, but these are not explicitly linked to a specific mathematical framework or formal verification discussions.
 - There is no mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract.
 - The abstract does not provide details on specific mathematical properties guaranteed, proof techniques used, or limitations/constraints of the framework.","- ""Rewriting is a computational paradigm that speciies the actions, but not the control.""
  - ""We introduce a hierarchical structure representing, at a high level of abstraction, a form of control.""
  - ""For example, we show how to extend the expressive power of Log(F) and how to improve the eeciency of an implementation of BABEL.""
  - ""Our framework provides a notion of degree of parallelism of an operation and shows that the elements of a necessary set of redexes are related by an and-or relation.""
  - ""Both concepts nd application in parallel implementations of rewriting.""
  - ""In an environment in which computations can be executed in parallel we are able to detect sequential computations in order to minimize overheads and/or optimize execution.""
  - ""Conversely, we are able to detect when inherently sequential computations can be executed in parallel without performing unnecessary rewrites.""",,"- The abstract discusses rewriting as a computational paradigm, which is a form of control, but it does not explicitly mention the integration of different programming paradigms.
 - The mention of extending the expressive power of Log(F) and improving the efficiency of BABEL suggests some form of integration or enhancement within the context of rewriting, but it does not specify how different paradigms are integrated.
 - The abstract focuses on the hierarchical structure and its application in parallel implementations, which is more about optimizing execution within a paradigm rather than integrating different paradigms.
 - There is no explicit discussion of specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques related to integrating different programming paradigms.","- ""We introduce a hierarchical structure representing, at a high level of abstraction, a form of control.""
  - ""Our framework provides a notion of degree of parallelism of an operation and shows that the elements of a necessary set of redexes are related by an and-or relation.""
  - ""In an environment in which computations can be executed in parallel we are able to detect sequential computations in order to minimize overheads and/or optimize execution.""",,"- The abstract mentions the introduction of a ""hierarchical structure"" which represents a form of control at a high level of abstraction. This suggests a mechanism for representing generic abstractions, as it involves abstracting control structures.
 - The mention of a ""notion of degree of parallelism"" and the relationship between redexes indicates a conceptual abstraction related to parallelism, which is a form of generic programming.
 - The ability to detect sequential computations in a parallel environment implies some form of static checking or optimization strategy, as it involves identifying and optimizing execution paths.
 - However, the abstract does not explicitly mention generic programming methodology, type system discussions, or specific abstraction mechanisms beyond the hierarchical structure and parallelism concepts.","- ""We introduce a hierarchical structure representing, at a high level of abstraction, a form of control.""
  - ""Our framework provides a notion of degree of parallelism of an operation and shows that the elements of a necessary set of redexes are related by an and-or relation.""
  - ""Conversely, we are able to detect when inherently sequential computations can be executed in parallel without performing unnecessary rewrites.""
  - ""In an environment in which computations can be executed in parallel we are able to detect sequential computations in order to minimize overheads and/or optimize execution.""",,"- The abstract introduces a ""hierarchical structure"" as a novel contribution, which represents a form of control at a high level of abstraction. This is a key theoretical advancement as it addresses a specific problem in the design and implementation of sequential, lazy, functional programming languages.
 - The framework provides a new concept of ""degree of parallelism of an operation,"" which is a theoretical innovation. This concept is crucial for understanding how operations can be parallelized, which is a significant theoretical contribution.
 - The abstract also mentions that the elements of a necessary set of redexes are related by an ""and-or relation."" This is another theoretical advancement as it provides insight into how redexes interact, which is important for parallel implementations.
 - The ability to detect sequential computations and optimize execution, as well as identifying when sequential computations can be parallelized, are significant theoretical contributions. These capabilities are essential for improving the efficiency and effectiveness of programming languages.
 - The abstract implies that these contributions have potential implications for programming language design, particularly in terms of parallel implementations and optimizing execution."
Programming language theory and its implementation - applicative and imperative paradigms,-,-,-,Prentice Hall International series in Computer Science,18,1988,Not specified (the abstract does not explicitly define any conceptual primitives or their definitions),Not specified (the abstract does not provide detailed information about the mathematical framework characteristics),No specific integration approach described,Generic programming not extensively addressed,Not mentioned (the abstract does not provide information on novel theoretical contributions or advancements beyond existing approaches),"- ""This volume introduces and explores those parts of programming language theory that have important applications in improving the quality of software.""
  - ""Provides an elementary introduction to Floyd-Hoare logic and Calculus, Combinators and Functional Programming.""",,"- The abstract mentions ""Floyd-Hoare logic and Calculus, Combinators and Functional Programming"" as topics covered in the volume. These are theoretical frameworks and concepts within programming language theory.
 - However, the abstract does not explicitly define any conceptual primitives. It only mentions the introduction to these topics, which suggests that the volume may discuss them in detail, but it does not specify what those primitives are or their definitions.
 - The abstract does not provide any information on the level of abstraction or orthogonality of any primitives, as it does not explicitly mention any primitives.","- ""Provides an elementary introduction to Floyd-Hoare logic and Calculus, Combinators and Functional Programming.""
  - ""This volume introduces and explores those parts of programming language theory that have important applications in improving the quality of software.""",,"- The abstract mentions ""Floyd-Hoare logic and Calculus,"" which are mathematical frameworks used in programming language theory. Floyd-Hoare logic is a formal system for reasoning about the correctness of programs, which is a type of mathematical framework.
 - The mention of ""Combinators and Functional Programming"" suggests a focus on functional programming paradigms, which often involve mathematical frameworks like lambda calculus or type theory.
 - However, the abstract does not specify the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework. It only provides a general introduction to these concepts.
 - The abstract does not provide detailed information about the mathematical framework characteristics such as type theory, category theory, or specific mathematical properties guaranteed.","- ""Provides an elementary introduction to Floyd-Hoare logic and Calculus, Combinators and Functional Programming.""
  - ""This volume introduces and explores those parts of programming language theory that have important applications in improving the quality of software.""",,"- The abstract mentions the exploration of programming language theory and its applications, but it does not explicitly discuss the integration of different programming paradigms.
 - The mention of ""applicative and imperative paradigms"" in the title suggests that the volume might cover these paradigms, but the abstract does not provide details on how they are integrated.
 - The abstract focuses on introducing specific concepts like Floyd-Hoare logic and functional programming, but it does not mention any specific integration mechanisms, interaction models, constraints, or novel translation techniques.
 - There is no explicit discussion of paradigm interactions, theoretical integration strategies, or comparative analysis sections in the abstract.","- ""Provides an elementary introduction to Floyd-Hoare logic and Calculus, Combinators and Functional Programming.""
  - ""This volume introduces and explores those parts of programming language theory that have important applications in improving the quality of software.""",,"- The abstract mentions the introduction to programming language theory and its applications, but it does not specifically address generic programming or abstraction mechanisms.
 - The focus on Floyd-Hoare logic and Calculus, Combinators, and Functional Programming suggests a theoretical approach to programming languages, but there is no explicit mention of genericity or abstraction mechanisms.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.
 - Since the abstract does not mention any specific focus on generic programming or abstraction mechanisms, it is reasonable to conclude that these topics are not extensively addressed in the study.","- ""Provides an elementary introduction to Floyd-Hoare logic and Calculus, Combinators and Functional Programming.""
  - ""This volume introduces and explores those parts of programming language theory that have important applications in improving the quality of software.""",,"- The abstract mentions that the volume ""introduces and explores"" parts of programming language theory, which suggests a focus on educational or foundational aspects rather than novel theoretical contributions.
 - The mention of providing an ""elementary introduction"" to specific topics like Floyd-Hoare logic and functional programming indicates that the work is more about educational content rather than advancing new theoretical insights.
 - There is no mention of any new theoretical advancements or comparisons with existing work that would suggest a novel contribution beyond existing approaches.
 - The abstract does not discuss any potential implications for programming language design that would be considered a theoretical innovation."
Mechanising a Unifying Theory,"Gift Nuka, J. Woodcock",10.1007/11768173_13,https://doi.org/10.1007/11768173_13,Unifying Theories of Programming,16,2006,"1. Primitive Name: Alphabetised Relational Calculus
  Definition: Used to describe and relate different programming paradigms.
 2. Primitive Name: Predicates
  Definition: Relate initial values v of variables to their final values v.
 3. Primitive Name: ok and ok Variables
  Definition: Express whether a program has been started and has terminated.
 4. Primitive Name: Subtyping
  Definition: Concept in object-oriented languages.
 5. Primitive Name: Single Inheritance
  Definition: Concept in object-oriented languages.
 6. Primitive Name: Dynamic Binding
  Definition: Concept in object-oriented languages.
 7. Primitive Name: Recursion
  Definition: Concept in object-oriented languages.
 8. Primitive Name: Parametrised Programs
  Definition: Part of the alphabet, used for method bodies.
 9. Primitive Name: Method Names
  Definition: Part of the alphabet, used for method declarations.
 10. Primitive Name: Observational Variables
  Definition: Record subclass relations and attribute types.
 11. Primitive Name: Assignment
  Definition: Standard imperative programming operator.
 12. Primitive Name: Conditional
  Definition: Standard imperative programming operator.
 13. Primitive Name: Sequential Composition
  Definition: Standard imperative programming operator.
 14. Primitive Name: Iteration
  Definition: Standard imperative programming operator.","- Type of mathematical framework: Relational calculus using Z notation
 - Specific mathematical properties guaranteed: Formal semantics and verification
 - Proof techniques used: Theorem proving with ProofPowerZ
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Deep embedding of programming languages in Z.
 - Interaction models between paradigms: Extension of UTP theories to include object-oriented concepts; combination of reactive and object-oriented designs.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Deep embedding of languages in Z.",Generic programming not extensively addressed,"- Formalization of a subset of the Unifying Theories of Programming (UTP)
 - Development of a verification framework for UTP
 - Use of ProofPowerZ for mechanized support in reasoning about UTP programs
 - Deep embedding of the language in Z for formal semantics
 - Formalization of imperative programming constructs and their denotational semantics in Z","- ""In UTP, the alphabetised relational calculus is used to describe and relate different programming paradigms, including functional, imperative, logic, and parallel programming.""
  - ""We develop a verification framework for UTP; we give a formal semantics to an imperative programming language, and use our definitions to create a deep embedding of the language in Z.""
  - ""We use ProofPowerZ, a theorem prover for Z to provide mechanised support for reasoning about programs in the unifying theory.""
  - ""The commonality of such themes opens perspectives for unifying theories, an activity which can increase our ability to use existing methods and notations, to recognise their limitations, and to extend and generalise them.""
  - ""The Unifying Theories of Programming (UTP), developed in [13] , model the termination behaviour of programs using two special variables ok and ok that express whether a program has been started and has terminated, respectively.""
  - ""Specifications and programs are identified with predicates relating the initial values v of variables to their final values v ; moreover, ok and ok may occur freely in predicates.""
  - ""the Unifying Theories of Programming (UTP) [6] , Hoare and He establish a framework to allow reasoning about different programming paradigms using a relational calculus.""
  - ""Our theory is an extension of the theories of designs and higher-order procedures.""
  - ""We introduce concepts of OO languages progressively and in isolation. We cover subtyping, single inheritance, dynamic binding, and (mutual) recursion, assuming a copy semantics.""
  - ""In our theory, a class declaration is not a single block, as usual in objectoriented languages. We have separated constructs to declare a class and its immediate superclass, to declare an attribute, and to declare a method.""
  - ""The method names are also part of the alphabet of our theory. Their values are parametrised programs (pds • p), where pds is a list of parameter declarations, and p is a program: the body of the parametrised program, which uses the parameters.""
  - ""The operators of the language cover conventional programming concepts. The notation consist of the standard imperative programming operators including assignment, conditional, sequential composition, variable declaration and iteration.""
  - ""The set of healthy pointer relations is a complete lattice, since it is the image of monotonic and idempotent healthiness conditions [7]""
  - ""The alphabet of a binary predicate expression is the union of the alphabets of the operands. Quantification removes a variable from the alphabet: we can no longer observe its value.""
  - ""Substitution p[e/x ] allows an expression e to be systematically substituted for free occurrences of the name x . It removes the variable x from the alphabet, but introduces the names of expression e, α e (e) instead.""",,"- The paper discusses the use of the alphabetised relational calculus in UTP to unify different programming paradigms, which suggests a focus on relational calculus as a conceptual primitive.
 - The mention of ""alphabetised relational calculus"" and ""predicates relating the initial values v of variables to their final values v"" indicates that predicates and relational calculus are fundamental primitives.
 - The use of ""ok"" and ""ok"" variables to model termination behavior is another primitive concept in UTP.
 - The paper also discusses the extension of UTP to object-oriented concepts, including subtyping, single inheritance, dynamic binding, and recursion, which are additional primitives.
 - The theory includes observational variables for subclass relations and attribute types, which are part of the conceptual framework.
 - The paper mentions the use of parametrised programs and method names as part of the alphabet, indicating these are also conceptual primitives.
 - The operators for assignment, conditional, sequential composition, and iteration are standard programming concepts that are likely considered primitives in this context.
 - The mention of ""healthy pointer relations"" and ""complete lattice"" suggests that these are also part of the theoretical framework, although they might be more abstract or derived primitives.","- ""In this paper, we present a formalisation of a subset of the unifying theories of programming (UTP).""
  - ""We develop a verification framework for UTP; we give a formal semantics to an imperative programming language, and use our definitions to create a deep embedding of the language in Z.""
  - ""We use ProofPowerZ, a theorem prover for Z to provide mechanised support for reasoning about programs in the unifying theory.""
  - ""We have presented a theory of the alphabetised relational calculus and its formal definition in the Z notation.""
  - ""Our approach has been to embed both the syntax and the semantics into Z so that we can be able to reason and prove theorems on the language.""
  - ""We have presented various definitions of the imperative programming constructs of a subset of UTP and formalised their denotational semantics in Z using ProofPowerZ.""
  - ""The formalisation we have presented forms the basis on which further mechanisation of UTP and program correctness analysis can be done.""",,"- The paper discusses the formalization of a subset of the Unifying Theories of Programming (UTP) using a relational calculus framework.
 - The mathematical framework used is based on the Z notation, which is a formal specification language.
 - The paper mentions the use of ProofPowerZ, a theorem prover for Z, indicating that the proof techniques involve theorem proving.
 - The framework provides a deep embedding of the language in Z, which suggests a focus on formal semantics and verification.
 - The paper does not explicitly mention type theory or category theory, but it does focus on relational calculus and Z notation.
 - The limitations or constraints of the framework are not explicitly discussed in the provided quotes.","- ""In UTP, the alphabetised relational calculus is used to describe and relate different programming paradigms, including functional, imperative, logic, and parallel programming.""
  - ""We develop a verification framework for UTP; we give a formal semantics to an imperative programming language, and use our definitions to create a deep embedding of the language in Z.""
  - ""The commonality of such themes opens perspectives for unifying theories, an activity which can increase our ability to use existing methods and notations, to recognise their limitations, and to extend and generalise them.""
  - ""the aims of this first UTP symposium are to reaffirm the significance of the ongoing UTP project, to encourage efforts to advance it by providing a focus for the sharing of results by those already actively contributing, and to raise awareness of the benefits of unifying theoretical frameworks among the wider computer science and software engineering communities.""
  - ""In the Unifying Theories of Programming (UTP) [6] , Hoare and He establish a framework to allow reasoning about different programming paradigms using a relational calculus.""
  - ""Our theory is an extension of the theories of designs and higher-order procedures.""
  - ""We target general object-oriented concepts, rather than any specific language. We introduce concepts of OO languages progressively and in isolation.""
  - ""our long-term goal is to define a combined theory for reactive, object-oriented designs, and use it to give a semantics to OhCircus [11] . This is an object-oriented extension of Circus [12] , a combination of Z [13] and CSP [14] whose semantics is based on the UTP.""",,"- The paper discusses the use of the Unifying Theories of Programming (UTP) as a framework for integrating different programming paradigms. UTP uses a relational calculus to describe and relate these paradigms.
 - The integration approach involves creating a deep embedding of programming languages in Z, which is a formal specification language. This allows for a unified verification framework.
 - The paper mentions the extension of UTP theories to include object-oriented concepts, indicating an integration of object-oriented programming with other paradigms.
 - The long-term goal is to combine reactive and object-oriented designs, suggesting an interaction model between these paradigms.
 - The paper does not explicitly mention specific integration mechanisms or constraints but focuses on the theoretical framework and its application to various paradigms.","- ""We develop a verification framework for UTP; we give a formal semantics to an imperative programming language, and use our definitions to create a deep embedding of the language in Z.""
  - ""We use ProofPowerZ, a theorem prover for Z to provide mechanised support for reasoning about programs in the unifying theory.""
  - ""The Unifying Theories of Programming (UTP), developed in [13] , model the termination behaviour of programs using two special variables ok and ok that express whether a program has been started and has terminated, respectively.""
  - ""Specifications and programs are identified with predicates relating the initial values v of variables to their final values v ; moreover, ok and ok may occur freely in predicates.""
  - ""The aims and results of the present paper are the following:
 

 1. We model normal designs in a more general class of algebras than pure relation algebra.""
  - ""We set up a formal connection between UTP and the theories of general (e.g., [2, 3, 9, 19, 21] ) and total (e.g., [1, 5, 6, 8, 20] ) correctness of programs (the latter also being known as demonic semantics).""
  - ""the designs form a left semiring and even a Kleene and omega algebra.""
  - ""The commands form a left semiring, i.e., satisfy all semiring laws except for the right annihilation law for the zero element fail.""
  - ""The Kleene and omega algebraic properties of commands finally enable the calculation of the least and greatest fixed points of the function that describes the demonic while loop.""
  - ""The presented method could also serve as a model for the extension by parameters that describe further observations as proposed in [13]""",,"- The paper primarily focuses on the Unifying Theories of Programming (UTP) and its application to formal verification rather than generic programming.
 - The use of Z and ProofPowerZ suggests a focus on formal methods and theorem proving rather than generic programming.
 - The paper discusses algebraic structures like semirings and Kleene algebras, which are relevant to formal verification but not directly related to generic programming.
 - There is no explicit mention of generic programming, type systems, or abstraction mechanisms specifically related to genericity.
 - The paper's focus is on formal verification and algebraic structures rather than generic programming methodologies.","- ""In this paper, we present a formalisation of a subset of the unifying theories of programming (UTP).""
  - ""We develop a verification framework for UTP; we give a formal semantics to an imperative programming language, and use our definitions to create a deep embedding of the language in Z.""
  - ""We use ProofPowerZ, a theorem prover for Z to provide mechanised support for reasoning about programs in the unifying theory.""
  - ""We have presented a theory of the alphabetised relational calculus and its formal definition in the Z notation.""
  - ""Our approach has been to embed both the syntax and the semantics into Z so that we can be able to reason and prove theorems on the language.""
  - ""We have presented various definitions of the imperative programming constructs of a subset of UTP and formalised their denotational semantics in Z using ProofPowerZ.""
  - ""The formalisation we have presented forms the basis on which further mechanisation of UTP and program correctness analysis can be done.""",,"- The paper presents a formalization of a subset of the Unifying Theories of Programming (UTP), which is a novel contribution as it provides a structured framework for reasoning about different programming paradigms.
 - The development of a verification framework for UTP is a significant theoretical advancement, as it enables formal verification of programs within the UTP framework.
 - The use of ProofPowerZ to provide mechanized support for reasoning about programs in UTP is a theoretical innovation, as it leverages theorem proving to ensure correctness.
 - The deep embedding of the language in Z is a unique theoretical contribution, as it allows for the formal semantics of the language to be defined and reasoned about within a well-established formal framework.
 - The formalization of imperative programming constructs and their denotational semantics in Z is a theoretical advancement, as it provides a rigorous basis for understanding and analyzing these constructs.
 - The paper's focus on embedding both syntax and semantics into Z is a novel approach, as it enables comprehensive reasoning and theorem proving about the language."
Reconstruction of paradigm shifts,"R. Lämmel, G. Riedewald",-,-,-,12,1999,Not specified (the abstract does not explicitly list or define specific conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework used),"- Specific integration mechanisms proposed: Generic and formal approach to reconstructing concepts; meta-programming framework applicable to multiple declarative paradigms.
 - Interaction models between paradigms: Importing and exporting concepts between frameworks.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Orthogonal derivation of reconstructions by unbundling and combining roles.","- Definition of ""concept"" used: Concepts underlying extensions of attribute grammar formalism.
 - Mechanisms for representing generic abstractions: Meta-programming framework that can be instantiated for various declarative paradigms.
 - Minimal type requirements identified: Not mentioned.
 - Static checking or optimization strategies: Not mentioned.","- Key novel insights: A generic and formal approach to reconstructing concepts as executable meta-programs, allowing for analysis based on preservation properties.
 - Theoretical advancements: The approach is effective and formal, enabling structured analysis and orthogonal derivation of reconstructions.
 - Potential implications: Broad applicability to multiple frameworks beyond attribute grammars, such as natural semantics and algebraic specification, enhancing programming language design by providing a systematic method for analyzing and applying concepts.","- ""the meta-programming framework can be instantiated not only for attribute grammars but also for several other representatives of the declarative paradigm,""
  - ""the reconstructed concepts are presented as executable meta-programs.""
  - ""a generic and formal approach to an effective and orthogonal reconstruction of the concepts underlying some extensions""
  - ""the derived meta-programs modelling certain concepts can be analysed based on properties of the meta-programs, e.g. preservation properties.""
  - ""the reconstructions are derived orthogonally in the sense that potential roles are first unbundled and then particular combinations of the roles can be investigated.""",,"- The abstract discusses a ""generic and formal approach"" to reconstructing concepts, which implies a focus on abstract, high-level primitives.
 - The use of ""executable meta-programs"" suggests that these primitives are defined in terms of their operational or functional properties.
 - The mention of ""preservation properties"" indicates that the primitives are analyzed based on how they maintain certain characteristics, which is a key aspect of their definition.
 - The framework's ability to be instantiated for various declarative paradigms suggests a high level of abstraction and generality.
 - The orthogonal derivation of reconstructions implies that the primitives are designed to be independent and modular, allowing for flexible combinations.
 - However, the abstract does not explicitly list specific conceptual primitives or provide detailed definitions for them.","- ""a generic and formal approach to an effective and orthogonal reconstruction of the concepts underlying some extensions""
  - ""the reconstructed concepts are presented as executable meta-programs.""
  - ""the derived meta-programs modelling certain concepts can be analysed based on properties of the meta-programs, e.g. preservation properties.""
  - ""the meta-programming framework can be instantiated not only for attribute grammars but also for several other representatives of the declarative paradigm,""
  - ""the reconstructions are derived orthogonally in the sense that potential roles are first unbundled and then particular combinations of the roles can be investigated.""
  - ""The described meta-programming framework has been implemented in the specification framework of Λ∆Λ""",,"- The abstract mentions a ""generic and formal approach"" and ""executable meta-programs,"" which suggests a focus on formal methods, but it does not specify a particular mathematical framework like type theory or category theory.
 - The mention of ""preservation properties"" indicates some level of formal analysis, but it does not detail the specific mathematical properties guaranteed or the proof techniques used.
 - The abstract does not provide information on the theoretical foundations, proof methodology, or formal verification discussions, which are key components for determining the mathematical framework characteristics.
 - The implementation in the ""specification framework of Λ∆Λ"" is noted, but this does not specify the type of mathematical framework or its characteristics.","- ""The described meta-programming framework has been implemented in the specification framework of Λ∆Λ and it is used for reusable formal language definition based on attribute grammars and operational semantics.""
  - ""the meta-programming framework can be instantiated not only for attribute grammars but also for several other representatives of the declarative paradigm, e.g. natural semantics and algebraic specification.""
  - ""the reconstructions are derived orthogonally in the sense that potential roles are first unbundled and then particular combinations of the roles can be investigated.""
  - ""concepts can be imported from and exported to other frameworks.""
  - ""a generic and formal approach to an effective and orthogonal reconstruction of the concepts underlying some extensions""",,"- The abstract discusses a ""generic and formal approach"" to reconstructing concepts, which suggests a method for integrating different programming paradigms by making their underlying concepts compatible.
 - The mention of the meta-programming framework being applicable to ""several other representatives of the declarative paradigm"" indicates that it can integrate different paradigms within the declarative paradigm.
 - The ability to ""import from and export to other frameworks"" implies a mechanism for interaction between paradigms, allowing for the exchange of concepts.
 - The orthogonal derivation of reconstructions suggests a structured approach to integrating paradigms by unbundling roles and then combining them, which could be seen as a novel translation technique.
 - The implementation in the Λ∆Λ framework and its use for formal language definition based on attribute grammars and operational semantics suggests a practical application of this integration approach.","- ""a generic and formal approach to an effective and orthogonal reconstruction of the concepts underlying some extensions""
  - ""The described meta-programming framework has been implemented in the specification framework of Λ∆Λ and it is used for reusable formal language definition based on attribute grammars and operational semantics.""
  - ""It is a generic approach because the meta-programming framework can be instantiated not only for attribute grammars but also for several other representatives of the declarative paradigm, e.g. natural semantics and algebraic specification.""
  - ""The approach to reconstruction is formal in the sense that the derived meta-programs modelling certain concepts can be analysed based on properties of the meta-programs, e.g. preservation properties.""",,"- The abstract describes a ""generic and formal approach"" to reconstructing concepts, indicating that genericity is a focus of the study.
 - The term ""generic"" is used to describe the approach, suggesting that it can be applied across different frameworks, not just attribute grammars.
 - The meta-programming framework is highlighted as a mechanism for representing generic abstractions, as it can be instantiated for various declarative paradigms.
 - The abstract mentions that the framework is used for ""reusable formal language definition,"" which implies a level of abstraction and genericity in its application.
 - There is no specific mention of minimal type requirements, static checking, or optimization strategies in the abstract.","- ""a generic and formal approach to an effective and orthogonal reconstruction of the concepts underlying some extensions""
  - ""The approach to reconstruction is formal in the sense that the derived meta-programs modelling certain concepts can be analysed based on properties of the meta-programs, e.g. preservation properties.""
  - ""The reconstruction is effective in the sense that the reconstructed concepts are presented as executable meta-programs.""
  - ""It is a generic approach because the meta-programming framework can be instantiated not only for attribute grammars but also for several other representatives of the declarative paradigm, e.g. natural semantics and algebraic specification.""
  - ""the reconstructions are derived orthogonally in the sense that potential roles are first unbundled and then particular combinations of the roles can be investigated.""",,"- The abstract describes a ""generic and formal approach"" to reconstructing concepts, which suggests a novel theoretical contribution by providing a systematic method for analyzing and applying these concepts.
 - The approach is ""effective"" because it presents concepts as ""executable meta-programs,"" which is a new way of representing these concepts in a practical and executable form.
 - The formal nature of the approach allows for analysis based on ""preservation properties,"" which is a theoretical advancement as it provides a structured way to evaluate the reconstructed concepts.
 - The generic nature of the approach means it can be applied to multiple frameworks beyond attribute grammars, such as natural semantics and algebraic specification, which is a significant theoretical contribution as it broadens the applicability of the method.
 - The orthogonal derivation of reconstructions by unbundling roles and then investigating combinations suggests a new theoretical perspective on how to analyze and combine these roles, which is a novel insight into the structure of these concepts."
2011 international workshop on foundations of object-oriented languages (fool'11): splash/oopsla '11 workshop summary,"Jonathan Aldrich, Jeremy G. Siek, E. Zucca",10.1145/2048147.2048228,https://doi.org/10.1145/2048147.2048228,OOPSLA Companion,0,2011,Not specified (the abstract does not explicitly define any conceptual primitives),Not specified (the abstract does not provide details about the mathematical framework characteristics),No specific integration approach described,Generic programming not extensively addressed,Not mentioned (the abstract does not specify any unique theoretical contributions or novel insights beyond the general purpose of the workshop),"- ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""
  - ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, meta-programming.""
  - ""The search for sound principles for object-oriented languages has given rise to considerable research during the last few decades, leading to a better understanding of the key concepts of object-oriented languages and to important developments in type theory, semantics, program verification, and program development.""",,"- The abstract discusses the search for sound principles in object-oriented languages, which implies a focus on foundational concepts. However, it does not explicitly define any conceptual primitives.
 - The abstract mentions ""key concepts of object-oriented languages"" but does not specify what these concepts are or how they are defined.
 - The purpose of the workshop is to discuss new ideas and provide feedback, which suggests a focus on exploring and developing concepts rather than defining specific primitives.
 - The abstract mentions integration with other paradigms and extensions like aspects, components, and meta-programming, but again, it does not define these as conceptual primitives or provide their definitions.","- ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""
  - ""The search for sound principles for object-oriented languages has given rise to considerable research during the last few decades, leading to a better understanding of the key concepts of object-oriented languages and to important developments in type theory, semantics, program verification, and program development.""
  - ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, meta-programming.""",,"- The abstract mentions ""important developments in type theory, semantics, program verification, and program development,"" which suggests that these areas are relevant to the workshop's focus. However, it does not specify any particular mathematical framework or its characteristics.
 - The abstract does not provide details about the type of mathematical framework used, specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework.
 - The abstract is more focused on the purpose and scope of the workshop rather than detailing specific mathematical frameworks or their characteristics.","- ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, meta-programming.""
  - ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""",,"- The abstract mentions that the workshop invites submissions related to the integration of object-oriented languages with other paradigms, such as aspects, components, and meta-programming. This suggests that the workshop is interested in discussing how object-oriented languages can be integrated with these other paradigms.
 - However, the abstract does not provide specific details about the integration mechanisms, interaction models, constraints, or novel translation techniques. It only indicates that these topics are within the scope of the workshop.
 - The abstract does not describe any specific integration approach or provide details on how these paradigms are integrated. It is more of an invitation for discussion rather than a presentation of specific integration strategies.","- ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, meta-programming.""
  - ""The search for sound principles for object-oriented languages has given rise to considerable research during the last few decades, leading to a better understanding of the key concepts of object-oriented languages and to important developments in type theory, semantics, program verification, and program development.""
  - ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""",,"- The abstract discusses the search for sound principles in object-oriented languages, which includes developments in type theory and semantics. These are relevant to generic programming and abstraction mechanisms.
 - The workshop's purpose is to discuss new ideas in the foundations of object-oriented languages, which could include generic programming and abstraction mechanisms.
 - The abstract mentions integration with other paradigms and extensions like aspects, components, and meta-programming, which are related to genericity and abstraction.
 - However, the abstract does not specifically mention ""genericity and abstraction mechanisms"" or provide details on these topics. It does not define ""concept,"" describe mechanisms for representing generic abstractions, identify minimal type requirements, or discuss static checking or optimization strategies.
 - The abstract is more focused on the workshop's purpose and scope rather than specific technical details like generic programming.","- ""The purpose of this workshop is to provide a forum for discussing new ideas in the foundations of object-oriented languages and provide feedback to authors.""
  - ""The search for sound principles for object-oriented languages has given rise to considerable research during the last few decades, leading to a better understanding of the key concepts of object-oriented languages and to important developments in type theory, semantics, program verification, and program development.""
  - ""Submissions to this workshop were invited in the general area of foundations of object-oriented languages, object-oriented languages, including integration with other paradigms and extensions, such as aspects, components, meta-programming.""",,"- The abstract discusses the workshop's purpose as a forum for discussing new ideas in the foundations of object-oriented languages, which suggests a focus on theoretical contributions and novel insights.
 - The mention of ""considerable research during the last few decades"" leading to ""important developments in type theory, semantics, program verification, and program development"" implies that the workshop is building upon existing theoretical advancements.
 - The abstract does not specify any particular novel insights or theoretical advancements beyond existing approaches, nor does it mention any specific implications for programming language design.
 - The focus on ""new ideas"" and ""feedback to authors"" suggests that the workshop is more about facilitating discussion and development rather than presenting specific novel contributions or theoretical advancements."
Object-Orientation in the UTP,"Thiago L. V. L. Santos, Ana Cavalcanti, A. Sampaio",10.1007/11768173_2,https://doi.org/10.1007/11768173_2,Unifying Theories of Programming,38,2006,"1. Primitive Name: Subtyping
  Definition: Not explicitly defined in the provided text
  Orthogonality Score: Not discussed
 2. Primitive Name: Data Inheritance
  Definition: Not explicitly defined in the provided text
  Orthogonality Score: Not discussed
 3. Primitive Name: (Mutually) Recursive Methods
  Definition: Not explicitly defined in the provided text
  Orthogonality Score: Not discussed
 4. Primitive Name: Dynamic Binding
  Definition: Not explicitly defined in the provided text
  Orthogonality Score: Not discussed","The mathematical framework used is the Unifying Theories of Programming (UTP), which employs relational calculus and first-order logic. It guarantees properties related to program termination and correctness using predicates and logical reasoning. The framework is implemented using a Z theorem prover. Limitations or constraints are not explicitly mentioned.","- Specific integration mechanisms proposed: Modular approach, dealing with each concept in isolation.
 - Interaction models between paradigms: Combined theory for reactive and object-oriented designs.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Describing object-oriented concepts in terms of UTP theories (designs and higher-order procedures).","- Definition of ""concept"" used: Concepts are introduced progressively and in isolation, focusing on object-oriented features like subtyping, inheritance, and dynamic binding.
 - Mechanisms for representing generic abstractions: Parametrised programs and parameter passing mechanisms are used to represent generic abstractions.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novel approach to describing object-oriented programming concepts within the UTP framework.
 - Modularity in treating each concept in isolation, facilitating modeling of integrated languages.
 - Extension of theories of designs and higher-order procedures to include object-oriented features.
 - Separation of class declaration constructs simplifies semantics and recursion.
 - Potential implications for programming language design, particularly in integrating reactive and object-oriented paradigms.","- ""We introduce concepts of OO languages progressively and in isolation. We cover subtyping, single inheritance, dynamic binding, and (mutual) recursion, assuming a copy semantics.""
  - ""This work shows how subtyping, data inheritance, (mutually) recursive methods, and dynamic binding can be described in the UTP by combining and extending the theories of designs and higher-order procedures.""
  - ""We target general object-oriented concepts, rather than any specific language.""
  - ""Our theory is an extension of the theories of designs and higher-order procedures.""",,"- The paper discusses the use of the Unifying Theories of Programming (UTP) to describe object-oriented programming concepts.
 - The specific conceptual primitives mentioned are subtyping, data inheritance, (mutually) recursive methods, and dynamic binding.
 - These primitives are introduced in isolation, suggesting a modular approach to reconstructing programming paradigms.
 - The paper does not provide explicit definitions for these primitives within the quoted text, but they are identified as key concepts in the UTP framework.
 - The level of abstraction is high, as these primitives are fundamental concepts in object-oriented programming.
 - Orthogonality is implied by the modular introduction of these concepts, but not explicitly scored or discussed.","- ""In this paper, we study object-oriented programming concepts present in languages like Java and C++ in the framework of the Unifying Theories of Programming (UTP).""
  - ""This work shows how subtyping, data inheritance, (mutually) recursive methods, and dynamic binding can be described in the UTP by combining and extending the theories of designs and higher-order procedures.""
  - ""Our theory is an extension of the theories of designs and higher-order procedures.""
  - ""In the Unifying Theories of Programming (UTP) [6] , Hoare and He establish a framework to allow reasoning about different programming paradigms using a relational calculus.""
  - ""Our formalisation in general is related to all these. However, there are some differences. We implement UTP in first order logic using a Z theorem prover.""
  - ""The Unifying Theories of Programming (UTP), developed in [13] , model the termination behaviour of programs using two special variables ok and ok that express whether a program has been started and has terminated, respectively.""
  - ""Specifications and programs are identified with predicates relating the initial values v of variables to their final values v ; moreover, ok and ok may occur freely in predicates.""",,"- The paper uses the Unifying Theories of Programming (UTP) as its mathematical framework, which is a relational calculus designed to reason about different programming paradigms.
 - UTP is used to describe object-oriented programming concepts such as subtyping, data inheritance, recursive methods, and dynamic binding.
 - The framework extends the theories of designs and higher-order procedures, indicating a focus on formal methods and logical reasoning.
 - The paper mentions the use of first-order logic and a Z theorem prover for formalization, which suggests a logical and proof-oriented approach to verification.
 - The UTP framework models program termination behavior using special variables (ok and ok), which are used to express whether a program has started and terminated.
 - The framework guarantees properties related to program termination and correctness through the use of predicates and logical reasoning.","- ""In this paper, we study object-oriented programming concepts present in languages like Java and C++ in the framework of the Unifying Theories of Programming (UTP).""
  - ""This work shows how subtyping, data inheritance, (mutually) recursive methods, and dynamic binding can be described in the UTP by combining and extending the theories of designs and higher-order procedures.""
  - ""A distinguishing feature of our approach is modularity: following the style of the UTP, we deal with each concept in isolation; this makes our theory convenient to model integrated languages that include constructs from several paradigms.""
  - ""We target general object-oriented concepts, rather than any specific language. We introduce concepts of OO languages progressively and in isolation.""
  - ""our long-term goal is to define a combined theory for reactive, object-oriented designs, and use it to give a semantics to OhCircus""
  - ""In our theory, a class declaration is not a single block, as usual in objectoriented languages. We have separated constructs to declare a class and its immediate superclass, to declare an attribute, and to declare a method.""
  - ""Dynamic binding is reflected in the value of a method variable. It is a conditional that checks the type of the target object and determines the right program that defines the behaviour of the method in each case.""",,"- The paper discusses the integration of object-oriented programming concepts into the Unifying Theories of Programming (UTP) framework, which is a theoretical approach to integrating different programming paradigms.
 - The authors propose a modular approach, dealing with each concept in isolation, which facilitates the modeling of integrated languages that include constructs from several paradigms.
 - The paper focuses on object-oriented concepts such as subtyping, data inheritance, recursive methods, and dynamic binding, and how these can be described within the UTP framework.
 - The authors aim to create a combined theory for reactive and object-oriented designs, indicating an interaction model between these paradigms.
 - The paper does not explicitly mention specific integration mechanisms or constraints beyond the modular approach and the use of UTP to integrate paradigms.
 - The novel translation or embedding technique involves describing object-oriented concepts in terms of UTP theories, particularly using designs and higher-order procedures.","- ""A distinguishing feature of our approach is modularity: following the style of the UTP, we deal with each concept in isolation; this makes our theory convenient to model integrated languages that include constructs from several paradigms.""
  - ""We introduce concepts of OO languages progressively and in isolation.""
  - ""Our theory is an extension of the theories of designs and higher-order procedures.""
  - ""We cover subtyping, single inheritance, dynamic binding, and (mutual) recursion, assuming a copy semantics.""
  - ""In our theory, a class declaration is not a single block, as usual in objectoriented languages. We have separated constructs to declare a class and its immediate superclass, to declare an attribute, and to declare a method.""
  - ""The method names are also part of the alphabet of our theory. Their values are parametrised programs (pds • p), where pds is a list of parameter declarations, and p is a program: the body of the parametrised program, which uses the parameters.""
  - ""Value (val), result (res), and value-result (valres) parameters are allowed.""
  - ""The notation pds stands for any parameter declaration list, possibly including the three parameter passing mechanisms.""
  - ""In bodies of the values of the observational variables named after methods nested conditionals with each branch representing the meaning of a method redefinition.""
  - ""Dynamic binding is reflected in the value of a method variable. It is a conditional that checks the type of the target object and determines the right program that defines the behaviour of the method in each case.""",,"- The paper discusses modularity and dealing with concepts in isolation, which suggests a focus on abstraction mechanisms.
 - The introduction of object-oriented concepts like subtyping, inheritance, and dynamic binding implies a form of genericity in handling these features.
 - The use of parametrised programs and parameter passing mechanisms indicates a mechanism for representing generic abstractions.
 - The paper does not explicitly mention minimal type requirements or static checking strategies, but the focus on modularity and isolation suggests some level of abstraction.
 - The paper does not provide a detailed discussion on generic programming methodology or type system discussions beyond the object-oriented features.","- ""A distinguishing feature of our approach is modularity: following the style of the UTP, we deal with each concept in isolation; this makes our theory convenient to model integrated languages that include constructs from several paradigms.""
  - ""our long-term goal is to define a combined theory for reactive, object-oriented designs, and use it to give a semantics to OhCircus""
  - ""This work shows how subtyping, data inheritance, (mutually) recursive methods, and dynamic binding can be described in the UTP by combining and extending the theories of designs and higher-order procedures.""
  - ""We show that this approach simplifies the semantics, and makes the treatment of (mutual) recursion straightforward, as it should be.""
  - ""Our theory is an extension of the theories of designs and higher-order procedures.""
  - ""We introduce concepts of OO languages progressively and in isolation. We cover subtyping, single inheritance, dynamic binding, and (mutual) recursion, assuming a copy semantics.""
  - ""In our theory, a class declaration is not a single block, as usual in objectoriented languages. We have separated constructs to declare a class and its immediate superclass, to declare an attribute, and to declare a method.""",,"- The paper introduces a novel approach to describing object-oriented programming concepts within the Unifying Theories of Programming (UTP) framework. This is a significant theoretical contribution as it extends existing UTP theories to include object-oriented features.
 - The modularity of the approach is highlighted as a key novelty, allowing for the treatment of each concept in isolation. This modularity is crucial for modeling languages that integrate multiple paradigms.
 - The paper provides a theoretical advancement by extending the theories of designs and higher-order procedures to include object-oriented concepts such as subtyping, inheritance, dynamic binding, and recursion.
 - The separation of class declaration constructs is a theoretical innovation, simplifying the semantics and making recursion more straightforward.
 - The long-term goal of defining a combined theory for reactive and object-oriented designs suggests potential implications for programming language design, particularly in integrating different paradigms."
Exploring Codata : The Relation to Object-Orientation,Zachary J. Sullivan,-,-,-,0,2019,"1. Primitive Name: Codata
  Definition: The dual of data, specifying all possible ways to use it.
  Orthogonality Score: Not specified
 2. Primitive Name: Data
  Definition: Constructed data.
  Orthogonality Score: Not specified
 3. Primitive Name: Subtyping
  Definition: Essential object-oriented feature.
  Orthogonality Score: Not specified
 4. Primitive Name: Classes
  Definition: Essential object-oriented feature.
  Orthogonality Score: Not specified
 5. Primitive Name: Inheritance
  Definition: Essential object-oriented feature.
  Orthogonality Score: Not specified",Not specified (the abstract hints at type theory but does not explicitly detail the mathematical framework characteristics),"- Specific integration mechanisms proposed: Extending a basic language with data and codata to include object-oriented features like subtyping, classes, and inheritance.
 - Interaction models between paradigms: Codata provides methods for accessing components, similar to objects defining pairs.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Extended language serves as a suitable intermediate language for compiling both paradigms.",Generic programming not extensively addressed,"- Key novel insights: Objects can arise naturally in logic; codata as the dual of data can be seen as an object.
 - Theoretical advancements: Extension of a basic language with data and codata to include object-oriented features; bridging functional and object-oriented paradigms.
 - Potential implications: Creation of an intermediate language for compiling both paradigms, enhancing versatility and efficiency in programming language design.","- ""Whereas data is constructed, codata specifies all the possible ways to use it.""
  - ""The dual of data, known as codata, can be seen as an object.""
  - ""Analogously to an object defining a pair, a codata pair gives two methods for accessing the first and second components.""
  - ""To substantiate this approach we extend a basic language containing both data and codata with the essential object-oriented features of subtyping, classes, and inheritance.""",,"- The abstract discusses the concept of ""codata"" as a primitive, which is defined as the dual of data. This suggests that codata is a fundamental concept in the study.
 - Codata is described as specifying all possible ways to use data, which implies a focus on usage or functionality rather than construction.
 - The mention of a ""codata pair"" providing methods for accessing components indicates that codata is used to define interactions or operations, aligning with object-oriented principles.
 - The extension of a language with data and codata to include object-oriented features like subtyping, classes, and inheritance suggests that these are also considered primitives in the context of reconstructing programming paradigms.
 - The abstract does not explicitly mention orthogonality or the level of abstraction of these primitives, but it implies that they are foundational to the study's approach.","- ""To substantiate this approach we extend a basic language containing both data and codata with the essential object-oriented features of subtyping, classes, and inheritance.""
  - ""Analogously to an object defining a pair, a codata pair gives two methods for accessing the first and second components.""
  - ""The dual of data, known as codata, can be seen as an object.""
  - ""Functional languages are known to enjoy an elegant connection to logic: lambda-calculus corresponds to natural deduction.""",,"- The abstract mentions the connection between functional languages and logic, specifically referencing lambda-calculus and natural deduction. This suggests a foundation in type theory, as lambda-calculus is a fundamental component of type theory.
 - The concept of codata and its relation to objects implies a theoretical framework that involves type theory, as codata is often discussed in the context of type systems.
 - The extension of a basic language with object-oriented features like subtyping, classes, and inheritance suggests a focus on type theory, as these features are typically formalized within type systems.
 - However, the abstract does not explicitly mention the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework. It only hints at the use of type theory through the mention of lambda-calculus and the extension of a language with object-oriented features.","- ""This suggests how the functional and objectoriented paradigms can embrace each other; the extended language also provides a suitable intermediate language for the compilation of the two programming paradigms.""
  - ""To substantiate this approach we extend a basic language containing both data and codata with the essential object-oriented features of subtyping, classes, and inheritance.""
  - ""Analogously to an object defining a pair, a codata pair gives two methods for accessing the first and second components.""
  - ""The dual of data, known as codata, can be seen as an object.""",,"- The abstract discusses the integration of functional and object-oriented programming paradigms through the concept of codata, which is seen as analogous to objects.
 - The integration mechanism proposed involves extending a basic language with both data and codata to include object-oriented features like subtyping, classes, and inheritance.
 - The interaction model between paradigms is described as codata providing methods for accessing components, similar to how objects define pairs.
 - The abstract suggests that this approach allows the two paradigms to ""embrace each other,"" indicating a theoretical integration strategy.
 - The extended language is also described as a suitable intermediate language for compiling both paradigms, which implies a novel translation or embedding technique.
 - There is no explicit mention of constraints or challenges in paradigm integration in the abstract.","- ""This suggests how the functional and objectoriented paradigms can embrace each other; the extended language also provides a suitable intermediate language for the compilation of the two programming paradigms.""
  - ""To substantiate this approach we extend a basic language containing both data and codata with the essential object-oriented features of subtyping, classes, and inheritance.""
  - ""The dual of data, known as codata, can be seen as an object.""
  - ""Our goal is to describe how objects arise naturally in logic.""
  - ""Type systems have been designed to capture all the fancy features present in current object-oriented languages.""",,"- The abstract discusses the relationship between object-orientation and logic, focusing on how objects can be represented in a logical framework using codata.
 - It mentions the extension of a basic language with object-oriented features like subtyping, classes, and inheritance, which are related to abstraction mechanisms.
 - However, there is no explicit mention of generic programming or specific mechanisms for representing generic abstractions.
 - The abstract does not provide details on minimal type requirements or static checking strategies related to generic programming.
 - The focus is more on integrating object-oriented features into a logical framework rather than on generic programming methodologies.","- ""The dual of data, known as codata, can be seen as an object.""
  - ""Our goal is to describe how objects arise naturally in logic.""
  - ""Analogously to an object defining a pair, a codata pair gives two methods for accessing the first and second components.""
  - ""To substantiate this approach we extend a basic language containing both data and codata with the essential object-oriented features of subtyping, classes, and inheritance.""
  - ""This suggests how the functional and objectoriented paradigms can embrace each other; the extended language also provides a suitable intermediate language for the compilation of the two programming paradigms.""",,"- The abstract introduces a novel insight by suggesting that objects can arise naturally in logic, which is a departure from the traditional view that object-oriented languages lack a clear logical foundation.
 - The concept of ""codata"" as the dual of data is presented as a theoretical contribution, where codata is seen as an object that specifies all possible ways to use it, offering a new perspective on object-oriented programming.
 - The extension of a basic language with both data and codata to include object-oriented features like subtyping, classes, and inheritance is a theoretical advancement. It bridges the gap between functional and object-oriented paradigms, suggesting a way for these paradigms to coexist.
 - The potential implication for programming language design is the creation of an intermediate language that can compile both functional and object-oriented programming paradigms, which could lead to more versatile and efficient programming languages."
BIONETS WP 2.2 – PARADIGM APPLICATION AND MAPPING D2.2.9 Mathematical Framework for Interaction Computing with Applications to Security and Service Choreography,"Paolo Dini, Gabor Horvath, Daniel Schreckling, Heiko Pfeffer",-,-,-,3,2009,Not specified (the abstract does not explicitly list or define the conceptual primitives),"- Type of mathematical framework: Algebraic structure, Lie group structure, Category Theory
 - Specific mathematical properties guaranteed: Concurrency, interdependability, non-deterministic and probabilistic computation, modularity
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of time-independent algebraic structure and time-dependent Lie group structure to model cellular pathways as static and dynamic symmetries.
 - Theoretical advancements: Ability to specify desired behavioral properties and derive corresponding structural properties; novel approach to language design by analyzing problem dynamics and structure first.
 - Potential implications for programming language design: Focus on behavioral specifications for language design.","- ""In the course of our research we will learn about this structure and identify basic functional components inspired by biology. This will also determine the primitives of the language.""
  - ""To make progress in this direction, we take as a starting hypothesis that the dynamically stable operation of the cell is critically dependent on two additional forms of structure that are more abstract than physical structure and that can be formalised mathematically as follows (see Figure 4): • Time-independent algebraic structure of the automata modelling the cellular pathways. Algebraic structure gives rise to what we are calling static symmetries. • Time-dependent Lie group structure of the dynamical systems modelling the same cellular pathways. This form of structure is formalised through a mixture of algebra and geometry and gives rise to what we are calling dynamic symmetries.""
  - ""The benefit of such a relationship would be the ability to specify desired behavioural properties and derive the corresponding structural properties (please see Appendix B for more elaboration).""
  - ""On top of that, our language will be based on behaviour the system to be described should exhibit.""",,"- The abstract discusses two main mathematical structures: time-independent algebraic structure and time-dependent Lie group structure. These are related to static and dynamic symmetries, respectively.
 - The abstract mentions that these structures are used to derive structural properties from desired behavioral properties, which suggests a focus on how these mathematical structures can be used to define programming paradigms.
 - The abstract indicates that the research aims to identify basic functional components inspired by biology, which will determine the primitives of the language. However, it does not explicitly list or define these primitives.
 - The abstract does not provide specific names or definitions for the conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""Category Theory Specification of Interaction Computing Machine Algebraic Structure of Automata & Dynamical Systems""
  - ""Time-independent algebraic structure of the automata modelling the cellular pathways. Algebraic structure gives rise to what we are calling static symmetries.""
  - ""Time-dependent Lie group structure of the dynamical systems modelling the same cellular pathways. This form of structure is formalised through a mixture of algebra and geometry and gives rise to what we are calling dynamic symmetries.""
  - ""The benefit of such a relationship would be the ability to specify desired behavioural properties and derive the corresponding structural properties (please see Appendix B for more elaboration).""
  - ""Interaction computing is highly different from existing systems in terms of its concurrency, its interdependability, its realisation of functionality, its non-deterministic and probabilistic computation, and its modularity.""",,"- The abstract mentions the use of ""algebraic structure"" and ""Lie group structure"" as part of the mathematical framework, indicating a focus on algebra and geometry.
 - The mention of ""Category Theory Specification"" suggests that category theory is part of the framework, which is a type of mathematical framework used for formalizing and guaranteeing properties.
 - The abstract discusses the ability to ""specify desired behavioural properties and derive the corresponding structural properties,"" which implies a focus on formal verification.
 - The framework is designed to handle ""concurrency, interdependability, non-deterministic and probabilistic computation, and modularity,"" which are specific mathematical properties guaranteed by the framework.
 - The abstract does not explicitly mention proof techniques or limitations, but it does highlight the unique aspects of interaction computing that the framework is designed to address.","- ""The relevance of the relationship between structure and function to all types of engineering and applied thinking motivates us to investigate how these two kinds of mathematical structure are related.""
  - ""The benefit of such a relationship would be the ability to specify desired behavioural properties and derive the corresponding structural properties""
  - ""Having summarised the main concepts of the mathematical theory, we now start building a bridge towards computer science.""
  - ""Interaction computing is highly different from existing systems in terms of its concurrency, its interdependability, its realisation of functionality, its non-deterministic and probabilistic computation, and its modularity.""
  - ""instead of trying to describe interaction computing using an existing language, adapting it to our needs, we take the opposite approach and start with analysing the problem first, i.e. its dynamical and structural properties.""
  - ""On top of that, our language will be based on behaviour the system to be described should exhibit.""",,"- The abstract discusses the integration of mathematical structures from biology into computer science, particularly focusing on the relationship between structure and function.
 - It mentions building a bridge from mathematical theory to computer science, which implies a theoretical integration strategy.
 - The abstract highlights the unique characteristics of interaction computing, such as concurrency and non-determinism, which suggests a need for novel integration mechanisms.
 - The approach involves analyzing the problem first and then developing a language based on the behavior of the system, which could be seen as a novel translation or embedding technique.
 - However, the abstract does not explicitly describe specific integration mechanisms, interaction models between paradigms, or constraints/challenges in paradigm integration.","- ""In the course of our research we will learn about this structure and identify basic functional components inspired by biology. This will also determine the primitives of the language.""
  - ""Interaction computing is highly different from existing systems in terms of its concurrency, its interdependability, its realisation of functionality, its non-deterministic and probabilistic computation, and its modularity.""
  - ""Having summarised the main concepts of the mathematical theory, we now start building a bridge towards computer science.""
  - ""The benefit of such a relationship would be the ability to specify desired behavioural properties and derive the corresponding structural properties (please see Appendix B for more elaboration).""
  - ""To make progress in this direction, we take as a starting hypothesis that the dynamically stable operation of the cell is critically dependent on two additional forms of structure that are more abstract than physical structure and that can be formalised mathematically as follows (see Figure 4): • Time-independent algebraic structure of the automata modelling the cellular pathways. Algebraic structure gives rise to what we are calling static symmetries. • Time-dependent Lie group structure of the dynamical systems modelling the same cellular pathways.""",,"- The abstract discusses the use of mathematical structures such as algebraic and Lie group structures to model cellular pathways, which suggests a focus on abstract representations.
 - The mention of deriving structural properties from behavioral properties indicates a mechanism for representing generic abstractions.
 - The abstract does not explicitly mention generic programming or type systems, but it does discuss building a new language based on behavior, which implies some level of abstraction.
 - The focus on identifying basic functional components inspired by biology suggests a conceptual abstraction mechanism.
 - However, the abstract does not provide specific details on minimal type requirements or static checking strategies.","- ""To make progress in this direction, we take as a starting hypothesis that the dynamically stable operation of the cell is critically dependent on two additional forms of structure that are more abstract than physical structure and that can be formalised mathematically as follows (see Figure 4): • Time-independent algebraic structure of the automata modelling the cellular pathways. Algebraic structure gives rise to what we are calling static symmetries. • Time-dependent Lie group structure of the dynamical systems modelling the same cellular pathways. This form of structure is formalised through a mixture of algebra and geometry and gives rise to what we are calling dynamic symmetries.""
  - ""The benefit of such a relationship would be the ability to specify desired behavioural properties and derive the corresponding structural properties (please see Appendix B for more elaboration).""
  - ""instead of trying to describe interaction computing using an existing language, adapting it to our needs, we take the opposite approach and start with analysing the problem first, i.e. its dynamical and structural properties.""
  - ""On top of that, our language will be based on behaviour the system to be described should exhibit.""
  - ""Interaction computing is highly different from existing systems in terms of its concurrency, its interdependability, its realisation of functionality, its non-deterministic and probabilistic computation, and its modularity.""",,"- The abstract introduces a novel theoretical framework by proposing two abstract forms of structure: time-independent algebraic structure and time-dependent Lie group structure. These are used to model cellular pathways and are referred to as static and dynamic symmetries, respectively. This is a key novel insight as it applies mathematical structures to biological systems in a way that can be transferred to computer science.
 - The theoretical advancement lies in the ability to specify desired behavioral properties and derive corresponding structural properties. This is a significant contribution as it allows for a more systematic approach to designing systems based on their intended behavior.
 - The abstract highlights that interaction computing differs significantly from existing systems due to its unique characteristics such as concurrency, interdependence, and non-deterministic computation. This suggests a theoretical contribution in addressing these challenges through a new approach.
 - The study takes a novel approach by starting with the analysis of the problem's dynamical and structural properties rather than adapting existing languages. This is a theoretical advancement as it focuses on understanding the problem's nature before developing a language.
 - The language design is based on the behavior the system should exhibit, which is a novel approach compared to traditional language design methods. This has potential implications for programming language design by focusing on behavioral specifications."
Non-Cartesian Guarded Recursion with Daggers,Louis Lemonnier,10.48550/arXiv.2409.14591,https://doi.org/10.48550/arXiv.2409.14591,arXiv.org,0,2024,"1. Primitive Name: Guarded Recursion
  Definition: A paradigm for capturing and controlling recursive calls within the type system.
  Orthogonality Score: High
 

 2. Primitive Name: Later Functor
  Definition: A functor that shifts all components to the right, used for delaying or shifting components in a categorical model.
  Orthogonality Score: High
 

 3. Primitive Name: Rig Category
  Definition: A category equipped with symmetric monoidal structures, used for modeling reversible programming.
  Orthogonality Score: High
 

 4. Primitive Name: Dagger Category
  Definition: A category with an involutive operator on morphisms, ensuring reversibility of operations.
  Orthogonality Score: High","- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Enrichment, fixed points, preservation of monoidal structures
 - Proof techniques used: Construction of categories, application of fixed point theorems
 - Limitations or constraints of the framework: Challenges in applying to certain programming paradigms like quantum computing","- Specific integration mechanisms proposed: Use of dagger categories to model reversible programming.
 - Interaction models between paradigms: Construction of categories like C ∞ e and C ∞ † to interpret reversible programming languages.
 - Constraints or challenges in paradigm integration: Difficulty in integrating paradigms that do not fit into cartesian closed categories.
 - Novel translation or embedding techniques: Guarded recursion to bypass issues in reversible programming through later modality and fixed point operator.",Generic programming not extensively addressed,"- Novel application of guarded recursion in dagger categories for reversible programming.
 - Theoretical framework for guarded recursion in non-cartesian settings.
 - Modeling reversible programming languages like symmetric pattern-matching using guarded recursion.
 - Addressing recursion issues in non-cartesian settings with guarded recursion.
 - Potential for future research on internal logic of introduced categories.","- ""Guarded recursion is a recent paradigm that allows us to capture and control recursive calls within the type system""
  - ""The category C ∞ † is by definition a dagger category.""
  - ""The category C ∞ e is a rig category. It is in particular ⊕-cartesian.""
  - ""the later functor L C restricts and corestricts to C ∞ e (if X is a cochain of dagger epimorphisms, L C X is too).""
  - ""The category C ∞ not only is enriched in S, but also shares some structure with it, such as the later functor.""
  - ""The later functor is the functor L : S → S such that given an object X in S, we have LX(0) = 1 and LX(n+1) = X(n); and given a morphism α : X → Y in S, we have Lα 0 = ! 1 (the terminal map), and (Lα) n+1 = α n""",,"- The paper introduces ""guarded recursion"" as a paradigm for controlling recursive calls, which is a conceptual primitive for reconstructing programming paradigms.
 - The ""later functor"" is a key primitive in this framework, used to delay or shift components in a categorical model, which is essential for guarded recursion.
 - The paper discusses the enrichment of categories in the topos of trees (S), which provides a structure for interpreting guarded recursion.
 - The ""rig category"" and ""dagger category"" are also conceptual primitives, as they provide structures for modeling reversible programming and ensuring reversibility of operations.
 - The ""later functor"" and the ""rig category"" are orthogonal primitives, as they serve different purposes: the later functor is about delaying or shifting components, while the rig category is about providing a structure for reversible operations.","- ""Guarded recursion is a framework allowing for a formalisation of streams in classical programming languages.""
  - ""The latter take their semantics in cartesian closed categories.""
  - ""we focus on reversible programming through the prism of dagger categories, which are categories that contain an involutive operator on morphisms.""
  - ""Given a dagger category, we build categories shown to be suitable for guarded recursion in multiple ways, via enrichment and fixed point theorems.""
  - ""The category S is a cartesian closed category.""
  - ""The category C ∞ yields an S-enriched category with the following data:""
  - ""The category C ∞ e is a rig category. It is in particular ⊕-cartesian.""
  - ""The category C ∞ † is by definition a dagger category.""
  - ""The results obtained above in this paper suggest that guarded recursion is a way to bypass those issues.""
  - ""the category C ∞ has a terminal object, that we write T , and which can be pictured in C with the following constant sequence:""
  - ""the category C ∞ is contractively complete [BMSS12, Definition 7.4].""
  - ""the category C ∞ e needs to preserve some of the structure, both linked to guarded recursion and to the monoidal tensors.""",,"- The paper uses category theory as the mathematical framework to formalize and guarantee properties of the conceptual primitives. This is evident from the repeated references to categories and their properties.
 - The framework involves cartesian closed categories, dagger categories, and rig categories, which are specific types of categories used to model different aspects of programming languages.
 - The paper guarantees properties such as enrichment, fixed points, and the preservation of monoidal structures, which are crucial for modeling guarded recursion and reversible programming.
 - The proof techniques used include the construction of categories and the application of fixed point theorems to ensure the existence of fixed points for certain functors.
 - The limitations or constraints of the framework are not explicitly mentioned, but the paper discusses challenges in applying these frameworks to certain types of programming paradigms, such as quantum computing.","- ""The latter take their semantics in cartesian closed categories. However, some programming paradigms do not take their semantics in a cartesian setting; this is the case for concurrency, reversible and quantum programming for example.""
  - ""In this paper, we focus on reversible programming through the prism of dagger categories, which are categories that contain an involutive operator on morphisms.""
  - ""The goal of this paper is to show that guarded recursion has a use beyond the formalisation of streams in classical programming languages. This is done through the prism of dagger categories.""
  - ""we show that our construction is suitable as a model of reversible programming languages, such as symmetric pattern-matching.""
  - ""we show that the guarded construction from a dagger rig category is a categorical model of a reversible programming language with guarded recursion based on pattern-matching""
  - ""The category C ∞ e is a rig category. It is in particular ⊕-cartesian.""
  - ""The category C ∞ † is by definition a dagger category. While it is a difficult task to exactly characterise the morphisms of C ∞ † , we can point out a sufficient number of them to interpret a reversible programming language.""
  - ""The results obtained above in this paper suggest that guarded recursion is a way to bypass those issues. A sort of recursion would be ensured due to the later modality and to the typing rule for the fixed point operator""",,"- The paper discusses the integration of different programming paradigms by focusing on reversible programming and its interaction with guarded recursion.
 - The integration mechanism proposed involves using dagger categories, which are categories with an involutive operator on morphisms, to model reversible programming.
 - The interaction model between paradigms is achieved through the construction of categories like C ∞ e and C ∞ †, which are used to interpret reversible programming languages.
 - The paper highlights the challenge of integrating paradigms that do not fit into cartesian closed categories, such as concurrency and quantum programming.
 - A novel translation technique involves using guarded recursion to bypass issues in reversible programming, particularly through the later modality and fixed point operator.","- ""The goal of this paper is to show that guarded recursion has a use beyond the formalisation of streams in classical programming languages. This is done through the prism of dagger categories.""
  - ""The category C ∞ not only is enriched in S, but also shares some structure with it, such as the later functor.""
  - ""The category C ∞ e is a rig category. It is in particular ⊕-cartesian.""
  - ""The category C ∞ † is by definition a dagger category.""
  - ""the semantics of symmetric pattern-matching [SVV18] with inductive types and higher-order quantum operations is an open question.""
  - ""The results obtained above in this paper suggest that guarded recursion is a way to bypass those issues.""",,"- The paper primarily focuses on extending guarded recursion to non-cartesian settings using dagger categories, which is a different focus from generic programming.
 - The paper discusses categorical structures and their properties, such as enrichment and rig categories, but these are not directly related to generic programming or abstraction mechanisms.
 - There is no explicit mention of generic programming methodology, type system discussions, or abstraction mechanism explanations that would typically be associated with genericity and abstraction.
 - The paper's focus is on the application of guarded recursion in reversible programming and dagger categories, rather than on generic programming or abstraction mechanisms.","- ""The goal of this paper is to show that guarded recursion has a use beyond the formalisation of streams in classical programming languages. This is done through the prism of dagger categories.""
  - ""we show that the guarded construction from a dagger rig category is a categorical model of a reversible programming language with guarded recursion based on pattern-matching""
  - ""The story of reversible guarded recursion is very different to the classical one.""
  - ""we show that our construction is suitable as a model of reversible programming languages, such as symmetric pattern-matching.""
  - ""The results obtained above in this paper suggest that guarded recursion is a way to bypass those issues. A sort of recursion would be ensured due to the later modality and to the typing rule for the fixed point operator""
  - ""There are several points that can be tackled as further work. One avenue of research is to determine the internal logic behind the categories C ∞ , C ∞ e and C ∞ † , since their structure is close to the one of the topos of trees.""",,"- The paper introduces a novel application of guarded recursion beyond its traditional use in classical programming languages by extending it to dagger categories, which are relevant for reversible programming.
 - It provides a theoretical framework for modeling guarded recursion in non-cartesian settings, which is a departure from the traditional cartesian closed categories.
 - The paper demonstrates how the guarded construction can be used to model reversible programming languages, specifically symmetric pattern-matching, which is a significant theoretical contribution.
 - The use of guarded recursion in reversible programming addresses issues related to recursion in non-cartesian settings, offering a new approach to handling recursive calls in reversible contexts.
 - The paper suggests future research directions, such as exploring the internal logic of the categories introduced, indicating potential for further theoretical development."
Linguistic paradigms for programming complex distributed systems,G. Agha,10.1145/234528.234730,https://doi.org/10.1145/234528.234730,CSUR,3,1996,"1. Primitive Name: Actor Model
  Definition: A flexible method for representing computation in real-world systems, extending objects to concurrent computation by encapsulating a thread of control.
  Orthogonality Score: Not discussed
 2. Primitive Name: Asynchronous Communication
  Definition: Preserves the available potential for parallel activity; an actor sending a message need not block until the recipient is ready.
  Orthogonality Score: Not discussed
 3. Primitive Name: Dynamic Interconnection
  Definition: Actor addresses may be communicated in messages, allowing dynamic interconnection.
  Orthogonality Score: Not discussed
 4. Primitive Name: Actor Creation
  Definition: New actors may be created with unique addresses.
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The actor model provides a flexible method for representing computation in real-world systems, extending objects to concurrent computation.
 - Theoretical advancements: Actors extend the concept of objects to concurrent computation, providing a general and inherently parallel model. Abstracting over patterns of interactions between actors simplifies complex interactions.
 - Potential implications for programming language design: Finding the right set of abstractions for building complex distributed systems, addressing security and modularity in distributed software development.","- ""The actor model provides a flexible method for representing computation in real-world systems.""
  - ""Actors extend the concept of objects to concurrent computation [Agha 1986].""
  - ""Specifically, objects encapsulate a state and a set of procedures that manipulate the state; actors extend this by also encapsulating a thread of control.""
  - ""Each actor potentially executes in parallel with other actors and may send messages to actors of which it knows the addresses.""
  - ""Actor addresses may be communicated in messages, allowing dynamic interconnection.""
  - ""Finally, new actors may be created; such actors have their own unique addresses.""
  - ""The actor model is general and inherently parallel.""
  - ""asynchronous communication preserves the available potential for parallel activity: an actor sending a message need not block until the recipient is ready to receive (or process) a message.""
  - ""More complex communication patterns, such as remote procedure calls, can easily be expressed as a series of asynchronous messages [Agha 1990].""
  - ""Concurrency leads to complex interactions among different actors.""
  - ""To simplify the task of implementing realworld systems, we must abstract over patterns of interactions between actors.""
  - ""The goal of our research is to find the right set of abstractions for building complex distributed systems.""",,"- The abstract discusses the actor model as a conceptual framework for representing computation in distributed systems. This suggests that the actor model itself is a conceptual primitive.
 - The actor model extends the object concept by encapsulating a thread of control, which is a key primitive in concurrent computation.
 - The ability of actors to execute in parallel and communicate asynchronously is highlighted as a fundamental aspect of the model.
 - The abstract mentions the dynamic interconnection of actors through address communication and the creation of new actors with unique addresses, which are part of the actor model's primitives.
 - The focus on asynchronous communication and its role in preserving parallel activity indicates that this is a critical primitive in the actor model.
 - The abstract does not explicitly list or define specific conceptual primitives beyond the actor model and its components. However, it emphasizes the need for abstractions to simplify interactions between actors, suggesting that these abstractions are part of the conceptual primitives.","- ""The actor model provides a flexible method for representing computation in real-world systems.""
  - ""Actors extend the concept of objects to concurrent computation [Agha 1986].""
  - ""It is possible to extend any sequential language with the actor constructs (e.g., the callby-value l calculus is extended in Agha et al. [1996]).""
  - ""The actor model is general and inherently parallel.""
  - ""Concurrency leads to complex interactions among different actors.""
  - ""The goal of our research is to find the right set of abstractions for building complex distributed systems.""",,"- The abstract discusses the actor model and its application to concurrent computation, but it does not explicitly mention a mathematical framework used to formalize or guarantee properties of these conceptual primitives.
 - The mention of extending sequential languages with actor constructs suggests some theoretical foundation, but it does not specify a particular mathematical framework like type theory or category theory.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.
 - The focus is on the conceptual and practical aspects of the actor model rather than its mathematical formalization.","- ""The actor model provides a flexible method for representing computation in real-world systems.""
  - ""It is possible to extend any sequential language with the actor constructs""
  - ""The actor model is general and inherently parallel.""
  - ""Concurrency leads to complex interactions among different actors.""
  - ""The goal of our research is to find the right set of abstractions for building complex distributed systems.""
  - ""Consider requirements such as security, availability, and atomicity.""
  - ""The implementation of interaction policies is generally quite complex.""
  - ""Current techniques for developing distributed software require developers to implement interaction policies and application behavior together, significantly complicating code.""",,"- The abstract discusses the actor model as a flexible method for representing computation in distributed systems, which implies a focus on integrating concurrent computation into existing sequential languages.
 - The mention of extending any sequential language with actor constructs suggests a mechanism for integrating different programming paradigms, specifically by adding concurrency to sequential languages.
 - The abstract highlights the complexity of interactions among actors and the need for abstractions to simplify these interactions, which could be seen as a challenge in integrating different paradigms.
 - The discussion of requirements like security, availability, and atomicity implies constraints that need to be considered in the integration process.
 - However, the abstract does not explicitly describe a specific integration approach or novel translation techniques for integrating different programming paradigms.","- ""The actor model provides a flexible method for representing computation in real-world systems.""
  - ""Actors extend the concept of objects to concurrent computation [Agha 1986].""
  - ""Specifically, objects encapsulate a state and a set of procedures that manipulate the state; actors extend this by also encapsulating a thread of control.""
  - ""It is possible to extend any sequential language with the actor constructs (e.g., the callby-value l calculus is extended in Agha et al. [1996]).""
  - ""A more concrete way to think of actors is as an abstraction over concurrent architectures.""
  - ""The actor model is general and inherently parallel.""
  - ""Concurrency leads to complex interactions among different actors.""
  - ""The goal of our research is to find the right set of abstractions for building complex distributed systems.""
  - ""Consider requirements such as security, availability, and atomicity.""
  - ""The implementation of interaction policies is generally quite complex.""",,"- The abstract discusses the actor model as a method for representing computation in distributed systems, which implies a focus on abstraction mechanisms.
 - Actors are described as extending the concept of objects to include concurrent computation, which suggests a form of generic abstraction.
 - The mention of extending sequential languages with actor constructs indicates a mechanism for representing generic abstractions.
 - The abstract refers to actors as an abstraction over concurrent architectures, which aligns with the concept of abstraction mechanisms.
 - The goal of finding the right set of abstractions for complex distributed systems suggests a focus on abstraction mechanisms.
 - The abstract does not explicitly mention generic programming methodology, type system discussions, or minimal type requirements, nor does it discuss static checking or optimization strategies.
 - The focus is more on the conceptual abstraction provided by the actor model rather than specific generic programming techniques.","- ""The actor model provides a flexible method for representing computation in real-world systems.""
  - ""Actors extend the concept of objects to concurrent computation [Agha 1986].""
  - ""An actor runtime system provides the interface to services such as global addressing, memory management, fair scheduling, and communication [Kim and Agha 1995].""
  - ""The actor model is general and inherently parallel.""
  - ""Concurrency leads to complex interactions among different actors. To simplify the task of implementing realworld systems, we must abstract over patterns of interactions between actors.""
  - ""The goal of our research is to find the right set of abstractions for building complex distributed systems.""
  - ""Consider requirements such as security, availability, and atomicity. How can we define a component that imposes a certain security policy on an arbitrary application?""
  - ""The implementation of interaction policies is generally quite complex. Current techniques for developing distributed software require developers to implement interaction policies and application behavior together, significantly complicating code.""",,"- The abstract discusses the actor model as a novel approach for representing computation in distributed systems, which is a key theoretical contribution.
 - The extension of objects to concurrent computation through actors is highlighted as a significant advancement, indicating a theoretical innovation beyond existing object-oriented programming paradigms.
 - The mention of abstracting over patterns of interactions between actors suggests a theoretical contribution towards simplifying complex interactions in distributed systems.
 - The focus on finding the right set of abstractions for building complex distributed systems implies a theoretical contribution towards improving the design of programming languages for distributed systems.
 - The discussion on imposing security policies and the complexity of current techniques suggests a theoretical contribution towards addressing security and modularity in distributed software development."
Concepts and paradigms of object-oriented programming,P. Wegner,10.1145/382192.383004,https://doi.org/10.1145/382192.383004,OOPS,515,1990,"1. Primitive Name: Object
  Definition: An idea that can be manipulated, inherited, and moved through different states.
  Orthogonality Score: High
 2. Primitive Name: Actor
  Definition: A user who can have multiple roles in the system, such as submitter, collaborator, reviewer, and evaluator.
  Orthogonality Score: High
 3. Primitive Name: Workflow
  Definition: A single process with multiple states through which ideas are processed.
  Orthogonality Score: High",Not specified,"- Specific integration mechanisms proposed: Integration of object-oriented programming concepts with business process workflow concepts.
 - Interaction models between paradigms: Using objects and actors from OOP within a workflow process.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"- Key novel insights: Application of object-oriented programming concepts to idea management systems.
 - Theoretical advancements: Examination of origins and paradigms of object-oriented programming; exploration of language design alternatives and models of concurrency.
 - Potential implications for programming language design: Demonstrates versatility of object-oriented concepts in new domains.","- ""Starting from software engineering goals, we examine the origins and paradigms of object-oriented programming, explore its language design alternatives, consider its models of concurrency, and review its mathematical models to make them accessible to nonmathematical readers.""
  - ""This paper expands on the OOPSLA 89 keynote talk.""
  - ""To solve these issues in the design of an idea management system, this paper proposes a conceptual design of an idea management system based on concepts from object oriented programming (Cox, 1985) and manufacturing production process.""
  - ""The idea management system will be based on the concepts of object, actor and workflow.""
  - ""In this system, the idea is an object, the user is an actor and the process is a workflow.""
  - ""The system will use tags to categorize the ideas into different categories (Carbone et al., 2012).""
  - ""We propose an idea management system based on the concept of an object and an actor from object-oriented paradigm and a single workflow process from a business process perspective.""
  - ""In the system, an idea is basically an object. It can be manipulated, inherited and moved from one state to another state.""
  - ""The user in the system is an actor. As an actor, a user can has multiple roles in the system.""
  - ""The system consists of multiple states in a single workflow.""",,"- The paper discusses the conceptual design of an idea management system using concepts from object-oriented programming and business process workflow.
 - The primitives defined in the paper are ""object,"" ""actor,"" and ""workflow.""
 - The ""object"" refers to an idea that can be manipulated, inherited, and moved through different states.
 - The ""actor"" refers to a user who can have multiple roles in the system, such as submitter, collaborator, reviewer, and evaluator.
 - The ""workflow"" refers to a single process with multiple states through which ideas are processed.
 - These primitives are orthogonal as they represent distinct concepts within the system: the idea itself, the user interacting with the idea, and the process through which ideas are managed.
 - The level of abstraction is high as these primitives are fundamental concepts used to design the system.","- ""Starting from software engineering goals, we examine the origins and paradigms of object-oriented programming, explore its language design alternatives, consider its models of concurrency, and review its mathematical models to make them accessible to nonmathematical readers.""
  - ""Finally, we briefly speculate on what may come after object-oriented programming and conclude that it is a robust component-based modeling paradigm that is both effective and fundamental.""
  - ""In this paper, we are concerns with on how to design an idea management system from a software design perspective.""
  - ""We propose an idea management system based on the concept of an object and an actor from object-oriented paradigm and a single workflow process from a business process perspective.""
  - ""The proposed system has solves many issues related to an idea management system.""
  - ""In conclusion, this paper presents a new perspective in the conceptual design of an idea management system using the concepts of an object and an actor from an object-oriented paradigm and a multi-states single workflow from a business workflow process.""",,"- The paper discusses the origins and paradigms of object-oriented programming and reviews its mathematical models, but it does not specify any particular mathematical framework or properties.
 - The focus of the paper is on the conceptual design of an idea management system using object-oriented programming concepts, not on a mathematical framework.
 - There is no mention of a specific type of mathematical framework such as type theory or category theory.
 - The paper does not discuss any specific mathematical properties guaranteed or proof techniques used.
 - The paper does not mention any limitations or constraints of a mathematical framework.","- ""Starting from software engineering goals, we examine the origins and paradigms of object-oriented programming, explore its language design alternatives, consider its models of concurrency, and review its mathematical models to make them accessible to nonmathematical readers.""
  - ""This paper expands on the OOPSLA 89 keynote talk.""
  - ""We propose an idea management system based on the concept of an object and an actor from object-oriented paradigm and a single workflow process from a business process perspective.""
  - ""The proposed system has solves many issues related to an idea management system.""
  - ""The proposed conceptual architecture provides a general framework to design and to develop an idea management system.""
  - ""In conclusion, this paper presents a new perspective in the conceptual design of an idea management system using the concepts of an object and an actor from an object-oriented paradigm and a multi-states single workflow from a business workflow process.""",,"- The paper discusses the integration of object-oriented programming (OOP) concepts with business process workflow concepts to design an idea management system.
 - The integration mechanism proposed involves using OOP concepts like objects and actors, and combining them with a single workflow process from a business process perspective.
 - The interaction model between paradigms is described as using objects and actors from OOP within a workflow process, which suggests a structured interaction where ideas (objects) are manipulated by users (actors) through different states of the workflow.
 - The paper does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.
 - The focus is on applying OOP concepts to a new domain (idea management) rather than integrating multiple programming paradigms within the same system.","- ""In this paper, we are concerns with on how to design an idea management system from a software design perspective.""
  - ""To solve these issues in the design of an idea management system, this paper proposes a conceptual design of an idea management system based on concepts from object oriented programming (Cox, 1985) and manufacturing production process.""
  - ""The idea management system will be based on the concepts of object, actor and workflow.""
  - ""In the system, an idea is basically an object. It can be manipulated, inherited and moved from one state to another state.""
  - ""An idea (object) can derive its features from one root idea or combinations of features from multiple root ideas.""
  - ""The user in the system is an actor. As an actor, a user can has multiple roles in the system.""
  - ""The proposed system has solves many issues related to an idea management system.""
  - ""The system encourages reuse of ideas or using previous ideas as a template to generate new ideas.""
  - ""The system allows the user to modify, to combine, to add, to expand and to edit previous ideas.""",,"- The paper focuses on designing an idea management system using concepts from object-oriented programming and business process workflow, rather than generic programming or abstraction mechanisms.
 - The paper discusses the use of objects and actors in the system, which are fundamental concepts in object-oriented programming, but it does not delve into generic programming or abstraction mechanisms.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanism explanations that would indicate a focus on genericity and abstraction.
 - The paper's emphasis is on the design of an idea management system rather than on generic programming or conceptual abstraction.","- ""This paper expands on the OOPSLA 89 keynote talk.""
  - ""Starting from software engineering goals, we examine the origins and paradigms of object-oriented programming, explore its language design alternatives, consider its models of concurrency, and review its mathematical models to make them accessible to nonmathematical readers.""
  - ""Finally, we briefly speculate on what may come after object-oriented programming and conclude that it is a robust component-based modeling paradigm that is both effective and fundamental.""
  - ""this paper proposes a conceptual design of an idea management system based on concepts from object oriented programming (Cox, 1985) and manufacturing production process.""
  - ""The proposed system has solves many issues related to an idea management system.""
  - ""The proposed conceptual architecture provides a general framework to design and to develop an idea management system.""
  - ""In conclusion, this paper presents a new perspective in the conceptual design of an idea management system using the concepts of an object and an actor from an object-oriented paradigm and a multi-states single workflow from a business workflow process.""",,"- The paper discusses the origins and paradigms of object-oriented programming, which suggests a theoretical contribution by examining these foundational aspects.
 - It explores language design alternatives and models of concurrency, indicating a theoretical advancement in understanding these aspects of object-oriented programming.
 - The paper speculates on what comes after object-oriented programming, suggesting a forward-thinking theoretical contribution.
 - The proposal of a conceptual design for an idea management system based on object-oriented programming concepts is a novel insight, as it applies these concepts to a new domain.
 - The paper provides a general framework for designing and developing an idea management system, which is a theoretical advancement beyond existing approaches.
 - The use of object-oriented concepts in a new context (idea management) has potential implications for programming language design, as it demonstrates the versatility and applicability of these concepts."
"On Functional Programming , Language Design , andPersistence",Claus Reinke,-,-,-,0,1998,"1. Primitive Name: Abstraction
  Definition: The process of separating properties of objects into two classes, one for details that are relevant to a given task and the other for those that are not.
  Orthogonality Score: High
 

 2. Primitive Name: Correspondence
  Definition: Ensuring consistent rules for the introduction and use of names in programming languages.
  Orthogonality Score: High
 

 3. Primitive Name: Civil Rights of Data Objects
  Definition: The right to participate in all services provided by the general language framework.
  Orthogonality Score: High","- Type of mathematical framework: Lambda calculus
 - Specific mathematical properties guaranteed: Abstraction, compositionality
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,"- Definition of ""concept"" used: Abstraction is the process of separating properties of objects into two classes, one for details that are relevant to a given task and the other for those that are not.
 - Mechanisms for representing generic abstractions: The language is based on the -calculus, which includes multi-parameter abstractions and applications.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: The principles of abstraction and correspondence provide a framework for designing functional programming languages with semantic uniformity and uncompromising support for abstraction.
 - Theoretical advancements: The principle of abstraction is a major tool for handling complexity, and the principle of correspondence ensures consistency in name usage.
 - Potential implications: These principles can guide the design of extensions to functional languages and contribute to achieving a complete characterization of functional programming languages.","- ""The principles are strongly correlated: abstraction, which is explicitly required as a civil right for all language objects, is usually provided by giving names to details that are to be abstracted away in a partial program view.""
  - ""the principle of abstraction demands language support for it.""
  - ""The principle of correspondence derives directly from Landin's work [Lan66], who pointed out that inconsistent rules for the introduction and use of names unnecessarily complicate the description of programming languages and mentioned that `any use of a user-coined name implicitly involves a functional relation'.""
  - ""The principles are not restricted to languages that support only functions as basic units of programming, which is a very welcome property because it means that the principles can also guide the design of extensions to functional languages.""
  - ""the civil rights of data objects in programming languages as the right to participate in all services provided by the general language framework.""",,"- The abstract discusses several key concepts that can be considered as conceptual primitives for reconstructing programming paradigms. These include abstraction, correspondence, and civil rights of data objects.
 - Abstraction is defined as the process of separating properties of objects into relevant and irrelevant details, which is a fundamental concept in handling complexity.
 - The principle of correspondence is about ensuring consistent rules for introducing and using names in programming languages, which is crucial for avoiding inconsistencies.
 - The civil rights of data objects refer to their ability to participate in all services provided by the language framework, which is essential for ensuring that all objects are treated uniformly.
 - These principles are strongly correlated and are not limited to functional programming languages, indicating a high level of abstraction and orthogonality.","- ""The language is basically an extended -calculus, including variables, multi-parameter abstractions and applications.""
  - ""The essential civil rights in this simple language relate to abstraction, which is allowed for all data objects.""",,"- The abstract mentions the use of ""universal quantification"" as a method to formalize abstraction, which is a mathematical concept often used in type theory and formal verification.
 - The language described is based on an ""extended -calculus,"" which is a mathematical framework used to formalize functional programming concepts. The -calculus is a well-known framework in theoretical computer science for studying functions and their properties.
 - The abstract discusses the use of -abstractions and their interpretation as programmer-defined functions, which aligns with the mathematical properties guaranteed by the -calculus, such as abstraction and compositionality.
 - The abstract does not explicitly mention specific proof techniques or limitations of the framework, but it implies that the -calculus provides a foundation for formalizing and guaranteeing properties related to abstraction and functional programming.","- ""To strengthen this point, we investigate the same language again with a slight shift of emphasis, motivated by the needs of programming practice: if programs get large, the original objects of discourse are no longer the only objects of interest.""
  - ""Languages of other paradigms (logic, object-oriented) would need to be evaluated to settle this issue.""
  - ""The principles are not restricted to languages that support only functions as basic units of programming, which is a very welcome property because it means that the principles can also guide the design of extensions to functional languages.""",,"- The abstract discusses the principles of language design that are not limited to functional programming, suggesting a potential for integration with other paradigms.
 - It mentions that languages designed according to these principles might share virtues with functional languages, but does not explicitly describe how different paradigms are integrated.
 - The abstract notes that languages from other paradigms (logic, object-oriented) would need evaluation, indicating a potential for integration but without specific mechanisms or models.
 - The discussion on large programs and the need for abstraction over definitions suggests a challenge in integrating modular programming practices, but again, no specific integration mechanisms are described.
 - The abstract does not provide specific integration mechanisms, interaction models, constraints, or novel translation techniques for integrating different programming paradigms.","- ""abstraction is our major tool to handle complexity, and the principle of abstraction demands language support for it.""
  - ""The principle of correspondence derives directly from Landin's work [Lan66], who pointed out that inconsistent rules for the introduction and use of names unnecessarily complicate the description of programming languages""
  - ""the civil rights of data objects in programming languages as the right to participate in all services provided by the general language framework.""
  - ""abstraction, which is explicitly required as a civil right for all language objects, is usually provided by giving names to details that are to be abstracted away in a partial program view.""
  - ""The principle of correspondence, which explicitly deals with names, implicitly requires that every object that can be named by a declaration can also be passed as a parameter,""
  - ""The language is basically an extended -calculus, including variables, multi-parameter abstractions and applications.""
  - ""The -calculus then establishes the programming framework in which these problem-speci c features may be used.""
  - ""The essential civil rights in this simple language relate to abstraction, which is allowed for all data objects.""
  - ""abstraction over abstractions is also supported by the -calculus.""",,"- The abstract discusses abstraction as a key mechanism for handling complexity, which is a fundamental aspect of generic programming.
 - The principle of abstraction is highlighted as a major tool, indicating its importance in the study.
 - The principle of correspondence is mentioned, which relates to the use of names and parameters, potentially relevant to generic programming.
 - The abstract describes a simple functional language based on the -calculus, which includes multi-parameter abstractions, suggesting a mechanism for generic abstractions.
 - The language allows abstraction over all data objects, which aligns with generic programming principles.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does emphasize abstraction and correspondence, which are relevant to generic programming.","- ""The principles are strongly correlated: abstraction, which is explicitly required as a civil right for all language objects, is usually provided by giving names to details that are to be abstracted away in a partial program view.""
  - ""The principle of correspondence, which explicitly deals with names, implicitly requires that every object that can be named by a declaration can also be passed as a parameter, partially overlapping with the principle of data type completeness.""
  - ""All these principles follow the general rule of `power through simplicity, simplicity through generality' (attributed to van Wijngaarden [vW63]), and we argue that they give a good approximation of some important aspects of purely functional programming languages: semantic uniformity, uncompromising support for abstraction, and no complex exceptions to restrict some language objects to second class status.""
  - ""Therefore, we propose to take the principles as a starting point when searching for a characterization of functional programming languages.""
  - ""The principles are not restricted to languages that support only functions as basic units of programming, which is a very welcome property because it means that the principles can also guide the design of extensions to functional languages.""
  - ""Additional soundness constraints (most likely including CRP and RT) are necessary to get a complete characterization of languages that carry the virtues of functional programming beyond the domain of functions.""
  - ""we conjecture that languages that are complete with respect to the principles also share many of the virtues of functional languages.""",,"- The abstract discusses the principles of abstraction and correspondence as key theoretical contributions. These principles are novel in that they provide a framework for understanding and designing functional programming languages with semantic uniformity and uncompromising support for abstraction.
 - The principle of abstraction is highlighted as a major tool for handling complexity by disregarding inessential details, which is a novel insight into how functional programming languages can be designed to manage complexity.
 - The principle of correspondence ensures that names introduced as formal parameters correspond to names introduced by local declarations, which is a theoretical advancement beyond existing approaches by ensuring consistency in name usage.
 - The abstract suggests that these principles can guide the design of extensions to functional languages, which is a potential implication for programming language design.
 - The mention of additional soundness constraints like CRP and RT indicates a theoretical contribution towards achieving a complete characterization of functional programming languages.
 - The conjecture that languages complete with respect to these principles share virtues of functional languages suggests a theoretical advancement in understanding the nature of functional programming languages."
A Verified Integration of Imperative Parallel Programming Paradigms in an Object-Oriented Language,Paul Sivilotti,-,-,-,1,1993,"1. Primitive Name: Parallel Composition
  Definition: Used to express concurrency
  Orthogonality Score: Not specified
 2. Primitive Name: Atomic Functions
  Definition: Used to express concurrency
  Orthogonality Score: Not specified
 3. Primitive Name: Single-Assignment Variables
  Definition: Used to express concurrency
  Orthogonality Score: Not specified",Not specified (the abstract does not provide details on the mathematical framework used for formal verification),"- Specific integration mechanisms proposed: Collection of libraries
 - Interaction models between paradigms: Not mentioned
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Key novel insights: Integration of imperative parallel programming paradigms into an object-oriented language.
 - Theoretical advancements: Equivalence with traditional models (semaphores, monitors, asynchronous channels) and formal verification of the integration.
 - Potential implications: More comprehensive and flexible framework for parallel programming, influencing future language design by integrating diverse paradigms.","- ""CC++ is a parallel object-oriented programming language that uses parallel composition, atomic functions, and single- assignment variables to express concurrency.""
  - ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely: semaphores, monitors, and asynchronous channels.""",,"- The abstract mentions ""parallel composition, atomic functions, and single-assignment variables"" as elements used in the CC++ programming language to express concurrency. These can be considered as conceptual primitives since they are fundamental components used to construct the programming paradigm.
 - The abstract also mentions ""semaphores, monitors, and asynchronous channels"" as traditional models that are integrated with CC++. These are not explicitly defined as primitives in the abstract but are rather models that the CC++ paradigm is equivalent to.
 - The abstract does not provide explicit definitions for these primitives or discuss their orthogonality.
 - The level of abstraction is implied by the context of being fundamental components of the CC++ language, but it is not explicitly detailed.","- ""A collection of libraries which integrates these traditional models with CC++ is specified, implemented, and formally verified.""",,"- The abstract mentions that a collection of libraries is ""formally verified,"" which suggests the use of a mathematical framework to guarantee certain properties.
 - However, the abstract does not specify the type of mathematical framework used (e.g., type theory, category theory).
 - There is no mention of specific mathematical properties guaranteed by the framework.
 - The abstract does not provide details on the proof techniques used or any limitations or constraints of the framework.
 - The lack of specific details about the mathematical framework, properties, techniques, or limitations means that the information is not explicitly provided in the abstract.","- ""A collection of libraries which integrates these traditional models with CC++ is specified, implemented, and formally verified.""
  - ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely: semaphores, monitors, and asynchronous channels.""
  - ""CC++ is a parallel object-oriented programming language that uses parallel composition, atomic functions, and single- assignment variables to express concurrency.""",,"- The abstract mentions that CC++ integrates traditional imperative communication and synchronization models (semaphores, monitors, and asynchronous channels) into its parallel object-oriented programming paradigm. This suggests a focus on integrating different programming paradigms.
 - The integration is achieved through a ""collection of libraries,"" which implies a specific integration mechanism.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration.
 - There is no mention of novel translation or embedding techniques in the abstract.","- ""CC++ is a parallel object-oriented programming language that uses parallel composition, atomic functions, and single- assignment variables to express concurrency.""
  - ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely: semaphores, monitors, and asynchronous channels.""
  - ""A collection of libraries which integrates these traditional models with CC++ is specified, implemented, and formally verified.""",,"- The abstract mentions that CC++ is a parallel object-oriented programming language, which suggests it might involve some level of abstraction and genericity inherent in object-oriented programming.
 - The focus on ""parallel composition, atomic functions, and single-assignment variables"" indicates mechanisms for expressing concurrency, but these are not explicitly linked to generic programming or abstraction mechanisms.
 - The equivalence to traditional models like semaphores, monitors, and asynchronous channels suggests a focus on concurrency and synchronization rather than generic programming or abstraction.
 - The mention of a ""collection of libraries"" integrating traditional models with CC++ implies some form of abstraction, but it does not specify how these libraries address generic programming or abstraction mechanisms.
 - There is no explicit mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract.","- ""CC++ is a parallel object-oriented programming language that uses parallel composition, atomic functions, and single- assignment variables to express concurrency.""
  - ""We show that this programming paradigm is equivalent to several traditional imperative communication and synchronization models, namely: semaphores, monitors, and asynchronous channels.""
  - ""A collection of libraries which integrates these traditional models with CC++ is specified, implemented, and formally verified.""",,"- The abstract introduces CC++ as a parallel object-oriented programming language, which is a novel integration of imperative parallel programming paradigms. This suggests a key novel insight in combining different programming paradigms within an object-oriented framework.
 - The equivalence of CC++ with traditional models like semaphores, monitors, and asynchronous channels indicates a theoretical advancement. This equivalence shows that CC++ can capture the functionality of these traditional models, which is a significant theoretical contribution.
 - The formal verification of the integration of these models with CC++ is another theoretical advancement. It implies that the integration is not just conceptual but has been rigorously tested and validated, which is crucial for ensuring the reliability and correctness of the programming language.
 - The potential implications for programming language design are significant. By integrating traditional imperative models into an object-oriented language, CC++ offers a more comprehensive and flexible framework for parallel programming. This could influence future programming language design by encouraging the integration of diverse paradigms."
Dagstuhl Seminar 9538 New Trends in the Intergration of Paradigms,Chris Hankin,-,-,-,0,1995,Not specified (the abstract does not explicitly define conceptual primitives for reconstructing programming paradigms),Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Development of integrated languages, design of calculi, coordination languages (e.g., Linda, Gamma)
 - Interaction models between paradigms: Coordination languages based on shared data space
 - Constraints or challenges in paradigm integration: Semantics, verification, static analysis; need for unifying frameworks for transformation and implementation
 - Novel translation or embedding techniques: Use of constraints for efficient implementations",Generic programming not extensively addressed,"- Key novel insights: Integration of programming paradigms, development of integrated languages and calculi, coordination languages based on shared data spaces.
 - Theoretical advancements: Operational semantics surpassing denotational semantics, use of inference systems, need for unifying frameworks for transformation and implementation.
 - Potential implications for programming language design: Integration of paradigms, development of new semantic frameworks.","- ""A number of programming paradigms have been identiied, including object-oriented, concurrent , applicative (functional), declarative (logic), as well as imperative.""
  - ""Integration of paradigms necessitates a deeper understanding of the design methodologies, the semantic basis, the techniques for analysis, transformation and implementation, and the application in the construction of sofware as well as the veriication of the ensuing systems.""
  - ""These problems may be approached via the development of integrated languages or may be studied through the design of calculi that exhibit the essential features.""
  - ""In the past the study of the lambda-calculus and calculi for concurrency have helped in providing a breakthrough in our understanding of functional languages and concurrent systems and calculi for object-orientation are on their way.""
  - ""Coordination languages are based on a model of concurrent computation in which agents cooperate via a shared data space, rather than message passing or shared variables.""
  - ""Problems relating to semantics, (open systems) veriication and static analysis are current research topics.""
  - ""In both approaches, we anticipate that techniques of a deductive nature will prove essential for most theoretical studies: semantics is likely to be based on variations of operational semantics whose descriptive power surpasses that of denotational semantics and more recent semantic frameworks.""
  - ""Consequently analyses may prootably be based on inference systems (perhaps including type systems as special cases).""
  - ""To obtain eecient implementations the use of constraints seem beneecial.""",,"- The abstract discusses various programming paradigms such as object-oriented, concurrent, applicative (functional), declarative (logic), and imperative, but it does not explicitly define conceptual primitives for reconstructing these paradigms.
 - It mentions the integration of paradigms and the need for a deeper understanding of design methodologies, semantic basis, and techniques for analysis, transformation, and implementation. However, it does not specify any conceptual primitives.
 - The abstract refers to the study of lambda-calculus and calculi for concurrency, which are theoretical frameworks, but again, no specific conceptual primitives are defined.
 - Coordination languages and their model of concurrent computation are discussed, but no explicit primitives are mentioned.
 - The abstract discusses semantic frameworks and inference systems, but these are not defined as conceptual primitives.
 - Overall, the abstract does not provide explicit conceptual primitives for reconstructing programming paradigms.","- ""In both approaches, we anticipate that techniques of a deductive nature will prove essential for most theoretical studies: semantics is likely to be based on variations of operational semantics whose descriptive power surpasses that of denotational semantics and more recent semantic frameworks.""
  - ""However, many problems still require unifying frameworks, not least those of transformation and implementation.""
  - ""To obtain eecient implementations the use of constraints seem beneecial.""
  - ""Integration of paradigms necessitates a deeper understanding of the design methodologies, the semantic basis, the techniques for analysis, transformation and implementation, and the application in the construction of sofware as well as the veriication of the ensuing systems.""
  - ""Consequently analyses may prootably be based on inference systems (perhaps including type systems as special cases).""",,"- The abstract discusses the integration of programming paradigms and the need for a deeper understanding of design methodologies and semantic basis, which implies a focus on theoretical foundations.
 - It mentions the use of ""techniques of a deductive nature"" and ""inference systems,"" which suggests a mathematical framework based on deductive reasoning and possibly type theory.
 - The mention of ""operational semantics"" and ""inference systems"" indicates a focus on formal verification and analysis.
 - The abstract does not specify a particular type of mathematical framework like type theory or category theory explicitly, nor does it detail specific mathematical properties guaranteed or limitations of the framework.
 - The mention of ""constraints"" suggests a potential use of constraint-based methods, but this is not explicitly linked to a specific mathematical framework.","- ""There appear to be two ways forward: integration of paradigms taking the best from each or the development of coordination mechanisms which support inter-language working.""
  - ""These problems may be approached via the development of integrated languages or may be studied through the design of calculi that exhibit the essential features.""
  - ""In the past the study of the lambda-calculus and calculi for concurrency have helped in providing a breakthrough in our understanding of functional languages and concurrent systems and calculi for object-orientation are on their way.""
  - ""Coordination languages are based on a model of concurrent computation in which agents cooperate via a shared data space, rather than message passing or shared variables.""
  - ""Examples range from collections of coordination primitives to be embedded in other languages, as in Linda, to pure coordination languages such as Gamma.""
  - ""In both approaches, we anticipate that techniques of a deductive nature will prove essential for most theoretical studies: semantics is likely to be based on variations of operational semantics whose descriptive power surpasses that of denotational semantics and more recent semantic frameworks.""
  - ""However, many problems still require unifying frameworks, not least those of transformation and implementation.""",,"- The abstract discusses two main approaches to integrating programming paradigms: integrating paradigms by taking the best from each and developing coordination mechanisms for inter-language working.
 - Integration of paradigms requires a deeper understanding of design methodologies, semantic basis, analysis, transformation, implementation, and verification.
 - The development of integrated languages and calculi that exhibit essential features are proposed as methods to address these challenges.
 - Coordination languages are mentioned as a model for concurrent computation, with examples like Linda and Gamma.
 - Challenges include semantics, verification, and static analysis, with a focus on operational semantics and inference systems.
 - The use of constraints is suggested for efficient implementations, but unifying frameworks for transformation and implementation are still needed.","- ""In both approaches, we anticipate that techniques of a deductive nature will prove essential for most theoretical studies: semantics is likely to be based on variations of operational semantics whose descriptive power surpasses that of denotational semantics and more recent semantic frameworks.""
  - ""These problems may be approached via the development of integrated languages or may be studied through the design of calculi that exhibit the essential features.""",,"- The abstract discusses the integration of programming paradigms and the need for a deeper understanding of design methodologies, semantic basis, and techniques for analysis and implementation. This suggests a focus on conceptual abstraction and integration rather than specific generic programming mechanisms.
 - The mention of ""integrated languages"" and ""calculi that exhibit the essential features"" implies a focus on developing frameworks that can incorporate multiple paradigms, but it does not specifically address generic programming or abstraction mechanisms.
 - The abstract mentions ""techniques of a deductive nature"" and ""inference systems"" which could relate to type systems, but it does not provide specific details on genericity or abstraction mechanisms.
 - The use of ""constraints"" for efficient implementations is mentioned, but again, this is not specifically related to generic programming or abstraction mechanisms.
 - Overall, the abstract does not provide specific information on generic programming or conceptual abstraction mechanisms, indicating that these topics are not extensively addressed.","- ""These problems may be approached via the development of integrated languages or may be studied through the design of calculi that exhibit the essential features.""
  - ""However, many problems still require unifying frameworks, not least those of transformation and implementation.""
  - ""Coordination languages are based on a model of concurrent computation in which agents cooperate via a shared data space, rather than message passing or shared variables.""
  - ""In the past the study of the lambda-calculus and calculi for concurrency have helped in providing a breakthrough in our understanding of functional languages and concurrent systems and calculi for object-orientation are on their way.""
  - ""In both approaches, we anticipate that techniques of a deductive nature will prove essential for most theoretical studies: semantics is likely to be based on variations of operational semantics whose descriptive power surpasses that of denotational semantics and more recent semantic frameworks.""",,"- The abstract discusses the integration of programming paradigms as a key theoretical contribution, emphasizing the need for a deeper understanding of design methodologies, semantic basis, and analysis techniques.
 - It highlights the development of integrated languages and calculi as a novel approach to understanding and integrating different paradigms.
 - The mention of lambda-calculus and calculi for concurrency and object-orientation suggests a theoretical advancement in understanding functional languages and concurrent systems.
 - The introduction of coordination languages based on shared data spaces is a novel insight into concurrent computation models.
 - The focus on operational semantics and inference systems indicates a theoretical contribution in terms of semantic frameworks.
 - The discussion on the need for unifying frameworks for transformation and implementation suggests a theoretical advancement in addressing these challenges.
 - The abstract also implies potential implications for programming language design by emphasizing the integration of paradigms and the development of new semantic frameworks."
Simplifying OMG MOF-Based Metamodeling,N. Rouquette,10.1007/978-3-319-47169-3_8,https://doi.org/10.1007/978-3-319-47169-3_8,Leveraging Applications of Formal Methods,2,2016,Not specified (the abstract does not explicitly define conceptual primitives or provide specific names and definitions),Not specified (the abstract does not mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Unification of modeling and programming using normalized, implementation-neutral database schemas.
 - Interaction models between paradigms: Information-centric architecture separating structural and operational aspects.
 - Constraints or challenges in paradigm integration: Departure from mainstream API-based or serialization-based approaches.
 - Novel translation or embedding techniques: Treating programs as pure functions and models as pure data.",Generic programming not extensively addressed,"- Key novel insights: Unification of modeling and programming through normalized, implementation-neutral database schemas.
 - Theoretical advancements: Departure from mainstream API ecosystems and external serialization; introduction of an information-centric architecture separating structural and operational aspects.
 - Potential implications: Simplification and integration of programming and modeling processes; potential for more efficient programming language design.","- ""Such tables constitute the basis of a functional information architecture unifying modeling and programming""
  - ""an information-centric architecture to separate the structural aspects of language syntax via normalized schema tables from the operational aspects of language syntax and semantics via programs operating on normalized tables or derived table views.""
  - ""reconstructs several normalized schema accounting for the information content and organization of different kinds of resources involved in modeling: libraries of datatypes, metamodels like UML, profiles like the Systems Modeling Language (SysML) that extend metamodels and models that conform to metamodels optionally extended with applied profiles.""
  - ""representing programs and models in terms of irreducible and independent tables.""",,"- The abstract discusses the idea of representing programs and models using ""irreducible and independent tables,"" which suggests a conceptual primitive related to data representation.
 - The mention of an ""information-centric architecture"" implies a focus on data as a fundamental aspect, which could be considered a conceptual primitive.
 - The use of ""normalized schema tables"" to separate structural and operational aspects indicates a primitive related to data organization and structure.
 - The reconstruction of ""normalized schema"" for various resources (libraries of datatypes, metamodels, profiles) suggests a primitive related to the organization and content of these resources.
 - However, the abstract does not explicitly define these as conceptual primitives or provide specific names or detailed definitions for them.
 - The level of abstraction and orthogonality of these primitives are not explicitly discussed in the abstract.","- ""this idea emphasizes an information-centric architecture to separate the structural aspects of language syntax via normalized schema tables from the operational aspects of language syntax and semantics via programs operating on normalized tables or derived table views.""
  - ""This paper advocates for a unification of modeling & programming from the perspective of normalized, implementation-neutral database schemas: representing programs and models in terms of irreducible and independent tables.""
  - ""This paper first deconstructs the multi-level, reflective architecture for modeling languages defined at the Object Management Group (OMG) based on the Meta-Object Facility (MOF) and the Unified Modeling Language (UML) and subsequently reconstructs several normalized schema accounting for the information content and organization of different kinds of resources involved in modeling:""",,"- The abstract discusses the unification of modeling and programming using normalized database schemas, which suggests a focus on structural and operational aspects of language syntax and semantics.
 - It mentions the deconstruction and reconstruction of multi-level architectures based on MOF and UML, which are related to modeling languages rather than a specific mathematical framework.
 - There is no explicit mention of a mathematical framework such as type theory or category theory, nor are there any details about specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The abstract does not provide any information about theoretical foundations, proof methodology, or formal verification discussions related to a mathematical framework.","- ""This paper advocates for a unification of modeling & programming from the perspective of normalized, implementation-neutral database schemas: representing programs and models in terms of irreducible and independent tables.""
  - ""This idea departs from the mainstream of modeling & programming, which typically revolves around Application Program Interface (API) ecosystems for operational needs and external serialization for interchange needs.""
  - ""Instead, this idea emphasizes an information-centric architecture to separate the structural aspects of language syntax via normalized schema tables from the operational aspects of language syntax and semantics via programs operating on normalized tables or derived table views.""
  - ""Such tables constitute the basis of a functional information architecture unifying modeling and programming as a radical departure from standardizing APIs in a programming fashion or standardizing serialization interchange in a modeling fashion.""
  - ""This paper focuses on the current API-less serialization-centric modeling paradigm because it is the farthest from a unified functional information architecture compared to functional programming languages where thinking about programs as pure functions and models as pure data is closest to this kind of unification.""
  - ""This paper first deconstructs the multi-level, reflective architecture for modeling languages defined at the Object Management Group (OMG) based on the Meta-Object Facility (MOF) and the Unified Modeling Language (UML) and subsequently reconstructs several normalized schema accounting for the information content and organization of different kinds of resources involved in modeling: libraries of datatypes, metamodels like UML, profiles like the Systems Modeling Language (SysML) that extend metamodels and models that conform to metamodels optionally extended with applied profiles.""",,"- The abstract discusses a unification approach that involves representing both programs and models using normalized, implementation-neutral database schemas. This suggests a novel integration mechanism where both programming and modeling are unified under a common framework.
 - The emphasis on an information-centric architecture indicates a shift from traditional API-based or serialization-based approaches, suggesting a new interaction model between paradigms.
 - The abstract mentions deconstructing and reconstructing normalized schema tables, which implies a theoretical integration strategy focusing on structural and operational aspects of language syntax and semantics.
 - The focus on API-less serialization-centric modeling and comparison with functional programming languages suggests a novel translation or embedding technique by treating programs as pure functions and models as pure data.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the departure from mainstream approaches, which could imply potential challenges in adopting this new paradigm.","- ""This paper advocates for a unification of modeling & programming from the perspective of normalized, implementation-neutral database schemas: representing programs and models in terms of irreducible and independent tables.""
  - ""this idea emphasizes an information-centric architecture to separate the structural aspects of language syntax via normalized schema tables from the operational aspects of language syntax and semantics via programs operating on normalized tables or derived table views.""
  - ""This paper first deconstructs the multi-level, reflective architecture for modeling languages defined at the Object Management Group (OMG) based on the Meta-Object Facility (MOF) and the Unified Modeling Language (UML) and subsequently reconstructs several normalized schema accounting for the information content and organization of different kinds of resources involved in modeling: libraries of datatypes, metamodels like UML, profiles like the Systems Modeling Language (SysML) that extend metamodels and models that conform to metamodels optionally extended with applied profiles.""",,"- The abstract discusses a unification of modeling and programming through normalized database schemas, which suggests a focus on abstraction and genericity in terms of data representation.
 - The emphasis on an ""information-centric architecture"" implies a conceptual abstraction mechanism where data is separated from operational aspects, potentially allowing for generic representations.
 - The deconstruction and reconstruction of MOF and UML architectures suggest a focus on abstraction mechanisms, but the abstract does not explicitly mention generic programming or type systems.
 - There is no explicit mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies in the abstract.","- ""This paper advocates for a unification of modeling & programming from the perspective of normalized, implementation-neutral database schemas: representing programs and models in terms of irreducible and independent tables.""
  - ""Such tables constitute the basis of a functional information architecture unifying modeling and programming as a radical departure from standardizing APIs in a programming fashion or standardizing serialization interchange in a modeling fashion.""
  - ""Instead, this idea emphasizes an information-centric architecture to separate the structural aspects of language syntax via normalized schema tables from the operational aspects of language syntax and semantics via programs operating on normalized tables or derived table views.""
  - ""This paper first deconstructs the multi-level, reflective architecture for modeling languages defined at the Object Management Group (OMG) based on the Meta-Object Facility (MOF) and the Unified Modeling Language (UML) and subsequently reconstructs several normalized schema accounting for the information content and organization of different kinds of resources involved in modeling:""
  - ""This idea departs from the mainstream of modeling & programming, which typically revolves around Application Program Interface (API) ecosystems for operational needs and external serialization for interchange needs.""",,"- The abstract introduces a novel approach by advocating for the unification of modeling and programming through the use of normalized, implementation-neutral database schemas. This is a key novel insight as it suggests a new way of integrating these two traditionally separate fields.
 - The theoretical advancement lies in the departure from mainstream practices that focus on API ecosystems and external serialization. Instead, the paper proposes an information-centric architecture that separates structural and operational aspects, which is a significant theoretical contribution.
 - The potential implications for programming language design are substantial, as this approach could lead to more integrated and efficient programming and modeling processes. The emphasis on normalized schema tables could simplify the design and interaction between models and programs.
 - The abstract also mentions the deconstruction and reconstruction of existing architectures like MOF and UML, which suggests a theoretical contribution in terms of rethinking and improving these established frameworks."
The Functional Paradigm,"M. Gabbrielli, S. Martini",10.1007/978-1-84882-914-5_11,https://doi.org/10.1007/978-1-84882-914-5_11,-,0,2010,Not specified (the abstract does not explicitly define conceptual primitives or their orthogonality),Not specified (the abstract mentions lambda-calculus but does not provide specific details about the mathematical framework characteristics),No specific integration approach described,Generic programming not extensively addressed,"Not mentioned (the abstract does not specify any novel insights, theoretical advancements, or potential implications for programming language design)","- ""In functional programming, computation proceeds by rewriting functions and not by modifying the state.""
  - ""The fundamental characteristic of the languages in this paradigm, at least in their ""pure"" form, is precisely that of not possessing the concept of memory (and therefore side effect).""
  - ""Once an environment is fixed, an expression always denotes the same value.""
  - ""The chapter concludes with a more theoretical section which provides a succinct introduction to the lambda-calculus, a formal system for computability which inspires all functional languages and which has been a constant model for the design of programming languages.""",,"- The abstract discusses the main properties of functional programming, which can be considered as conceptual primitives for this paradigm.
 - The first quote indicates that computation in functional programming is based on rewriting functions, which is a fundamental primitive.
 - The second quote highlights the absence of memory and side effects as a characteristic of pure functional programming languages, which can be seen as another primitive.
 - The third quote emphasizes that expressions always denote the same value once the environment is fixed, which is a primitive related to determinism and referential transparency.
 - The mention of lambda-calculus suggests it as a theoretical framework that underlies functional programming, but it is not explicitly defined as a conceptual primitive in the abstract.
 - The abstract does not provide explicit names for these primitives or discuss their orthogonality.","- ""The chapter concludes with a more theoretical section which provides a succinct introduction to the lambda-calculus, a formal system for computability which inspires all functional languages and which has been a constant model for the design of programming languages.""",,"- The abstract mentions the ""lambda-calculus"" as a ""formal system for computability"" that inspires functional languages. This suggests that lambda-calculus is a mathematical framework used in the context of functional programming.
 - The abstract does not provide specific details about the type of mathematical framework beyond mentioning lambda-calculus.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework in the abstract.
 - The abstract does not explicitly discuss theoretical foundations, proof methodology, or formal verification discussions beyond the mention of lambda-calculus.","- ""The chapter concludes with a more theoretical section which provides a succinct introduction to the lambda-calculus, a formal system for computability which inspires all functional languages and which has been a constant model for the design of programming languages.""
  - ""Functional programming languages, however, merge these ""pure"" ingredients in a context that adds many other mechanisms; we will review them before touching upon the SECD machine, an abstract machine for higher-order functional languages which constitutes the prototype of many real implementations.""",,"- The abstract mentions that functional programming languages ""merge these 'pure' ingredients in a context that adds many other mechanisms,"" which suggests some form of integration of different programming paradigms. However, it does not specify what these mechanisms are or how they integrate with other paradigms.
 - The mention of the SECD machine as a prototype for many real implementations implies a theoretical integration strategy, but again, no specific details are provided about how different paradigms are integrated.
 - The abstract does not explicitly discuss interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.
 - The focus on lambda-calculus as a formal system inspiring functional languages does not directly address integration with other paradigms.","- ""In functional programming, computation proceeds by rewriting functions and not by modifying the state.""
  - ""The fundamental characteristic of the languages in this paradigm, at least in their ""pure"" form, is precisely that of not possessing the concept of memory (and therefore side effect).""
  - ""The chapter concludes with a more theoretical section which provides a succinct introduction to the lambda-calculus, a formal system for computability which inspires all functional languages and which has been a constant model for the design of programming languages.""
  - ""Functional programming languages, however, merge these ""pure"" ingredients in a context that adds many other mechanisms; we will review them before touching upon the SECD machine, an abstract machine for higher-order functional languages which constitutes the prototype of many real implementations.""
  - ""Once an environment is fixed, an expression always denotes the same value.""",,"- The abstract discusses the fundamental properties of functional programming, focusing on the absence of state modification and side effects, which are key aspects of functional programming but do not directly address genericity or abstraction mechanisms.
 - The mention of ""rewriting functions"" and ""not possessing the concept of memory"" suggests a focus on functional programming principles rather than generic programming or abstraction mechanisms.
 - The abstract does not explicitly mention generic programming, type systems, or abstraction mechanisms, which are crucial for addressing genericity and abstraction.
 - The discussion of the lambda-calculus is theoretical and related to computability and language design, but it does not specifically address generic programming or abstraction mechanisms.
 - The abstract does not provide any information on minimal type requirements, static checking, or optimization strategies related to generic programming.","- ""In this chapter, we present the main properties of functional programming.""
  - ""The fundamental characteristic of the languages in this paradigm, at least in their ""pure"" form, is precisely that of not possessing the concept of memory (and therefore side effect).""
  - ""We will discuss the pure paradigm in the first sections, explaining the fundamental aspects.""
  - ""Functional programming languages, however, merge these ""pure"" ingredients in a context that adds many other mechanisms; we will review them before touching upon the SECD machine, an abstract machine for higher-order functional languages which constitutes the prototype of many real implementations.""
  - ""We will, at this point, be in a position to discuss the reasons why the functional programming paradigm is interesting with respect to ordinary imperative languages.""
  - ""The chapter concludes with a more theoretical section which provides a succinct introduction to the lambda-calculus, a formal system for computability which inspires all functional languages and which has been a constant model for the design of programming languages.""",,"- The abstract primarily focuses on presenting the main properties and fundamental aspects of functional programming, which suggests a review or introductory nature rather than novel insights.
 - The mention of the ""pure paradigm"" and its characteristics indicates a focus on foundational concepts rather than new theoretical contributions.
 - The discussion of the SECD machine and its role in higher-order functional languages is more about existing mechanisms rather than novel advancements.
 - The comparison with imperative languages and the introduction to lambda-calculus are theoretical discussions but do not explicitly indicate new theoretical contributions beyond existing knowledge.
 - The abstract does not mention any specific novel insights, theoretical advancements, or potential implications for programming language design that are unique to this study."
Generic Programming with Concepts,-,-,-,-,9,2008,Not specified (the abstract discusses concepts as institutions but does not explicitly define specific conceptual primitives),"- Type of mathematical framework: Institutional theory related to category theory, with elements of algebraic specification
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Translation from Haskell generic interfaces to C++ interfaces.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Important differences between C++ and functional languages.
 - Novel translation or embedding techniques: Translation from Haskell to C++ interfaces.","- Definition of ""concept"": Constraints on template parameters
 - Mechanisms for representing generic abstractions: Templates constrained by concepts, formal semantics of separate type checking
 - Minimal type requirements: Implied through formal semantics and mathematical foundations
 - Static checking or optimization strategies: Formal semantics, separate type checking, performance-based component composition","- Formal semantics of separate type checking with concepts
 - Concepts as institutions, enabling application of algebraic specification techniques
 - Conceptual change impact analysis for generic libraries
 - Performance-based component composition tool
 - Application of datatype-generic paradigm to imperative languages like C++
 - Translation of Haskell generic interfaces to C++","- ""Concepts as institutions is another view on the semantics of concepts we
 

 provide in this thesis. Institutions describe the parts of logics: signatures
 

 are the vocabulary, sentences are phrases that can be said given a vocabulary,
 

 and models are the subjects of the phrases.""
  - ""The institutions of concepts we
 

 provide make concepts into logics; the most basic general institution frames
 

 concepts as signatures and concept maps as sentences and models at the same
 

 time.""
  - ""Formally specifying the semantics of programming languages is a difficult
 

 task, one that is taken up rarely due to its complexity. In this thesis we
 

 provide a formal semantics of the separate type checking with concepts.""
  - ""In the C++ programming language, generic programming is
 

 implemented by the means of parameterized fragments of code, called templates,
 

 in which parameters are constrained by concepts.""",,"- The abstract discusses the use of ""concepts"" in generic programming within the C++ language, which are used to constrain parameters in templates. This suggests that concepts are a fundamental primitive in this context.
 - The mention of ""formal semantics of the separate type checking with concepts"" implies that concepts are defined in a formal manner, which is a key aspect of conceptual primitives.
 - The abstract describes ""Concepts as institutions,"" which involves framing concepts as ""signatures,"" ""sentences,"" and ""models."" This indicates a structured approach to defining conceptual primitives.
 - The abstract does not provide explicit names or definitions for specific conceptual primitives beyond the general framework of concepts as institutions. It does not detail specific primitives or their orthogonality.","- ""Formally specifying the semantics of programming languages is a difficult
 

 task, one that is taken up rarely due to its complexity.""
  - ""In this thesis we
 

 provide a formal semantics of the separate type checking with concepts.""
  - ""A formal semantics, such as ours, makes
 

 it easier to discuss language design, to improve the quality of the informal
 

 specification, and may serve as a model for compilers and other tools.""
  - ""Concepts as institutions is another view on the semantics of concepts we
 

 provide in this thesis.""
  - ""Institutions describe the parts of logics: signatures
 

 are the vocabulary, sentences are phrases that can be said given a vocabulary,
 

 and models are the subjects of the phrases.""
  - ""The institutions of concepts we
 

 provide make concepts into logics; the most basic general institution frames
 

 concepts as signatures and concept maps as sentences and models at the same
 

 time.""
  - ""The logic view on concepts makes it possible to apply techniques from
 

 the field of algebraic specification in the realm of C++ programming.""",,"- The abstract mentions the provision of a ""formal semantics of the separate type checking with concepts,"" which suggests a focus on formalizing the semantics of concepts in C++.
 - The mention of ""institutions"" and their role in describing the parts of logics indicates a mathematical framework based on institutional theory, which is related to category theory.
 - The abstract describes how concepts are framed as signatures, concept maps as sentences, and models, which aligns with the use of institutional theory to formalize concepts.
 - The reference to applying techniques from ""algebraic specification"" suggests that the mathematical framework may also involve elements of algebraic specification, which is a method used in formal verification.
 - However, the abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, nor does it discuss limitations or constraints of the framework.","- ""We also consider similarities between generic programming in Haskell
 

 and C++: based on a particular library we provide a translation from Haskell
 

 generic interfaces to the corresponding interfaces in C++.""
  - ""We
 

 investigate how the datatype-generic paradigm applies to an imperative
 

 language such as C++: we provide a possible solution and outline the important
 

 differences between C++ and a functional language that must be taken into
 

 account.""
  - ""Finally, we consider multi-paradigm development of generic libraries.""",,"- The abstract mentions ""multi-paradigm development of generic libraries,"" indicating an integration approach involving different programming paradigms.
 - It specifically discusses applying the ""datatype-generic paradigm"" to C++, which is an imperative language, suggesting a mechanism for integrating this paradigm with C++.
 - The abstract outlines ""important differences between C++ and a functional language,"" which implies consideration of constraints or challenges in integrating these paradigms.
 - A novel translation technique is mentioned, where they ""provide a translation from Haskell generic interfaces to the corresponding interfaces in C++,"" which is a specific integration mechanism.
 - The abstract does not explicitly mention interaction models or detailed theoretical integration strategies, but it does highlight a practical approach to integrating paradigms through translation.","- ""Generic programming is an indispensable ingredient of modern programming
 

 languages.""
  - ""In the C++ programming language, generic programming is
 

 implemented by the means of parameterized fragments of code, called templates,
 

 in which parameters are constrained by concepts.""
  - ""This thesis consists of
 

 seven publications investigating different aspects of generic programming with
 

 concepts---formal semantics of the concepts language feature, the mathematical
 

 foundations of concepts as a specification tool, change impact analysis of
 

 generic libraries, performance-based component composition, and
 

 multi-paradigm, multi-language library development.""
  - ""Formally specifying the semantics of programming languages is a difficult
 

 task, one that is taken up rarely due to its complexity. In this thesis we
 

 provide a formal semantics of the separate type checking with concepts.""
  - ""Concepts as institutions is another view on the semantics of concepts we
 

 provide in this thesis.""
  - ""The institutions of concepts we
 

 provide make concepts into logics; the most basic general institution frames
 

 concepts as signatures and concept maps as sentences and models at the same
 

 time.""
  - ""Generic programming with concepts also requires more practical support: in
 

 this thesis we describe a conceptual change impact analysis for generic
 

 libraries and a tool for performance-based component composition.""
  - ""Our change
 

 impact analysis is applied at the specification level of a generic library,
 

 which comprises the underlying concept hierarchy and generic interfaces of
 

 library functions and data structures.""
  - ""We provide a tool that learns from
 

 experiments and automatically selects the combination of components expected
 

 to be the best in a given situation---a case study is provided for our fast
 

 Fourier transform library.""
  - ""Finally, we consider multi-paradigm development of generic libraries. We
 

 investigate how the datatype-generic paradigm applies to an imperative
 

 language such as C++: we provide a possible solution and outline the important
 

 differences between C++ and a functional language that must be taken into
 

 account.""",,"- The abstract discusses generic programming as a fundamental aspect of modern programming languages, specifically in C++ using templates constrained by concepts.
 - The definition of ""concept"" is implied to be related to constraints on template parameters, but a direct definition is not provided.
 - Mechanisms for representing generic abstractions include the use of templates and concepts, which are formalized through a formal semantics of separate type checking.
 - The abstract mentions the formal semantics of concepts and their mathematical foundations, which could imply minimal type requirements, but these are not explicitly stated.
 - Static checking is implied through the formal semantics and separate type checking with concepts.
 - Optimization strategies are suggested by the mention of performance-based component composition and a tool that selects optimal component combinations.","- ""This thesis consists of
 

 seven publications investigating different aspects of generic programming with
 

 concepts---formal semantics of the concepts language feature, the mathematical
 

 foundations of concepts as a specification tool, change impact analysis of
 

 generic libraries, performance-based component composition, and
 

 multi-paradigm, multi-language library development.""
  - ""Formally specifying the semantics of programming languages is a difficult
 

 task, one that is taken up rarely due to its complexity. In this thesis we
 

 provide a formal semantics of the separate type checking with concepts.""
  - ""A formal semantics, such as ours, makes
 

 it easier to discuss language design, to improve the quality of the informal
 

 specification, and may serve as a model for compilers and other tools.""
  - ""Concepts as institutions is another view on the semantics of concepts we
 

 provide in this thesis. Institutions describe the parts of logics: signatures
 

 are the vocabulary, sentences are phrases that can be said given a vocabulary,
 

 and models are the subjects of the phrases.""
  - ""The logic view on concepts makes it possible to apply techniques from
 

 the field of algebraic specification in the realm of C++ programming.""
  - ""Our change
 

 impact analysis is applied at the specification level of a generic library,
 

 which comprises the underlying concept hierarchy and generic interfaces of
 

 library functions and data structures.""
  - ""We provide a tool that learns from
 

 experiments and automatically selects the combination of components expected
 

 to be the best in a given situation---a case study is provided for our fast
 

 Fourier transform library.""
  - ""We
 

 investigate how the datatype-generic paradigm applies to an imperative
 

 language such as C++: we provide a possible solution and outline the important
 

 differences between C++ and a functional language that must be taken into
 

 account.""
  - ""We also consider similarities between generic programming in Haskell
 

 and C++: based on a particular library we provide a translation from Haskell
 

 generic interfaces to the corresponding interfaces in C++.""",,"- The abstract mentions several novel insights and theoretical contributions, particularly in the area of formal semantics and the mathematical foundations of concepts. The provision of a formal semantics for separate type checking with concepts is highlighted as a significant contribution.
 - The introduction of concepts as institutions provides a new perspective on the semantics of concepts, allowing them to be treated as logics. This enables the application of algebraic specification techniques in C++ programming, which is a theoretical advancement.
 - The development of a conceptual change impact analysis for generic libraries and a tool for performance-based component composition are practical contributions that have theoretical implications for library development and component integration.
 - The exploration of multi-paradigm development, particularly the application of datatype-generic paradigms to imperative languages like C++, and the translation of Haskell generic interfaces to C++, are significant theoretical contributions that expand the scope of generic programming.
 - These contributions have potential implications for programming language design, as they provide new frameworks and tools for improving language specifications and compiler development."
1 Kernel Andorra Prolog ( KAP ) : the language,-,-,-,-,0,2005,"1. Primitive Name: Guarded definite clause languages
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed
 2. Primitive Name: Deep guards
  Definition: Necessary for selecting a single solution or collecting all solutions in nondeterministic languages
  Orthogonality Score: Not discussed
 3. Primitive Name: Guard operators (wait, cut, and commit)
  Definition: Not explicitly defined in the abstract
  Orthogonality Score: Not discussed",Not specified (the abstract does not provide explicit details about the mathematical framework used),"- Specific integration mechanisms proposed: Adding specific constraint systems and operations; use of deep guards and three guard operators (wait, cut, and commit).
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"- Key novel insights: Kernel Andorra Prolog as a framework for nondeterministic concurrent constraint logic programming languages; combination of Prolog and committed choice languages.
 - Theoretical advancements: Formalization of the control of the computation model; transformational semantics; use of deep guards and three guard operators.
 - Potential implications: Enables fully general combinations of programming paradigms; facilitates parallelism through deep guards.","- ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""In general, the machinery of deep guards is necessary in nondeterministic languages, for selecting a single solution, or collecting all solutions for a given goal.""
  - ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""
  - ""Deep guards can *The visit at SICS of Catuscia Palamidessi, during which this work was carried out, has been supported by the project Andorra""",,"- The abstract describes Kernel Andorra Prolog as a framework for nondeterministic concurrent constraint logic programming languages, indicating it is a conceptual framework rather than a specific set of primitives.
 - The mention of ""guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit)"" suggests these are key components or primitives within the framework.
 - The abstract does not provide explicit definitions for these primitives beyond their role in nondeterministic languages and their function in selecting or collecting solutions.
 - There is no mention of the level of abstraction or orthogonality of these primitives in the abstract.","- ""In general, the machinery of deep guards is necessary in nondeterministic languages, for selecting a single solution, or collecting all solutions for a given goal.""
  - ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""The semantics of Kernel Andorra Prolog is a set of or.trees which also captures infinite computations.""
  - ""To this we add a formal description of the transformational semantics of Kernel Andorra Prolog.""
  - ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""",,"- The abstract mentions that Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages, indicating a focus on logic programming and constraint systems.
 - The mention of ""adding the formal machinery"" suggests an effort to formalize the framework, but it does not specify the type of mathematical framework used (e.g., type theory, category theory).
 - The abstract discusses the transformational semantics and the use of ""or.trees"" to capture infinite computations, which are aspects of formal verification but do not specify a particular mathematical framework.
 - The abstract does not provide specific details about the type of mathematical framework, mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus on ""guarded definite clause languages"" and ""deep guards"" indicates specific features of the framework but does not specify the underlying mathematical framework.","- ""Many languages, such as Prolog, GtIC, Parlog, and Atomic Herbrand, can be seen as instances of this framework, by adding specific constraint systems and constraint operations, and optionally by imposing further restrictions on the language and the control of the computation model.""
  - ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""Kernel Andorra Prolog is language framework that is specifically designed to combine the programming paradigms of Prolog and committed choice languages [HJ91], allowing fully general combinations.""
  - ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""
  - ""In particular the generalization to deep guards is essential to achieve the goal of simultaneously subsuming Prolog and exploiting independent and dependent parallelism.""",,"- The abstract describes Kernel Andorra Prolog as a framework that integrates nondeterministic concurrent constraint logic programming languages, indicating a focus on integrating different programming paradigms.
 - It mentions that various languages like Prolog, GtIC, Parlog, and Atomic Herbrand can be seen as instances of this framework by adding specific constraint systems and operations, suggesting a mechanism for integrating these paradigms.
 - The framework is specifically designed to combine Prolog and committed choice languages, allowing for fully general combinations, which is a direct integration approach.
 - The use of ""deep guards"" and ""three guard operators (wait, cut, and commit)"" suggests specific integration mechanisms for managing nondeterminism and parallelism.
 - The abstract does not explicitly mention interaction models or constraints/challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.","- ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""
  - ""In general, the machinery of deep guards is necessary in nondeterministic languages, for selecting a single solution, or collecting all solutions for a given goal.""
  - ""Deep guards can *The visit at SICS of Catuscia Palamidessi, during which this work was carried out, has been supported by the project Andorra""
  - ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""Many languages, such as Prolog, GtIC, Parlog, and Atomic Herbrand, can be seen as instances of this framework, by adding specific constraint systems and constraint operations, and optionally by imposing further restrictions on the language and the control of the computation model.""",,"- The abstract describes Kernel Andorra Prolog as a framework for nondeterministic concurrent constraint logic programming languages, which suggests a level of abstraction and genericity in its design.
 - The mention of various languages being instances of this framework by adding specific constraint systems and operations indicates a mechanism for representing generic abstractions.
 - The use of ""deep guards"" and ""three guard operators (wait, cut, and commit)"" suggests a mechanism for abstraction, as these are used to select solutions or collect all solutions for a given goal.
 - However, the abstract does not explicitly discuss type systems, minimal type requirements, or static checking strategies, which are typically part of generic programming methodologies.
 - The focus is more on the framework's ability to subsume other languages and exploit parallelism rather than on generic programming or abstraction mechanisms per se.","- ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""
  - ""To this we add a formal description of the transformational semantics of Kernel Andorra Prolog.""
  - ""The semantics of Kernel Andorra Prolog is a set of or.trees which also captures infinite computations.""
  - ""Kernel Andorra Prolog is language framework that is specifically designed to combine the programming paradigms of Prolog and committed choice languages [HJ91], allowing fully general combinations.""
  - ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""In particular the generalization to deep guards is essential to achieve the goal of simultaneously subsuming Prolog and exploiting independent and dependent parallelism.""",,"- The abstract introduces Kernel Andorra Prolog as a framework for nondeterministic concurrent constraint logic programming languages, which is a novel approach by itself.
 - The formalization of the control of the computation model and the addition of transformational semantics are significant theoretical contributions, as they provide a comprehensive framework for understanding and working with the language.
 - The combination of Prolog and committed choice languages is a unique theoretical contribution, as it allows for fully general combinations, which is a novel insight in programming language design.
 - The use of deep guards and three guard operators (wait, cut, and commit) is a theoretical advancement, as it enables the selection of a single solution or collection of all solutions for a given goal, which is essential for nondeterministic languages.
 - The generalization to deep guards is crucial for achieving parallelism, which is a significant theoretical contribution with implications for programming language design."
Combining OO and Functional Language Concepts,Qiang Zhen,-,-,-,0,2000,"1. Primitive Name: objects
  Definition: Not specified
  Orthogonality Score: Not discussed
 2. Primitive Name: classes
  Definition: Not specified
  Orthogonality Score: Not discussed
 3. Primitive Name: multiple inheritance
  Definition: Not specified
  Orthogonality Score: Not discussed
 4. Primitive Name: method redefinition
  Definition: Not specified
  Orthogonality Score: Not discussed
 5. Primitive Name: dynamic binding
  Definition: Not specified
  Orthogonality Score: Not discussed
 6. Primitive Name: static type safety
  Definition: Not specified
  Orthogonality Score: Not discussed
 7. Primitive Name: binary methods
  Definition: Not specified
  Orthogonality Score: Not discussed
 8. Primitive Name: algebraic data types
  Definition: Not specified
  Orthogonality Score: Not discussed
 9. Primitive Name: higher order functions
  Definition: Not specified
  Orthogonality Score: Not discussed
 10. Primitive Name: ML polymorphism
  Definition: Not specified
  Orthogonality Score: Not discussed",Not specified (the abstract does not provide details about the mathematical framework used to formalize and guarantee properties),"- Specific integration mechanisms proposed: Combining well-known concepts from mainstream languages without introducing new concepts.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Combining object-oriented and functional programming paradigms without introducing new concepts; integrating well-known concepts from mainstream languages.
 - Theoretical advancements: Ensuring individual language concepts do not overly influence the whole language; proposing a core language with operational semantics for functional object-oriented programming.
 - Potential implications: Providing a more modular and efficient use of language features; integrating diverse programming paradigms into a cohesive framework for future language design.","- ""The core language combines the following key language concepts from the languages Eiffel, Java, ML and Haskell: objects, classes, multiple inheritance, method redefinition, dynamic binding, static type safety, binary methods, algebraic data types, higher order functions, ML polymorphism.""
  - ""the authors do not introduce new language concepts but try to interpret well known language concepts based on the new ones.""
  - ""the authors combine several important concepts as they are well known in widespread mainstream languages.""",,"- The abstract mentions that the authors combine several important concepts from mainstream languages, indicating that these concepts are being used as primitives.
 - It is explicitly stated that the authors do not introduce new language concepts, suggesting that the primitives are existing concepts being reinterpreted.
 - The list of key language concepts from Eiffel, Java, ML, and Haskell provides a clear enumeration of the conceptual primitives: objects, classes, multiple inheritance, method redefinition, dynamic binding, static type safety, binary methods, algebraic data types, higher order functions, and ML polymorphism.
 - The abstract does not provide explicit definitions for each primitive, nor does it discuss their orthogonality or level of abstraction.","- ""the properties mentioned above hold.""
  - ""a core language for functional object oriented programming together with a straightforward operational semantics is proposed,""",,"- The abstract mentions the proposal of a ""core language for functional object oriented programming together with a straightforward operational semantics."" This suggests that the mathematical framework might involve operational semantics, which is a way of describing the meaning of programming languages.
 - The phrase ""the properties mentioned above hold"" implies that certain properties are guaranteed, but it does not specify what these properties are or how they are mathematically formalized.
 - There is no explicit mention of a specific mathematical framework such as type theory or category theory, nor are there details about specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The abstract does not provide any information about theoretical foundations, proof methodology, or formal verification discussions, which are typically where mathematical framework characteristics would be detailed.","- ""This paper considers the problem of combining the object oriented and functional programming paradigms.""
  - ""the combination has the following two advantages.""
  - ""the authors combine several important concepts as they are well known in widespread mainstream languages.""
  - ""the authors do not introduce new language concepts but try to interpret well known language concepts based on the new ones.""
  - ""the combination has the property that individual language concepts do not influence the whole language to the extent as they do traditionally, so that usually one needs to pay for a language concept only when he uses it.""
  - ""a core language for functional object oriented programming together with a straightforward operational semantics is proposed, where the properties mentioned above hold.""
  - ""The core language combines the following key language concepts from the languages Eiffel, Java, ML and Haskell: objects, classes, multiple inheritance, method redefinition, dynamic binding, static type safety, binary methods, algebraic data types, higher order functions, ML polymorphism.""",,"- The abstract discusses the integration of object-oriented and functional programming paradigms, indicating a focus on combining these two paradigms.
 - The integration approach involves combining well-known concepts from mainstream languages without introducing new concepts, suggesting a strategy of reinterpretation rather than innovation.
 - The abstract mentions that individual language concepts do not overly influence the whole language, implying a modular or selective integration approach where concepts are used as needed.
 - A core language is proposed with a straightforward operational semantics, which suggests a theoretical integration strategy.
 - The abstract lists specific language concepts from various languages (Eiffel, Java, ML, Haskell) that are combined in the core language, indicating a focus on integrating these concepts.
 - There is no explicit mention of interaction models, constraints, or novel translation techniques in the abstract.","- ""the authors do not introduce new language concepts but try to interpret well known language concepts based on the new ones.""
  - ""a core language for functional object oriented programming together with a straightforward operational semantics is proposed, where the properties mentioned above hold.""
  - ""the combination has the property that individual language concepts do not influence the whole language to the extent as they do traditionally, so that usually one needs to pay for a language concept only when he uses it.""
  - ""The core language combines the following key language concepts from the languages Eiffel, Java, ML and Haskell: objects, classes, multiple inheritance, method redefinition, dynamic binding, static type safety, binary methods, algebraic data types, higher order functions, ML polymorphism.""
  - ""the authors combine several important concepts as they are well known in widespread mainstream languages.""",,"- The abstract discusses combining object-oriented and functional programming paradigms, focusing on interpreting well-known concepts rather than introducing new ones. This suggests a focus on conceptual abstraction rather than generic programming.
 - The mention of ""individual language concepts do not influence the whole language"" implies a modular approach to language design, which could relate to abstraction mechanisms.
 - The core language combines concepts from various languages, including ""algebraic data types"" and ""higher order functions,"" which are relevant to generic programming. However, these are not explicitly discussed in terms of genericity or abstraction mechanisms.
 - The abstract does not explicitly mention generic programming methodology, type system discussions, or specific abstraction mechanism explanations related to genericity.
 - The focus on combining existing concepts and the lack of explicit mention of generic programming or abstraction mechanisms suggests that genericity is not extensively addressed in this abstract.","- ""This paper considers the problem of combining the object oriented and functional programming paradigms.""
  - ""Compared with most of the approaches in this direction, the combination has the following two advantages.""
  - ""First, the authors combine several important concepts as they are well known in widespread mainstream languages.""
  - ""Second, the combination has the property that individual language concepts do not influence the whole language to the extent as they do traditionally, so that usually one needs to pay for a language concept only when he uses it.""
  - ""Concretely, a core language for functional object oriented programming together with a straightforward operational semantics is proposed, where the properties mentioned above hold.""
  - ""The core language combines the following key language concepts from the languages Eiffel, Java, ML and Haskell: objects, classes, multiple inheritance, method redefinition, dynamic binding, static type safety, binary methods, algebraic data types, higher order functions, ML polymorphism.""",,"- The abstract discusses the combination of object-oriented and functional programming paradigms, which is a significant theoretical contribution as it addresses a long-standing challenge in programming language design.
 - The first advantage mentioned is the combination of well-known concepts from mainstream languages, which suggests a novel approach to integrating these concepts without introducing new ones. This is a key insight as it leverages existing knowledge and frameworks.
 - The second advantage highlights a theoretical advancement by ensuring that individual language concepts do not overly influence the entire language, allowing for more modular and efficient use of language features. This is a significant theoretical contribution as it improves the scalability and usability of the combined paradigm.
 - The proposal of a core language with operational semantics is a theoretical advancement as it provides a structured framework for functional object-oriented programming, which can guide future language design.
 - The combination of key language concepts from various languages (Eiffel, Java, ML, Haskell) is a novel insight as it integrates diverse programming paradigms into a cohesive framework, which can have implications for future programming language design by providing a more comprehensive and flexible programming environment."
Programming and Reasoning with Infinite Data in Isabelle / HOL,"M. Fleury, Andreas Lochbihler, A. Popescu",-,-,-,0,2017,"1. Primitive Name: Streams
  Definition: Infinite objects used in programming
  Orthogonality Score: Not specified
 2. Primitive Name: Infinite-depth Trees
  Definition: Infinite objects used in programming
  Orthogonality Score: Not specified
 3. Primitive Name: Total/Productive Coprogramming
  Definition: Paradigm for programming with infinite objects
  Orthogonality Score: Not specified
 4. Primitive Name: Coinductive Datatypes
  Definition: Modular design for infinite objects
  Orthogonality Score: Not specified","- Type of mathematical framework: Type theory, specifically coinductive datatypes
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Total/productive coprogramming, coinductive datatypes
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Development of a framework for programming with and reasoning about infinite objects such as streams and infinite-depth trees.
 - Theoretical advancements: Implementation of total/productive coprogramming and modular design of coinductive datatypes.
 - Potential implications for programming language design: Modular design could lead to flexible and reusable frameworks in programming languages.","- ""Recently we have endowed the proof assistant Isabelle/HOL with a powerful framework for programming with, and reasoning about, infinite objects such as streams and infinite-depth trees.""
  - ""It implements the paradigm of total/productive coprogramming, and is based on a modular design of coinductive datatypes.""",,"- The abstract mentions the implementation of a framework for programming with infinite objects, specifically streams and infinite-depth trees. This suggests that these are conceptual primitives used in the study.
 - The framework is based on ""total/productive coprogramming,"" which implies that this paradigm is a conceptual primitive for reconstructing programming paradigms.
 - The abstract also mentions a ""modular design of coinductive datatypes,"" which suggests that coinductive datatypes are another conceptual primitive.
 - The level of abstraction is high since these primitives are related to programming paradigms and data structures.
 - Orthogonality is not explicitly discussed in the abstract, so it cannot be scored.","- ""Recently we have endowed the proof assistant Isabelle/HOL with a powerful framework for programming with, and reasoning about, infinite objects such as streams and infinite-depth trees.""
  - ""It implements the paradigm of total/productive coprogramming, and is based on a modular design of coinductive datatypes.""
  - ""The tutorial will present this framework through examples taken from the field of programming languages.""
  - ""He developed Isabelle’s widely used Coinductive library.""
  - ""He proved correct a compiler for a large subset of concurrent Java and built the CryptHOL framework for cryptographic security proofs.""
  - ""Both projects rely heavily on codatatypes and total corecursive programming.""
  - ""He designed and developed Isabelle’s codatatype and corecursion mechanisms jointly with Jasmin Blanchette and Dmitriy Traytel, and the confidentiality-verified conference management system CoCon.""",,"- The abstract mentions the use of a ""powerful framework for programming with, and reasoning about, infinite objects"" which suggests a focus on handling infinite data structures.
 - The framework is described as implementing ""total/productive coprogramming"" and being based on ""coinductive datatypes,"" which are specific mathematical concepts related to type theory and formal verification.
 - The mention of ""coinductive datatypes"" and ""codatatypes"" indicates a type of mathematical framework related to type theory, specifically focusing on coinductive types.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or limitations of the framework, but it does highlight the use of coinductive datatypes and total corecursive programming, which are proof techniques.
 - The abstract does not provide detailed information on the theoretical foundations or proof methodology beyond the use of coinductive datatypes and total corecursive programming.","- ""The tutorial will present this framework through examples taken from the field of programming languages.""
  - ""It implements the paradigm of total/productive coprogramming, and is based on a modular design of coinductive datatypes.""
  - ""Recently we have endowed the proof assistant Isabelle/HOL with a powerful framework for programming with, and reasoning about, infinite objects such as streams and infinite-depth trees.""",,"- The abstract mentions the implementation of ""total/productive coprogramming"" as a paradigm, which suggests a focus on a specific programming paradigm rather than the integration of multiple paradigms.
 - The mention of ""coinductive datatypes"" indicates a modular design, which could imply some form of integration or structuring within the paradigm, but it does not explicitly address the integration of different programming paradigms.
 - The abstract does not provide specific details on how different programming paradigms are integrated, nor does it mention interaction models, constraints, or novel translation techniques.
 - The focus is on presenting a framework for programming with infinite objects, rather than on integrating multiple paradigms.","- ""The tutorial will present this framework through examples taken from the field of programming languages.""
  - ""Recently we have endowed the proof assistant Isabelle/HOL with a powerful framework for programming with, and reasoning about, infinite objects such as streams and infinite-depth trees.""
  - ""It implements the paradigm of total/productive coprogramming, and is based on a modular design of coinductive datatypes.""",,"- The abstract mentions a ""powerful framework for programming with, and reasoning about, infinite objects,"" which suggests a focus on handling complex data structures, but it does not explicitly address generic programming or abstraction mechanisms.
 - The mention of ""total/productive coprogramming"" and ""coinductive datatypes"" indicates a focus on programming paradigms and data structures, but these are not directly related to generic programming or abstraction mechanisms.
 - The abstract does not provide any specific information about the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The focus of the abstract is on the framework for handling infinite objects and its presentation through examples, rather than on generic programming or abstraction mechanisms.","- ""Recently we have endowed the proof assistant Isabelle/HOL with a powerful framework for programming with, and reasoning about, infinite objects such as streams and infinite-depth trees.""
  - ""The tutorial will present this framework through examples taken from the field of programming languages.""
  - ""It implements the paradigm of total/productive coprogramming, and is based on a modular design of coinductive datatypes.""",,"- The abstract mentions the development of a ""powerful framework for programming with, and reasoning about, infinite objects"" in Isabelle/HOL. This suggests a novel insight into handling infinite data structures, which is a significant theoretical contribution.
 - The implementation of ""total/productive coprogramming"" and the use of ""coinductive datatypes"" indicate theoretical advancements beyond existing approaches. These concepts are central to the framework and represent new ways of programming and reasoning about infinite data.
 - The mention of a ""modular design"" implies a structured approach that could have implications for programming language design, as it suggests a flexible and potentially reusable framework.
 - The presentation of the framework through examples from programming languages suggests that the theoretical contributions have practical applications and implications for programming language design."
Structural Recursion As A Query Language,V. Tannen,-,-,-,0,2014,"1. Primitive Name: Structural Recursion
  Definition: Main computational engine using structural recursion on sets
  Orthogonality Score: Not specified
 2. Primitive Name: Typed Lambda Calculus
  Definition: Programming framework within a ""nicely"" typed lambda calculus
  Orthogonality Score: Not specified","- Type of mathematical framework: Type theory (lambda calculus)
 - Specific mathematical properties guaranteed: Total map taking finite relations to finite relations
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Structural recursion on sets
 - Interaction models between paradigms: Structural recursion mimics relational algebra's expressive power
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Novel insights: Combining semantic simplicity of relational algebra with expressive power of unrestricted programming languages.
 - Theoretical advancements: Structural recursion on sets as the main computational engine; scaling up to query languages for the complex-object model.
 - Potential implications: Efficient programs for transitive closure; flexible type system for moving out of and back to sets; finer grain programming for better optimizations.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a ""nicely"" typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""",,"- The abstract discusses a programming paradigm that combines the simplicity of relational algebra with the expressiveness of unrestricted programming languages. This suggests a focus on structural recursion as a key conceptual primitive.
 - The main computational engine is identified as ""structural recursion on sets,"" which is a specific conceptual primitive.
 - The use of a ""nicely"" typed lambda calculus indicates another conceptual primitive, as it provides a framework for programming within this paradigm.
 - The emphasis on how queries are implemented suggests that the method of implementation is a conceptual primitive, although it is not explicitly defined in terms of specific primitives.
 - The abstract does not provide explicit definitions or names for these primitives beyond ""structural recursion"" and ""typed lambda calculus.""
 - There is no mention of orthogonality or level of abstraction for these primitives in the abstract.","- ""All programming is done within a ""nicely"" typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""As in relational algebra, the meaning of any relation transformer is guaranteed to be a total map taking finite relations to finite relations.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""",,"- The abstract mentions that all programming is done within a ""nicely"" typed lambda calculus, which suggests that the mathematical framework is based on type theory.
 - The mention of ""nicely"" typed lambda calculus indicates a focus on ensuring that programs are well-typed, which is a characteristic of type theory.
 - The abstract guarantees that the meaning of any relation transformer is a total map taking finite relations to finite relations, which is a specific mathematical property related to relational algebra.
 - The use of structural recursion and its expressive power equivalent to relational algebra suggests a formal verification approach that ensures certain properties about the programs.
 - The abstract does not explicitly mention proof techniques or limitations of the framework, but it implies a structured approach to programming and query language design.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a ""nicely"" typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The same programming paradigm scales up, yielding query languages for the complex-object model [AB89].""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""",,"- The abstract discusses a programming paradigm that integrates elements from relational algebra and unrestricted programming languages, aiming to combine their strengths.
 - The main integration mechanism is structural recursion on sets, which is used as the computational engine.
 - The use of a ""nicely"" typed lambda calculus suggests a theoretical integration strategy that ensures type consistency across different programming paradigms.
 - The abstract mentions that a restricted class of programs using structural recursion has the same expressive power as relational algebra, indicating a specific interaction model where structural recursion can mimic relational algebra's capabilities.
 - The paradigm scales up to query languages for complex-object models, suggesting flexibility and adaptability in integrating different paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the use of structural recursion and lambda calculus.","- ""Its main computational engine is structural recursion on sets.""
  - ""All programming is done within a ""nicely"" typed lambda calculus, as in Machiavelli [OBB89].""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""
  - ""Therefore we expect that lower-level and therefore better optimizations will be feasible.""",,"- The abstract mentions the use of ""structural recursion on sets"" as the main computational engine, which suggests a focus on recursive programming rather than generic programming.
 - The mention of ""nicely typed lambda calculus"" indicates a structured approach to programming, but it does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not provide a definition of ""concept"" or discuss mechanisms for representing generic abstractions.
 - There is no mention of minimal type requirements or static checking strategies related to generic programming.
 - The focus on optimization and finer grain programming suggests an emphasis on performance rather than genericity and abstraction.","- ""We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.""
  - ""Its main computational engine is structural recursion on sets.""
  - ""A guiding principle is that how queries are implemented is as important as whether they can be implemented.""
  - ""A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra.""
  - ""The same programming paradigm scales up, yielding query languages for the complex-object model""
  - ""Beyond that, there are, for example, efficient programs for transitive closure and we are also able to write programs that move out of sets, and then perhaps back to sets, as long as we stay within a (quite flexible) type system.""
  - ""The uniform paradigm of the language suggests positive expectations for the optimization problem.""
  - ""structural recursion yields finer grain programming.""
  - ""Therefore we expect that lower-level and therefore better optimizations will be feasible.""",,"- The abstract introduces a new programming paradigm that combines the simplicity of relational algebra with the expressiveness of unrestricted programming languages, which is a novel insight.
 - The use of structural recursion on sets as the main computational engine is a theoretical advancement, as it provides a new way to approach programming.
 - The emphasis on how queries are implemented being as important as whether they can be implemented suggests a theoretical contribution in terms of programming philosophy.
 - The ability to scale up to query languages for the complex-object model indicates a theoretical advancement beyond existing relational algebra approaches.
 - The mention of efficient programs for transitive closure and the ability to move out of and back to sets within a flexible type system highlights potential implications for programming language design.
 - The expectation of better optimizations due to finer grain programming suggests a theoretical contribution in terms of optimization techniques."
Can computational logic provide a paradigm for both the specification and implementation of concurrent systems?,D. Gilbert,10.1145/234528.234733,https://doi.org/10.1145/234528.234733,CSUR,1,1996,"1. Primitive Name: Tell
  Definition: An update operation that adds a constraint to a store without removing existing constraints.
  Orthogonality Score: Not explicitly discussed
 

 2. Primitive Name: Ask
  Definition: A query operation that checks if a constraint is entailed by the store.
  Orthogonality Score: Not explicitly discussed
 

 3. Primitive Name: Committed Choice 'Don't Care' Operator
  Definition: Inherited from CLP, allows for non-deterministic choice.
  Orthogonality Score: Not explicitly discussed
 

 4. Primitive Name: Parallel Operator
  Definition: With interleaving semantics, allows for concurrent execution.
  Orthogonality Score: Not explicitly discussed
 

 5. Primitive Name: Sequencing Operator
  Definition: Over processes, allows for sequential execution.
  Orthogonality Score: Not explicitly discussed",Not specified (the paper discusses the CCLP paradigm but does not explicitly mention a specific mathematical framework or proof techniques),"- Specific integration mechanisms proposed: Adaptation of logic programming paradigm to concurrent constraint logic programming (CCLP).
 - Interaction models between paradigms: Use of a ""store"" or ""blackboard"" for multi-party communication and data passing.
 - Constraints or challenges in paradigm integration: General challenge of demonstrating the usefulness of this methodology.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: The concurrent constraint paradigm is mature enough for both specification and implementation of concurrent systems.
 - Theoretical advancements: Generalization of logic programming to CCLP for computing constraints over various domains; integration of communication and data passing in CCLP.
 - Potential implications: Development of tools for automated reasoning about concurrent systems; design of languages for efficient execution in distributed environments with automated reasoning tools.","- ""In the CCLP paradigm [de Boer and Palamidessi 1991] a simple constraint c is a token that may be added to a store or set of such constraints s but may never be removed from the store; that is, updates are monotonic.""
  - ""This update operation is called “tell” and has no effect on the store if it already contains the told constraint.""
  - ""The state of the store can be queried by an “ask” operation that succeeds if the store entails the asked constraint.""
  - ""We can conceptualize the store as a blackboard (potentially distributed), parts of which can be made private to designated processes, ask operations as reads, and tells as writes on data.""
  - ""CCLP languages have inherited the committed choice \don't care"" operator from CLP, have a parallel operator with interleaving semantics, and a sequencing operator over processes.""
  - ""The communication primitives act on a given store in the following way: as usual, given a constraint c, the process ask(c) succeeds if c is entailed by the store, otherwise it is suspended until it can succeed.""
  - ""In our language synchronisation is achieved by forcing a tell(c) operation to suspend if the constraint c is not entailed by the store; it can be resumed synchronously with an ask(d) operation provided that the conjunction of the store and c entails d, in which case the store is updated with c.""",,"- The paper discusses the concurrent constraint paradigm (CCLP) as a framework for specifying and implementing concurrent systems.
 - The CCLP paradigm is described with two primary operations: ""tell"" and ""ask."" The ""tell"" operation adds constraints to a store, while the ""ask"" operation queries the store to check if a constraint is entailed.
 - These operations are conceptualized as writes and reads on a distributed blackboard, with producers updating the store and consumers querying it.
 - The paper also mentions additional primitives such as the committed choice 'don't care' operator, a parallel operator with interleaving semantics, and a sequencing operator over processes.
 - The level of abstraction is high, as these primitives are designed to be general and applicable across various concurrent systems.
 - Orthogonality is implied by the distinct roles of each primitive, but it is not explicitly scored or discussed in the paper.","- ""The generalization of the logic programming paradigm to encompass computing constraints over various domains [Van Hentenryck 1989] and the adaptation of this paradigm to concurrent constraint logic programming (CCLP) [Maher 1987; Saraswat 1993] is, I believe, the key to progress.""
  - ""In the CCLP paradigm [de Boer and Palamidessi 1991] a simple constraint c is a token that may be added to a store or set of such constraints s but may never be removed from the store; that is, updates are monotonic.""
  - ""The state of the store can be queried by an “ask” operation that succeeds if the store entails the asked constraint.""
  - ""The communication engendered is inherently multi-party, since there is no restriction on the number of concurrent ask operations that may be made on one constraint, nor on the number of concurrent tells on that constraint, as long as they are consistent with the store.""
  - ""CCLP languages have inherited the committed choice \don't care"" operator from CLP, have a parallel operator with interleaving semantics, and a sequencing operator over processes.""
  - ""The inherently multi-party form of communication, and the natural way in which communication and data passing are integrated in one coherent theory makes the CCLP paradigm an excellent candidate for the formal description of concurrent systems.""
  - ""Our intention is that this language should be used to specify and reason about concurrent systems, and that tools based on its semantics can be constructed to permit mechanised reasoning about the behaviour of programs.""",,"- The paper discusses the use of the concurrent constraint logic programming (CCLP) paradigm, which is a mathematical framework for specifying and implementing concurrent systems.
 - The CCLP paradigm is based on the idea of constraints being added to a store in a monotonic manner, which is a key mathematical property.
 - The framework includes operations like ""ask"" and ""tell,"" which are used to query and update the store, respectively. These operations are part of the formal verification discussions.
 - The paper mentions the integration of communication and data passing in a coherent theory, which suggests a focus on formal verification.
 - However, the paper does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it detail specific proof techniques or limitations.","- ""The inherently multi-party form of communication, and the natural way in which communication and data passing are integrated in one coherent theory makes the CCLP paradigm an excellent candidate for the formal description of concurrent systems.""
  - ""CCLP languages have inherited the committed choice \don't care"" operator from CLP, have a parallel operator with interleaving semantics, and a sequencing operator over processes.""
  - ""The communication engendered is inherently multi-party, since there is no restriction on the number of concurrent ask operations that may be made on one constraint, nor on the number of concurrent tells on that constraint, as long as they are consistent with the store.""
  - ""We can conceptualize the store as a blackboard (potentially distributed), parts of which can be made private to designated processes, ask operations as reads, and tells as writes on data.""
  - ""The state of the store can be queried by an “ask” operation that succeeds if the store entails the asked constraint.""",,"- The paper discusses the integration of different programming paradigms through the adaptation of the logic programming paradigm to concurrent constraint logic programming (CCLP). This is a specific integration mechanism proposed in the paper.
 - The interaction model between paradigms is described through the use of a ""store"" or ""blackboard"" where constraints are added and queried. This model allows for multi-party communication and integrates data passing in a coherent theory.
 - The paper mentions that CCLP languages have inherited operators from CLP, indicating a form of integration between these paradigms.
 - The paper does not explicitly mention any novel translation or embedding techniques, nor does it discuss specific constraints or challenges in paradigm integration beyond the general challenge of demonstrating the usefulness of this methodology.
 - The paper focuses on the potential of CCLP as a paradigm for both specification and implementation of concurrent systems, rather than detailing specific integration strategies or challenges.","- ""The generalization of the logic programming paradigm to encompass computing constraints over various domains [Van Hentenryck 1989] and the adaptation of this paradigm to concurrent constraint logic programming (CCLP) [Maher 1987; Saraswat 1993] is, I believe, the key to progress.""
  - ""Our intention is that this language should be used to specify and reason about concurrent systems, and that tools based on its semantics can be constructed to permit mechanised reasoning about the behaviour of programs.""
  - ""The inherently multi-party form of communication, and the natural way in which communication and data passing are integrated in one coherent theory makes the CCLP paradigm an excellent candidate for the formal description of concurrent systems.""
  - ""CCLP languages have inherited the committed choice \don't care"" operator from CLP, have a parallel operator with interleaving semantics, and a sequencing operator over processes.""
  - ""In the CCLP paradigm [de Boer and Palamidessi 1991] a simple constraint c is a token that may be added to a store or set of such constraints s but may never be removed from the store; that is, updates are monotonic.""",,"- The paper discusses the generalization of the logic programming paradigm to concurrent constraint logic programming (CCLP), which suggests a focus on abstraction mechanisms through the use of constraints.
 - The CCLP paradigm is described as having monotonic updates, which implies a form of abstraction where constraints are added but not removed, providing a mechanism for representing generic abstractions.
 - The mention of operators like ""committed choice 'don't care'"" and parallel and sequencing operators indicates mechanisms for abstraction and generic programming.
 - The paper does not explicitly discuss minimal type requirements or static checking strategies, but it does emphasize the use of CCLP for formal descriptions and reasoning, which implies a focus on abstraction.
 - The paper does not extensively address generic programming in terms of traditional generic programming methodologies or type system discussions.","- ""I propose that a serious effort be made to accept this challenge and suggest that the concurrent constraint paradigm is now mature enough to be used in this role; moreover, one way to achieve this goal is to develop tools for automated reasoning about concurrent systems, based on the semantics of this paradigm.""
  - ""The inherently multi-party form of communication, and the natural way in which communication and data passing are integrated in one coherent theory makes the CCLP paradigm an excellent candidate for the formal description of concurrent systems.""
  - ""Our intention is that this language should be used to specify and reason about concurrent systems, and that tools based on its semantics can be constructed to permit mechanised reasoning about the behaviour of programs.""",,"- The paper suggests that the concurrent constraint paradigm is mature enough to be used for both specification and implementation of concurrent systems, which is a novel insight as it bridges the gap between formal description and efficient implementation.
 - The generalization of the logic programming paradigm to CCLP is highlighted as a key theoretical advancement, as it allows for computing constraints over various domains, which is a significant theoretical contribution.
 - The CCLP paradigm's ability to integrate communication and data passing in a coherent theory is emphasized, which is a theoretical innovation beyond existing approaches.
 - The paper discusses the potential for developing tools for automated reasoning about concurrent systems based on CCLP semantics, which is a theoretical advancement with implications for programming language design.
 - The focus on developing languages that permit efficient execution in a distributed environment and coupling them with automated reasoning tools is a novel theoretical contribution with significant implications for future programming language design."
Practical structured parallelism using BMF,David Crooke,-,-,-,3,1998,Not specified (the abstract does not provide explicit definitions or details about the conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),"No specific integration approach described (the abstract discusses the integration of BMF with imperative programming but lacks detailed mechanisms, interaction models, or constraints)","- Definition of ""concept"" used: The Bird-Meertens Formalism (BMF) is used as a basis for expressing parallel algorithms.
 - Mechanisms for representing generic abstractions: BMF Theory of Lists and the sequential language C.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novel application of Bird-Meertens Formalism to control parallelism in imperative programming languages.
 - Definition of criteria for a suitable parallel programming paradigm.
 - Proposal of a new programming language integrating BMF with the sequential language C.
 - Development of a concurrent operational semantics for parallel programs.
 - Exploration of extending the paradigm language and using alternative BMF-like type theories.
 - Theoretical insights into optimizing parallel programming languages for performance.","- ""A programming language is proposed which is an example of this paradigm, based on the BMF Theory of Lists and the sequential language C.""
  - ""The Bird-Meertens Formalism, which has in the past been shown to be a suitable vehicle for expressing parallel algorithms, is used as the basis for a proposed imperative parallel programming paradigm which meets these criteria.""
  - ""A concurrent operational semantics is outlined, with the emphasis on its use as a practical tool for increasing con dence in program correctness, rather than on full and rigorous formality.""
  - ""Criteria for a suitable parallel programming paradigm to meet this goal are de ned.""",,"- The abstract mentions that criteria for a parallel programming paradigm are defined, but it does not specify what these criteria are or what conceptual primitives are used.
 - The Bird-Meertens Formalism (BMF) is mentioned as a basis for the proposed paradigm, but the abstract does not provide specific details on the conceptual primitives defined within this formalism.
 - The mention of the BMF Theory of Lists suggests that lists might be a conceptual primitive, but this is not explicitly stated in the abstract.
 - The abstract does not provide explicit definitions or details about the conceptual primitives used in the study.","- ""This thesis concerns the use of the Bird-Meertens Formalism as a mechanism to control parallelism in an imperative programming language.""
  - ""A programming language is proposed which is an example of this paradigm, based on the BMF Theory of Lists and the sequential language C.""
  - ""The Bird-Meertens Formalism, which has in the past been shown to be a suitable vehicle for expressing parallel algorithms, is used as the basis for a proposed imperative parallel programming paradigm which meets these criteria.""
  - ""A concurrent operational semantics is outlined, with the emphasis on its use as a practical tool for increasing con dence in program correctness, rather than on full and rigorous formality.""",,"- The abstract mentions the use of the ""Bird-Meertens Formalism"" as a mathematical framework to control parallelism in programming languages. This suggests that the Bird-Meertens Formalism is the type of mathematical framework used.
 - The abstract does not specify any particular mathematical properties guaranteed by this framework, nor does it mention specific proof techniques or limitations.
 - The mention of ""concurrent operational semantics"" implies some form of formal verification, but it is not detailed in terms of specific mathematical properties or proof techniques.
 - The abstract does not provide explicit details about the theoretical foundations, proof methodology, or formal verification discussions related to the mathematical framework.","- ""This thesis concerns the use of the Bird-Meertens Formalism as a mechanism to control parallelism in an imperative programming language.""
  - ""The Bird-Meertens Formalism, which has in the past been shown to be a suitable vehicle for expressing parallel algorithms, is used as the basis for a proposed imperative parallel programming paradigm which meets these criteria.""
  - ""A programming language is proposed which is an example of this paradigm, based on the BMF Theory of Lists and the sequential language C.""
  - ""A concurrent operational semantics is outlined, with the emphasis on its use as a practical tool for increasing con dence in program correctness, rather than on full and rigorous formality.""
  - ""A prototype implementation of a subset of this language for a distributed memory, massively parallel computer is produced in the form of a C subroutine library.""
  - ""A range of further possibilities is examined, in particular ways in which the paradigm language might be extended, and the possibility of using alternative BMF-like type theories.""",,"- The abstract discusses the integration of the Bird-Meertens Formalism (BMF) with an imperative programming language to control parallelism. This suggests a specific integration mechanism where BMF is used to express parallel algorithms within an imperative framework.
 - The proposed programming language is based on the BMF Theory of Lists and the sequential language C, indicating an interaction model where BMF is integrated into a C-based language.
 - The abstract mentions a concurrent operational semantics, which implies a theoretical integration strategy focusing on practicality and program correctness rather than strict formality.
 - There is no explicit mention of constraints or challenges in paradigm integration, nor are there any novel translation or embedding techniques described in the abstract.
 - The abstract does not provide detailed information on specific integration mechanisms, interaction models, or constraints beyond the general integration of BMF with imperative programming.","- ""A key objective should be to minimize costs by abstracting much of the complexity away from the programmer.""
  - ""The Bird-Meertens Formalism, which has in the past been shown to be a suitable vehicle for expressing parallel algorithms, is used as the basis for a proposed imperative parallel programming paradigm which meets these criteria.""
  - ""A programming language is proposed which is an example of this paradigm, based on the BMF Theory of Lists and the sequential language C.""
  - ""A concurrent operational semantics is outlined, with the emphasis on its use as a practical tool for increasing con dence in program correctness, rather than on full and rigorous formality.""
  - ""A prototype implementation of a subset of this language for a distributed memory, massively parallel computer is produced in the form of a C subroutine library.""
  - ""A range of further possibilities is examined, in particular ways in which the paradigm language might be extended, and the possibility of using alternative BMF-like type theories.""",,"- The abstract mentions the use of the Bird-Meertens Formalism (BMF) as a basis for a parallel programming paradigm, which suggests a focus on abstraction mechanisms. BMF is known for its ability to express parallel algorithms in a formal and abstract way.
 - The mention of ""abstracting much of the complexity away from the programmer"" indicates an approach to generic programming by simplifying the programming process through abstraction.
 - The proposed programming language is based on the BMF Theory of Lists and the sequential language C, which implies a mechanism for representing generic abstractions through the use of BMF.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on BMF and abstraction suggests a structured approach to generic programming.
 - The discussion of extending the paradigm language and exploring alternative BMF-like type theories suggests ongoing work in refining genericity and abstraction mechanisms.","- ""This thesis concerns the use of the Bird-Meertens Formalism as a mechanism to control parallelism in an imperative programming language.""
  - ""The Bird-Meertens Formalism, which has in the past been shown to be a suitable vehicle for expressing parallel algorithms, is used as the basis for a proposed imperative parallel programming paradigm which meets these criteria.""
  - ""A range of further possibilities is examined, in particular ways in which the paradigm language might be extended, and the possibility of using alternative BMF-like type theories.""
  - ""A programming language is proposed which is an example of this paradigm, based on the BMF Theory of Lists and the sequential language C.""
  - ""Pragmatic considerations for achieving performance in a production implementation are discussed.""",,"- The abstract discusses the use of the Bird-Meertens Formalism (BMF) to control parallelism in imperative programming languages, which is a novel application of BMF.
 - The definition of criteria for a suitable parallel programming paradigm is a theoretical contribution, as it provides a framework for evaluating parallel programming languages.
 - The proposal of a new programming language based on BMF and the sequential language C is a theoretical advancement, as it integrates BMF with existing programming paradigms.
 - The development of a concurrent operational semantics is a theoretical contribution, as it provides a formal basis for understanding the behavior of parallel programs.
 - The exploration of extending the paradigm language and using alternative BMF-like type theories suggests potential implications for future programming language design.
 - The discussion of pragmatic considerations for achieving performance in a production implementation implies theoretical insights into optimizing parallel programming languages."
Strategic polymorphism requires just two combinators!,"R. Lämmel, Joost Visser",-,-,arXiv.org,13,2002,"1. Primitive Name: Not specified
  Definition: Not specified
  Orthogonality Score: Not specified
 2. Primitive Name: Not specified
  Definition: Not specified
  Orthogonality Score: Not specified",Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Use of two primitive combinators to capture strategic polymorphism.
 - Interaction models between paradigms: Integration of term rewriting strategies into the functional programming paradigm.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Reconstruction of representative fragments of the Strafunski library for functional strategies.","- Definition of ""concept"" used: Functional strategies as first-class generic functions.
 - Mechanisms for representing generic abstractions: Strategic polymorphism captured by two primitive combinators.
 - Minimal type requirements identified: Not mentioned.
 - Static checking or optimization strategies: Not mentioned.","- Key novel insights: Introduction of functional strategies as first-class generic functions that can traverse terms of any type, adapting term rewriting strategies to the functional programming paradigm.
 - Theoretical advancements: Capture of strategic polymorphism using just two primitive combinators, analysis of the design space for implementational models, and generality demonstrated by reconstructing parts of the Strafunski library.
 - Potential implications for programming language design: Simplification and portability of functional strategies across different languages, providing a framework for understanding implementation models.","- ""We capture strategic polymorphism by just two primitive combinators.""
  - ""We demonstrate the generality of our approach by reconstructing representative fragments of the Strafunski library for functional strategies.""
  - ""We analyse the design space for implementational models of functional strategies.""
  - ""we provide a compact and matured reconstruction of functional strategies.""
  - ""This is done without commitment to a specific functional language.""",,"- The abstract mentions that strategic polymorphism is captured by ""just two primitive combinators."" This indicates that the study defines two specific conceptual primitives.
 - The abstract does not provide explicit names or definitions for these combinators, but it emphasizes their role in capturing strategic polymorphism.
 - The study is described as a ""compact and matured reconstruction of functional strategies,"" suggesting that these primitives are fundamental to the approach.
 - The abstract does not specify the level of abstraction or orthogonality of these primitives, nor does it provide explicit definitions or names for them.
 - The focus on generality and the ability to reconstruct fragments of the Strafunski library suggests that these primitives are designed to be broadly applicable and orthogonal, but this is not explicitly stated.","- ""In previous work, we introduced the notion of functional strategies: first-class generic functions that can traverse terms of any type while mixing uniform and type-specific behaviour.""
  - ""Functional strategies transpose the notion of term rewriting strategies (with coverage of traversal) to the functional programming paradigm.""
  - ""We capture strategic polymorphism by just two primitive combinators.""
  - ""This is done without commitment to a specific functional language.""
  - ""We analyse the design space for implementational models of functional strategies.""
  - ""For completeness, we also provide an operational reference model for implementing functional strategies (in Haskell).""
  - ""We demonstrate the generality of our approach by reconstructing representative fragments of the Strafunski library for functional strategies.""",,"- The abstract discusses the concept of ""functional strategies"" and their application in generic programming, which suggests a focus on functional programming principles rather than a specific mathematical framework like type theory or category theory.
 - The mention of ""first-class generic functions"" and ""strategic polymorphism"" indicates a focus on programming concepts rather than a formal mathematical framework.
 - The abstract does not explicitly mention any theoretical foundations, proof methodology, or formal verification discussions, which are typically associated with a mathematical framework.
 - The operational reference model in Haskell is mentioned, but this is more about implementation rather than a mathematical framework.
 - The abstract does not provide details about specific mathematical properties guaranteed, proof techniques used, or limitations of the framework, which are key components of a mathematical framework.","- ""This is done without commitment to a specific functional language.""
  - ""We demonstrate the generality of our approach by reconstructing representative fragments of the Strafunski library for functional strategies.""
  - ""We analyse the design space for implementational models of functional strategies.""
  - ""We capture strategic polymorphism by just two primitive combinators.""
  - ""Functional strategies transpose the notion of term rewriting strategies (with coverage of traversal) to the functional programming paradigm.""",,"- The abstract discusses the integration of term rewriting strategies into the functional programming paradigm, indicating a form of paradigm integration.
 - The use of ""two primitive combinators"" suggests a specific integration mechanism, as it implies a minimal set of operations to achieve strategic polymorphism.
 - The mention of ""without commitment to a specific functional language"" implies flexibility in the integration approach, allowing it to be applied across different functional languages.
 - The analysis of the ""design space for implementational models"" suggests a theoretical integration strategy, as it involves examining how functional strategies can be implemented in various contexts.
 - The reconstruction of fragments from the Strafunski library demonstrates a practical application of this integration approach, showing how it can be used to integrate different programming paradigms.","- ""we introduced the notion of functional strategies: first-class generic functions that can traverse terms of any type while mixing uniform and type-specific behaviour.""
  - ""We analyse the design space for implementational models of functional strategies.""
  - ""We demonstrate the generality of our approach by reconstructing representative fragments of the Strafunski library for functional strategies.""
  - ""Functional strategies transpose the notion of term rewriting strategies (with coverage of traversal) to the functional programming paradigm.""
  - ""We capture strategic polymorphism by just two primitive combinators.""",,"- The abstract discusses ""functional strategies"" as a concept, which are defined as ""first-class generic functions"" that can handle terms of any type. This suggests a focus on generic programming.
 - The mention of ""strategic polymorphism"" being captured by ""just two primitive combinators"" indicates a mechanism for representing generic abstractions.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, but it does discuss analyzing the design space for implementational models, which could imply some consideration of these aspects.
 - The abstract does not provide detailed information on the type system or specific abstraction mechanisms beyond the use of combinators.","- ""In previous work, we introduced the notion of functional strategies: first-class generic functions that can traverse terms of any type while mixing uniform and type-specific behaviour.""
  - ""Functional strategies transpose the notion of term rewriting strategies (with coverage of traversal) to the functional programming paradigm.""
  - ""We capture strategic polymorphism by just two primitive combinators.""
  - ""This is done without commitment to a specific functional language.""
  - ""We analyse the design space for implementational models of functional strategies.""
  - ""We demonstrate the generality of our approach by reconstructing representative fragments of the Strafunski library for functional strategies.""",,"- The abstract introduces the concept of ""functional strategies"" as a novel approach, which are first-class generic functions capable of traversing terms of any type. This is a key novel insight as it adapts term rewriting strategies to the functional programming paradigm.
 - The capture of strategic polymorphism using just two primitive combinators is a significant theoretical advancement. It simplifies the implementation of functional strategies and makes them more accessible.
 - The fact that this is achieved without commitment to a specific functional language is a theoretical contribution, as it implies a level of generality and portability across different programming languages.
 - The analysis of the design space for implementational models of functional strategies is a theoretical advancement, as it provides a framework for understanding how these strategies can be implemented in various contexts.
 - The demonstration of the approach's generality by reconstructing parts of the Strafunski library suggests potential implications for programming language design, as it shows how these strategies can be applied in real-world scenarios."
Logic of computational semi-effects and categorical gluing for equivariant functors,"Yuichi Nishiwaki, Toshiya Asai",-,-,arXiv.org,1,2020,"1. Primitive Name: Modal type $\rhd$
  Definition: A refinement in the type theory
  Orthogonality Score: Not specified
 2. Primitive Name: Semi-effects
  Definition: A weaker version of effects
  Orthogonality Score: Not specified","- Type of mathematical framework: Type theory and category theory
 - Specific mathematical properties guaranteed: Categorical gluing, logical predicates for $\rhd$-modality
 - Proof techniques used: Proof-theoretic reconstruction
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Proof-theoretic reconstruction of Moggi's computational metalanguage, decomposition of lax logic via Benton's adjoint calculus.
 - Interaction models between paradigms: Equivariant functors and categorical gluing.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Novel approach to Moggi's calculus of computational effects using logic of monoidal action (actegory).
 - Introduction of ""semi-effects"" as a weaker version of effects.
 - More general approach using equivariant functors, which include Freyd categories and strong monads as special cases.
 - Demonstration of categorical gluing along equivariant functors and derivation of logical predicates for $\rhd$-modality.
 - Alignment with Katsumata's categorical $\top\top$-lifting, suggesting implications for programming language design.","- ""we perform proof-theoretic reconstruction of Moggi's computational metalanguage and obtain a type theory with a modal type $\rhd$ as a refinement.""
  - ""its logic can be seen as a decomposition of lax logic via Benton's adjoint calculus.""
  - ""This calculus models as a programming language a weaker version of effects, which we call \emph{semi-effects}.""
  - ""categorical gluing along equivariant functors is possible and derive logical predicates for $\rhd$-modality.""
  - ""we give its semantics using actegories and equivariant functors.""",,"- The abstract mentions the ""proof-theoretic reconstruction of Moggi's computational metalanguage"" which results in a ""type theory with a modal type $\rhd$ as a refinement."" This suggests that the modal type $\rhd$ is a conceptual primitive used in the reconstruction.
 - The logic is described as a ""decomposition of lax logic via Benton's adjoint calculus,"" indicating that lax logic and Benton's adjoint calculus are part of the theoretical framework, but they are not explicitly defined as primitives in the abstract.
 - The concept of ""semi-effects"" is introduced as a weaker version of effects, which is a key conceptual primitive in the study.
 - The use of ""actegories and equivariant functors"" for semantics and ""categorical gluing"" for deriving logical predicates suggests these are methodological primitives, but they are not explicitly defined as conceptual primitives in the abstract.
 - The abstract does not provide explicit definitions or orthogonality scores for these primitives.","- ""we revisit Moggi's celebrated calculus of computational effects from the perspective of logic of monoidal action (actegory).""
  - ""we perform proof-theoretic reconstruction of Moggi's computational metalanguage and obtain a type theory with a modal type $\rhd$ as a refinement.""
  - ""its logic can be seen as a decomposition of lax logic via Benton's adjoint calculus.""
  - ""we give its semantics using actegories and equivariant functors.""
  - ""our approach is more general in that models are directly given by equivariant functors, which include Freyd categories (hence strong monads) as a special case.""
  - ""we show that categorical gluing along equivariant functors is possible and derive logical predicates for $\rhd$-modality.""
  - ""this gluing, under a natural assumption, gives rise to logical predicates that coincide with those derived by Katsumata's categorical $\top\top$-lifting for Moggi's metalanguage.""",,"- The abstract mentions the use of ""logic of monoidal action (actegory)"" and ""type theory with a modal type $\rhd$ as a refinement,"" indicating that the mathematical framework involves both category theory and type theory.
 - The mention of ""proof-theoretic reconstruction"" suggests that proof techniques are used to establish the properties of the framework.
 - The use of ""actegories and equivariant functors"" for semantics indicates that these are key components of the mathematical framework.
 - The abstract notes that the approach is ""more general"" and includes ""Freyd categories (hence strong monads) as a special case,"" suggesting that the framework provides a broad and inclusive structure for modeling effects.
 - The mention of ""categorical gluing"" and the derivation of ""logical predicates"" indicates specific mathematical properties guaranteed by the framework.
 - The abstract does not explicitly mention limitations or constraints of the framework.","- ""we revisit Moggi's celebrated calculus of computational effects from the perspective of logic of monoidal action (actegory).""
  - ""we perform proof-theoretic reconstruction of Moggi's computational metalanguage and obtain a type theory with a modal type $\rhd$ as a refinement.""
  - ""its logic can be seen as a decomposition of lax logic via Benton's adjoint calculus.""
  - ""we give its semantics using actegories and equivariant functors.""
  - ""our approach is more general in that models are directly given by equivariant functors, which include Freyd categories (hence strong monads) as a special case.""
  - ""we show that categorical gluing along equivariant functors is possible and derive logical predicates for $\rhd$-modality.""
  - ""this gluing, under a natural assumption, gives rise to logical predicates that coincide with those derived by Katsumata's categorical $\top\top$-lifting for Moggi's metalanguage.""",,"- The abstract discusses the integration of different programming paradigms through the lens of Moggi's calculus of computational effects and the logic of monoidal action (actegory). This suggests a theoretical integration strategy.
 - The use of ""proof-theoretic reconstruction"" and ""decomposition of lax logic via Benton's adjoint calculus"" indicates a specific integration mechanism that involves refining Moggi's metalanguage.
 - The mention of ""equivariant functors"" and ""categorical gluing"" suggests an interaction model between paradigms, where these functors serve as a bridge.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the general approach of using actegories and equivariant functors.
 - The integration approach is described in terms of theoretical strategies and models rather than specific programming paradigms or their interactions.","- ""we revisit Moggi's celebrated calculus of computational effects from the perspective of logic of monoidal action (actegory).""
  - ""we perform proof-theoretic reconstruction of Moggi's computational metalanguage and obtain a type theory with a modal type $\rhd$ as a refinement.""
  - ""its logic can be seen as a decomposition of lax logic via Benton's adjoint calculus.""
  - ""we give its semantics using actegories and equivariant functors.""
  - ""our approach is more general in that models are directly given by equivariant functors, which include Freyd categories (hence strong monads) as a special case.""
  - ""we show that categorical gluing along equivariant functors is possible and derive logical predicates for $\rhd$-modality.""",,"- The abstract discusses the use of actegories and equivariant functors, which are related to categorical structures and can be seen as mechanisms for abstraction.
 - The mention of ""proof-theoretic reconstruction"" and ""type theory with a modal type $\rhd$"" suggests a focus on type systems and logical abstractions.
 - The use of ""equivariant functors"" and ""categorical gluing"" implies a level of genericity in the approach, as these concepts are often used to generalize and abstract over different structures.
 - However, the abstract does not explicitly mention generic programming or abstraction mechanisms in the context of generic programming methodologies or type system discussions.
 - The focus seems to be more on the logical and categorical aspects rather than specific generic programming techniques or minimal type requirements.","- ""In this paper, we revisit Moggi's celebrated calculus of computational effects from the perspective of logic of monoidal action (actegory).""
  - ""Through the proposition-as-type paradigm, its logic can be seen as a decomposition of lax logic via Benton's adjoint calculus.""
  - ""This calculus models as a programming language a weaker version of effects, which we call \emph{semi-effects}.""
  - ""Compared to previous studies of effects and actegories, our approach is more general in that models are directly given by equivariant functors, which include Freyd categories (hence strong monads) as a special case.""
  - ""we show that categorical gluing along equivariant functors is possible and derive logical predicates for $\rhd$-modality.""
  - ""this gluing, under a natural assumption, gives rise to logical predicates that coincide with those derived by Katsumata's categorical $\top\top$-lifting for Moggi's metalanguage.""",,"- The paper revisits Moggi's calculus of computational effects from a new perspective, using the logic of monoidal action (actegory), which is a novel approach.
 - The introduction of ""semi-effects"" as a weaker version of effects is a key novel insight, as it provides a new way to model effects in programming languages.
 - The use of equivariant functors as models is more general than previous approaches, which typically focused on Freyd categories or strong monads. This is a theoretical advancement beyond existing methods.
 - The demonstration of categorical gluing along equivariant functors and the derivation of logical predicates for $\rhd$-modality are significant theoretical contributions, as they provide new tools for analyzing and designing programming languages.
 - The alignment with Katsumata's categorical $\top\top$-lifting suggests a potential implication for programming language design, as it connects the new approach with established theoretical frameworks."
Functional Polytypic Programming,Patrik Jansson,-,-,-,33,2000,"1. Primitive Name: Construct for defining polytypic functions by induction
  Definition: Allows for the definition of polytypic functions by induction on the structure of user-defined datatypes
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Structured recursion operators (catamorphisms, maps, traversals)
  Definition: Powerful operators for structured recursion
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Interface of four functions for pattern matching, unification, and term rewriting
  Definition: Sufficient to express polytypic functions for these tasks
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Embedded domain-specific language for data conversion
  Definition: Expressed in a hierarchy of Haskell's constructor classes
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: PolyP language extension for defining polytypic functions by induction on user-defined datatypes.
 - Interaction models between paradigms: PolyLib with structured recursion operators; translation of PolyP programs to Haskell.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Translation of PolyP programs to Haskell.","- Definition of ""concept"" used: Polytypic programming as a paradigm for expressing algorithms that work with different datatypes.
 - Mechanisms for representing generic abstractions: PolyP language extension for defining polytypic functions by induction on datatype structure; structured recursion operators like catamorphisms, maps, and traversals.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned, but implies type safety and use of embedded domain-specific language for data conversion.","- Introduction of polytypic programming for functional programming languages.
 - Development of PolyP, a language extension for type-safe implementation of polytypic functions.
 - Creation of PolyLib with structured recursion operators and polytypic standard functions.
 - Framework for polytypic programming on terms with a minimal interface.
 - Implementation and proof of correctness for polytypic data conversion functions.","- ""PolyP extends a functional language (a subset of Haskell) with a construct for defining polytypic functions by induction on the structure of user-defined datatypes.""
  - ""We show that an interface of four functions is sufficient to express polytypic functions for pattern matching, unification and term rewriting.""
  - ""PolyLib contains powerful structured recursion operators like catamorphisms, maps and traversals, as well as polytypic versions of a number of standard functions from functional programming: sum, length, zip,""
  - ""polytypic programming is a paradigm for expressing such algorithms.""
  - ""The conversion functions are expressed in an embedded domain specific language for data conversion (a hierarchy of Haskell's constructor classes).""",,"- The abstract discusses polytypic programming as a paradigm, which suggests it is a conceptual framework rather than a specific primitive.
 - PolyP is mentioned as a language extension that allows for the definition of polytypic functions by induction on user-defined datatypes. This implies that the construct for defining polytypic functions is a conceptual primitive.
 - PolyLib is described as containing structured recursion operators like catamorphisms, maps, and traversals, which are likely conceptual primitives for polytypic programming.
 - The mention of an interface of four functions for pattern matching, unification, and term rewriting suggests these functions are conceptual primitives for polytypic programming in the context of term rewriting.
 - The use of an embedded domain-specific language for data conversion implies that this language is a conceptual primitive for data conversion tasks.","- ""The first larger application is a framework for polytypic programming on terms. We show that an interface of four functions is sufficient to express polytypic functions for pattern matching, unification and term rewriting.""
  - ""In the second application, a number of functions for polytypic data conversion are implemented and proved correct.""
  - ""This dissertation introduces polytypic programming for functional programming languages, shows how to construct and prove properties of polytypic algorithms, presents the language extension PolyP for implementing polytypic algorithms in a type safe way, and presents a number of applications of polytypic programming.""
  - ""PolyP extends a functional language (a subset of Haskell) with a construct for defining polytypic functions by induction on the structure of user-defined datatypes.""
  - ""PolyLib contains powerful structured recursion operators like catamorphisms, maps and traversals, as well as polytypic versions of a number of standard functions from functional programming: sum, length, zip,""",,"- The abstract mentions the introduction of polytypic programming for functional programming languages and the construction and proof of properties of polytypic algorithms. This suggests a focus on type theory, as polytypic programming is closely related to type systems.
 - The mention of ""PolyP extends a functional language (a subset of Haskell) with a construct for defining polytypic functions by induction on the structure of user-defined datatypes"" indicates the use of type theory, as it involves defining functions by induction on datatypes, which is a common technique in type theory.
 - The abstract does not explicitly mention any specific mathematical framework like category theory or type theory, nor does it detail specific mathematical properties guaranteed or proof techniques used.
 - The abstract does not provide information on limitations or constraints of the framework.","- ""This dissertation introduces polytypic programming for functional programming languages, shows how to construct and prove properties of polytypic algorithms, presents the language extension PolyP for implementing polytypic algorithms in a type safe way, and presents a number of applications of polytypic programming.""
  - ""PolyP extends a functional language (a subset of Haskell) with a construct for defining polytypic functions by induction on the structure of user-defined datatypes.""
  - ""Programs in the extended language are translated to Haskell.""
  - ""PolyLib contains powerful structured recursion operators like catamorphisms, maps and traversals, as well as polytypic versions of a number of standard functions from functional programming: sum, length, zip,""
  - ""The first larger application is a framework for polytypic programming on terms. We show that an interface of four functions is sufficient to express polytypic functions for pattern matching, unification and term rewriting.""
  - ""In the second application, a number of functions for polytypic data conversion are implemented and proved correct.""
  - ""The conversion functions are expressed in an embedded domain specific language for data conversion (a hierarchy of Haskell's constructor classes).""",,"- The abstract discusses the introduction of polytypic programming for functional programming languages, which is a paradigm for expressing algorithms that can be applied to different datatypes.
 - PolyP is a language extension that allows for the definition of polytypic functions by induction on user-defined datatypes, which is a specific integration mechanism.
 - The abstract mentions that programs in PolyP are translated to Haskell, indicating a translation technique for integrating polytypic programming with existing functional programming languages.
 - The use of PolyLib and its structured recursion operators suggests an interaction model between polytypic programming and functional programming paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the translation of PolyP programs to Haskell.
 - The focus is on integrating polytypic programming with functional programming, particularly through the extension of a functional language (Haskell) with polytypic constructs.","- ""polytypic programming is a paradigm for expressing such algorithms.""
  - ""This dissertation introduces polytypic programming for functional programming languages, shows how to construct and prove properties of polytypic algorithms, presents the language extension PolyP for implementing polytypic algorithms in a type safe way, and presents a number of applications of polytypic programming.""
  - ""PolyP extends a functional language (a subset of Haskell) with a construct for defining polytypic functions by induction on the structure of user-defined datatypes.""
  - ""PolyLib contains powerful structured recursion operators like catamorphisms, maps and traversals, as well as polytypic versions of a number of standard functions from functional programming: sum, length, zip,""
  - ""The first larger application is a framework for polytypic programming on terms.""
  - ""The conversion functions are expressed in an embedded domain specific language for data conversion (a hierarchy of Haskell's constructor classes).""",,"- The abstract discusses ""polytypic programming"" as a paradigm for expressing algorithms that can work with different datatypes, which aligns with the concept of generic programming.
 - The ""PolyP"" language extension is introduced as a mechanism for implementing polytypic algorithms in a type-safe way, indicating a focus on genericity and abstraction.
 - The mention of ""construct for defining polytypic functions by induction on the structure of user-defined datatypes"" suggests a mechanism for representing generic abstractions.
 - The use of ""structured recursion operators"" and ""polytypic versions of standard functions"" implies a method for abstracting common operations across different datatypes.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on type safety and the use of Haskell's constructor classes suggests some level of type system discussion.
 - The abstract does not provide detailed information on static checking or optimization strategies, but it does emphasize the use of an embedded domain-specific language for data conversion, which could imply some form of optimization.","- ""This dissertation introduces polytypic programming for functional programming languages, shows how to construct and prove properties of polytypic algorithms, presents the language extension PolyP for implementing polytypic algorithms in a type safe way, and presents a number of applications of polytypic programming.""
  - ""The first larger application is a framework for polytypic programming on terms. We show that an interface of four functions is sufficient to express polytypic functions for pattern matching, unification and term rewriting.""
  - ""PolyLib contains powerful structured recursion operators like catamorphisms, maps and traversals, as well as polytypic versions of a number of standard functions from functional programming: sum, length, zip,""
  - ""PolyP extends a functional language (a subset of Haskell) with a construct for defining polytypic functions by induction on the structure of user-defined datatypes.""
  - ""In the second application, a number of functions for polytypic data conversion are implemented and proved correct.""",,"- The abstract introduces polytypic programming for functional programming languages, which is a novel approach as it allows for the expression of algorithms that can work across different datatypes.
 - The development of PolyP, a language extension that enables the definition of polytypic functions by induction on user-defined datatypes, is a theoretical advancement. It provides a type-safe way to implement these algorithms.
 - The creation of PolyLib, which includes structured recursion operators and polytypic versions of standard functions, is a significant contribution. It provides a library of basic building blocks for polytypic programming.
 - The framework for polytypic programming on terms, which requires only four functions to express pattern matching, unification, and term rewriting, is a key theoretical insight. It simplifies the process of implementing these complex operations.
 - The implementation and proof of correctness for polytypic data conversion functions, such as pretty printing and parsing, are theoretical advancements. They demonstrate the applicability and reliability of polytypic programming in data conversion tasks.
 - The potential implications for programming language design include the ability to write more generic and reusable code, reducing the need for repeated implementation of algorithms for different datatypes."
"Programming languages and systems, ESOP '94 : 5th European Symposium on Programming, Edinburgh, U.K., April 11-13, 1994 : proceedings",D. Sannella,-,-,-,0,1994,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: Lambda calculus, type theory, denotational semantics, structural operational semantics (SOS), category theory
 - Specific mathematical properties guaranteed: Not explicitly mentioned
 - Proof techniques used: Fixed point iteration, term rewriting systems, algebraic proofs
 - Limitations or constraints of the framework: Not explicitly mentioned",No specific integration approach described,"- Definition of ""concept"" used: Not explicitly defined in the abstract.
 - Mechanisms for representing generic abstractions: Type classes in Haskell, First-class polymorphism for ML.
 - Minimal type requirements identified: Not explicitly mentioned in the abstract.
 - Static checking or optimization strategies: Lazy type inference for the strictness analysis of lists, Polymorphic binding-time analysis.","- Key novel insights: Introduction of Pi-nets as a graphical form of ?-calculus, local type reconstruction by symbolic fixed point iteration, and synergistic analysis for sharing and groundness.
 - Theoretical advancements: Foundational issues in constraint logic programming, logical denotational semantics for constraint logic programming, and semantics for higher-order functors.
 - Potential implications: Advancements in programming language design through new theoretical frameworks and analyses.","- ""A theory of primitive objects.-""
  - ""Pi-nets: A graphical form of ?-calculus.-""
  - ""Local type reconstruction by means of symbolic fixed point iteration.-""
  - ""An asynchronous process algebra with multiple clocks.-""
  - ""Foundational issues in implementing constraint logic programming systems.-""
  - ""Programming with behaviors in an ML framework - The syntax and semantics of LCS.-""
  - ""Characterizing behavioural semantics and abstractor semantics.-""
  - ""Extending pruning techniques to polymorphic second order ?-calculus.-""
  - ""definition of function(al)s by normal forms.-""
  - ""Simulation of SOS definitions with term rewriting systems.-""
  - ""Strategies in modular system design by interface rewriting.-""
  - ""Symbolic model checking and constraint logic programming: A cross-fertilization.-""
  - ""A logical denotational semantics for constraint logic programming.-""
  - ""Compilation of head and strong reduction.-""
  - ""Suffix trees in the functioned programming paradigm.-""
  - ""Type classes in Haskell.-""
  - ""Lazy type inference for the strictness analysis of lists.-""
  - ""Lazy unification with simplification.-""
  - ""Polymorphic binding-time analysis.-""
  - ""Shapely types and shape polymorphism.-""
  - ""Bottom-up grammar analysis - A functional formulation.-""
  - ""First-class polymorphism for ML.-""
  - ""Dimension types.-""
  - ""A synergistic analysis for sharing and groundness which traces linearity.-""
  - ""A ?-calculus specification of prolog.-""
  - ""A logical framework for evolution of specifications.-""
  - ""A semantics for higher-order functors.-""
  - ""The PCKS-machine: An abstract machine for sound evaluation of parallel functional programs with first-class continuations.-""
  - ""A tiny constraint functional logic language and its continuation semantics.-""
  - ""Fully abstract translations and parametric polymorphism.-""
  - ""Broadcasting with priority.-""
  - ""Towards unifying partial evaluation, deforestation, supercompilation, and GPC.-""
  - ""Algebraic proofs of properties of objects.""",,"- The abstract mentions several topics related to programming languages and systems, but it does not explicitly define conceptual primitives.
 - The term ""primitive objects"" is mentioned, but no specific definition or details are provided in the abstract.
 - Other terms like ""Pi-nets,"" ""asynchronous process algebra,"" and ""constraint logic programming"" are mentioned, but they are not explicitly defined as conceptual primitives.
 - The abstract lists various topics and techniques but does not provide a clear definition or list of conceptual primitives as requested by the question.","- ""A theory of primitive objects.-""
  - ""Pi-nets: A graphical form of ?-calculus.-""
  - ""Local type reconstruction by means of symbolic fixed point iteration.-""
  - ""Foundational issues in implementing constraint logic programming systems.-""
  - ""Characterizing behavioural semantics and abstractor semantics.-""
  - ""Extending pruning techniques to polymorphic second order ?-calculus.-""
  - ""definition of function(al)s by normal forms.-""
  - ""Simulation of SOS definitions with term rewriting systems.-""
  - ""A logical denotational semantics for constraint logic programming.-""
  - ""A semantics for higher-order functors.-""
  - ""Algebraic proofs of properties of objects.""",,"- The abstract mentions several topics related to mathematical frameworks, such as ""A theory of primitive objects,"" which suggests a foundational approach to object theory.
 - ""Pi-nets: A graphical form of ?-calculus"" indicates the use of lambda calculus, a mathematical framework for functional programming.
 - ""Local type reconstruction by means of symbolic fixed point iteration"" suggests the use of type theory and fixed point iteration, a mathematical technique.
 - ""Foundational issues in implementing constraint logic programming systems"" implies discussions on the theoretical foundations of constraint logic programming.
 - ""Characterizing behavioural semantics and abstractor semantics"" and ""A logical denotational semantics for constraint logic programming"" indicate the use of denotational semantics, a mathematical framework for describing programming languages.
 - ""Extending pruning techniques to polymorphic second order ?-calculus"" and ""?-definition of function(al)s by normal forms"" further suggest the use of lambda calculus and type theory.
 - ""Simulation of SOS definitions with term rewriting systems"" indicates the use of structural operational semantics (SOS) and term rewriting systems, which are mathematical frameworks for formalizing programming languages.
 - ""A semantics for higher-order functors"" suggests the use of category theory, as functors are a key concept in this field.
 - ""Algebraic proofs of properties of objects"" implies the use of algebraic methods for proving properties, which is a common approach in mathematical frameworks.","- ""Programming with behaviors in an ML framework""
  - ""The syntax and semantics of LCS.-""
  - ""Extending pruning techniques to polymorphic second order ?-calculus.-""
  - ""Simulation of SOS definitions with term rewriting systems.-""
  - ""Strategies in modular system design by interface rewriting.-""
  - ""Symbolic model checking and constraint logic programming: A cross-fertilization.-""
  - ""A logical denotational semantics for constraint logic programming.-""
  - ""Compilation of head and strong reduction.-""
  - ""Suffix trees in the functioned programming paradigm.-""
  - ""Type classes in Haskell.-""
  - ""Lazy type inference for the strictness analysis of lists.-""
  - ""Lazy unification with simplification.-""
  - ""Polymorphic binding-time analysis.-""
  - ""Shapely types and shape polymorphism.-""
  - ""Bottom-up grammar analysis - A functional formulation.-""
  - ""First-class polymorphism for ML.-""
  - ""Dimension types.-""
  - ""A synergistic analysis for sharing and groundness which traces linearity.-""
  - ""A ?-calculus specification of prolog.-""
  - ""A logical framework for evolution of specifications.-""
  - ""A semantics for higher-order functors.-""
  - ""The PCKS-machine: An abstract machine for sound evaluation of parallel functional programs with first-class continuations.-""
  - ""A tiny constraint functional logic language and its continuation semantics.-""
  - ""Fully abstract translations and parametric polymorphism.-""
  - ""Broadcasting with priority.-""
  - ""Towards unifying partial evaluation, deforestation, supercompilation, and GPC.-""
  - ""Algebraic proofs of properties of objects.""",,"- The abstract mentions several programming paradigms and languages, such as ML, LCS, constraint logic programming, and functional programming, indicating a focus on multiple paradigms.
 - The mention of ""Programming with behaviors in an ML framework"" suggests an integration of behavioral programming with ML, which is a specific integration mechanism.
 - The abstract discusses ""Symbolic model checking and constraint logic programming: A cross-fertilization,"" which implies an interaction model between these two paradigms.
 - The mention of ""Extending pruning techniques to polymorphic second order ?-calculus"" and ""Simulation of SOS definitions with term rewriting systems"" suggests novel translation or embedding techniques.
 - The abstract also mentions ""Strategies in modular system design by interface rewriting,"" which could be related to interaction models or integration strategies.
 - However, the abstract does not explicitly discuss constraints or challenges in paradigm integration, nor does it provide a comprehensive integration approach that ties all these elements together.","- ""A theory of primitive objects.-""
  - ""Pi-nets: A graphical form of ?-calculus.-""
  - ""Local type reconstruction by means of symbolic fixed point iteration.-""
  - ""Extending pruning techniques to polymorphic second order ?-calculus.-""
  - ""Type classes in Haskell.-""
  - ""Lazy type inference for the strictness analysis of lists.-""
  - ""Polymorphic binding-time analysis.-""
  - ""Shapely types and shape polymorphism.-""
  - ""First-class polymorphism for ML.-""
  - ""Dimension types.-""",,"- The abstract mentions several topics related to generic programming and abstraction mechanisms, such as ""A theory of primitive objects,"" which could imply a focus on basic building blocks for generic programming.
 - ""Pi-nets: A graphical form of ?-calculus"" suggests a graphical representation of lambda calculus, which is a fundamental concept in functional programming and could relate to generic abstractions.
 - ""Local type reconstruction by means of symbolic fixed point iteration"" and ""Extending pruning techniques to polymorphic second order ?-calculus"" indicate discussions on type systems and polymorphism, which are crucial for generic programming.
 - ""Type classes in Haskell"" and ""First-class polymorphism for ML"" directly relate to generic programming methodologies, as type classes and first-class polymorphism are mechanisms for representing generic abstractions.
 - ""Lazy type inference for the strictness analysis of lists"" and ""Polymorphic binding-time analysis"" suggest strategies for static checking and optimization, which are important for generic programming.
 - ""Shapely types and shape polymorphism"" and ""Dimension types"" further indicate a focus on type systems and polymorphism, which are essential for generic programming.","- ""A theory of primitive objects.-""
  - ""Pi-nets: A graphical form of ?-calculus.-""
  - ""Local type reconstruction by means of symbolic fixed point iteration.-""
  - ""An asynchronous process algebra with multiple clocks.-""
  - ""Foundational issues in implementing constraint logic programming systems.-""
  - ""Programming with behaviors in an ML framework - The syntax and semantics of LCS.-""
  - ""Characterizing behavioural semantics and abstractor semantics.-""
  - ""Extending pruning techniques to polymorphic second order ?-calculus.-""
  - ""definition of function(al)s by normal forms.-""
  - ""Simulation of SOS definitions with term rewriting systems.-""
  - ""Strategies in modular system design by interface rewriting.-""
  - ""Symbolic model checking and constraint logic programming: A cross-fertilization.-""
  - ""A logical denotational semantics for constraint logic programming.-""
  - ""Compilation of head and strong reduction.-""
  - ""Suffix trees in the functioned programming paradigm.-""
  - ""Type classes in Haskell.-""
  - ""Lazy type inference for the strictness analysis of lists.-""
  - ""Lazy unification with simplification.-""
  - ""Polymorphic binding-time analysis.-""
  - ""Shapely types and shape polymorphism.-""
  - ""Bottom-up grammar analysis - A functional formulation.-""
  - ""First-class polymorphism for ML.-""
  - ""Dimension types.-""
  - ""A synergistic analysis for sharing and groundness which traces linearity.-""
  - ""A ?-calculus specification of prolog.-""
  - ""A logical framework for evolution of specifications.-""
  - ""A semantics for higher-order functors.-""
  - ""The PCKS-machine: An abstract machine for sound evaluation of parallel functional programs with first-class continuations.-""
  - ""A tiny constraint functional logic language and its continuation semantics.-""
  - ""Fully abstract translations and parametric polymorphism.-""
  - ""Broadcasting with priority.-""
  - ""Towards unifying partial evaluation, deforestation, supercompilation, and GPC.-""
  - ""Algebraic proofs of properties of objects.""",,"- The abstract lists numerous topics related to programming languages and systems, indicating a broad range of theoretical contributions.
 - The mention of ""A theory of primitive objects"" suggests a novel theoretical framework for understanding primitive objects.
 - ""Pi-nets: A graphical form of ?-calculus"" introduces a new graphical representation, which is a theoretical innovation.
 - ""Local type reconstruction by means of symbolic fixed point iteration"" and ""Extending pruning techniques to polymorphic second order ?-calculus"" indicate advancements in type reconstruction and pruning techniques.
 - The discussion of ""Foundational issues in implementing constraint logic programming systems"" and ""A logical denotational semantics for constraint logic programming"" suggests theoretical contributions to the foundation and semantics of constraint logic programming.
 - The abstract mentions several topics related to programming languages, such as ""Programming with behaviors in an ML framework,"" ""Type classes in Haskell,"" and ""First-class polymorphism for ML,"" which are theoretical advancements in these areas.
 - The mention of ""A synergistic analysis for sharing and groundness which traces linearity"" and ""A semantics for higher-order functors"" indicates novel theoretical analyses and semantics.
 - The abstract also discusses theoretical frameworks and machines, such as ""The PCKS-machine: An abstract machine for sound evaluation of parallel functional programs with first-class continuations,"" which is a theoretical contribution to parallel programming.
 - The abstract does not provide explicit conclusions or comparative analyses, but the variety of topics suggests a comprehensive theoretical contribution to programming languages and systems."
Programming Language Abstractions for Modularly Verified Distributed Systems,"James R. Wilcox, Ilya Sergey, Zachary Tatlock",10.4230/LIPIcs.SNAPL.2017.19,https://doi.org/10.4230/LIPIcs.SNAPL.2017.19,Summit on Advances in Programming Languages,23,2017,"1. Primitive Name: Instrumented message-passing primitives (send/receive)
  Definition: Derived from protocol transitions, serving as basic building blocks for distributed programs.
  Orthogonality Score: High (can be adapted to various protocols)
 2. Primitive Name: Distributed Hoare Types (DHT)
  Definition: An extension of Hoare Types, for verifying well-behaved programs in the context of user-provided protocols.
  Orthogonality Score: High (can be parametrized by protocol contexts and pre/postconditions)","- Type of mathematical framework: Type theory (Hoare Type Theory and Distributed Hoare Types)
 - Specific mathematical properties guaranteed: Program well-formedness with respect to protocols, ensuring externally observable transitions follow protocol transitions
 - Proof techniques used: Type derivation mechanisms
 - Limitations or constraints of the framework: Non-decidable","- Specific integration mechanisms proposed: Distributed Hoare Types (DHT)
 - Interaction models between paradigms: Typing rule WithInv
 - Constraints or challenges in paradigm integration: Need for modular verification framework
 - Novel translation or embedding techniques: Extension of Hoare Types to DHT",Generic programming not extensively addressed,"- Key novel insights: The paper introduces Distributed Hoare Types (DHT) as a novel approach to modular verification of distributed systems, integrating high-level protocols and low-level implementation safety properties.
 - Theoretical advancements: DHT extends Hoare Type Theory to distributed systems, providing a unified framework for modular verification and addressing challenges in refinement proofs.
 - Potential implications for programming language design: DHT can be represented as dependent types, offering a flexible and expressive verification mechanism, and serves as a link between protocol properties and program properties, enabling modular reasoning.","- ""the programming component of DHT is a pure functional language with general recursion and message passing.""
  - ""Distributed Hoare Types can be effectively represented as dependent types, parametrized by the protocol contexts and pre/postconditions""
  - ""Our approach, mechanized within a proof assistant, provides the means of decomposition necessary for modular proofs about distributed protocols and systems.""",,"- The paper introduces two main conceptual primitives: ""Instrumented message-passing primitives (send/receive)"" and ""Distributed Hoare Types (DHT).""
 - The ""Instrumented message-passing primitives (send/receive)"" are defined as derived from protocol transitions and serve as basic building blocks for distributed programs. This suggests a focus on message-passing as a fundamental primitive for distributed systems.
 - ""Distributed Hoare Types (DHT)"" are an extension of Hoare Types, designed to verify well-behaved programs in the context of user-provided protocols. This indicates a focus on type theory as a primitive for ensuring program correctness.
 - The paper also mentions that Distributed Hoare Types can be represented as dependent types, which are parametrized by protocol contexts and pre/postconditions. This suggests a high level of abstraction and orthogonality, as these types can be adapted to various protocols and contexts.
 - The programming component of DHT is described as a pure functional language with general recursion and message passing, indicating a focus on functional programming principles as part of the primitives.","- ""We have drawn inspiration from results on Hoare Type Theory (HTT) [43,42,41] and specifically its recent variants, which support specifying and verifying fine-grained sharedmemory concurrent algorithms [40,50,51,52].""
  - ""Distributed Hoare Types. In this work, we extend the notion of Hoare types to distributed system implementations, whose ""state"" captures both local components (e.g., a heap) and a global component, namely the (multi-)set of messages exchanged by the nodes involved in the system.""
  - ""Distributed Hoare Types can be effectively represented as dependent types, parametrized by the protocol contexts and pre/postconditions [42].""
  - ""This allowed us to implement the type-based verification approach, sketched in Section 2, in a verification tool Disel, by embedding our type system, its semantic foundations, and inference rules into the Coq proof assistant [6].""
  - ""Our careful choice of basic programming primitives, namely, protocol transitions, is the trick that allowed us to replace expensive proofs of program refinement with a far less complicated (although still non-decidable) and uniform type derivation mechanism.""
  - ""The interaction between protocol-level proofs and program-level verification is enabled by the typing rule WithInv from Figure 1""",,"- The paper discusses the use of Hoare Type Theory (HTT) as a foundation for their mathematical framework, specifically extending it to distributed systems.
 - The framework is based on ""Distributed Hoare Types,"" which are an extension of Hoare Types to handle distributed system implementations.
 - These types are represented as dependent types, which are parametrized by protocol contexts and pre/postconditions, indicating a type theory framework.
 - The framework guarantees program well-formedness with respect to protocols, ensuring that externally observable transitions follow protocol transitions.
 - The proof techniques involve type derivation mechanisms, which replace expensive refinement proofs with a more uniform approach.
 - The framework is implemented using the Coq proof assistant, which is a tool for formal verification.
 - The limitations or constraints are not explicitly mentioned, but the framework is described as non-decidable, indicating potential complexity in certain scenarios.","- ""In this paper, we focus on the challenge of modular verification of distributed systems with respect to high-level protocol invariants as well as for low-level implementation safety properties.""
  - ""We argue that the missing link between the two is a programming paradigm that would allow one to reason about both high-level distributed protocols and low-level implementation primitives in a single verification-friendly framework.""
  - ""Our approach, mechanized within a proof assistant, provides the means of decomposition necessary for modular proofs about distributed protocols and systems.""
  - ""Distributed Hoare Types. In this work, we extend the notion of Hoare types to distributed system implementations, whose ""state"" captures both local components (e.g., a heap) and a global component, namely the (multi-)set of messages exchanged by the nodes involved in the system.""
  - ""The interaction between protocol-level proofs and program-level verification is enabled by the typing rule WithInv from Figure 1""
  - ""We believe that DHT serves as a link, connecting proofs of protocol properties and program properties in the same logical framework while providing modular reasoning.""",,"- The paper discusses the integration of high-level distributed protocols and low-level implementation primitives through a programming paradigm that allows for modular verification.
 - The proposed integration mechanism is the use of Distributed Hoare Types (DHT), which extend Hoare Types to capture both local and global state components in distributed systems.
 - The interaction model between paradigms is facilitated by the typing rule WithInv, which enables the interaction between protocol-level proofs and program-level verification.
 - The challenge in paradigm integration is the need for a framework that can handle both high-level protocols and low-level implementations in a modular way.
 - The novel translation or embedding technique is the extension of Hoare Types to Distributed Hoare Types, which allows for the integration of different programming paradigms in a single verification framework.","- ""We argue that the missing link between the two is a programming paradigm that would allow one to reason about both high-level distributed protocols and low-level implementation primitives in a single verification-friendly framework.""
  - ""Distributed Hoare Types can be effectively represented as dependent types, parametrized by the protocol contexts and pre/postconditions""
  - ""Distributed Hoare Types. In this work, we extend the notion of Hoare types to distributed system implementations, whose ""state"" captures both local components (e.g., a heap) and a global component, namely the (multi-)set of messages exchanged by the nodes involved in the system.""
  - ""Our approach, mechanized within a proof assistant, provides the means of decomposition necessary for modular proofs about distributed protocols and systems.""
  - ""In this paper, we focus on the challenge of modular verification of distributed systems with respect to high-level protocol invariants as well as for low-level implementation safety properties.""",,"- The paper primarily focuses on modular verification of distributed systems, which involves high-level protocol invariants and low-level implementation safety properties. This suggests a focus on abstraction mechanisms rather than generic programming.
 - The concept of ""Distributed Hoare Types"" is central to the paper, which is an extension of Hoare types to distributed systems. This involves representing system states and interactions in a way that supports modular verification.
 - The paper mentions the use of dependent types and parametrization by protocol contexts and pre/postconditions, which are mechanisms for representing generic abstractions.
 - The mention of ""reusable specifications for programs in terms of abstract predicates"" indicates a form of abstraction mechanism, but it does not explicitly address generic programming.
 - There is no specific section or discussion dedicated to generic programming methodology or minimal type requirements, nor are there static checking or optimization strategies explicitly mentioned in the context of generic programming.","- ""In this paper, we focus on the challenge of modular verification of distributed systems with respect to high-level protocol invariants as well as for low-level implementation safety properties.""
  - ""We argue that the missing link between the two is a programming paradigm that would allow one to reason about both high-level distributed protocols and low-level implementation primitives in a single verification-friendly framework.""
  - ""Our approach, mechanized within a proof assistant, provides the means of decomposition necessary for modular proofs about distributed protocols and systems.""
  - ""Distributed Hoare Types. In this work, we extend the notion of Hoare types to distributed system implementations, whose ""state"" captures both local components (e.g., a heap) and a global component, namely the (multi-)set of messages exchanged by the nodes involved in the system.""
  - ""The first scenario is fairly standard: one should always be able to make low-level optimizations in an actual implementation, as long as these changes are not observable on the abstract level, with the high-level protocol serving as a system specification.""
  - ""The second scenario demonstrates an interplay between properties of a protocol and proofs of an implementation that relies on them: indeed, the correctness of a refinement by the latter depends on the invariants of the former.""
  - ""The third scenario demonstrates a common pattern where a protocol implementor assumes the system is initialized to a certain ""good"" state.""
  - ""From the discussion above, it seems that the proofs of refinement, i.e., that an implementation ""does not go wrong"", are unavoidable for formally establishing the correspondence between the code of an implementation and its abstract protocol specification.""
  - ""We have drawn inspiration from results on Hoare Type Theory (HTT) [43,42,41] and specifically its recent variants, which support specifying and verifying fine-grained sharedmemory concurrent algorithms [40,50,51,52].""
  - ""Distributed Hoare Types can be effectively represented as dependent types, parametrized by the protocol contexts and pre/postconditions [42].""
  - ""We believe that DHT serves as a link, connecting proofs of protocol properties and program properties in the same logical framework while providing modular reasoning.""",,"- The paper introduces a novel approach to modular verification of distributed systems by extending Hoare Type Theory to include distributed system implementations. This is a key theoretical contribution as it allows for the verification of both high-level protocols and low-level implementation safety properties within a single framework.
 - The paper addresses three scenarios that highlight the challenges in modular verification, providing a comprehensive understanding of the issues and how Distributed Hoare Types (DHT) can address them. This is a theoretical advancement as it provides a structured approach to handling complex verification challenges.
 - The use of DHT as a link between protocol properties and program properties is a significant theoretical contribution. It enables modular reasoning, which is crucial for managing the complexity of distributed systems.
 - The paper discusses the potential for DHT to be represented as dependent types, which is a theoretical innovation in terms of programming language design. This allows for more flexible and expressive verification mechanisms.
 - The paper's focus on providing a programming paradigm that integrates high-level protocols and low-level implementation primitives is a novel insight. It addresses a gap in existing verification tools by offering a unified framework for modular verification."
Communicating Parallel Processes,S. Brookes,-,-,-,1,2000,Not specified (the abstract does not provide explicit definitions or details on the conceptual primitives),Not specified (the abstract does not provide specific details about the mathematical framework),"- Specific integration mechanisms proposed: Generalized syntax and semantics based on asynchronous communication and fair parallel execution.
 - Interaction models between paradigms: Unification of paradigms through a semantic framework that models asynchronous processes, shared-variable programs, and Kahn-style dataflow networks.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed (the abstract focuses on conceptual abstraction and unification of paradigms but does not explicitly address generic programming methodology or type system discussions),"- Key novel insights: Introduction of an ""idealized"" version of CSP with asynchronous communication and fair parallel execution; nested and recursive uses of parallelism.
 - Theoretical advancements: Shift from synchronous to asynchronous communication; simple semantics for the new language; unification of paradigms for asynchronous processes, shared-variable programs, and Kahn-style dataflow networks.
 - Potential implications for programming language design: Broader applicability and flexibility in programming language design; potential for more efficient and flexible parallel programming.","- ""We propose an “idealized” version of CSP whose syntax generalizes the original language along familiar lines but whose semantics is based on asynchronous communication and fair parallel execution, in direct contrast with the original language and its main successors.""
  - ""CSP treated input and output as fundamental programming primitives, and included a simple form of parallel composition based on synchronized communication.""
  - ""Our semantic framework is equally well suited to modelling asynchronous processes, shared-variable programs, and Kahn-style dataflow networks, so that we achieve a unification of paradigms.""
  - ""This language permits nested and recursive uses of parallelism, so it is more appropriate for us to refer to Communicating Parallel Processes.""",,"- The abstract mentions that CSP treated ""input and output as fundamental programming primitives,"" which are conceptual primitives in the original CSP.
 - The abstract proposes an ""idealized"" version of CSP with a focus on ""asynchronous communication and fair parallel execution,"" which suggests new conceptual primitives related to asynchronous communication.
 - The mention of ""nested and recursive uses of parallelism"" implies a conceptual primitive related to parallel composition.
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality or level of abstraction in detail.
 - The abstract does not specify any new conceptual primitives beyond those implied by the changes to CSP, such as asynchronous communication and fair parallel execution.","- ""We outline a simple semantics for this language and compare its structure with the most prominent models of the synchronous language.""
  - ""Investigations of the semantic foundations of CSP and its successors and derivatives have flourished, bringing forth a variety of mathematical models, each tailored to focus on a particular kind of program behavior.""
  - ""We propose an “idealized” version of CSP whose syntax generalizes the original language along familiar lines but whose semantics is based on asynchronous communication and fair parallel execution, in direct contrast with the original language and its main successors.""
  - ""Our semantic framework is equally well suited to modelling asynchronous processes, shared-variable programs, and Kahn-style dataflow networks, so that we achieve a unification of paradigms.""",,"- The abstract mentions ""investigations of the semantic foundations of CSP"" and the development of ""mathematical models,"" indicating that there is some form of mathematical framework involved in the study of CSP and its derivatives.
 - The proposal of an ""idealized"" version of CSP with semantics based on ""asynchronous communication and fair parallel execution"" suggests a focus on asynchronous processes, which could imply a mathematical framework tailored to handle such processes.
 - The mention of ""a simple semantics for this language"" and comparison with ""prominent models of the synchronous language"" implies that there is some form of mathematical framework or model being discussed, but it does not specify the type of mathematical framework (e.g., type theory, category theory).
 - The abstract does not provide specific details about the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework. It only mentions a ""unification of paradigms,"" which suggests a broad applicability but lacks specific mathematical details.","- ""We propose an “idealized” version of CSP whose syntax generalizes the original language along familiar lines but whose semantics is based on asynchronous communication and fair parallel execution, in direct contrast with the original language and its main successors.""
  - ""Our semantic framework is equally well suited to modelling asynchronous processes, shared-variable programs, and Kahn-style dataflow networks, so that we achieve a unification of paradigms.""
  - ""Ideas from CSP have influenced the design of more recent programming languages such as occam and Ada.""
  - ""The notion of processes is easy to grasp intuitively, provides a natural abstraction of the way many parallel systems behave, and has an abundance of applications.""",,"- The abstract discusses the evolution of the Communicating Sequential Processes (CSP) language and its influence on other programming languages, indicating a historical integration of ideas.
 - The proposal of an ""idealized"" version of CSP with asynchronous communication and fair parallel execution suggests a new integration mechanism by generalizing the syntax and semantics.
 - The mention of a semantic framework that can model different types of processes (asynchronous, shared-variable, Kahn-style dataflow networks) implies a theoretical integration strategy that unifies these paradigms.
 - The abstract does not explicitly mention specific interaction models or constraints/challenges in paradigm integration, nor does it detail novel translation or embedding techniques.","- ""Our semantic framework is equally well suited to modelling asynchronous processes, shared-variable programs, and Kahn-style dataflow networks, so that we achieve a unification of paradigms.""
  - ""We propose an “idealized” version of CSP whose syntax generalizes the original language along familiar lines but whose semantics is based on asynchronous communication and fair parallel execution, in direct contrast with the original language and its main successors.""
  - ""This language permits nested and recursive uses of parallelism, so it is more appropriate for us to refer to Communicating Parallel Processes.""
  - ""The notion of processes is easy to grasp intuitively, provides a natural abstraction of the way many parallel systems behave, and has an abundance of applications.""",,"- The abstract discusses the concept of processes as a natural abstraction for parallel systems, indicating a focus on conceptual abstraction.
 - The proposal of an ""idealized"" version of CSP suggests a mechanism for representing generic abstractions by generalizing the original language syntax.
 - The mention of nested and recursive uses of parallelism implies a mechanism for representing complex abstractions.
 - The semantic framework's ability to model various paradigms suggests a unification of abstraction mechanisms.
 - However, there is no explicit mention of generic programming methodology, type system discussions, or specific static checking or optimization strategies.","- ""We propose an “idealized” version of CSP whose syntax generalizes the original language along familiar lines but whose semantics is based on asynchronous communication and fair parallel execution, in direct contrast with the original language and its main successors.""
  - ""This language permits nested and recursive uses of parallelism, so it is more appropriate for us to refer to Communicating Parallel Processes.""
  - ""Our semantic framework is equally well suited to modelling asynchronous processes, shared-variable programs, and Kahn-style dataflow networks, so that we achieve a unification of paradigms.""
  - ""We outline a simple semantics for this language and compare its structure with the most prominent models of the synchronous language.""",,"- The abstract introduces a novel theoretical contribution by proposing an ""idealized"" version of CSP that shifts from synchronous to asynchronous communication and fair parallel execution. This is a significant departure from the original CSP and its successors.
 - The new language allows for nested and recursive uses of parallelism, which is a key novel insight as it extends the capabilities of parallel programming.
 - The abstract mentions a simple semantics for this new language, which is a theoretical advancement as it provides a framework for understanding and analyzing the behavior of parallel processes.
 - The comparison with prominent models of synchronous languages highlights the theoretical contribution by showing how the new framework differs and improves upon existing approaches.
 - The unification of paradigms by making the semantic framework applicable to asynchronous processes, shared-variable programs, and Kahn-style dataflow networks is a significant theoretical advancement. It implies a broader applicability and flexibility in programming language design."
Reasoning about Names In Higher-Order Abstract Syntax,Ivan Scagnetto,-,-,-,11,2002,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Logical Frameworks (LFs) based on constructive type theory
 - Specific mathematical properties guaranteed: Propositions-as-types, proofs-as-terms paradigm
 - Proof techniques used: Axiomatic theory, Higher-Order Abstract Syntax (HOAS) encoding approach
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,"- Definition of ""concept"" used: Not mentioned
 - Mechanisms for representing generic abstractions: Higher-Order Abstract Syntax (HOAS) and Logical Frameworks (LFs) based on constructive type theory
 - Minimal type requirements identified: Not mentioned
 - Static checking or optimization strategies: Type checking implied","- Key novel insights: Proposal of an axiomatic theory in conjunction with HOAS for encoding and reasoning about formal systems.
 - Theoretical advancements: Use of Logical Frameworks (LFs) based on constructive type theory; reduction of proof checking to type checking for mechanized implementation.
 - Potential implications for programming language design: Enhanced ability to encode and reason about formal systems, potentially influencing programming language design and verification.","- ""The contribution of this thesis is the proposal of an axiomatic theory which, in conjunction with the Higher-Order Abstract Syntax (HOAS) encoding approach, allows one to adequately encode and reason over a large class of formal systems.""
  - ""Recently Logical Frameworks (LFs) based on constructive type theory have emerged as general metalanguages for encoding and formally reasoning about formal systems by means of the propositions-as-types, proofs-as-terms paradigm.""",,"- The abstract mentions the proposal of an ""axiomatic theory"" in conjunction with ""Higher-Order Abstract Syntax (HOAS)"" as a contribution. This suggests that the study involves conceptual primitives related to these frameworks.
 - The mention of ""Logical Frameworks (LFs) based on constructive type theory"" and the ""propositions-as-types, proofs-as-terms paradigm"" indicates that these are part of the theoretical framework used in the study.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It discusses the use of HOAS and LFs but does not provide detailed definitions or a list of primitives.
 - The abstract does not mention the level of abstraction or orthogonality of any primitives.","- ""Recently Logical Frameworks (LFs) based on constructive type theory have emerged as general metalanguages for encoding and formally reasoning about formal systems by means of the propositions-as-types, proofs-as-terms paradigm.""
  - ""The latter allows one to reduce the problem of proof checking to that of type checking opening the way to a mechanized implementation of LFs.""
  - ""the formal methods of mathematics provide a rigorous way for reasoning and understanding the behaviour of programs, languages, and complex systems.""
  - ""The contribution of this thesis is the proposal of an axiomatic theory which, in conjunction with the Higher-Order Abstract Syntax (HOAS) encoding approach, allows one to adequately encode and reason over a large class of formal systems.""
  - ""Many logics and calculi have arisen in order to deal with a plethora of problems and properties.""
  - ""The field of Computer Aided Formal Reasoning (CAFR) is a research branch whose aim is to study and implement tools allowing one to develop formal proofs in a computer-assisted way.""",,"- The abstract mentions the use of ""formal methods of mathematics"" and ""many logics and calculi,"" indicating a broad application of mathematical frameworks for reasoning about complex systems.
 - It specifically highlights ""Logical Frameworks (LFs) based on constructive type theory,"" which is a type of mathematical framework used for formalizing and reasoning about formal systems.
 - The ""propositions-as-types, proofs-as-terms paradigm"" is a specific mathematical property guaranteed by this framework, as it allows for the reduction of proof checking to type checking.
 - The use of ""axiomatic theory"" in conjunction with ""Higher-Order Abstract Syntax (HOAS) encoding approach"" suggests a structured method for encoding and reasoning about formal systems.
 - The abstract does not explicitly mention limitations or constraints of the framework, but it does imply that the framework is designed to address the complexity and subtleties involved in formal reasoning.","- ""The continuously growing application of computer science to a wide range of human activities yields several issues.""
  - ""Most of the time, programmers convince themselves that their code meets the original specifications by informal arguments or by testing the software over some sample of input data.""
  - ""the formal methods of mathematics provide a rigorous way for reasoning and understanding the behaviour of programs, languages, and complex systems.""
  - ""The field of Computer Aided Formal Reasoning (CAFR) is a research branch whose aim is to study and implement tools allowing one to develop formal proofs in a computer-assisted way.""
  - ""Recently Logical Frameworks (LFs) based on constructive type theory have emerged as general metalanguages for encoding and formally reasoning about formal systems by means of the propositions-as-types, proofs-as-terms paradigm.""
  - ""The contribution of this thesis is the proposal of an axiomatic theory which, in conjunction with the Higher-Order Abstract Syntax (HOAS) encoding approach, allows one to adequately encode and reason over a large class of formal systems.""",,"- The abstract discusses the need for formal methods in computer science to ensure the correctness of complex systems, which implies a focus on formal reasoning rather than programming paradigms.
 - It mentions the use of Logical Frameworks (LFs) and Higher-Order Abstract Syntax (HOAS) for encoding and reasoning about formal systems, but these are not explicitly described as mechanisms for integrating different programming paradigms.
 - There is no mention of specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques related to programming paradigms.
 - The focus is on formal reasoning and encoding rather than on integrating different programming paradigms.","- ""The latter allows one to reduce the problem of proof checking to that of type checking opening the way to a mechanized implementation of LFs.""
  - ""Recently Logical Frameworks (LFs) based on constructive type theory have emerged as general metalanguages for encoding and formally reasoning about formal systems by means of the propositions-as-types, proofs-as-terms paradigm.""
  - ""The contribution of this thesis is the proposal of an axiomatic theory which, in conjunction with the Higher-Order Abstract Syntax (HOAS) encoding approach, allows one to adequately encode and reason over a large class of formal systems.""",,"- The abstract discusses the use of Higher-Order Abstract Syntax (HOAS) and Logical Frameworks (LFs) based on constructive type theory. These are mechanisms for representing generic abstractions, as they allow for the encoding and formal reasoning about formal systems.
 - The mention of ""propositions-as-types, proofs-as-terms paradigm"" suggests a conceptual abstraction mechanism where propositions are treated as types and proofs as terms, which is a form of generic programming methodology.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on type checking implies some level of static checking.
 - The abstract does not provide a specific definition of ""concept"" used in the study, nor does it explicitly address generic programming methodology or type system discussions in detail.","- ""We hope that this work will help in the understanding and application of LFs.""
  - ""The latter allows one to reduce the problem of proof checking to that of type checking opening the way to a mechanized implementation of LFs.""
  - ""Recently Logical Frameworks (LFs) based on constructive type theory have emerged as general metalanguages for encoding and formally reasoning about formal systems by means of the propositions-as-types, proofs-as-terms paradigm.""
  - ""The contribution of this thesis is the proposal of an axiomatic theory which, in conjunction with the Higher-Order Abstract Syntax (HOAS) encoding approach, allows one to adequately encode and reason over a large class of formal systems.""",,"- The abstract mentions the proposal of an ""axiomatic theory"" in conjunction with HOAS as a key contribution. This suggests a novel theoretical framework for encoding and reasoning about formal systems.
 - The use of Logical Frameworks (LFs) based on constructive type theory is highlighted as a recent development. This indicates an advancement in theoretical approaches by leveraging these frameworks for formal reasoning.
 - The reduction of proof checking to type checking is a significant theoretical advancement, as it enables mechanized implementation, which is a novel insight in the field.
 - The potential implications for programming language design are implied by the ability to encode and reason about a large class of formal systems, which could influence how programming languages are designed and verified."
Programming in Protocols - A Paradigm of Behavioral Programming,"A. McNeile, Ella E. Roubtsova",10.5220/0001759200230030,https://doi.org/10.5220/0001759200230030,International Conference on Evaluation of Novel Approaches to Software Engineering,4,2008,"1. Primitive Name: Protocol Machine
  Definition: A machine that has a specified protocol whereby it will accept, refuse or ignore any event that is presented to it.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Protocol Model
  Definition: A model built from Protocol Machines, event-driven and deterministic.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Event-driven System
  Definition: A system where an event (properly an 'event instance') is the data representation of an occurrence in the real world domain that is of interest to the system.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Object Model
  Definition: A system comprising a population of objects, each with its own unique identity.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Stored State
  Definition: A machine type with a single, distinguished, state variable as part of its local state.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Derived State
  Definition: A machine type with a single, distinguished, state function that returns its state value.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Process algebra (CCS, CSP)
 - Specific mathematical properties guaranteed: Observational Conformance
 - Proof techniques used: Local reasoning at a behavioral level
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Composition of partial behavioral descriptions using process algebraic techniques (CCS, CSP).
 - Interaction models between paradigms: Protocol Machines composed using CSP rules.
 - Constraints or challenges in paradigm integration: Combinatorial state-space explosion addressed by composing separate machines.
 - Any novel translation or embedding techniques: Not explicitly mentioned.",Generic programming not extensively addressed,"- Novel insights: Use of derived quantities as states in behavioral machines, enabling abstraction by representing similar constructs in a simplified manner.
 - Theoretical advancements: Bridging the gap between behavioral models and code, ensuring observational conformance through CSP composition, enabling local reasoning at a behavior level.
 - Potential implications for programming language design: Simplifying complex behavior descriptions, avoiding state-space explosion, and enabling emergent business processes through object behavior.","- ""The language is based on the idea of composing partial behavioral descriptions using process algebraic techniques.""
  - ""The Protocol Modeling paradigm described in this paper has its origins in the JSD, but we have both moved away from the particular notations used in JSD towards a more abstract formulation, and strengthened the semantic basis of the ideas, to the point where direct execution can (and has) been sup-ported.""
  - ""a Protocol Machine as a machine that has a specified protocol whereby it will accept, refuse or ignore any event that is presented to it; and observe that the above definition means that the composition of two Protocol Machines is another Protocol Machine.""
  - ""A Protocol Model is a model built from Protocol Machines. Such models are event driven and deterministic, and the language we use to build them belongs to the class of languages termed synchronous reactive""
  - ""The language deals with event driven systems, where an event (properly an ""event instance"") is the data representation of an occurrence in the real world domain that is of interest to the system.""
  - ""Our aim is to model systems that comprise a population of objects, which are separately instantiated and which each have their own, unique, identity -in other words, an Object Model.""
  - ""The behavior of a machine type is specified as a set of success scenarios, with the following rules:
 

 • The two variants are not mixed within a given machine type. A machine type is either stored state in which case it has a single, distinguished, state variable as part of its local state and only uses left hand variant scenarios; or it is derived state in which case it has a single, distinguished, state function that returns its state value and only uses right hand variant scenarios.""",,"- The paper discusses the creation of a programming paradigm based on event protocols of objects, which suggests that the conceptual primitives are related to these protocols and object behaviors.
 - The concept of ""Protocol Machines"" is central, as they are defined by their ability to accept, refuse, or ignore events, which is a fundamental primitive in this paradigm.
 - The composition of Protocol Machines to form a Protocol Model is another key primitive, as it allows for the creation of complex systems from simpler components.
 - The paper also emphasizes the use of event-driven systems and the deterministic nature of these models, which are essential primitives in understanding how the system operates.
 - The distinction between stored state and derived state in machine types is another primitive, as it defines how state is managed within the system.
 - The paper does not explicitly list these as ""conceptual primitives,"" but they are fundamental concepts that underpin the proposed programming paradigm.","- ""The language is based on the idea of composing partial behavioral descriptions using process algebraic techniques.""
  - ""The Process Algebras (CCS, CSP, etc.) all deal with abstract processes (or machines) that offer their environment the ability to accept some events and refuse or ignore others, based on their ""state"".""
  - ""we define a Protocol Machine as a machine that has a specified protocol whereby it will accept, refuse or ignore any event that is presented to it; and observe that the above definition means that the composition of two Protocol Machines is another Protocol Machine.""
  - ""The language deals with event driven systems, where an event (properly an ""event instance"") is the data representation of an occurrence in the real world domain that is of interest to the system.""
  - ""The use of CSP as the means of combining the mixin components of an object guarantees that the composite has Observational Conformance (a term coined by Ebert and Engels in (Ebert and Engels, 1994b)) with the components contributing to it8""
  - ""the use of CSP composition enables local reasoning at a behavior level, on the following grounds (this argument is sketched only).""
  - ""The language described here has proved valuable in the early stages of development, where the focus is on behavioral requirements.""",,"- The paper explicitly mentions the use of ""process algebraic techniques"" as the basis for the mathematical framework, specifically referencing CCS and CSP.
 - The framework is centered around the concept of Protocol Machines, which are defined in terms of their ability to accept, refuse, or ignore events based on their state.
 - The composition of Protocol Machines is guaranteed to result in another Protocol Machine, which is a key property of the framework.
 - The use of CSP ensures Observational Conformance, which is a specific mathematical property guaranteed by the framework.
 - The framework enables local reasoning at a behavioral level, which is a proof technique used to analyze the behavior of composed systems.
 - The paper does not explicitly discuss limitations or constraints of the framework, nor does it delve into specific proof methodologies or formal verification discussions beyond the use of CSP.","- ""Our claim is this results in a high level executable language that bridges the gap between behavioral models and code for a large class of systems.""
  - ""The language is based on the idea of composing partial behavioral descriptions using process algebraic techniques.""
  - ""The Protocol Modeling paradigm described in this paper has its origins in the JSD, but we have both moved away from the particular notations used in JSD towards a more abstract formulation, and strengthened the semantic basis of the ideas, to the point where direct execution can (and has) been sup-ported.""
  - ""The Process Algebras (CCS, CSP, etc.) all deal with abstract processes (or machines) that offer their environment the ability to accept some events and refuse or ignore others, based on their ""state"".""
  - ""we define a Protocol Machine as a machine that has a specified protocol whereby it will accept, refuse or ignore any event that is presented to it; and observe that the above definition means that the composition of two Protocol Machines is another Protocol Machine.""
  - ""A Protocol Model is a model built from Protocol Machines. Such models are event driven and deterministic, and the language we use to build them belongs to the class of languages termed synchronous reactive""
  - ""the use of CSP composition enables local reasoning at a behavior level,""",,"- The paper discusses the integration of behavioral models and code through the creation of a high-level executable language, which suggests a paradigm integration approach.
 - The use of process algebraic techniques, specifically CCS and CSP, indicates a mechanism for integrating different programming paradigms by composing partial behavioral descriptions.
 - The concept of Protocol Machines and their composition using CSP rules provides an interaction model between paradigms, ensuring that the composite machine behaves predictably.
 - The paper mentions the challenge of combinatorial state-space explosion, which is addressed by describing complex behavior as a composition of separate machines.
 - The use of CSP composition enables local reasoning, which is a novel approach to understanding the behavior of complex systems.
 - The paper does not explicitly mention novel translation or embedding techniques but focuses on the integration through process algebraic techniques and CSP composition.","- ""The language described here has proved valuable in the early stages of development, where the focus is on behavioral requirements.""
  - ""The use of these abstraction mechanisms has no affect on the semantics of machine composition, and is therefore orthogonal to the ability to perform local reasoning about behavior.""
  - ""Protocol Modeling enables abstraction in models, in the sense that one machine can contain constructs that represent a set of similar constructs in another machine, with the differences that distinguish the individuals of the set abstracted away.""
  - ""Our aim is to model systems that comprise a population of objects, which are separately instantiated and which each have their own, unique, identity -in other words, an Object Model.""
  - ""The Protocol Modeling paradigm described in this paper has its origins in the JSD, but we have both moved away from the particular notations used in JSD towards a more abstract formulation, and strengthened the semantic basis of the ideas, to the point where direct execution can (and has) been sup-ported.""",,"- The paper discusses the evolution of the Protocol Modeling paradigm from Jackson System Development (JSD), indicating a move towards more abstract formulations. This suggests an emphasis on abstraction.
 - The focus on modeling systems with unique object identities implies a level of abstraction in representing complex systems.
 - The paper explicitly mentions that Protocol Modeling enables abstraction by allowing one machine to represent similar constructs in another, abstracting away differences. This is a mechanism for representing generic abstractions.
 - The abstraction mechanisms are orthogonal to machine composition semantics, indicating that they do not interfere with the composition process.
 - The paper does not explicitly discuss generic programming methodology, type systems, or static checking strategies, suggesting that these aspects are not extensively addressed.","- ""Our claim is this results in a high level executable language that bridges the gap between behavioral models and code for a large class of systems.""
  - ""The language is based on the idea of composing partial behavioral descriptions using process algebraic techniques.""
  - ""the concepts forming the basis of this language shed light on questions relating to the description of behavior in object models, particularly in the areas of reuse, abstraction, and behavioral conformance.""
  - ""the use of a derived quantity as the state of behavioral machine (as we do in the right hand form of Figure 2 ) is, as far as we know, unique to our approach.""
  - ""Describing complex behavior as a composition of separate machines, some with stored and some with derived states, helps to ensure that descriptions remain as simple as possible, and to avoid the problem of combinatorial state-space explosion that results from representing complex behavior in a single diagram.""
  - ""Protocol Modeling enables abstraction in models, in the sense that one machine can contain constructs that represent a set of similar constructs in another machine, with the differences that distinguish the individuals of the set abstracted away.""
  - ""Protocol Modeling is the only behavioral modeling approach that guarantees a degree of behavioral conformance by virtue of its semantics,""
  - ""the use of CSP composition enables local reasoning at a behavior level,""
  - ""Building behavioral intelligence into objects in this way means that business processes become emergent properties of the combined behavior of the participating objects, rather than being defined as process flow models using languages such as BPEL.""",,"- The paper introduces a novel programming paradigm based on event protocols of objects, which bridges the gap between behavioral models and executable code. This is a key theoretical contribution as it addresses a significant challenge in software development.
 - The use of process algebraic techniques to compose partial behavioral descriptions is a unique approach that simplifies complex behavior descriptions and avoids state-space explosion.
 - The paper highlights the use of derived quantities as states in behavioral machines, which is a novel insight not found in other approaches.
 - The Protocol Modeling approach enables abstraction by representing similar constructs in a simplified manner, which is essential for achieving economy and simplicity in expression.
 - The use of CSP composition ensures observational conformance, which is a theoretical advancement beyond existing approaches that often require complex formation rules to achieve conformance.
 - The paper demonstrates how local reasoning at a behavior level is enabled through CSP composition, which is a significant theoretical contribution for compositional software development.
 - The concept of building behavioral intelligence into objects so that business processes emerge from their combined behavior is a novel theoretical contribution that contrasts with traditional process flow modeling."
"Actors , Objects , Contextures , Morphograms Readings and Reflections about Hierarchy and Heterarchy in Programming Paradigms 1 Actors","R. Kaehr, Juli",-,-,-,0,2007,"1. Primitive Name: Algebra
  Definition: Construction
  Orthogonality Score: Not discussed
 2. Primitive Name: Coalgebra
  Definition: Observation
  Orthogonality Score: Not discussed
 3. Primitive Name: Interacting-Components
  Definition: Signal-response interaction
  Orthogonality Score: Not discussed","- Type of mathematical framework: Category theory (algebras and coalgebras)
 - Specific mathematical properties guaranteed: Minimal and maximal solutions (fixed points) of recursive type equations
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The distinction between algebra and coalgebra as a fundamental concept in computer science; the signal-response interaction type in interacting-components MOCs.
 - Theoretical advancements: A modern, mathematical precise way to express the difference between algebras and coalgebras; understanding different models of computation and their connection to object abstraction.
 - Potential implications for programming language design: Theoretical framework for understanding programming paradigms, particularly the role of object-oriented programming in creating homogeneous systems.","- ""data types on the other hand'' [CoAlg, 4]: ``Whereas abstract data types in the initial approach may be formalized as minimal soulutions (fixed points) of recursive type equations, object types may be understood as maximal solutions (fixed points) of recursive type equations'' [CoAlg, 2].""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""The basic dichotomy may be described as construction versus observation'' [ TCACI, 4].""
  - ""The initial algebras and terminal coalgebras ... can be described in a canonical way: an initial algebra can be obtained from the closed terms (i.e. from those terms which are generated by iteratively applying the algebra's constructor operations), and the terminal coalgebra can be obtained from the pure observations'' [TCACI, 3].""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Message-passing Models, Client/Server Models or Object Models [MCOM, Quib 99-104] are closely connected with the object abstraction:""",,"- The abstract discusses the distinction between algebra and coalgebra, which are fundamental concepts in computer science. These are presented as a dichotomy between construction and observation, which could be considered as conceptual primitives.
 - The abstract mentions ""initial algebras"" and ""terminal coalgebras,"" which are specific mathematical constructs that could be seen as primitives in the context of programming paradigms.
 - The concept of ""interacting-components"" and ""signal-response"" interaction is also highlighted, which could be considered as a primitive in the context of computation models.
 - The abstract does not explicitly list these as ""conceptual primitives,"" but they are central to the discussion of programming paradigms and could be inferred as such.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines. A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""The initial algebras and terminal coalgebras ... can be described in a canonical way: an initial algebra can be obtained from the closed terms (i.e. from those terms which are generated by iteratively applying the algebra's constructor operations), and the terminal coalgebra can be obtained from the pure observations''""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Whereas abstract data types in the initial approach may be formalized as minimal soulutions (fixed points) of recursive type equations, object types may be understood as maximal solutions (fixed points) of recursive type equations''""",,"- The abstract discusses the use of algebras and coalgebras as a mathematical framework to formalize data types and object types. This suggests that the mathematical framework is based on category theory, as algebras and coalgebras are central concepts in this field.
 - The mention of ""minimal soulutions (fixed points) of recursive type equations"" and ""maximal solutions (fixed points) of recursive type equations"" indicates specific mathematical properties related to type theory and recursion.
 - The description of initial algebras and terminal coalgebras being obtained from closed terms and pure observations, respectively, implies a focus on formal verification and proof techniques related to these structures.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it detail specific proof techniques beyond the general use of algebras and coalgebras.","- ""The basic dichotomy may be described as construction versus observation''""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a fundamental aspect of programming paradigms, indicating a focus on theoretical integration strategies.
 - The mention of ""construction versus observation"" suggests a conceptual framework for understanding how different paradigms might interact.
 - The description of ""Interacting-Components MOCs"" and ""signal-response"" interaction implies a model for interaction between different components or paradigms.
 - The reference to ""different styles of interaction and computing units"" leading to different models suggests a variety of interaction models between paradigms.
 - The discussion of object-oriented programming and its homogeneous structure indicates a specific integration mechanism where objects can operate on themselves, potentially integrating different paradigms.
 - However, the abstract does not explicitly mention specific integration mechanisms, constraints, or novel translation techniques beyond these conceptual frameworks.","- ""data types on the other hand'' [CoAlg, 4]: ``Whereas abstract data types in the initial approach may be formalized as minimal soulutions (fixed points) of recursive type equations, object types may be understood as maximal solutions (fixed points) of recursive type equations'' [CoAlg, 2].""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""The initial algebras and terminal coalgebras ... can be described in a canonical way: an initial algebra can be obtained from the closed terms (i.e. from those terms which are generated by iteratively applying the algebra's constructor operations), and the terminal coalgebra can be obtained from the pure observations'' [TCACI, 3].""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a""
  - ""type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Message-passing Models, Client/Server Models or Object Models [MCOM, Quib 99-104] are closely connected with the object abstraction: «In all other languages we've considered [Fortran, Algol60, Lisp, APL, Cobol, Pascal], a program consists of passive data-objects on the one hand and the executable program that manipulates these passive objects on the other.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.» [PLing, 249]""
  - ""Inappropriate for arithmetics: «For most people, it is natural to think of arithmetic in terms of expressions that state""
  - ""It is less natural to think of arithmetic as being performed by one number ... upon the rest.""",,"- The abstract discusses the distinction between algebra and coalgebra, which is relevant to understanding data types and object types. This suggests a focus on conceptual abstraction mechanisms.
 - The mention of ""minimal soulutions (fixed points) of recursive type equations"" and ""maximal solutions (fixed points) of recursive type equations"" indicates a discussion on type systems and possibly minimal type requirements.
 - The abstract describes interacting-components architecture and object-oriented programming, which are mechanisms for representing generic abstractions.
 - The discussion on object-oriented programming replacing a bipartite structure with a homogeneous one suggests a mechanism for abstraction.
 - However, there is no explicit mention of generic programming methodology, static checking, or optimization strategies in the abstract.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""The basic dichotomy may be described as construction versus observation''""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a fundamental theoretical contribution in understanding programming paradigms. This distinction is highlighted as a pervasive concept in computer science, indicating a novel insight into the theoretical underpinnings of programming.
 - The abstract provides a modern, mathematical way to express the difference between algebras and coalgebras, which is a theoretical advancement beyond existing approaches. This mathematical precision is a significant contribution to the field.
 - The description of interacting-components MOCs and their signal-response interaction type introduces a new perspective on computation, which is a key novel insight. This perspective suggests a theoretical innovation in how computation is conceptualized.
 - The discussion of different models of computation (e.g., message-passing, client/server, object models) and their connection to object abstraction indicates a theoretical advancement in understanding programming paradigms. This is particularly relevant for programming language design, as it highlights the importance of object-oriented programming in creating homogeneous systems.
 - The abstract's focus on the theoretical aspects of programming paradigms, such as the dichotomy between construction and observation, suggests potential implications for programming language design. This theoretical framework could influence the development of new programming languages or the refinement of existing ones."
Category-based Semantics for Equational and Constraint Logic Programming,R. Diaconescu,-,-,-,34,1994,Not specified (the abstract does not explicitly define conceptual primitives or their orthogonality),"- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Completeness under quantifier projectivity, Herbrand Theorem for constraint logics
 - Proof techniques used: Semantic treatment regarding quantifiers as models and valuations as model morphisms
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Constraint logics are integrated as a particular case of category-based equational logic.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Extension of equational logic programming to non-conventional structures.","- Definition of ""concept"" used: Not explicitly mentioned
 - Mechanisms for representing generic abstractions: Category-based equational logic
 - Minimal type requirements identified: Not explicitly mentioned
 - Static checking or optimization strategies: Not explicitly mentioned","- Novel framework: Category-based equational logic generalizing equational deduction to arbitrary categories.
 - Theoretical advancements: Proving completeness under quantifier projectivity; treating quantifiers as models and valuations as model morphisms.
 - Integration of constraint logic programming as a particular case of category-based equational logic.
 - Mathematical foundations for modularization in equational logic programming.
 - Extension of the equational logic programming paradigm to non-conventional structures.
 - Potential implications: Unified theoretical foundation for various equational logical systems; broader applicability in programming language design.","- ""This thesis proposes a general framework for equational logic programming, called categorybased equational logic by placing the general principles underlying the design of the programming language Eqlog and formulated by Goguen and Meseguer into an abstract form.""
  - ""Category-based equational logic in conjunction with the theory of institutions is used to give mathematical foundations for modularisation in equational logic programming.""
  - ""Constraint logic programming is integrated into the equational logic programming paradigm by showing that constraint logics are a particular case of category-based equational logic.""
  - ""The mathematical foundations of constraint logic programming are based on a Herbrand Theorem for constraint logics; this is obtained as an instance of a more general category-based version of Herbrand's Theorem.""",,"- The abstract discusses a ""general framework for equational logic programming"" called ""category-based equational logic,"" which suggests a conceptual primitive related to categorization.
 - The framework involves ""equational deduction to an arbitrary category satisfying certain natural conditions,"" indicating a primitive related to categorization and deduction.
 - The abstract mentions ""quantifiers as models rather than variables"" and ""valuations as model morphisms rather than functions,"" which could be considered as conceptual primitives in terms of how quantifiers and valuations are treated.
 - The integration of ""constraint logic programming"" into the framework suggests that constraint logics are a conceptual primitive within this context.
 - The abstract does not provide explicit names or definitions for these primitives, nor does it discuss their orthogonality.","- ""Category-based equational logic in conjunction with the theory of institutions is used to give mathematical foundations for modularisation in equational logic programming.""
  - ""The mathematical foundations of constraint logic programming are based on a Herbrand Theorem for constraint logics; this is obtained as an instance of a more general category-based version of Herbrand's Theorem.""
  - ""This thesis proposes a general framework for equational logic programming, called categorybased equational logic by placing the general principles underlying the design of the programming language Eqlog and formulated by Goguen and Meseguer into an abstract form.""",,"- The abstract mentions a ""category-based equational logic"" framework, indicating that category theory is the type of mathematical framework used.
 - The framework generalizes equational deduction to arbitrary categories with certain conditions, suggesting that it provides a broad applicability.
 - Completeness is proven under the hypothesis of quantifier projectivity, which is a specific mathematical property guaranteed by the framework.
 - The framework uses a semantic treatment that views quantifiers as models and valuations as model morphisms, which is a proof technique used within this framework.
 - The framework is used in conjunction with the theory of institutions to provide mathematical foundations for modularization, indicating its application in formal verification.
 - The abstract also mentions a Herbrand Theorem for constraint logics, which is an instance of a more general category-based version, suggesting another mathematical property guaranteed by the framework.
 - There is no explicit mention of limitations or constraints of the framework in the abstract.","- ""Constraint logic programming is integrated into the equational logic programming paradigm by showing that constraint logics are a particular case of category-based equational logic.""
  - ""The results in this thesis apply to equational and constraint logic programming languages that are based on a variety of equational logical systems including many and order sorted equational logics, Horn clause logic, equational logic modulo a theory, constraint logics, and more, as well as any possible combination between them.""
  - ""Category-based equational logic in conjunction with the theory of institutions is used to give mathematical foundations for modularisation in equational logic programming.""
  - ""This thesis proposes a general framework for equational logic programming, called categorybased equational logic by placing the general principles underlying the design of the programming language Eqlog and formulated by Goguen and Meseguer into an abstract form.""",,"- The abstract discusses the integration of constraint logic programming into the equational logic programming paradigm, indicating a specific integration mechanism where constraint logics are treated as a particular case of category-based equational logic.
 - The use of category-based equational logic and the theory of institutions provides a theoretical integration strategy for modularization in equational logic programming.
 - The abstract mentions the application of the framework to various equational logical systems, suggesting a broad integration approach that encompasses multiple paradigms.
 - The extension of the equational logic programming paradigm to non-conventional structures implies a novel translation or embedding technique, allowing for broader applicability.
 - There is no explicit mention of interaction models or specific constraints or challenges in paradigm integration, but the abstract does highlight the integration of different paradigms through a category-based approach.","- ""Category-based equational logic in conjunction with the theory of institutions is used to give mathematical foundations for modularisation in equational logic programming.""
  - ""This thesis proposes a general framework for equational logic programming, called categorybased equational logic by placing the general principles underlying the design of the programming language Eqlog and formulated by Goguen and Meseguer into an abstract form.""
  - ""The results in this thesis apply to equational and constraint logic programming languages that are based on a variety of equational logical systems including many and order sorted equational logics, Horn clause logic, equational logic modulo a theory, constraint logics, and more, as well as any possible combination between them.""",,"- The abstract discusses a ""general framework for equational logic programming"" and a ""category-based equational logic,"" which suggests a focus on abstraction and genericity by generalizing equational deduction to arbitrary categories.
 - The use of ""category-based equational logic"" implies a mechanism for representing generic abstractions, as it allows for the application of equational logic to various logical systems.
 - The mention of ""modularisation in equational logic programming"" suggests a mechanism for abstraction, as modularization is a way to abstract and organize code.
 - The abstract does not explicitly mention ""minimal type requirements"" or ""static checking or optimization strategies,"" but the focus on generalizing equational logic to arbitrary categories implies a level of abstraction that could involve type considerations.
 - The abstract does not provide a specific definition of ""concept"" used in the study, nor does it explicitly discuss static checking or optimization strategies.","- ""This thesis proposes a general framework for equational logic programming, called categorybased equational logic by placing the general principles underlying the design of the programming language Eqlog and formulated by Goguen and Meseguer into an abstract form.""
  - ""Category-based equational logic in conjunction with the theory of institutions is used to give mathematical foundations for modularisation in equational logic programming.""
  - ""We study the soundness and completeness problem for module imports in the context of a category-based semantics for solutions to equational logic programming queries.""
  - ""Constraint logic programming is integrated into the equational logic programming paradigm by showing that constraint logics are a particular case of category-based equational logic.""
  - ""The mathematical foundations of constraint logic programming are based on a Herbrand Theorem for constraint logics; this is obtained as an instance of a more general category-based version of Herbrand's Theorem.""
  - ""The results in this thesis apply to equational and constraint logic programming languages that are based on a variety of equational logical systems including many and order sorted equational logics, Horn clause logic, equational logic modulo a theory, constraint logics, and more, as well as any possible combination between them.""",,"- The abstract introduces a novel framework called ""category-based equational logic,"" which generalizes equational deduction to arbitrary categories. This is a key theoretical contribution as it provides a more abstract and flexible approach to equational logic programming.
 - The framework is theoretically advanced by proving completeness under certain conditions and by treating quantifiers and valuations in a new way, which is a significant theoretical innovation.
 - The integration of constraint logic programming into this framework by showing it as a particular case of category-based equational logic is another novel insight, as it unifies different programming paradigms under a single theoretical umbrella.
 - The use of category-based equational logic to provide mathematical foundations for modularization in equational logic programming is a theoretical advancement, as it addresses the soundness and completeness of module imports.
 - The extension of the equational logic programming paradigm to non-conventional structures is a significant theoretical contribution, as it opens up possibilities for applying these principles in new and broader contexts.
 - The abstract mentions the application of these results to various equational logical systems, indicating a broad potential impact on programming language design by providing a unified theoretical foundation."
Concatenative Programming - An Overlooked Paradigm in Functional Programming,"D. Herzberg, T. Reichert",10.5220/0002281402570262,https://doi.org/10.5220/0002281402570262,International Conference on Software and Data Technologies,10,2009,Not specified (the abstract does not provide explicit definitions or detailed descriptions of specific conceptual primitives beyond the mention of Concat),Not specified (the abstract does not provide details on the mathematical framework used to formalize and guarantee properties of the conceptual primitives),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of concatenative programming as a valuable paradigm in software engineering research.
 - Theoretical advancements: Formal introduction of Concat, a purely functional concatenative language.
 - Potential implications: Offers a fresh perspective on functional programming, potentially helping to tackle challenges in LDSD/LOP.","- ""The simplicity of Concat is contrasted by its expressiveness and a richness of inspiring approaches.""
  - ""Based on the state of our ongoing research into Language-Driven Software Development (LDSD) and Language-Oriented Programming (LOP) we argue that the yet relatively unknown paradigm of concatena-tive programming is valuable for fundamental software engineering research and might prove to be a suitable foundation for future programming.""
  - ""To be sound, we formally introduce Concat, our research prototype of a purely functional concatenative language.""
  - ""Concatenative languages contribute a fresh and different sight on functional programming, which might help tackle challenges in LDSD/LOP from a new viewpoint.""",,"- The abstract discusses the introduction of a new paradigm called ""concatenative programming"" and its potential value in software engineering research.
 - It mentions the formal introduction of ""Concat,"" a research prototype of a purely functional concatenative language, which suggests that Concat is a key conceptual primitive in this context.
 - The abstract highlights the simplicity and expressiveness of Concat, indicating that these are important characteristics of the primitive.
 - However, the abstract does not provide explicit definitions or detailed descriptions of specific conceptual primitives beyond the mention of Concat and its characteristics.
 - There is no mention of multiple sets of primitives or any discussion of orthogonality.","- ""The simplicity of Concat is contrasted by its expressiveness and a richness of inspiring approaches.""
  - ""To be sound, we formally introduce Concat, our research prototype of a purely functional concatenative language.""",,"- The abstract mentions the formal introduction of Concat, a purely functional concatenative language, which suggests some level of formalization.
 - However, there is no explicit mention of a specific mathematical framework such as type theory or category theory.
 - There is no discussion of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The abstract does not provide details on the theoretical foundations, proof methodology, or formal verification discussions related to the mathematical framework.","- ""Concatenative languages contribute a fresh and different sight on functional programming, which might help tackle challenges in LDSD/LOP from a new viewpoint.""
  - ""the yet relatively unknown paradigm of concatena-tive programming is valuable for fundamental software engineering research and might prove to be a suitable foundation for future programming.""",,"- The abstract discusses the potential value of concatenative programming as a paradigm, but it does not explicitly mention any specific integration mechanisms or interaction models between different programming paradigms.
 - There is no mention of constraints or challenges in integrating paradigms, nor are there any novel translation or embedding techniques described.
 - The abstract focuses on the potential of concatenative programming as a foundation for future programming and its contribution to a new viewpoint in functional programming, but it does not provide details on how it integrates with other paradigms.","- ""Based on the state of our ongoing research into Language-Driven Software Development (LDSD) and Language-Oriented Programming (LOP)""
  - ""Concatenative languages contribute a fresh and different sight on functional programming, which might help tackle challenges in LDSD/LOP from a new viewpoint.""
  - ""the yet relatively unknown paradigm of concatena-tive programming is valuable for fundamental software engineering research and might prove to be a suitable foundation for future programming.""
  - ""The simplicity of Concat is contrasted by its expressiveness and a richness of inspiring approaches.""
  - ""To be sound, we formally introduce Concat, our research prototype of a purely functional concatenative language.""",,"- The abstract discusses the introduction of a new paradigm in functional programming, specifically concatenative programming, and its potential value in software engineering research.
 - It mentions the formal introduction of a research prototype called Concat, which is a purely functional concatenative language.
 - The abstract highlights the simplicity and expressiveness of Concat, suggesting it offers new approaches to functional programming.
 - However, there is no specific mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract.
 - The focus is on the introduction of a new paradigm and its potential applications rather than on genericity and abstraction mechanisms.","- ""we argue that the yet relatively unknown paradigm of concatena-tive programming is valuable for fundamental software engineering research and might prove to be a suitable foundation for future programming.""
  - ""Concatenative languages contribute a fresh and different sight on functional programming, which might help tackle challenges in LDSD/LOP from a new viewpoint.""
  - ""we formally introduce Concat, our research prototype of a purely functional concatenative language.""",,"- The abstract introduces the concept of concatenative programming as a novel paradigm in functional programming, which is a key novel insight. This suggests that the study highlights the potential of concatenative programming as a valuable approach in software engineering research.
 - The formal introduction of Concat, a purely functional concatenative language, represents a theoretical advancement. This prototype language is likely to provide a new framework for understanding and applying concatenative programming principles.
 - The mention of concatenative languages offering a ""fresh and different sight on functional programming"" implies that they could provide new perspectives and solutions to challenges in Language-Driven Software Development (LDSD) and Language-Oriented Programming (LOP). This suggests potential implications for programming language design by offering alternative approaches to tackle existing challenges.
 - The abstract does not provide specific implementation details but focuses on the theoretical contributions and potential implications of concatenative programming, aligning with the request to focus on theoretical innovations."
A Mathematical Model of Dialog,"Mark W. Johnson, P. McBurney, S. Parsons",10.1016/j.entcs.2005.05.015,https://doi.org/10.1016/j.entcs.2005.05.015,FInCo@ETAPS,33,2005,Not specified (the abstract does not provide explicit names or definitions for the conceptual primitives),"- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The study proposes the first mathematical theory that accounts for the semantics of agent interaction.
 - Theoretical advancements beyond existing approaches: The framework incorporates category-theoretic entities for utterances and commitments, with maps between these, addressing a gap in current research.
 - Potential implications for programming language design: The development of a mathematical theory for agent interaction could influence future language and protocol design.","- ""Our framework incorporates category-theoretic entities for the utterances made in an agent dialog and for the commitments incurred by those utterances, together with maps between these.""",,"- The abstract mentions the use of ""category-theoretic entities"" for ""utterances made in an agent dialog"" and ""commitments incurred by those utterances."" These are likely the conceptual primitives defined in the study.
 - The abstract does not provide explicit names or definitions for these primitives, nor does it discuss their orthogonality.
 - The mention of ""maps between these"" suggests a structural relationship between the primitives, but again, no specific details are provided in the abstract.","- ""We argue that such a theory needs to account for the semantics of agent interaction, and propose the first mathematical theory which does this.""
  - ""Our framework incorporates category-theoretic entities for the utterances made in an agent dialog and for the commitments incurred by those utterances, together with maps between these.""",,"- The abstract mentions that the authors propose a ""mathematical theory"" to account for the semantics of agent interaction, indicating that a mathematical framework is indeed presented.
 - The type of mathematical framework used is explicitly stated as ""category-theoretic entities,"" which suggests that category theory is the foundation of their framework.
 - The abstract does not provide specific details about the mathematical properties guaranteed by the framework, nor does it mention any proof techniques or limitations/constraints of the framework.
 - The focus is on the incorporation of category-theoretic entities for utterances and commitments, but no further details are provided about the theoretical foundations, proof methodology, or formal verification discussions.","- ""Despite this effort, no formal mathematical theory of agent interaction languages and protocols yet exists.""
  - ""Our framework incorporates category-theoretic entities for the utterances made in an agent dialog and for the commitments incurred by those utterances, together with maps between these.""
  - ""We argue that such a theory needs to account for the semantics of agent interaction, and propose the first mathematical theory which does this.""
  - ""Evidence of this shift is the significant effort devoted recently to the design and implementation of languages and protocols for communications and interaction between software agents.""
  - ""Computer Science is currently undergoing a paradigm shift, from viewing computer systems as isolated programs to viewing them as dynamic multi-agent societies.""",,"- The abstract discusses a paradigm shift in computer science towards viewing systems as dynamic multi-agent societies, which implies a change in how programming paradigms are integrated.
 - It mentions the design and implementation of languages and protocols for agent interaction, suggesting an integration of different programming paradigms through communication and interaction protocols.
 - The abstract proposes a mathematical theory to account for the semantics of agent interaction, which could be seen as a theoretical integration strategy.
 - The framework uses category-theoretic entities and maps, which might be novel translation or embedding techniques for integrating different paradigms.
 - However, the abstract does not explicitly describe specific integration mechanisms, interaction models between paradigms, or constraints/challenges in paradigm integration.","- ""Computer Science is currently undergoing a paradigm shift, from viewing computer systems as isolated programs to viewing them as dynamic multi-agent societies.""
  - ""Our framework incorporates category-theoretic entities for the utterances made in an agent dialog and for the commitments incurred by those utterances, together with maps between these.""
  - ""We argue that such a theory needs to account for the semantics of agent interaction, and propose the first mathematical theory which does this.""
  - ""no formal mathematical theory of agent interaction languages and protocols yet exists.""",,"- The abstract discusses a paradigm shift in computer science towards multi-agent societies, which implies a focus on interaction and communication rather than generic programming or abstraction mechanisms.
 - The mention of a ""mathematical theory"" and ""category-theoretic entities"" suggests a focus on theoretical foundations rather than specific programming methodologies or type systems.
 - There is no mention of generic programming, type systems, or abstraction mechanisms in the abstract, which are key components of genericity and abstraction.
 - The abstract does not provide any information on minimal type requirements, static checking, or optimization strategies related to generic programming.","- ""Our framework incorporates category-theoretic entities for the utterances made in an agent dialog and for the commitments incurred by those utterances, together with maps between these.""
  - ""We argue that such a theory needs to account for the semantics of agent interaction, and propose the first mathematical theory which does this.""
  - ""no formal mathematical theory of agent interaction languages and protocols yet exists.""
  - ""Computer Science is currently undergoing a paradigm shift, from viewing computer systems as isolated programs to viewing them as dynamic multi-agent societies.""",,"- The abstract mentions a paradigm shift in computer science towards viewing systems as dynamic multi-agent societies, indicating a broader context for the study.
 - It highlights the lack of a formal mathematical theory for agent interaction languages and protocols, which suggests a gap in current research that the study aims to address.
 - The study proposes the ""first mathematical theory"" that accounts for the semantics of agent interaction, which is a key novel insight and theoretical advancement.
 - The use of ""category-theoretic entities"" and ""maps between these"" indicates a unique theoretical approach to modeling agent dialog, which is a theoretical innovation.
 - The potential implications for programming language design are implied by the development of a mathematical theory for agent interaction, which could influence how languages and protocols are designed in the future."
Logical foundations of object-oriented and frame-based languages,"M. Kifer, G. Lausen, James Wu",10.1145/210332.210335,https://doi.org/10.1145/210332.210335,JACM,1866,1995,"1. Primitive Name: Object Identity
  Definition: A logical abstraction of the implementational concept of physical object identity.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Complex Objects
  Definition: Objects constructed out of simpler components.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Inheritance
  Definition: A mechanism for passing properties from one class to another.
  Orthogonality Score: Not specified
 

 4. Primitive Name: Polymorphic Types
  Definition: Methods can be invoked on different classes with arguments of different types.
  Orthogonality Score: Not specified
 

 5. Primitive Name: Query Methods
  Definition: Methods used to query data in F-logic.
  Orthogonality Score: Not specified
 

 6. Primitive Name: Encapsulation
  Definition: A policy of type-correctness that views encapsulation as an elaborate policy.
  Orthogonality Score: Not specified","- Type of mathematical framework: Model theory
 - Specific mathematical properties guaranteed: Soundness and completeness for the monotonic part
 - Proof techniques used: Resolution-based proof theory
 - Limitations or constraints of the framework: Non-monotonic extensions cannot have a complete proof theory",No specific integration approach described (the paper discusses the potential for multi-paradigm languages and the compatibility between relational and object-oriented languages but does not provide specific integration mechanisms or techniques),"- Definition of ""concept"" used: F-logic's higher-order syntax allows for exploring data and schema using the same declarative language.
 - Mechanisms for representing generic abstractions: Independence of scalar and set-valued methods; tool-kit-like structure for addressing different aspects separately.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Sound and complete resolution-based proof procedure implies some level of static checking.","- Introduction of F-logic as a novel formalism for object-oriented and frame-based languages.
 - Model-theoretic semantics and sound and complete resolution-based proof theory for F-logic.
 - Higher-order syntax allowing for data and schema exploration.
 - Adaptation of semantics for negation and introduction of canonic model semantics for F-programs with equality.
 - Relationship between F-logic and predicate calculus, with F-logic being more powerful.
 - Theorem 17.1 providing a mapping between F-logic and predicate calculus.","- ""These features include object identity, complex objects, inheritance, polymorphic types, query methods, encapsulation, and others.""
  - ""A small number of fundamental concepts that come from object-oriented programming have direct representation in F-logic; other, secondary aspects of this paradigm are easily modeled as well.""
  - ""We propose a novel formalism, called Frame Logic (abbr., F-logic), that accounts in a clean and declarative fashion for most of the structural aspects of object-oriented and frame-based languages.""
  - ""F-logic has a model-theoretic semantics and a sound and complete resolution-based proof theory.""",,"- The paper introduces Frame Logic (F-logic) as a formalism that captures structural aspects of object-oriented and frame-based languages.
 - The features listed include object identity, complex objects, inheritance, polymorphic types, query methods, and encapsulation, which are conceptual primitives in the context of F-logic.
 - These primitives are fundamental to the F-logic formalism and are used to reconstruct programming paradigms.
 - The paper does not explicitly mention the level of abstraction or orthogonality of these primitives, but they are presented as core components of the F-logic framework.","- ""The non-monotonic part of F-logic is based on the monotonic part, especially on its model theory.""
  - ""F-logic has a model-theoretic semantics and a sound and complete resolution-based proof theory.""
  - ""The proof of this theorem is almost identical to the standard proof for predicate calculus, and is omitted.""
  - ""The proof theory presented in Section 10 is sound and complete for the monotonic part, but the non-monotonic extensions cannot have a complete proof theory.""
  - ""Herbrand's theorem plays the same fundamental role.""",,"- The paper mentions that F-logic has a ""model-theoretic semantics,"" which indicates that the mathematical framework is based on model theory.
 - The use of ""resolution-based proof theory"" suggests that the proof techniques are similar to those used in classical logic, which is a common approach in model theory.
 - The reference to Herbrand's theorem further supports the use of model theory, as Herbrand's theorem is a fundamental result in classical logic that is often used in model-theoretic frameworks.
 - The paper notes that the proof theory is ""sound and complete"" for the monotonic part, which are typical properties guaranteed by model-theoretic frameworks.
 - The limitation mentioned is that the non-monotonic extensions cannot have a complete proof theory, which is a common constraint in many logical frameworks when dealing with non-monotonic reasoning.","- ""It will be clear from this paper that inside the deductive domain, relational and object-oriented languages go hand-in-hand.""
  - ""In general, we believe that the future belongs to multi-paradigm languages, and so the aforementioned impurity""""",,"- The paper discusses the integration of different programming paradigms, specifically mentioning the potential for multi-paradigm languages and the need for clean integration.
 - It highlights the compatibility between relational and object-oriented languages within the deductive domain, suggesting a harmonious interaction between these paradigms.
 - The paper addresses the misconception about the incompatibility of deductive and object-oriented languages by pointing out the orthogonal nature of their classification axes.
 - The introduction of upward-compatible object-oriented logics is mentioned as a way to bridge the perceived gap between deductive and object-oriented paradigms.
 - However, the paper does not provide specific integration mechanisms, interaction models, or novel translation techniques beyond the general discussion of compatibility and the orthogonal nature of paradigm classification.","- ""The syntax of F-logic is higher-order, which, among other things, allows the user to explore data and schema using the same declarative language.""
  - ""F-logic is capable of representing almost all aspects of what is known as the object-oriented paradigm.""
  - ""the semantics of scalar methods is independent from that of set-valued methods, and we can consider each t ype of methods as a separate tool.""
  - ""The non-monotonic part of F-logic is also composed of a collection of distinct ideas. One of them is the canonic model semantics for F-programs with equality, as discussed in Section 11 and in Appendix A.""
  - ""The non-monotonic part of F-logic is based on the monotonic part, especially on its model theory.""
  - ""The proof theory presented in Section 10 is sound and complete for the monotonic part, but the non-monotonic extensions cannot have a complete proof theory.""",,"- The paper discusses the higher-order syntax of F-logic, which allows for exploring data and schema using the same declarative language. This suggests a level of abstraction and genericity in representing complex structures.
 - F-logic is described as having a model-theoretic semantics and a sound and complete resolution-based proof procedure, indicating a strong foundation for generic programming.
 - The paper mentions the independence of scalar and set-valued methods, which can be considered as separate tools. This implies a mechanism for representing generic abstractions by treating different types of methods separately.
 - The tool-kit-like structure of F-logic is highlighted as beneficial for addressing different aspects of the logic separately, which aligns with principles of generic programming.
 - The non-monotonic part of F-logic includes canonic model semantics, which suggests a mechanism for handling generic abstractions in non-monotonic contexts.
 - The paper does not explicitly discuss minimal type requirements or static checking strategies, but the focus on sound and complete proof procedures implies some level of static checking.","- ""We propose a novel formalism, called Frame Logic (abbr., F-logic), that accounts in a clean and declarative fashion for most of the structural aspects of object-oriented and frame-based languages.""
  - ""F-logic has a model-theoretic semantics and a sound and complete resolution-based proof theory.""
  - ""In a sense, F-logic stands in the same relationship to the object-oriented paradigm as classical predicate calculus stands to relational programming.""
  - ""The syntax of F-logic is higher-order, which, among other things, allows the user to explore data and schema using the same declarative language.""
  - ""F-logic has a model-theoretic semantics and a sound and complete resolution-based proof procedure.""
  - ""This paper also discusses various aspects of programming in declarative object-oriented languages based on F-logic.""
  - ""The general principle in adapting the various semantics for negation such a s 8 1 , 39, 96, 95, 82, 4, 54 to F-logic is to use method names whenever predicates are used in the standard setting.""
  - ""The non-monotonic part of F-logic is also composed of a collection of distinct ideas. One of them is the canonic model semantics for F-programs with equality, as discussed in Section 11 and in Appendix A.""
  - ""the relationship between predicate calculus and F-logic. In one direction, predicate calculus is a subset of F-logic and so the latter is more powerful than the former.""
  - ""Theorem 17.1 There a r e mappings , : fF-formulasg 7 ,! fwell-formed formulas of predicate calculusg : fF-structuresg 7 ,! fsemantic structures of predicate calculusg such that M j = F if and only if M j = P C ,
 

 for any F-structure M and any F-formula ; here j = F "" and j = P C "" denote logical entailment in F-logic and predicate calculus, respectively.""",,"- The paper introduces F-logic as a novel formalism that provides a clean and declarative way to represent object-oriented and frame-based languages, which is a key theoretical contribution.
 - F-logic's model-theoretic semantics and sound and complete resolution-based proof theory are significant theoretical advancements, as they provide a rigorous foundation for the logic.
 - The higher-order syntax of F-logic allows for the exploration of data and schema using the same declarative language, which is a novel insight into how object-oriented concepts can be integrated into a logical framework.
 - The paper discusses the adaptation of semantics for negation and the introduction of canonic model semantics for F-programs with equality, which are theoretical advancements beyond existing approaches.
 - The relationship between F-logic and predicate calculus is explored, with F-logic being more powerful and capable of representing object-oriented concepts in a way that predicate calculus cannot.
 - Theorem 17.1 provides a mapping between F-logic and predicate calculus, showing that F-logic is equivalent to predicate calculus in certain respects, which is a significant theoretical contribution."
El Lenguaje CLP(H/E): Una Aproximación basada en Restricciones a la Integración de la Programación Lógica y Funcional,María Alpuente Frasnedo,-,-,-,0,1991,"1. Primitive Name: Equational Logic Program (P, E)
  Definition: A positive logic program P augmented by a Horn equational theory E.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Model Intersection Property
  Definition: The property that ensures the generation of a smallest equational congruence on the Herbrand universe.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: CLP Scheme
  Definition: A general framework for introducing constraints into logic programming.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Equality Predicate Symbol
  Definition: The only predicate symbol for constraints, interpreted as semantic equality.
  Orthogonality Score: Not discussed",Not specified (the abstract discusses logical and set-theoretic concepts but does not explicitly mention a specific mathematical framework or proof techniques),"- Specific integration mechanisms proposed: Considering an equational logic program as a positive logic program augmented by a Horn equational theory.
 - Interaction models between paradigms: Use of the CLP scheme to formalize integration between logic and equational programming.
 - Constraints or challenges in paradigm integration: General challenge of integrating logical and equational languages.
 - Novel translation or embedding techniques: Defining CLP(H/E) as an instance of the CLP(C) scheme to inherit semantic properties.","- Definition of ""concept"" used: Integration of logic and equational programming, use of constraints.
 - Mechanisms for representing generic abstractions: CLP scheme, instances like CLP(H/E).
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: Integration of logical and equational languages by considering an equational logic program as a positive logic program augmented by a Horn equational theory.
 - Theoretical advancements: Preservation of main semantic properties of traditional logic programs; introduction of CLP(H/E) as a new instance of the CLP scheme for integrating logic and equational programming.
 - Potential implications: Combination of logic programming with conditional equations and constraint programming, leading to more powerful and flexible programming paradigms.","- ""A relevant approach to address this problem is based on considering an equational logic program (P, E) as a positive logic program P that is augmented by a Horn equational theory E.""
  - ""the program (P, E) fulfills the well-known property of model intersection, and thus generates an smallest equational congruence on the Herbrand universe associated with the program.""
  - ""On the interpretation domain, that is, the quotient of the Herbrand universe module this congruence, the equational logic program admits a minimal model semantics and a fixpoint semantics as well.""
  - ""the main semantic properties of traditional logic programs are preserved in the more general, integrated, logic-equational programming paradigm.""
  - ""The CLP scheme ensures that the semantic properties of conventional logic programs are inherited by any language that can be formalized as an instance of the schema.""
  - ""The thesis defines an instance of the CLP scheme that is specialized in solving equations in an equational Horn theory E.""
  - ""The computer structure is given just by the smallest partition H/E induced by E on the Herbrand universe H for the program.""
  - ""The equality = is the only predicate symbol for constraints, that is interpreted as semantic equality in this domain.""
  - ""The proposed language, CLP (H/E), combines the logic programming paradigm with (conditional) equations and Constraint programming.""",,"- The abstract discusses the integration of logical and equational programming paradigms, focusing on the use of equational logic programs and Horn equational theories.
 - The concept of an equational logic program (P, E) is central, where P is a positive logic program augmented by a Horn equational theory E.
 - The program (P, E) is characterized by its fulfillment of the model intersection property, leading to a smallest equational congruence on the Herbrand universe.
 - The abstract mentions the preservation of traditional logic program semantic properties in the integrated paradigm.
 - The CLP scheme is highlighted as a framework for introducing constraints into logic programming, ensuring the inheritance of semantic properties.
 - The thesis defines an instance of the CLP scheme specialized in solving equations in an equational Horn theory E, with a computer structure based on the smallest partition H/E.
 - The equality predicate symbol is used for constraints, interpreted as semantic equality.
 - The proposed language, CLP (H/E), integrates logic programming with conditional equations and constraint programming.","- ""A relevant approach to address this problem is based on considering an equational logic program (P, E) as a positive logic program P that is augmented by a Horn equational theory E.""
  - ""the program (P, E) fulfills the well-known property of model intersection, and thus generates an smallest equational congruence on the Herbrand universe associated with the program.""
  - ""On the interpretation domain, that is, the quotient of the Herbrand universe module this congruence, the equational logic program admits a minimal model semantics and a fixpoint semantics as well.""
  - ""The CLP scheme ensures that the semantic properties of conventional logic programs are inherited by any language that can be formalized as an instance of the schema.""
  - ""The thesis defines an instance of the CLP scheme that is specialized in solving equations in an equational Horn theory E.""
  - ""The computer structure is given just by the smallest partition H/E induced by E on the Herbrand universe H for the program.""
  - ""The equality = is the only predicate symbol for constraints, that is interpreted as semantic equality in this domain.""",,"- The abstract discusses the integration of logical and equational languages using a framework based on equational logic programs and Horn equational theories. This suggests a mathematical framework rooted in logic and set theory.
 - The mention of ""model intersection"" and ""smallest equational congruence"" indicates the use of set-theoretic and algebraic properties to ensure semantic consistency.
 - The reference to ""minimal model semantics"" and ""fixpoint semantics"" suggests the use of model theory and fixed-point theory as part of the mathematical framework.
 - The CLP scheme is described as ensuring the inheritance of semantic properties, which implies a structured approach to formal verification.
 - The use of ""smallest partition H/E"" and ""semantic equality"" suggests a focus on equivalence relations and partitioning, which are concepts from set theory and algebra.
 - The abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it detail specific proof techniques or limitations.","- ""One of the most challenging problems in Computational Logic is the integration of two of the most popular families of declarative languages: logical languages and equational languages.""
  - ""A relevant approach to address this problem is based on considering an equational logic program (P, E) as a positive logic program P that is augmented by a Horn equational theory E.""
  - ""The main argument discussed in this thesis is that, in the context of CLP, it is possible to formalize the desired integration between logic programming and equational programming by a suitable treatment of the equality relation.""
  - ""The thesis defines an instance of the CLP scheme that is specialized in solving equations in an equational Horn theory E.""
  - ""The proposed language, CLP (H/E), combines the logic programming paradigm with (conditional) equations and Constraint programming.""
  - ""The advantage of this new integration approach is that, since the language is defined as an instance of the CLP(C) scheme, all the semantic properties mentioned above are automatically inherited within it.""",,"- The abstract discusses the integration of logical languages and equational languages, which are two different programming paradigms.
 - The integration mechanism proposed involves considering an equational logic program as a positive logic program augmented by a Horn equational theory. This suggests a way to combine these paradigms.
 - The interaction model involves the use of the CLP scheme, which is a general framework for introducing constraints in logic programming. This framework is used to formalize the integration between logic and equational programming.
 - The challenge in paradigm integration is addressed by defining an instance of the CLP scheme that specializes in solving equations in an equational Horn theory. This indicates a specific strategy for handling the integration.
 - The novel translation or embedding technique involves defining the language CLP(H/E) as an instance of the CLP(C) scheme, which allows for the automatic inheritance of semantic properties.
 - The abstract does not explicitly mention any constraints or challenges in the integration process beyond the general challenge of integrating these paradigms.","- ""The CLP scheme ensures that the semantic properties of conventional logic programs are inherited by any language that can be formalized as an instance of the schema.""
  - ""The proposed language, CLP (H/E), combines the logic programming paradigm with (conditional) equations and Constraint programming.""
  - ""The advantage of this new integration approach is that, since the language is defined as an instance of the CLP(C) scheme, all the semantic properties mentioned above are automatically inherited within it.""
  - ""The thesis defines an instance of the CLP scheme that is specialized in solving equations in an equational Horn theory E.""
  - ""A relevant approach to address this problem is based on considering an equational logic program (P, E) as a positive logic program P that is augmented by a Horn equational theory E.""",,"- The abstract discusses the integration of logical and equational languages, which involves a form of abstraction by combining different programming paradigms.
 - The CLP scheme is described as a ""general framework"" and a ""generic scheme for the introduction of constraints in logic programming,"" indicating a level of genericity in its design.
 - The definition of ""concept"" in this context seems to relate to the integration of logic and equational programming, as well as the use of constraints.
 - The mechanism for representing generic abstractions is the CLP scheme itself, which allows for the creation of instances like CLP(H/E) that specialize in solving equations.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does imply that the CLP scheme ensures the inheritance of semantic properties, which could relate to type requirements.
 - The abstract does not provide detailed information on static checking or optimization strategies, but it does mention the ease of incorporating an efficient procedure for solving constraints into a general CLP system.","- ""A relevant approach to address this problem is based on considering an equational logic program (P, E) as a positive logic program P that is augmented by a Horn equational theory E.""
  - ""The advantage of this approach is that, since the equational theory E is also a set of defined Horn clauses, the program (P, E) fulfills the well-known property of model intersection, and thus generates an smallest equational congruence on the Herbrand universe associated with the program.""
  - ""On the interpretation domain, that is, the quotient of the Herbrand universe module this congruence, the equational logic program admits a minimal model semantics and a fixpoint semantics as well.""
  - ""Thus, the main semantic properties of traditional logic programs are preserved in the more general, integrated, logic-equational programming paradigm.""
  - ""The main argument discussed in this thesis is that, in the context of CLP, it is possible to formalize the desired integration between logic programming and equational programming by a suitable treatment of the equality relation.""
  - ""The thesis defines an instance of the CLP scheme that is specialized in solving equations in an equational Horn theory E.""
  - ""The proposed language, CLP (H/E), combines the logic programming paradigm with (conditional) equations and Constraint programming.""
  - ""The advantage of this new integration approach is that, since the language is defined as an instance of the CLP(C) scheme, all the semantic properties mentioned above are automatically inherited within it.""",,"- The abstract discusses a novel approach to integrating logical and equational languages by considering an equational logic program as a positive logic program augmented by a Horn equational theory. This is a key theoretical contribution as it provides a framework for integrating these two programming paradigms.
 - The integration preserves the main semantic properties of traditional logic programs, such as minimal model semantics and fixpoint semantics, which is a significant theoretical advancement.
 - The thesis introduces a new instance of the CLP scheme, CLP(H/E), which is specialized in solving equations in an equational Horn theory. This is a novel theoretical contribution as it provides a framework for integrating logic programming with equational programming within the CLP context.
 - The abstract highlights that this integration approach automatically inherits semantic properties from the CLP scheme, which is a theoretical advancement beyond existing approaches.
 - The potential implications for programming language design include the ability to combine logic programming with conditional equations and constraint programming, which could lead to more powerful and flexible programming paradigms."
AKL - A Multiparadigm Programming Language,Sverker Janson,-,-,-,71,1994,Not specified (the abstract does not provide explicit definitions or details about the conceptual primitives),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Combining constraint solving and nondeterministic capabilities of Prolog with process-describing capabilities of concurrent logic languages like GHC.
 - Interaction models between paradigms: Constraints used to express data and interaction.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Rewriting of ""semi-logical"" expressions in the computation model.",Generic programming not extensively addressed,"- Key novel insights: The need for new basic principles to avoid complexity, integration of multiple programming paradigms into a single language.
 - Theoretical advancements: Combining constraint solving and concurrent logic capabilities, operational semantics using ""semi-logical"" expressions and constraints.
 - Potential implications: Simplified language design, unified framework for multiple paradigms, potential for automatic parallel execution.","- ""The operational semantics of AKL is captured by a computation model, involving rewriting of “semi-logical” expressions that form the computation states.""
  - ""This thesis reports on an investigation into principles for combining the constraint solving and don't know nondeterministic capabilities of Prolog and the constraint logic programming languages with the process-describing capabilities of concurrent logic languages such as GHC.""
  - ""The result, AKL, is a coherent language supporting multiple programming paradigms, such as concurrent, object-oriented, functional, logic, and constraint programming.""
  - ""The computation model is then augmented with control, giving an execution model, which demonstrates how to perform computations in a systematic manner.""
  - ""Constraints are used to express data and interaction.""",,"- The abstract discusses the combination of different programming paradigms and capabilities, such as constraint solving, nondeterminism, and process description, which suggests that these are conceptual primitives used in the study.
 - The mention of ""semi-logical"" expressions and constraints indicates that these are fundamental concepts in the AKL language, likely serving as primitives.
 - The abstract does not provide explicit definitions for these primitives, nor does it mention their orthogonality or level of abstraction.
 - The focus on combining different paradigms and capabilities implies that these are the conceptual primitives, but without explicit definitions or further details, it is challenging to provide a precise list.","- ""The computation model is then augmented with control, giving an execution model, which demonstrates how to perform computations in a systematic manner.""
  - ""The operational semantics of AKL is captured by a computation model, involving rewriting of “semi-logical” expressions that form the computation states.""
  - ""Constraints are used to express data and interaction.""",,"- The abstract mentions a ""computation model"" and ""rewriting of 'semi-logical' expressions,"" which suggests a formal approach to defining the language's operational semantics. However, it does not specify a particular mathematical framework such as type theory or category theory.
 - The use of ""constraints"" to express data and interaction implies some form of formalism, but again, no specific mathematical framework is named.
 - The abstract does not provide details on specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the operational semantics and execution model rather than a detailed mathematical framework.","- ""This thesis reports on an investigation into principles for combining the constraint solving and don't know nondeterministic capabilities of Prolog and the constraint logic programming languages with the process-describing capabilities of concurrent logic languages such as GHC.""
  - ""Constraints are used to express data and interaction.""
  - ""The operational semantics of AKL is captured by a computation model, involving rewriting of “semi-logical” expressions that form the computation states.""
  - ""The result, AKL, is a coherent language supporting multiple programming paradigms, such as concurrent, object-oriented, functional, logic, and constraint programming.""
  - ""The computation model is then augmented with control, giving an execution model, which demonstrates how to perform computations in a systematic manner.""",,"- The abstract discusses the integration of different programming paradigms by combining the capabilities of Prolog and concurrent logic languages like GHC. This suggests a specific integration mechanism where constraint solving and nondeterministic capabilities are merged with process-describing capabilities.
 - The mention of AKL supporting multiple paradigms indicates a theoretical integration strategy where these paradigms are integrated into a single coherent language.
 - The use of constraints to express data and interaction suggests an interaction model between paradigms, where constraints serve as a common language for data and interaction.
 - The operational semantics and computation model provide a systematic approach to integrating these paradigms, indicating a novel translation or embedding technique through the rewriting of ""semi-logical"" expressions.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it provide a comparative analysis of different integration strategies.","- ""The result, AKL, is a coherent language supporting multiple programming paradigms, such as concurrent, object-oriented, functional, logic, and constraint programming.""
  - ""The computation model is then augmented with control, giving an execution model, which demonstrates how to perform computations in a systematic manner.""
  - ""Constraints are used to express data and interaction.""
  - ""The operational semantics of AKL is captured by a computation model, involving rewriting of “semi-logical” expressions that form the computation states.""
  - ""New basic principles are necessary that support the desired functionality using a minimum of concepts.""",,"- The abstract mentions the need for ""new basic principles"" that use a ""minimum of concepts,"" which suggests an emphasis on simplicity and abstraction. However, it does not explicitly define what these concepts are or how they are used in terms of generic programming.
 - The language AKL supports multiple programming paradigms, which could imply a level of genericity in its design. However, the abstract does not provide specific details on how these paradigms are implemented or how they contribute to generic programming.
 - The use of ""constraints"" to express data and interaction could be related to abstraction mechanisms, but again, there is no explicit mention of how these constraints are used for generic programming.
 - The abstract does not mention any specific mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""New programming languages conceived by adding yet another permutation of new features on top of established languages offer only complexity and confusion to software developers.""
  - ""New basic principles are necessary that support the desired functionality using a minimum of concepts.""
  - ""This thesis reports on an investigation into principles for combining the constraint solving and don't know nondeterministic capabilities of Prolog and the constraint logic programming languages with the process-describing capabilities of concurrent logic languages such as GHC.""
  - ""The result, AKL, is a coherent language supporting multiple programming paradigms, such as concurrent, object-oriented, functional, logic, and constraint programming.""
  - ""The operational semantics of AKL is captured by a computation model, involving rewriting of “semi-logical” expressions that form the computation states.""
  - ""Constraints are used to express data and interaction.""
  - ""The computation model is then augmented with control, giving an execution model, which demonstrates how to perform computations in a systematic manner.""",,"- The abstract highlights the need for new basic principles in programming languages to avoid complexity and confusion, indicating a theoretical contribution towards simplifying language design.
 - The investigation into combining different programming paradigms (constraint solving, concurrent logic) suggests a novel approach to integrating multiple paradigms into a single language, AKL.
 - The development of AKL as a coherent language supporting multiple paradigms is a key theoretical contribution, as it addresses the complexity issue by providing a unified framework.
 - The operational semantics and computation model involving ""semi-logical"" expressions and constraints represent theoretical advancements in how programming languages can be designed to express data and interaction.
 - The abstract implies that AKL's design could have potential implications for future programming language design by offering a more streamlined and integrated approach to multiple paradigms."
A Graph-Based Formal Semantics of Reactive Programming from First Principles,"Bjarno Oeyen, Joeri De Koster, Wolfgang De Meuter",10.1145/3611096.3611101,https://doi.org/10.1145/3611096.3611101,FTfJP@ECOOP,0,2022,"1. Primitive Name: DEPLOY nodes
  Definition: Denote deployments of DAGs (i.e., holes in one graph that have to be filled in, at run-time, by another DAG).
 2. Primitive Name: RHO nodes
  Definition: Denote in-line DAG (reactor) definitions that have access to their lexical scope.
 3. Primitive Name: Reduction Rules (e.g., w-Ref, w-deploy, w-Rho, s-self-Ref, s-deploy-pRimitive, s-tuple-Ref, s-deploy-new)
  Definition: Define how the system behaves in terms of wiring and snapshot operations.
  Orthogonality Score: Not discussed",Not specified (the paper does not explicitly mention a specific mathematical framework or properties guaranteed by it),"- Specific integration mechanisms proposed: Integration of reactive code with imperative code; composition of reactive programs from smaller parts.
 - Interaction models between paradigms: Modular composition similar to function-based RP.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Higher-order deployments can model conditionals.",Generic programming not extensively addressed,"- Key novel insights: Karcharias provides an intuitive understanding of graph-based reactive programming and offers a clear formalization of how reactive programs operate over time.
 - Theoretical advancements: Formalization of reactive programming from first principles without relying on a base language, clear semantics for deployments, and potential for generalization to other graph-based reactive-like languages.
 - Potential implications for programming language design: Generalization of the formalization could impact the design of other graph-based reactive programming languages and frameworks.","- ""In this paper, we present Karcharias, a formalisation of reactive programming – a model that shares many core ideas found in the various aforementioned libraries and frameworks – that is built from first principles.""
  - ""Our formalisation of Haai, which we have named Karcharias, provides an intuitive understanding of graph-based RP.""
  - ""The smallstep semantics provide a clear formalisation of how RP programs operate over time (e.g., by recomputing the program with respect to some current values).""
  - ""The names , and , are special as they denote the input and output signals of reactors: the first index denotes the index of the source or sink signal (1-based indexing), and the second index denotes the scoping level (similar to De Bruijn Indices which were originally invented for -calculi [9]; using 0-based indexing) in case of nested reactor definitions (without nested reactor definitions or lexical scoping there is no need for the second index).""
  - ""There are two supported node types () in Karcharias. The aforementioned DEPLOY nodes denote deployments of DAGs (i.e. holes in one graph that have to be filled in, at run-time, by another DAG). RHO ⟨ ⟩ nodes denotes in-line DAG (reactor) definitions that have access to their lexical scope.""
  - ""Operations. Finally, we assume a set of primitives that are available to the operational semantics. Every primitive (denoted as a ), has a corresponding function . We assume that every is total (with respect to the values""
  - ""The reduction rules that perform wiring-level operations are presented in Figure 4""
  - ""The s-self-Ref rule replaces a S REF refering to a local name with the result of looking up that name in its own environment (only if it is a value, and not a yet-to-be-reduced signal).""
  - ""The s-deploy-pRimitive and s-tuple-Ref rules are used for the primitive operations.""
  - ""The s-deploy-new is the most important rule of our formalisation. Its purpose is to deploy: i.e. create a new W for a S DEP that is present in a signal.""",,"- The paper introduces Karcharias as a formalization of reactive programming built from first principles, indicating that it provides a foundational framework for understanding reactive programming.
 - The formalization includes a focus on graph-based program structure and value propagation, which are key conceptual primitives in the context of reactive programming.
 - The paper defines two node types in Karcharias: DEPLOY nodes and RHO nodes. These are conceptual primitives as they represent fundamental elements in the graph-based structure of reactive programs.
 - The paper mentions ""primitives"" in the context of operational semantics, which are functions associated with each primitive. These primitives are part of the formalization but are not explicitly listed or named in the text.
 - The reduction rules (e.g., w-Ref, w-deploy, w-Rho, s-self-Ref, s-deploy-pRimitive, s-tuple-Ref, s-deploy-new) are part of the formal semantics and can be considered as operational primitives that define how the system behaves.
 - The paper does not provide a specific list of conceptual primitives with precise definitions, but it discusses several key concepts and rules that are fundamental to the formalization of reactive programming.","- ""In this paper, we present Karcharias, a formalisation of reactive programming – a model that shares many core ideas found in the various aforementioned libraries and frameworks – that is built from first principles.""
  - ""Our formalisation of Haai, which we have named Karcharias, provides an intuitive understanding of graph-based RP.""
  - ""The smallstep semantics provide a clear formalisation of how RP programs operate over time (e.g., by recomputing the program with respect to some current values).""
  - ""the small-step operational intra-turn semantics. We make a distinction between two types of rules: wiring rules (or w-rules for short) that reconfigure the dependency graph and snapshot rules (or s-rules for short) that determine the values of the signals in a deployment during a given turn.""
  - ""The reduction rules that perform wiring-level operations are presented in Figure 4""
  - ""The inter-turn semantics describe how the values of the external source signals are supplied and consequently used by the intraturn semantics to reduce a configuration to one where all deployments ∈ have a corresponding S that whose signal environments contain only values.""
  - ""Our formalisation of graph-based RP provides a clear semantic for deployments: i.e. instantiated parts of (dependency) graphs.""",,"- The paper presents a formalization of reactive programming called Karcharias, which is built from first principles. This suggests a theoretical foundation but does not specify a particular mathematical framework like type theory or category theory.
 - The paper discusses the use of small-step operational semantics, which is a common approach in formal verification. However, it does not explicitly mention any specific mathematical framework or properties guaranteed by it.
 - The paper focuses on the operational semantics and reduction rules for wiring and snapshot operations, which are part of the formal verification process. However, it does not detail any specific mathematical properties or proof techniques used.
 - The paper does not mention any limitations or constraints of the framework, nor does it specify any particular mathematical framework or properties guaranteed by it.","- ""Research on graph-based RPLs has been focused on efficiency (e.g., Emfrp [30], REScala [11], and ReactiFi [33]), integrating reactive code with imperative code (e.g., FrTime [15], and Stella [10]) and making RP work for distributed applications (e.g., XFRP [32], and AmbientTalk/R [4]).""
  - ""Our formalisation of graph-based RP provides a clear semantic for deployments: i.e. instantiated parts of (dependency) graphs. Deployment nodes in the dependency graph, which can be filled in at run-time, make it possible for a developer to compose reactive programs out of smaller programs, similar to the composition of signal functions in function-based RP.""
  - ""An interesting future research avenue is to further compare the semantics of graph-based RP with the semantics (and implementations) of function-based RP: e.g., to establish whether or not they are computationally equivalent (i.e. can they implement the same RP programs).""
  - ""Finally, graph-based RPLs usually update their signals incrementally: only signals affected by an (external) change are usually recomputed. This is completely absent from our formalisation as at the start of each turn the next-tuRn rule throws away all Ss. However, incrementality is an optimisation and should not lead to semantic differences.""
  - ""Our work presented here does not formalise all possible aspects of an RPL. One noteworthy omission are conditional deployments created using if. We argue that semantics are already captured by the higher-order deployments. By ""delaying"" a graph using RHO ⟨ ⟩ and providing an eager , one can easily model conditionals (and thus, conditional deployments) using our current formalisation.""",,"- The paper discusses the integration of reactive code with imperative code, which is a form of paradigm integration. This is mentioned in the context of graph-based RPLs, indicating that these libraries and frameworks are designed to work with imperative code.
 - The paper highlights the composition of reactive programs from smaller parts, similar to function-based RP, suggesting a mechanism for integrating different programming paradigms through modular composition.
 - The paper does not explicitly describe a novel translation or embedding technique but suggests that higher-order deployments can model conditionals, which could be seen as a form of integration.
 - The paper does not provide specific constraints or challenges in paradigm integration but notes that incrementality is an optimization that does not affect semantic differences, implying that it is not a significant challenge in integration.
 - The paper does not provide a detailed theoretical integration strategy or comparative analysis of different paradigms beyond the mention of future research avenues.","- ""In this paper, we present Karcharias, a formalisation of reactive programming – a model that shares many core ideas found in the various aforementioned libraries and frameworks – that is built from first principles.""
  - ""Our formalisation of Haai, which we have named Karcharias, provides an intuitive understanding of graph-based RP.""
  - ""The smallstep semantics provide a clear formalisation of how RP programs operate over time (e.g., by recomputing the program with respect to some current values).""
  - ""By formalising reactive programs as graphs where nodes have values that change over time, it is easier to reason about the memory allocation and consumption behaviour of RP programs, compared to most formalisations of function-based RPLs [16][17][18] which often rely on recursion and various memory-intensive operations to model the time-varying nature of signals.""
  - ""Haai is a higher-order reactive language which allows dynamic reconfigurations of the dependency graph, without the need for any switching operators.""
  - ""Our work presented here does not formalise all possible aspects of an RPL. One noteworthy omission are conditional deployments created using if.""
  - ""Another noteworthy omission is the support for stateful comptuations (e.g., using operators like foldp [8] or using other state management mechanisms [26]).""
  - ""Finally, graph-based RPLs usually update their signals incrementally: only signals affected by an (external) change are usually recomputed.""",,"- The paper focuses on formalizing graph-based reactive programming, particularly through the Karcharias model, which is built from first principles. This suggests a focus on conceptual abstraction rather than generic programming.
 - The paper discusses the use of graphs to represent reactive programs, which is a form of abstraction mechanism. However, it does not explicitly address generic programming or type systems.
 - The mention of higher-order reactive language and dynamic reconfigurations indicates some level of abstraction, but it does not specify mechanisms for generic abstractions or minimal type requirements.
 - The paper does not discuss static checking or optimization strategies related to generic programming.
 - The omissions mentioned in the paper, such as conditional deployments and stateful computations, suggest that while abstraction is considered, generic programming is not a primary focus.","- ""In this paper, we present Karcharias, a formalisation of reactive programming – a model that shares many core ideas found in the various aforementioned libraries and frameworks – that is built from first principles.""
  - ""Instead of extending an existing language with a graph-based stream processing framework, and formalising this integrated language, we formalised the reactive programming paradigm without relying on a base language (such as the λ -calculus).""
  - ""Our formalisation of Haai, which we have named Karcharias, provides an intuitive understanding of graph-based RP.""
  - ""The smallstep semantics provide a clear formalisation of how RP programs operate over time (e.g., by recomputing the program with respect to some current values).""
  - ""By formalising reactive programs as graphs where nodes have values that change over time, it is easier to reason about the memory allocation and consumption behaviour of RP programs, compared to most formalisations of function-based RPLs""
  - ""Our formalisation of graph-based RP provides a clear semantic for deployments: i.e. instantiated parts of (dependency) graphs.""
  - ""An interesting future research avenue is to further compare the semantics of graph-based RP with the semantics (and implementations) of function-based RP: e.g., to establish whether or not they are computationally equivalent (i.e. can they implement the same RP programs).""
  - ""We hypothesise that our formalisation can be generalised such that it also captures other graphbased reactive-like languages.""",,"- The paper introduces Karcharias, a formal model of reactive programming built from first principles, which is a novel contribution as it does not rely on an existing base language like λ-calculus.
 - The formalization provides an intuitive understanding of graph-based reactive programming, which is a key novel insight into how reactive programs operate.
 - The small-step semantics offer a clear formalization of how reactive programs operate over time, which is a theoretical advancement beyond existing approaches.
 - The paper provides a clear semantic for deployments, which is a theoretical contribution to understanding graph-based reactive programming.
 - The potential for generalizing the formalization to capture other graph-based reactive-like languages suggests a broader impact on programming language design.
 - The comparison with function-based reactive programming languages and the question of computational equivalence highlight a theoretical advancement in understanding the relationship between different reactive programming paradigms."
A Mechanized Theory of Program Refinement,"Boubacar Demba Sall, F. Peschanski, E. Chailloux",10.1007/978-3-030-32409-4_19,https://doi.org/10.1007/978-3-030-32409-4_19,IEEE International Conference on Formal Engineering Methods,2,2019,"1. Primitive Name: Effect Statement
  Definition: Reflects the notion of state transformation as a syntactic constructor.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: R Construct
  Definition: A specification statement.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Specified Block
  Definition: Represents a pair of statements resulting from the refinement of one by another.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: ϕ Projection Function
  Definition: Used in formulating rules and properties of the calculus to abstract and concretize program designs.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Predicative Interpretation
  Definition: Associates specifications with statements.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Refinement Relation
  Definition: Defines how one program refines another based on termination and observable behaviors.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Predicative programming paradigm based on dependent type theory
 - Specific mathematical properties guaranteed: Type checking, type inference, parametric polymorphism, correctness-by-construction
 - Proof techniques used: Soundness theorem, completeness theorem
 - Limitations or constraints of the framework: Not explicitly mentioned, but scalability needs improvement","- Specific integration mechanisms proposed: Synthesis of predicative and relational programming paradigms to create a new calculus.
 - Interaction models between paradigms: Synthesis of strengths from both paradigms to enhance each other.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Use of Coq proof assistant to integrate paradigms within a functional language framework.","- Definition of ""concept"" used: Not explicitly defined in the context of generic programming.
 - Mechanisms for representing generic abstractions: Parametric polymorphism is mentioned as a feature of the Coq proof assistant.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novel approach combining predicative programming with relational refinement.
 - Formalization of a language for stepwise program design and a calculus for correctness-by-construction.
 - Identification of necessary and sufficient conditions for refining while statements.
 - Use of predicative semantics for loops, particularly the least fixpoint approach.
 - Central role of the refinement relation in program development.
 - Potential implications for programming language design include inherent correctness-by-construction and flexible specification methods.","- ""We formalize a design language with support for gradual refinement and a calculus which enforces correctness-by-construction.""
  - ""The language is an extension of a simple imperative language with assignment, sequence, if statements and iteration.""
  - ""The syntax of the core language we study is given in Figure 1""
  - ""The statements of the language. Sequential composition as well as the statements related to the if and while keywords are self-explanatory.""
  - ""The effect statement reflects the notion of state transformation as a syntactic constructor.""
  - ""The R construct is a specification statement""
  - ""The specified block S 1 { S 2 } represents a pair of statements resulting from the refinement of S 1 by S 2""
  - ""The ϕ projection function. We now define the projection function ϕ, which will be used in the formulation of the rules and properties of the calculus.""
  - ""The predicative interpretation of statements associates to each statement a specification of type Spec.""
  - ""The refinement relation occupies unsurprisingly a central place in our development.""
  - ""Definition 2 (Predicative refinement). We say that S 2 refines S 1 if and only if whenever S 1 terminates on some state s, S 2 terminates on s and all observable behaviors of S 2 on s are observable behaviors of S 1 on s:""",,"- The paper introduces a design language that supports gradual refinement and correctness-by-construction, which suggests that the conceptual primitives are related to these concepts.
 - The language includes basic imperative constructs like assignment, sequence, if statements, and iteration, which are fundamental primitives in programming.
 - The ""effect"" statement is a primitive that represents state transformation, which is a basic operation in programming.
 - The ""R"" construct is a specification statement, indicating that specifications are a primitive concept in this framework.
 - The ""specified block"" is a primitive that represents refinement steps, which is central to the theory of program refinement.
 - The ϕ projection function is a primitive that helps in formulating rules and properties of the calculus, indicating its role in abstracting and concretizing program designs.
 - The predicative interpretation of statements is a primitive that associates specifications with statements, which is a key concept in the predicative programming paradigm.
 - The refinement relation is a primitive that defines how one program refines another, which is central to the theory of program refinement.","- ""We formalize a design language with support for gradual refinement and a calculus which enforces correctness-by-construction.""
  - ""The underlying theory follows the predicative programming paradigm where programs and specifications are both easily expressed as predicates, which fit naturally in the dependent type theory of the proof assistant.""
  - ""The predicative interpretation of statements associates to each statement a specification of type Spec. This interpretation is inductively defined on the syntax of statements as indicated in Table 1 above.""
  - ""The refinement relation occupies unsurprisingly a central place in our development. Intuitively, it corresponds to a kind of translation of the classical relational interpretation (as found in e.g. [23]) in predicative terms.""
  - ""The completeness part of Theorem 1 reassures us that the design rules we restrict ourselves to use do not themselves restrict the kind of programs that can be obtained by applying these rules.""
  - ""we have mechanized the aforementioned calculus as well as the underlying theory in the Coq p.a. so that the declaration of a refinement step automatically triggers the generation of p.o.s (in the language of the p.a.) to ensure the correctness of the refinement.""",,"- The paper uses a ""predicative programming paradigm,"" which is a type of mathematical framework that expresses programs and specifications as predicates.
 - The framework is based on ""dependent type theory,"" which is a specific mathematical property guaranteed by the use of Coq, a proof assistant.
 - The paper mentions ""type checking, type inference, and parametric polymorphism"" as properties provided by Coq, indicating these are part of the framework's characteristics.
 - The ""predicative interpretation of statements"" and the ""refinement relation"" are key components of the framework, ensuring correctness-by-construction.
 - The framework uses ""proof techniques"" such as the soundness theorem and completeness theorem to guarantee properties of the program designs.
 - The paper does not explicitly mention limitations or constraints of the framework, but it does discuss the need for further development to improve scalability.","- ""the predicative point of view makes it easier to write specifications and handle proof obligations (p.o.s).""
  - ""the Coq p.a. provides a full blown functional language to write specifications with the benefit of type checking, type inference and parametric polymorphism for free.""
  - ""the relational point of view unifies the usual assertions (e.g. precondition, post-condition, invariant) under a single and more general notion of specification, hence simplifying the formulation of the theory.""
  - ""The formalization is the result of our study of both relational and predicative points of view on stepwise refinement, which lead us to a calculus benefiting from some crossfertilization between the two points of view.""
  - ""The calculus stems from a synthesis of ideas from predicative and relational theories of refinement.""",,"- The paper discusses the integration of two programming paradigms: predicative programming and relational programming. This is evident from the quotes that mention the synthesis of ideas from both paradigms to create a new calculus.
 - The integration mechanism involves using the relational point of view to unify assertions and the predicative point of view to simplify specification writing and proof obligations. This suggests a theoretical integration strategy where both paradigms are used to enhance each other.
 - The interaction model between paradigms is described as a synthesis, indicating that the strengths of each paradigm are combined to create a more robust framework.
 - The paper does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the benefits of combining these paradigms, such as simplifying the formulation of the theory and making it easier to write specifications.
 - The use of the Coq proof assistant is a novel translation or embedding technique, as it allows for the integration of these paradigms within a functional language framework, leveraging type checking and inference.","- ""The underlying theory follows the predicative programming paradigm where programs and specifications are both easily expressed as predicates, which fit naturally in the dependent type theory of the proof assistant.""
  - ""The syntax of the core language we study is given in Figure 1 . It is a very classical imperative language, close in spirit to the language studied in [21], but embedded in the Coq p.a. Since Coq is underpinned by a dependent type theory, type checking, type inference and parametric polymorphism are for free.""
  - ""the Coq p.a. provides a full blown functional language to write specifications with the benefit of type checking, type inference and parametric polymorphism for free.""",,"- The paper discusses the use of a ""predicative programming paradigm,"" which involves expressing programs and specifications as predicates. This suggests a focus on conceptual abstraction through the use of predicates.
 - The mention of ""parametric polymorphism"" indicates that the study uses generic programming mechanisms, as parametric polymorphism is a key feature of generic programming.
 - The paper highlights the benefits of using Coq, which includes ""type checking, type inference and parametric polymorphism for free."" This implies that the study leverages these features for genericity and abstraction.
 - The paper does not explicitly define a ""concept"" in the context of generic programming, nor does it detail specific mechanisms for representing generic abstractions or minimal type requirements.
 - The paper does not explicitly mention static checking or optimization strategies related to generic programming.","- ""we formalize in type theory a language of stepwise program design, and a calculus which enforces correctness by construction.""
  - ""we uncover necessary and sufficient conditions for a while statement to refine a given specification.""
  - ""The predicative semantics of loops corresponds to the least fixpoint of a rather complex function.""
  - ""The refinement relation occupies unsurprisingly a central place in our development.""
  - ""The semantics of our language of program designs is close to the predicative interpretation of programming constructs of [10,11,12], with important differences.""
  - ""Our work also differs with existing approaches in the way we treat loops.""
  - ""We have presented a formalized theory of stepwise refinement.""
  - ""We have mechanized this formalization thus allowing for correct-by-construction imperative program design in the Coq p.a.,""",,"- The paper introduces a novel approach by combining predicative programming with relational refinement, offering a unique perspective on program refinement.
 - The formalization of a language for stepwise program design and a calculus for correctness-by-construction is a significant theoretical contribution, as it provides a structured method for ensuring program correctness.
 - The identification of necessary and sufficient conditions for refining while statements is a key theoretical advancement, as it addresses a critical aspect of program refinement.
 - The use of predicative semantics for loops, particularly the least fixpoint approach, is a theoretical innovation that differs from existing methods.
 - The paper's focus on the refinement relation and its central role in the development is a theoretical contribution, as it provides a foundation for understanding program refinement.
 - The comparison with existing work highlights the unique aspects of this study, particularly in how it treats loops and integrates predicative and relational semantics.
 - The potential implications for programming language design include the possibility of developing languages that inherently support correctness-by-construction and more flexible specification methods."
Categorical Model of Functional Language with Natural Numbers and Boolean Values,"J. Perháč, Z. Bilanová",10.1109/CSIT49958.2020.9322039,https://doi.org/10.1109/CSIT49958.2020.9322039,International Conference on Computer Science and Information Technologies,2,2020,Not specified (the abstract does not explicitly define any conceptual primitives),"- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Focus on the correspondence between intuitionistic logic and category theory within the Curry–Howard–Lambek isomorphism.
 - Theoretical advancements: Application of category theory to model a simple functional language and describe its evaluation.
 - Potential implications: New insights or methods in programming language design through the use of category theory.","- ""We define a simple functional language, and we model it by category theory.""
  - ""Curry–Howard–Lambek isomorphism defines a correspondence between at first sight different theories: Church's computational calculi (which is the foundation of functional programming paradigm), intuitionistic logic, and category theory.""
  - ""We describe a correspondence between language in a motivating example of an evaluation of a simple functional program.""",,"- The abstract mentions the Curry–Howard–Lambek isomorphism, which is a theoretical framework that relates different areas of mathematics and computer science. However, it does not explicitly define any conceptual primitives.
 - The mention of defining a ""simple functional language"" and modeling it by ""category theory"" suggests that the study involves theoretical constructs related to these areas, but again, no specific primitives are explicitly mentioned.
 - The abstract does not provide any specific names or definitions of conceptual primitives, nor does it discuss their orthogonality or level of abstraction.
 - The focus of the abstract is on the correspondence between theories rather than on defining specific primitives.","- ""Curry–Howard–Lambek isomorphism defines a correspondence between at first sight different theories: Church's computational calculi (which is the foundation of functional programming paradigm), intuitionistic logic, and category theory.""
  - ""We define a simple functional language, and we model it by category theory.""
  - ""We describe a correspondence between language in a motivating example of an evaluation of a simple functional program.""",,"- The abstract mentions the Curry–Howard–Lambek isomorphism, which is a fundamental concept that relates different mathematical theories. This isomorphism is known for connecting type theory, intuitionistic logic, and category theory.
 - The abstract explicitly states that the authors ""model it by category theory,"" indicating that category theory is the mathematical framework used in this paper.
 - The mention of ""Church's computational calculi"" and ""intuitionistic logic"" suggests that these are part of the theoretical foundations, but the primary focus is on category theory as the framework for modeling the functional language.
 - The abstract does not provide specific details about the mathematical properties guaranteed, proof techniques used, or limitations of the framework. It only mentions the use of category theory as the framework.","- ""We describe a correspondence between language in a motivating example of an evaluation of a simple functional program.""
  - ""We define a simple functional language, and we model it by category theory.""
  - ""Curry–Howard–Lambek isomorphism defines a correspondence between at first sight different theories: Church's computational calculi (which is the foundation of functional programming paradigm), intuitionistic logic, and category theory.""",,"- The abstract mentions the Curry–Howard–Lambek isomorphism, which is a theoretical framework that establishes a correspondence between different theories, including functional programming, intuitionistic logic, and category theory. This suggests a theoretical integration strategy.
 - The study defines a simple functional language and models it using category theory, indicating an interaction model between functional programming and category theory.
 - The abstract does not explicitly mention specific integration mechanisms, constraints, or novel translation techniques. It focuses on the correspondence and modeling rather than detailed integration strategies or challenges.
 - The abstract does not provide a comparative analysis or discuss paradigm interactions beyond the theoretical correspondence.","- ""We describe a correspondence between language in a motivating example of an evaluation of a simple functional program.""
  - ""Curry–Howard–Lambek isomorphism defines a correspondence between at first sight different theories: Church's computational calculi (which is the foundation of functional programming paradigm), intuitionistic logic, and category theory.""
  - ""We define a simple functional language, and we model it by category theory.""",,"- The abstract discusses the Curry–Howard–Lambek isomorphism, which relates functional programming, intuitionistic logic, and category theory. This suggests a focus on theoretical foundations rather than specific programming methodologies.
 - The mention of defining a ""simple functional language"" and modeling it with category theory indicates an emphasis on theoretical modeling rather than practical programming mechanisms.
 - There is no explicit mention of generic programming, abstraction mechanisms, type systems, or static checking strategies in the abstract.
 - The focus appears to be on theoretical correspondences rather than practical programming methodologies or genericity.","- ""We describe a correspondence between language in a motivating example of an evaluation of a simple functional program.""
  - ""We define a simple functional language, and we model it by category theory.""
  - ""we focus on the correspondence between the last two theories.""
  - ""Curry–Howard–Lambek isomorphism defines a correspondence between at first sight different theories: Church's computational calculi (which is the foundation of functional programming paradigm), intuitionistic logic, and category theory.""",,"- The abstract discusses the Curry–Howard–Lambek isomorphism, which is a known theoretical framework. However, the novelty lies in the focus on the correspondence between intuitionistic logic and category theory, which is a specific aspect of this isomorphism.
 - The authors define a simple functional language and model it using category theory, which suggests a theoretical contribution in applying category theory to functional language design.
 - The description of a correspondence between language and the evaluation of a simple functional program implies a theoretical advancement in understanding how functional languages can be modeled and evaluated using category theory.
 - The potential implications for programming language design are implicit in the modeling of a functional language using category theory, which could lead to new insights or methods in language design."
Data abstraction in programming language semantics,Ramesh Subrahmanyam,-,-,-,1,1992,"1. Primitive Name: Algebraic Equations
  Definition: Used to specify ADTs by requiring observational equivalences in the extended language.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Reachable, Fully Abstract Algebras
  Definition: A class of algebras used to construct fully abstract models of programming languages extended with ADTs.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Categorical Descriptions (Initial and Final Algebra Semantics)
  Definition: Used to define paradigms of specification semantics.
  Orthogonality Score: Not specified","- Type of mathematical framework: Algebraic theory, Category theory
 - Specific mathematical properties guaranteed: Observational equivalences, fully abstract models
 - Proof techniques used: Axiomatizations, derivation of sufficient conditions for completeness
 - Limitations or constraints of the framework: Not explicitly mentioned","No specific integration approach described (the abstract focuses on integrating ADTs into programming languages using algebraic equations and denotational semantics, but does not explicitly address integration of different programming paradigms)","Generic programming not extensively addressed (the abstract focuses on abstraction mechanisms through ADTs and algebraic equations, but does not provide detailed information on generic programming methodologies or type system discussions)","- Novel insight: Focus on denotational semantics of languages with algebraically specified ADTs.
 - Theoretical advancements: Necessary and sufficient condition for computational adequacy; definition and construction of reachable, fully abstract algebras; construction of two algebras with categorical descriptions; study of a fragment of $PCF\sb{n}$ with ADTs and derivation of completeness conditions.
 - Potential implications: New frameworks for understanding and constructing models; new paradigms for specification semantics; advancements in programming language design through better understanding of computational adequacy and completeness.","- ""Algebraic equations are one such formalism; such a specification of an ADT constrains the class of valid implementations of the ADT by requiring that the equations be observational equivalences in the extended language.""
  - ""Both these algebras have appealing categorical descriptions that can be used to define paradigms of specification semantics, similar to initial and final algebra semantics.""
  - ""We define a class of algebras called reachable, fully abstract algebras, and exhibit a general construction that for a given algebraic specification of an ADT and any fully abstract algebra satisfying the specification constructs a fully abstract model of $PCF\sb{n}$ extended with the ADT.""",,"- The abstract discusses the use of ""algebraic equations"" as a formalism for specifying abstract data types (ADTs). This suggests that algebraic equations are a conceptual primitive for defining ADTs.
 - The concept of ""reachable, fully abstract algebras"" is introduced as a class of algebras that can be used to construct fully abstract models of programming languages extended with ADTs. This indicates that these algebras are conceptual primitives for reconstructing programming paradigms.
 - The mention of ""categorical descriptions"" similar to initial and final algebra semantics implies that these are also conceptual primitives used to define paradigms of specification semantics.
 - The abstract does not provide explicit definitions for these primitives in terms of their level of abstraction or orthogonality, but they are clearly identified as key concepts in the study.","- ""Both these algebras have appealing categorical descriptions that can be used to define paradigms of specification semantics, similar to initial and final algebra semantics.""
  - ""We define a class of algebras called reachable, fully abstract algebras, and exhibit a general construction that for a given algebraic specification of an ADT and any fully abstract algebra satisfying the specification constructs a fully abstract model of $PCF\sb{n}$ extended with the ADT.""
  - ""Algebraic equations are one such formalism; such a specification of an ADT constrains the class of valid implementations of the ADT by requiring that the equations be observational equivalences in the extended language.""
  - ""We study certain natural axiomatizations of specific environment models, which are models of call by name lambda calculi, and derive sufficient conditions for their completeness.""
  - ""To reason about the extended language it is useful to have a denotational semantics.""",,"- The abstract mentions the use of ""algebraic equations"" as a formalism for specifying abstract data types (ADTs), which suggests a mathematical framework based on algebraic theory.
 - The mention of ""denotational semantics"" indicates that the framework involves a way to assign meanings to programming language constructs, which is a key aspect of type theory and category theory.
 - The definition of ""reachable, fully abstract algebras"" and their construction suggests a focus on algebraic structures and their properties, aligning with algebraic theory.
 - The reference to ""categorical descriptions"" and ""initial and final algebra semantics"" explicitly points to the use of category theory as part of the mathematical framework.
 - The study of ""axiomatizations"" and derivation of ""sufficient conditions for completeness"" implies the use of formal proof techniques, likely within the context of type theory or category theory.","- ""Most modern programming languages allow the user to define abstract data types, thereby creating an extended language.""
  - ""Algebraic equations are one such formalism; such a specification of an ADT constrains the class of valid implementations of the ADT by requiring that the equations be observational equivalences in the extended language.""
  - ""This thesis studies the denotational semantics of languages with algebraically specified ADT's.""
  - ""We define a class of algebras called reachable, fully abstract algebras, and exhibit a general construction that for a given algebraic specification of an ADT and any fully abstract algebra satisfying the specification constructs a fully abstract model of $PCF\sb{n}$ extended with the ADT.""
  - ""We then show the construction of two reachable, fully abstract algebras satisfying the specification.""
  - ""For any programming language, there is the problem of reasoning about its models.""
  - ""We consider a fragment of $PCF\sb{n}$ extended with ADT's that consists of simply typed lambda terms with algebraic constants.""",,"- The abstract discusses the integration of abstract data types (ADTs) into programming languages, which can be seen as a form of paradigm integration since ADTs are a way to extend the language.
 - The use of algebraic equations as a formalism for specifying ADTs suggests a theoretical integration strategy, as these equations constrain the valid implementations of ADTs.
 - The study focuses on denotational semantics, which is a way to reason about the extended language, indicating a focus on theoretical integration strategies.
 - The construction of reachable, fully abstract algebras and their application to $PCF\sb{n}$ extended with ADTs suggests a specific integration mechanism.
 - The abstract does not explicitly mention interaction models between paradigms or constraints/challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.
 - The focus is on the theoretical integration of ADTs into programming languages rather than a broader integration of different programming paradigms.","- ""Most modern programming languages allow the user to define abstract data types, thereby creating an extended language.""
  - ""We define a class of algebras called reachable, fully abstract algebras, and exhibit a general construction that for a given algebraic specification of an ADT and any fully abstract algebra satisfying the specification constructs a fully abstract model of $PCF\sb{n}$ extended with the ADT.""
  - ""Both these algebras have appealing categorical descriptions that can be used to define paradigms of specification semantics, similar to initial and final algebra semantics.""
  - ""This thesis studies the denotational semantics of languages with algebraically specified ADT's.""
  - ""Algebraic equations are one such formalism; such a specification of an ADT constrains the class of valid implementations of the ADT by requiring that the equations be observational equivalences in the extended language.""",,"- The abstract discusses the use of abstract data types (ADTs) and algebraic equations as a formalism for specifying these ADTs. This suggests a focus on abstraction mechanisms.
 - The study involves denotational semantics, which is a way of describing the meaning of programming languages in terms of mathematical functions. This is relevant to understanding how generic abstractions are represented.
 - The mention of ""reachable, fully abstract algebras"" and their construction indicates a mechanism for representing generic abstractions, as these algebras are used to model ADTs.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, which are typically part of generic programming methodologies.
 - The focus on algebraic specifications and denotational semantics suggests a conceptual abstraction mechanism, but the abstract does not provide detailed information on generic programming methodologies or type system discussions.","- ""This thesis studies the denotational semantics of languages with algebraically specified ADT's.""
  - ""For a natural class of models for the extended language we give a necessary and sufficient condition for a model to be computationally adequate with respect to the extended language.""
  - ""We define a class of algebras called reachable, fully abstract algebras, and exhibit a general construction that for a given algebraic specification of an ADT and any fully abstract algebra satisfying the specification constructs a fully abstract model of $PCF\sb{n}$ extended with the ADT.""
  - ""We then show the construction of two reachable, fully abstract algebras satisfying the specification.""
  - ""Both these algebras have appealing categorical descriptions that can be used to define paradigms of specification semantics, similar to initial and final algebra semantics.""
  - ""We consider a fragment of $PCF\sb{n}$ extended with ADT's that consists of simply typed lambda terms with algebraic constants.""
  - ""We study certain natural axiomatizations of specific environment models, which are models of call by name lambda calculi, and derive sufficient conditions for their completeness.""",,"- The study provides a novel insight by focusing on the denotational semantics of languages with algebraically specified abstract data types (ADTs), which is a unique theoretical contribution.
 - The provision of a necessary and sufficient condition for a model to be computationally adequate with respect to the extended language is a significant theoretical advancement, as it provides a clear criterion for evaluating models.
 - The definition and construction of reachable, fully abstract algebras and their application to $PCF\sb{n}$ extended with ADTs represent a theoretical innovation, as it offers a new framework for understanding and constructing models.
 - The construction of two specific algebras with appealing categorical descriptions contributes to the theoretical understanding of specification semantics, offering new paradigms similar to initial and final algebra semantics.
 - The study of a fragment of $PCF\sb{n}$ with ADTs and the derivation of sufficient conditions for completeness of environment models are theoretical advancements that contribute to the understanding of programming language semantics."
"On Semantic Link Between Logic , Object-Oriented , Functional and Constraint Programming ?",A. Morozov,-,-,-,7,2002,Not specified (the abstract does not explicitly mention conceptual primitives or their definitions),Not specified (the abstract does not provide explicit details about the mathematical framework),"- Specific integration mechanisms proposed: Ensuring model-theoretic semantics for object-oriented and functional features in Actor Prolog.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Mathematical property ensuring completeness despite delays and deadlocks.
 - Novel translation or embedding techniques: Implementing a weak form of constraints in the logic language.",Generic programming not extensively addressed,"- Key novel insights: Investigation of semantic and operational links among object-oriented, logic, functional, and constraint programming paradigms.
 - Theoretical advancements: Development of means to ensure model-theoretic semantics for object-oriented and functional features in Actor Prolog; creation of a method for implementing a weak form of constraints in a logic language.
 - Potential implications: Integration of different programming paradigms; assurance of program completeness by preventing violations due to delaying computation and deadlocks.","- ""These means have provided an interesting mathematical property of implemented constraints, namely, they guarantee that delaying computation and deadlocks never violate the completeness of a logic program.""
  - ""I show how means developed for ensuring model-theoretic semantics of object-oriented and functional features in the Actor Prolog have led to creation of a method of implementing a weak form of constraints in the logic language.""
  - ""I investigate semantic and operational links among object-oriented, logic, functional and constraint programming paradigms by an example of implementing them in logic language Actor Prolog.""",,"- The abstract discusses the investigation of semantic and operational links among different programming paradigms, which suggests a focus on theoretical or conceptual frameworks rather than specific primitives.
 - The mention of ""means developed for ensuring model-theoretic semantics"" implies a focus on theoretical underpinnings rather than explicit primitives.
 - The abstract does not explicitly mention any conceptual primitives or their definitions.
 - The focus is on the method of implementing constraints and the mathematical property of these constraints, rather than defining specific primitives.","- ""These means have provided an interesting mathematical property of implemented constraints, namely, they guarantee that delaying computation and deadlocks never violate the completeness of a logic program.""
  - ""I show how means developed for ensuring model-theoretic semantics of object-oriented and functional features in the Actor Prolog have led to creation of a method of implementing a weak form of constraints in the logic language.""
  - ""I investigate semantic and operational links among object-oriented, logic, functional and constraint programming paradigms by an example of implementing them in logic language Actor Prolog.""",,"- The abstract mentions the investigation of semantic and operational links among different programming paradigms, which suggests a focus on theoretical foundations.
 - The use of ""model-theoretic semantics"" indicates a type of mathematical framework, specifically related to model theory, which is a branch of mathematical logic.
 - The abstract discusses the implementation of constraints in a logic language, which implies a formal verification aspect, but it does not specify the type of mathematical framework or proof techniques used.
 - The mention of ""an interesting mathematical property"" related to constraints suggests specific mathematical properties guaranteed, but it does not detail the type of mathematical framework or proof techniques.
 - The abstract does not provide explicit details about the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""I show how means developed for ensuring model-theoretic semantics of object-oriented and functional features in the Actor Prolog have led to creation of a method of implementing a weak form of constraints in the logic language.""
  - ""I investigate semantic and operational links among object-oriented, logic, functional and constraint programming paradigms by an example of implementing them in logic language Actor Prolog.""
  - ""These means have provided an interesting mathematical property of implemented constraints, namely, they guarantee that delaying computation and deadlocks never violate the completeness of a logic program.""",,"- The abstract discusses the investigation of semantic and operational links among different programming paradigms (object-oriented, logic, functional, and constraint programming) using the Actor Prolog language. This suggests an integration approach that involves implementing these paradigms within a single language framework.
 - The mention of ""means developed for ensuring model-theoretic semantics"" indicates a specific integration mechanism that focuses on ensuring consistent semantics across object-oriented and functional features within Actor Prolog.
 - The creation of a method for implementing a ""weak form of constraints"" in the logic language suggests a novel translation or embedding technique, as it involves integrating constraint programming into the logic language.
 - The abstract highlights a mathematical property related to constraints that ensures the completeness of the logic program, which could be seen as addressing a challenge in paradigm integration by preventing issues like deadlocks from affecting program completeness.
 - There is no explicit mention of interaction models between paradigms or specific challenges in paradigm integration beyond the mathematical property related to constraints.","- ""I investigate semantic and operational links among object-oriented, logic, functional and constraint programming paradigms by an example of implementing them in logic language Actor Prolog.""
  - ""These means have provided an interesting mathematical property of implemented constraints, namely, they guarantee that delaying computation and deadlocks never violate the completeness of a logic program.""
  - ""I show how means developed for ensuring model-theoretic semantics of object-oriented and functional features in the Actor Prolog have led to creation of a method of implementing a weak form of constraints in the logic language.""",,"- The abstract discusses the investigation of semantic and operational links among different programming paradigms, which suggests a focus on conceptual abstraction.
 - The mention of ""ensuring model-theoretic semantics of object-oriented and functional features"" implies a focus on abstraction mechanisms, as model-theoretic semantics is a way to define the meaning of programming constructs.
 - The creation of a method for implementing constraints in the logic language suggests a mechanism for representing generic abstractions, as constraints can be seen as a form of abstraction.
 - However, there is no explicit mention of generic programming methodology, type system discussions, or specific mechanisms for generic abstractions.
 - The abstract does not provide details on minimal type requirements or static checking/optimization strategies.","- ""I investigate semantic and operational links among object-oriented, logic, functional and constraint programming paradigms by an example of implementing them in logic language Actor Prolog.""
  - ""I show how means developed for ensuring model-theoretic semantics of object-oriented and functional features in the Actor Prolog have led to creation of a method of implementing a weak form of constraints in the logic language.""
  - ""These means have provided an interesting mathematical property of implemented constraints, namely, they guarantee that delaying computation and deadlocks never violate the completeness of a logic program.""",,"- The abstract discusses the investigation of semantic and operational links among different programming paradigms, which suggests a novel insight into how these paradigms can be integrated or related.
 - The development of means to ensure model-theoretic semantics for object-oriented and functional features in Actor Prolog is a theoretical advancement, as it provides a method for implementing constraints in a logic language.
 - The creation of a method for implementing a weak form of constraints in a logic language is a theoretical contribution, as it introduces a new approach to handling constraints.
 - The mathematical property that guarantees delaying computation and deadlocks do not violate the completeness of a logic program is a significant theoretical advancement, as it addresses a critical issue in programming language design related to consistency and reliability.
 - The potential implications for programming language design include the integration of different paradigms and the assurance of program completeness, which are novel contributions to the field."
"Functional programming, object-oriented programming and algebras!",B. C. D. S. Oliveira,10.1145/2633628.2633637,https://doi.org/10.1145/2633628.2633637,Workshop on Generic Programming,1,2014,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not provide details on the mathematical framework used to formalize and guarantee properties of the conceptual primitives),"- Specific integration mechanisms proposed: Use of (F-)Algebras as a common abstraction.
 - Interaction models between paradigms: Dual views of functional and object-oriented programming.
 - Constraints or challenges in paradigm integration: The Expression Problem.
 - Any novel translation or embedding techniques: Considering algebras as a primary structuring abstraction.",Generic programming not extensively addressed,"- Key novel insights: The common abstraction of (F-)Algebras behind various solutions to the Expression Problem.
 - Theoretical advancements: Proposal of a new programming paradigm based on algebras as a primary structuring abstraction.
 - Potential implications: Influence on future programming language design by adopting algebras as a fundamental structuring concept.","- ""Functional and Object-Oriented (OO) abstractions provide dual views on programming.""
  - ""Functional languages, like ML or Haskell, use algebraic datatypes as the main structuring abstraction.""
  - ""Algebraic datatypes require programmers to think about all the variants in advance, but in return they allow functions to be defined modularly.""
  - ""In Object-Oriented languages, like Java or C#, interfaces are the main abstraction.""
  - ""Interfaces require programmers to think about all the functions in advance, but in return they allow new variants to be defined modularly.""
  - ""This dual view in programming was first observed by Reynolds and later popularized by Wadler via the cunningly named Expression Problem.""
  - ""Wadler's Expression Problem emphasizes an additional question: can we have variants and functions both defined modularly?""
  - ""Recent years have been prolific in solutions to the Expression Problem for both functional and OO languages.""
  - ""Despite superficially looking quite different, various solutions have in fact a common abstraction behind them: some variant of (F-)Algebras.""
  - ""Finally I'll argue that a different programming paradigm arises when we take algebras (instead of algebraic datatypes or interfaces) as a primary structuring abstraction.""",,"- The abstract discusses two main abstractions: algebraic datatypes for functional programming and interfaces for object-oriented programming. These are not explicitly defined as conceptual primitives but are key concepts in the discussion.
 - The abstract mentions the Expression Problem, which is a conceptual framework rather than a primitive.
 - The mention of ""(F-)Algebras"" suggests a common abstraction behind various solutions, but it is not explicitly defined as a conceptual primitive in the abstract.
 - The abstract does not provide explicit definitions or lists of conceptual primitives as requested by the question.
 - The focus is on the dual views of programming and the role of algebras in solutions to the Expression Problem, rather than on defining specific conceptual primitives.","- ""Functional languages, like ML or Haskell, use algebraic datatypes as the main structuring abstraction.""
  - ""Algebraic datatypes require programmers to think about all the variants in advance, but in return they allow functions to be defined modularly.""
  - ""In Object-Oriented languages, like Java or C#, interfaces are the main abstraction.""
  - ""Interfaces require programmers to think about all the functions in advance, but in return they allow new variants to be defined modularly.""
  - ""Recent years have been prolific in solutions to the Expression Problem for both functional and OO languages.""
  - ""Despite superficially looking quite different, various solutions have in fact a common abstraction behind them: some variant of (F-)Algebras.""
  - ""Finally I'll argue that a different programming paradigm arises when we take algebras (instead of algebraic datatypes or interfaces) as a primary structuring abstraction.""",,"- The abstract discusses the use of algebraic datatypes in functional programming and interfaces in object-oriented programming, but it does not explicitly mention a mathematical framework or theoretical foundations.
 - The mention of ""(F-)Algebras"" suggests a connection to algebraic structures, but there is no detailed discussion of a specific mathematical framework, such as type theory or category theory.
 - There is no mention of proof methodology, formal verification discussions, or specific mathematical properties guaranteed by a framework.
 - The abstract focuses on the conceptual and programming paradigm aspects rather than the mathematical framework characteristics.","- ""Functional and Object-Oriented (OO) abstractions provide dual views on programming.""
  - ""This dual view in programming was first observed by Reynolds and later popularized by Wadler via the cunningly named Expression Problem.""
  - ""Recent years have been prolific in solutions to the Expression Problem for both functional and OO languages.""
  - ""Despite superficially looking quite different, various solutions have in fact a common abstraction behind them: some variant of (F-)Algebras.""
  - ""In this talk I'll give an overview of some of the solutions to the Expression Problem in both Functional and OO languages.""
  - ""Then I will discuss the algebra-related abstractions behind these solutions to relate the different solutions to the Expression Problem.""
  - ""Finally I'll argue that a different programming paradigm arises when we take algebras (instead of algebraic datatypes or interfaces) as a primary structuring abstraction.""",,"- The abstract discusses the dual views of functional and object-oriented programming, indicating a focus on integrating these paradigms.
 - The mention of the Expression Problem suggests a challenge in integrating these paradigms, as it involves defining both variants and functions modularly.
 - The abstract notes that various solutions to the Expression Problem share a common abstraction related to (F-)Algebras, which could be seen as a theoretical integration strategy.
 - The talk aims to overview solutions and discuss algebra-related abstractions, which implies a comparative analysis of integration strategies.
 - The abstract suggests a novel approach by considering algebras as a primary structuring abstraction, which could be a novel translation or embedding technique.","- ""Functional and Object-Oriented (OO) abstractions provide dual views on programming.""
  - ""Functional languages, like ML or Haskell, use algebraic datatypes as the main structuring abstraction.""
  - ""Algebraic datatypes require programmers to think about all the variants in advance, but in return they allow functions to be defined modularly.""
  - ""In Object-Oriented languages, like Java or C#, interfaces are the main abstraction.""
  - ""Interfaces require programmers to think about all the functions in advance, but in return they allow new variants to be defined modularly.""
  - ""Recent years have been prolific in solutions to the Expression Problem for both functional and OO languages.""
  - ""Despite superficially looking quite different, various solutions have in fact a common abstraction behind them: some variant of (F-)Algebras.""
  - ""Finally I'll argue that a different programming paradigm arises when we take algebras (instead of algebraic datatypes or interfaces) as a primary structuring abstraction.""",,"- The abstract discusses the dual views of programming provided by functional and object-oriented abstractions, which are related to genericity and abstraction mechanisms.
 - Algebraic datatypes in functional languages and interfaces in object-oriented languages are mentioned as primary structuring abstractions, which are mechanisms for representing generic abstractions.
 - The abstract mentions that these abstractions allow for modular definition of functions or variants, which implies a form of generic programming.
 - The mention of ""(F-)Algebras"" suggests a common abstraction behind various solutions, which could relate to minimal type requirements or static checking strategies.
 - However, the abstract does not explicitly define a ""concept"" used in the study, nor does it detail specific minimal type requirements or static checking strategies.
 - The focus is more on the paradigm shift when using algebras as a primary structuring abstraction rather than detailed generic programming methodologies or type system discussions.","- ""Finally I'll argue that a different programming paradigm arises when we take algebras (instead of algebraic datatypes or interfaces) as a primary structuring abstraction.""
  - ""Despite superficially looking quite different, various solutions have in fact a common abstraction behind them: some variant of (F-)Algebras.""
  - ""Recent years have been prolific in solutions to the Expression Problem for both functional and OO languages.""
  - ""This dual view in programming was first observed by Reynolds and later popularized by Wadler via the cunningly named Expression Problem.""",,"- The abstract discusses the ""Expression Problem,"" which is a known issue in programming languages, indicating that the novelty is not in identifying the problem but in addressing it.
 - The mention of ""some variant of (F-)Algebras"" as a common abstraction behind various solutions suggests a theoretical contribution by highlighting a unifying concept across different programming paradigms.
 - The abstract indicates that the talk will ""argue that a different programming paradigm arises when we take algebras (instead of algebraic datatypes or interfaces) as a primary structuring abstraction."" This suggests a novel theoretical contribution by proposing a new paradigm based on algebras.
 - The potential implications for programming language design are implied by the discussion of a new paradigm, which could influence how future programming languages are structured and developed."
Analysis of paradigm use in multiparadigm language programs,D. S. Westbrook,-,-,-,0,1998,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not mention a specific mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of the ""paradigmatic map"" model for representing paradigm use, formalization of paradigm inference system, concept of ""paradigm transition.""
 - Theoretical advancements: Development of a structured model for analyzing paradigm use, formalization of paradigm association with language constructs.
 - Potential implications: Insights into paradigm use can inform programming language design, making languages more effective and user-friendly.","- ""In the context of programming languages, a programming paradigm defines a distinctive model for solving problems.""
  - ""This model, called a paradigmatic map, is an abstract syntax tree where each node represents some language construct annotated with a paradigm representing the paradigmatic effect at that point.""
  - ""We define a paradigm transition as a change in paradigm use either between adjacent sibling nodes in a paradigmatic map (peer transition) or from child nodes to their parent (abstraction transition).""
  - ""We define a model for representing paradigm use in an MPL program as identified by the features (and deviations from those features) of the imperative, functional, logic, and object-oriented paradigms.""
  - ""The association of paradigms to language constructs as they occur in a program was formalized with a paradigm inference system consisting of inference rules for GED constructs.""",,"- The abstract discusses the concept of programming paradigms and their representation in a multiparadigm language (MPL) program.
 - It introduces a ""paradigmatic map"" as a model for representing paradigm use, which is an abstract syntax tree where each node is annotated with a paradigm.
 - The abstract mentions the association of paradigms to language constructs using a paradigm inference system, which suggests a method for identifying paradigmatic effects.
 - The concept of ""paradigm transition"" is defined as changes in paradigm use between nodes in the paradigmatic map.
 - However, the abstract does not explicitly list specific conceptual primitives or provide detailed definitions for them.
 - The focus is on the model and system for analyzing paradigm use rather than defining specific primitives.","- ""This model, called a paradigmatic map, is an abstract syntax tree where each node represents some language construct annotated with a paradigm representing the paradigmatic effect at that point.""
  - ""The association of paradigms to language constructs as they occur in a program was formalized with a paradigm inference system consisting of inference rules for GED constructs.""
  - ""We define a model for representing paradigm use in an MPL program as identified by the features (and deviations from those features) of the imperative, functional, logic, and object-oriented paradigms.""
  - ""A software tool, GPA (GED Paradigm Analyzer), was developed that produces a paradigmatic map and captures paradigm transition information from a GED program.""",,"- The abstract discusses the development of a ""paradigmatic map"" and a ""paradigm inference system"" to analyze paradigm use in multiparadigm language programs. This suggests a structured approach to understanding paradigmatic effects but does not explicitly mention a mathematical framework.
 - The use of ""inference rules"" implies some form of formalization, but it does not specify the type of mathematical framework (e.g., type theory, category theory) or any specific mathematical properties guaranteed.
 - There is no mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract, which are typically where mathematical frameworks are detailed.
 - The focus is on the development of a software tool (GPA) and its application, rather than on the mathematical underpinnings of the paradigmatic map or inference system.","- ""When a programming language provides linguistic support for more than one paradigm, it can be called a multiparadigm language (MPL).""
  - ""In using an MPL to solve a problem, the available paradigms may be combined in different ways, depending on the particular language and how the programmer perceives a solution, thus making the program more paradigmatically complex than one written in a single paradigm language.""
  - ""We define a model for representing paradigm use in an MPL program as identified by the features (and deviations from those features) of the imperative, functional, logic, and object-oriented paradigms.""
  - ""This model, called a paradigmatic map, is an abstract syntax tree where each node represents some language construct annotated with a paradigm representing the paradigmatic effect at that point.""
  - ""The association of paradigms to language constructs as they occur in a program was formalized with a paradigm inference system consisting of inference rules for GED constructs.""
  - ""From a paradigmatic map of a program, differences between paradigm use can be observed.""
  - ""We define a paradigm transition as a change in paradigm use either between adjacent sibling nodes in a paradigmatic map (peer transition) or from child nodes to their parent (abstraction transition).""
  - ""A software tool, GPA (GED Paradigm Analyzer), was developed that produces a paradigmatic map and captures paradigm transition information from a GED program.""",,"- The abstract discusses the concept of multiparadigm languages (MPLs) and how they allow for the combination of different paradigms in problem-solving.
 - It introduces a ""paradigmatic map"" as a model for representing paradigm use, which is an abstract syntax tree where each node is annotated with a paradigm.
 - The abstract mentions a ""paradigm inference system"" that formalizes the association of paradigms to language constructs, indicating a mechanism for integrating paradigms.
 - The concept of ""paradigm transition"" is introduced, which involves changes in paradigm use between nodes in the paradigmatic map, suggesting an interaction model between paradigms.
 - The development of the GPA tool indicates a practical application of these concepts to analyze paradigm use and transitions.
 - However, the abstract does not explicitly discuss specific integration mechanisms, interaction models, constraints, or novel translation techniques beyond the paradigmatic map and inference system.","- ""In the context of programming languages, a programming paradigm defines a distinctive model for solving problems.""
  - ""When a programming language provides linguistic support for more than one paradigm, it can be called a multiparadigm language (MPL).""
  - ""In using an MPL to solve a problem, the available paradigms may be combined in different ways, depending on the particular language and how the programmer perceives a solution, thus making the program more paradigmatically complex than one written in a single paradigm language.""
  - ""We define a model for representing paradigm use in an MPL program as identified by the features (and deviations from those features) of the imperative, functional, logic, and object-oriented paradigms.""
  - ""This model, called a paradigmatic map, is an abstract syntax tree where each node represents some language construct annotated with a paradigm representing the paradigmatic effect at that point.""
  - ""The association of paradigms to language constructs as they occur in a program was formalized with a paradigm inference system consisting of inference rules for GED constructs.""
  - ""A software tool, GPA (GED Paradigm Analyzer), was developed that produces a paradigmatic map and captures paradigm transition information from a GED program.""",,"- The abstract primarily discusses the analysis of paradigm use in multiparadigm language programs, focusing on how different paradigms are combined and represented.
 - The concept of a ""paradigmatic map"" is introduced as a model for representing paradigm use, which involves annotating language constructs with paradigms.
 - The abstract does not explicitly mention generic programming or abstraction mechanisms related to genericity.
 - There is no discussion of type systems, minimal type requirements, or static checking strategies related to generic programming.
 - The focus is on paradigm use and transitions rather than generic programming or abstraction mechanisms.","- ""In this dissertation, we use the multiparadigm language GED, which supports the imperative, functional, logic, and object-oriented paradigms, as a basis for examining paradigm use in MPL programs.""
  - ""We define a model for representing paradigm use in an MPL program as identified by the features (and deviations from those features) of the imperative, functional, logic, and object-oriented paradigms.""
  - ""This model, called a paradigmatic map, is an abstract syntax tree where each node represents some language construct annotated with a paradigm representing the paradigmatic effect at that point.""
  - ""The association of paradigms to language constructs as they occur in a program was formalized with a paradigm inference system consisting of inference rules for GED constructs.""
  - ""From a paradigmatic map of a program, differences between paradigm use can be observed.""
  - ""A software tool, GPA (GED Paradigm Analyzer), was developed that produces a paradigmatic map and captures paradigm transition information from a GED program.""
  - ""Through this work, a system for analyzing paradigm use in MPL programs has been defined, implemented, and applied.""
  - ""While our work is based on the language GED, we believe it can be adapted to other multiparadigm and non-imperative languages to gain information on how and why different paradigms are used by programmers.""",,"- The study introduces a novel model for representing paradigm use in multiparadigm language programs, known as a ""paradigmatic map."" This is a theoretical contribution as it provides a structured way to analyze and understand paradigm use.
 - The development of a ""paradigm inference system"" is another theoretical advancement. It formalizes the association of paradigms with language constructs, which is a significant contribution to understanding how paradigms are used in programming.
 - The concept of ""paradigm transition"" is introduced, which allows for the observation of differences in paradigm use. This is a key insight into how programmers switch between paradigms.
 - The study's focus on analyzing paradigm use in multiparadigm languages has potential implications for programming language design. By understanding how different paradigms are used, language designers can create more effective and user-friendly languages.
 - The adaptability of the system to other languages suggests a broader theoretical contribution beyond the specific language used in the study."
What we talk about when we talk about monads,T. Petříček,10.22152/programming-journal.org/2018/2/12,https://doi.org/10.22152/programming-journal.org/2018/2/12,"The Art, Science, and Engineering of Programming",7,2018,"1. Primitive Name: Formal Level
  Definition: A monad has a category theoretic definition.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Implementation Level
  Definition: Monads have been implemented as a type class definition, syntactic sugar, and as libraries in many other languages.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Metaphorical Level
  Definition: The influence of the metaphorical level is more difficult to trace as it is rarely documented in writing.
  Orthogonality Score: Not specified","- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Composition of monadic computations
 - Proof techniques used: Monad laws
 - Limitations or constraints of the framework: Less common use for program reasoning than expected",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The paper introduces a framework for understanding programming concepts at three levels: formal, metaphorical, and implementation.
 - Theoretical advancements: Integrates cognitive sciences and philosophy into the understanding of programming concepts, providing a broader understanding of monads beyond their formal definition.
 - Potential implications for programming language design: Considering multiple levels can lead to more effective and appropriate use of programming concepts, potentially avoiding issues in their application.","- ""we present a framework for understanding programming concepts that considers them at three levels: formal, metaphorical and implementation.""
  - ""The idea of treating programming concepts as entities consisting of multiple levels is not new. Turner and Angius [ ] treat programs as technical artifacts with two levels, one is a specification and function and the other is an implementation. Our analysis differs in that we look at programming concepts rather than programs as a whole and we separate the formal and intuitive aspects of the specification.""
  - ""this paper provides foundations for a broader understanding of programming concepts that integrates formal and technical views with reflections obtained through cognitive sciences and philosophy.""",,"- The paper discusses a framework for understanding programming concepts, specifically monads, at three levels: formal, metaphorical, and implementation. These levels are conceptual primitives that help in reconstructing programming paradigms.
 - The formal level refers to the category theoretic definition of a monad, which is a precise mathematical definition.
 - The implementation level involves how monads are implemented in programming languages, such as type class definitions or syntactic sugar.
 - The metaphorical level involves how monads are understood intuitively, often through metaphors like containers or computations.
 - These levels are interlinked and provide a comprehensive understanding of programming concepts like monads.
 - The paper does not explicitly mention an orthogonality score for these primitives, but they are distinct and complementary in understanding programming concepts.","- ""Monads have a precise and succinct category theoretical definition that formally defines exactly what a monad is.""
  - ""The following definition of a monad is taken from a paper by Moggi [ ] that first used monads in the context of programming languages: Definition . A monad over a category is a triple (T, η, µ) where T : → is a functor, η : I d → T and µ : T 2 → T are natural transformations such that:""
  - ""Monad laws are not motivated by intuition about programs, but are, instead, imported from the category theoretical definition.""
  - ""The laws do not appear obvious when expressed in terms of bind and unit. They are better understood in terms of composition of monadic computations (following our second metaphor).""
  - ""using monad laws to prove program properties is less ubiquitous than the early work might suggest.""
  - ""There are refactoring tools that use monads [ ] and that introduce monads [ ], but not tools that are directly enabled by the monad laws.""",,"- The paper explicitly mentions that monads have a ""category theoretical definition,"" indicating that category theory is the mathematical framework used to formalize monads.
 - The definition of a monad as a triple (T, η, µ) with specific natural transformations is a key aspect of this framework, providing a formal structure for monads.
 - The paper notes that monad laws are derived from category theory, which guarantees certain properties about the composition of monadic computations.
 - The use of monad laws for proving program properties suggests a proof methodology based on these laws, although it is noted that this is not as common as initially expected.
 - The paper does not explicitly discuss limitations or constraints of the category theory framework in this context, but it does mention that the use of monad laws for program reasoning is less prevalent than anticipated.","- ""In programming, an alternative, but equivalent, definition of monads became popular shortly after the original appeared.""
  - ""The first practical use of monads is for code reuse.""
  - ""The embedding of monads in Haskell can be used to define an order of evaluation (in an otherwise lazy language).""
  - ""The 'do' notation can be used with any monad, but it is closely linked with the metaphor that treats monads as computations.""
  - ""Other languages introduced other kinds of non-standard computations. For example, F# computation expressions [ ], a mechanism similar to the 'do' notation has been introduced in order to simplify writing of asynchronous computations""
  - ""Another instance of using monads to embed non-standard computations into a programming language is LINQ in C# and VB.Net""
  - ""Syntactic sugar Both Haskell 'do' notation and F# computation expressions are syntactic sugar, introduced primarily to provide nicer syntax when using monadic abstractions.""
  - ""The example shows that syntactic sugar originally designed for monads can later be used in a way that has very little to do with the original idea.""",,"- The paper discusses the integration of monads into different programming languages and paradigms, such as Haskell and F#.
 - The use of monads for code reuse and the embedding of monads in languages like Haskell are examples of integration mechanisms.
 - The 'do' notation and F# computation expressions are interaction models that facilitate the use of monads in different paradigms.
 - The paper mentions that syntactic sugar like 'do' notation can be used beyond its original purpose, indicating flexibility in paradigm integration.
 - However, the paper does not explicitly discuss a comprehensive ""Programming Paradigm Integration Approach"" or specific theoretical integration strategies.
 - The focus is more on how monads are used and evolve in different programming contexts rather than a detailed integration approach.","- ""The meaning of a programming concept such as monad comprises aspects at three different levels. The first is a mathematical aspect that can be used for formal analysis. The second is an implementation of the concept that is used for some purpose in concrete programs or libraries. Finally, the third is a metaphorical or intuitive understanding what the concept is in terms of general examples or analogies.""
  - ""In programming, an alternative, but equivalent, definition of monads became popular shortly after the original appeared. The following is adapted from Wadler [ ].
 

 Definition . A monad is a triple (M , unit, > > =) consisting of a type constructor M and two operations of the following types:
 

 These operations must satisfy the following laws:""
  - ""The first practical use of monads is for code reuse. In Haskell and other languages with higher-kinded types [ ], it is possible to write code that works for any monad, provided that the implementation needs only unit and bind, written as return and > > =, respectively.""
  - ""The embedding of monads in Haskell can be used to define an order of evaluation (in an otherwise lazy language). This aspect has been utilized by the IO monad [ ] to allow imperative programming and working with input/output.""
  - ""The 'do' notation can be used with any monad, but it is closely linked with the metaphor that treats monads as computations.""
  - ""the meaning of a programming language concept is constituted at three interlinked levels. For monads, the three levels provide the following:
 

 Formal level. A monad has a category theoretic definition. This is used in proofs, such as when reasoning about monadic code [ ], but it also interacts with the two other levels.""",,"- The paper discusses the concept of monads at three levels: mathematical, implementation, and metaphorical. This suggests a broad approach to conceptual abstraction, focusing on how monads are understood and used rather than specific generic programming mechanisms.
 - The paper mentions the use of monads for code reuse in languages with higher-kinded types, which is a mechanism for representing generic abstractions. However, it does not delve into specific type system discussions or minimal type requirements.
 - The paper does not explicitly address static checking or optimization strategies related to generic programming.
 - The focus of the paper is on understanding monads from a broader perspective rather than detailing generic programming methodologies or type system discussions.","- ""we present a framework for understanding programming concepts that considers them at three levels: formal, metaphorical and implementation.""
  - ""the meaning of a programming language concept is constituted at three interlinked levels.""
  - ""this paper provides foundations for a broader understanding of programming concepts that integrates formal and technical views with reflections obtained through cognitive sciences and philosophy.""
  - ""The idea of treating programming concepts as entities consisting of multiple levels is not new. Turner and Angius [ ] treat programs as technical artifacts with two levels, one is a specification and function and the other is an implementation. Our analysis differs in that we look at programming concepts rather than programs as a whole and we separate the formal and intuitive aspects of the specification.""
  - ""Finally, we discussed why such broader understanding of programming concepts such as monads is useful. We looked at a number of cases, documented in the literature, where a monad was used in a way that was revised in later work. For each case, we suggested that a broader understanding of monads could help the original authors to avoid the issues discovered later.""",,"- The paper introduces a novel framework for understanding programming concepts by considering them at three levels: formal, metaphorical, and implementation. This is a theoretical advancement as it integrates cognitive sciences and philosophy into the understanding of programming concepts.
 - The paper provides a broader understanding of monads by situating them within cognitive science, philosophy of science, and mathematics. This is a key novel insight as it moves beyond the traditional formal definition of monads.
 - The paper suggests that this broader understanding can help avoid issues in the use of monads, which is a potential implication for programming language design. It implies that considering these multiple levels can lead to more effective and appropriate use of programming concepts.
 - The paper distinguishes itself from existing work by focusing on programming concepts rather than programs as a whole and by separating formal and intuitive aspects, which is a theoretical advancement."
Applicative bidirectional programming,"Kazutaka Matsuda, Meng Wang",10.1017/S0956796818000096,https://doi.org/10.1017/S0956796818000096,Journal of functional programming,3,2018,"1. Primitive Name: Lifting of Lenses
  Definition: Transforming lenses of type Lens (A 1 , . . . , A n ) B to lens functions.
  Orthogonality Score: Not explicitly discussed.
 

 2. Primitive Name: Binary Lifting
  Definition: Ability to split pairs and apply separate lenses to each component.
  Orthogonality Score: Not explicitly discussed.
 

 3. Primitive Name: Lift Functions
  Definition: Functions like lift, unlift, lift 2, unlift 2 that enable lens manipulation.
  Orthogonality Score: Not explicitly discussed.","- Type of mathematical framework: Category theory, Type theory
 - Specific mathematical properties guaranteed: Well-behavedness, Lax monoidal functor
 - Proof techniques used: Free theorems, Parametricity, Relational interpretations
 - Limitations or constraints of the framework: Not explicitly detailed","- Specific integration mechanisms proposed: Lifting lenses to functions to enable applicative-style and higher-order programming.
 - Interaction models between paradigms: Combining lens framework with semantic bidirectionalization for backward transformations.
 - Constraints or challenges in paradigm integration: Ensuring well-behavedness and maintaining bidirectional laws.
 - Novel translation or embedding techniques: Lifting lenses to functions for higher-order programming.","- Definition of ""concept"" used: Lenses and higher-order functions as abstract concepts.
 - Mechanisms for representing generic abstractions: Lifting lenses to functions, applicative-style programming, use of traverse and lsequence functions.
 - Minimal type requirements identified: Type constraints like Eq s and Traversable t.
 - Static checking or optimization strategies: Implied through type constraints and generic functions.","- Novelty: Integration of lens framework and semantic bidirectionalization for a more flexible programming style.
 - Theoretical Advancements: Lifting lenses to functions for compositional reasoning, use of Yoneda embedding for covariant monoidal functor.
 - Potential Implications: More general and flexible framework for bidirectional transformations, enhancing programming language design.","- ""The key of binary lifting is the ability to split a pair and have separate lenses applied to each component.""
  - ""The key idea of our proposal is to lift lenses of type Lens (A 1 , . . . , A n ) B to lens functions of type""
  - ""The functions lift fst L • lift fst L and twice (lift fst L ) are examples of f in this theorem.""
  - ""We can now show that the new unlift 2 is the left-inverse of lift 2 (a similar property holds for lift/unlift); notice that, as we will discuss later, lift 2 is not a left-inverse of unlift 2 in contrast.""
  - ""The n-ary tuple (A 1 , . . . , A n ) above is then generalized to data structures such as lists in Section 4.""",,"- The paper discusses the concept of lifting lenses to functions, which is a key conceptual primitive in the framework.
 - The lifting process involves transforming lenses of type Lens (A 1 , . . . , A n ) B to lens functions, which is a fundamental primitive.
 - The paper also mentions the ability to split pairs and apply separate lenses to each component, which is another primitive related to binary lifting.
 - The functions lift, unlift, lift 2, unlift 2, etc., are central to the framework, as they enable the manipulation of lenses in an applicative style.
 - The paper does not explicitly list these as ""conceptual primitives"" but they are integral to the methodology described.","- ""our idea of mapping Lens A B to ∀s. Lens s A → Lens s B is based on the Yoneda lemma in category theory (Mac Lane 1998, Section III.2).""
  - ""The key idea of our proposal is to lift lenses of type Lens (A 1 , . . . , A n ) B to lens functions of type""
  - ""The pair of functions (lift, unlift) is a bijection between • { :: Lens A B}, and""
  - ""The fact that our framework forms a lax monoidal functor may suggest a connection to Haskell's Applicative class (McBride & Paterson 2008;Paterson 2012), which shares the same mathematical structure.""
  - ""In this section, we prove Theorem 6 (Proofs of Theorems 1 and 4 are similar and thus omitted). Our proof is based on the free theorems (Reynolds 1983;Voigtländer 2009b;Wadler 1989).""
  - ""parametricity states that, for a closed term f of a closed type τ, f is in τ 1 . Free theorems are theorems obtained by instantiating parametricity.""
  - ""we use the polymorphic nature of s and the fact that such a relation can depend on the choice of s, which is the reason why our proof becomes tricky.""",,"- The paper explicitly mentions the use of category theory, specifically the Yoneda lemma, as a foundation for their framework. This indicates that category theory is a key mathematical framework used in the paper.
 - The framework involves lifting lenses to functions and manipulating them, which is a characteristic of category theory, particularly in the context of functors and natural transformations.
 - The mention of a lax monoidal functor and its connection to Haskell's Applicative class suggests that the framework also involves concepts from type theory and functional programming.
 - The use of free theorems and parametricity indicates that the framework relies on type theory principles to guarantee properties such as well-behavedness.
 - The paper discusses the use of relational interpretations and relational actions, which are techniques from type theory used to prove properties about functions.
 - The limitations or constraints of the framework are not explicitly detailed in the provided quotes, but the use of specific mathematical properties and proof techniques suggests that there may be constraints related to the applicability of these methods.","- ""Ideally, bidirectional programming should be as easy as usual unidirectional programming. For this to be possible, techniques of conventional languages such as applicative-style and higher-order programming need to be available in the bidirectional languages, so that existing programming idioms and abstraction methods can be ported over.""
  - ""The key idea of our proposal is to lift lenses of type Lens (A 1 , . . . , A n ) B to lens functions of type""
  - ""Our work's unique ability to combine lenses and semantic bidirectionalization results in more applicability and control than those offered by bidirectionalization alone: user-defined lenses on base types can now be passed to higher-order functions.""
  - ""Our framework essentially bridges two very different approaches of bidirectional programming, namely the lens framework and Voigtländer's semantic bidirectionalization, creating a new programming style that is able to obtain benefits from both.""
  - ""Our framework can be viewed as a more general form of semantic bidirectionalization.""",,"- The paper discusses integrating two different approaches to bidirectional programming: the lens framework and semantic bidirectionalization. This integration is a key aspect of the study.
 - The integration mechanism involves lifting lenses to functions, which allows for applicative-style and higher-order programming techniques to be applied in bidirectional programming.
 - The interaction model between paradigms involves using the lens framework to represent bidirectional transformations and semantic bidirectionalization to handle the backward transformations.
 - The paper highlights the challenge of ensuring well-behavedness in the integrated framework, particularly in maintaining the bidirectional laws.
 - A novel translation technique is the lifting of lenses to functions, which enables the use of higher-order programming techniques in bidirectional programming.","- ""Our framework essentially bridges two very different approaches of bidirectional programming, namely the lens framework and Voigtländer's semantic bidirectionalization, creating a new programming style that is able to obtain benefits from both.""
  - ""Ideally, bidirectional programming should be as easy as usual unidirectional programming. For this to be possible, techniques of conventional languages such as applicative-style and higher-order programming need to be available in the bidirectional languages, so that existing programming idioms and abstraction methods can be ported over.""
  - ""The key idea of our proposal is to lift lenses of type Lens (A 1 , . . . , A n ) B to lens functions of type""
  - ""This function representation of lenses is open to manipulation in an applicative style, and can be passed to higher-order functions directly.""
  - ""In this section, we make the ideas developed in previous sections practical by extending the technique to lists and other data structures.""
  - ""We use traverse to define two functions that are able to extract data from the structure holding them (contents), and redecorate an ""empty"" structure with given data (fill Here, Const a b is an instance of the Haskell Functor that ignores its argument b.""
  - ""We can now define a generic lsequence function as follows.""
  - ""Following the example of lists, we have a generic unlifting function with length replaced by shape.""
  - ""The treatment of lists is an instance of the general case of container-like datatypes. We can view any container with n elements as an n-tuple, only to have list length replaced by the more general container shape.""",,"- The paper discusses the integration of different programming paradigms (lens framework and semantic bidirectionalization) to create a new programming style, which suggests a focus on abstraction mechanisms.
 - The mention of ""applicative-style and higher-order programming"" indicates a focus on generic programming methodologies that allow for abstraction and manipulation of functions.
 - The concept of lifting lenses to functions and manipulating them in an applicative style is a mechanism for representing generic abstractions.
 - The use of ""traverse"" and ""lsequence"" functions suggests a generic programming approach to handling data structures like lists and other containers.
 - The paper does not explicitly define a ""concept"" in the context of generic programming, but it implies the use of abstract concepts like lenses and higher-order functions.
 - Minimal type requirements are not explicitly identified, but the use of type constraints like ""Eq s"" and ""Traversable t"" suggests some type requirements for generic functions.
 - Static checking or optimization strategies are not explicitly mentioned, but the use of type constraints and generic functions implies some level of static checking.","- ""Our framework essentially bridges two very different approaches of bidirectional programming, namely the lens framework and Voigtländer's semantic bidirectionalization, creating a new programming style that is able to obtain benefits from both.""
  - ""Our framework can be viewed as a more general form of semantic bidirectionalization.""
  - ""Our work's unique ability to combine lenses and semantic bidirectionalization results in more applicability and control than those offered by bidirectionalization alone: user-defined lenses on base types can now be passed to higher-order functions.""
  - ""By using the Yoneda embedding, we obtained the covariant monoidal functor Lens S (-) that maps lenses of type Lens A B to functions Lens S A → Lens S B, where S is a Poset instance""
  - ""Our goal is to develop a representation of bidirectional transformations such that we can apply them, pass them to higher-order functions and reason about well-behavedness compositionally.""",,"- The paper introduces a novel framework that combines the strengths of two existing approaches: the lens framework and semantic bidirectionalization. This integration is a key theoretical contribution as it allows for a more flexible and powerful programming style.
 - The framework enables the lifting of lenses to functions, which can be composed and passed to higher-order functions, enhancing the expressiveness and applicability of bidirectional programming.
 - The use of the Yoneda embedding to create a covariant monoidal functor is a significant theoretical advancement, as it provides a mathematical foundation for the framework's compositional properties.
 - The framework's ability to handle higher-order functions and abstract types is a theoretical innovation that expands the capabilities of bidirectional programming.
 - The paper's approach has potential implications for programming language design by providing a more general and flexible framework for bidirectional transformations, which could lead to more efficient and expressive programming paradigms."
Conceptual Evolution of Object-Oriented Programming,P. Wegner,-,-,-,7,1989,Not specified (the abstract does not explicitly define any conceptual primitives or their definitions),Not specified (the abstract mentions mathematical models but does not specify the type of framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"The study provides a comprehensive review and analysis of object-oriented programming's theoretical foundations, exploring language design alternatives and mathematical models for OOP concepts. It also speculates on future directions, potentially identifying theoretical advancements in programming language design.","- ""Starting from software engineering goals, we examine the origins and paradigms of object-oriented programming.""
  - ""We address the following questions for object-oriented programming: What are its goals? What are its origins? What are its paradigms? What are its design alternatives? What are its models of concurrency? What are its formal computational models? What comes after object-oriented programming?""
  - ""Finally, we briefly speculate on what may come after object-oriented programming.""
  - ""Language design alternatives for objects, classes, inheritance, and object-based concurrency are then explored, and mathematical models for objects, types, inheritance, and reflection are reviewed.""",,"- The abstract discusses various aspects of object-oriented programming, such as goals, origins, paradigms, design alternatives, models of concurrency, and formal computational models.
 - It mentions examining the origins and paradigms of object-oriented programming, which suggests a focus on understanding the foundational concepts.
 - The abstract also mentions exploring language design alternatives for objects, classes, inheritance, and object-based concurrency, as well as reviewing mathematical models for these concepts.
 - However, the abstract does not explicitly define any conceptual primitives. It discusses various concepts related to object-oriented programming but does not specify any primitives or their definitions.
 - The abstract does not provide any information on the level of abstraction or orthogonality of any primitives.","- ""Language design alternatives for objects, classes, inheritance, and object-based concurrency are then explored, and mathematical models for objects, types, inheritance, and reflection are reviewed.""",,"- The abstract mentions ""mathematical models for objects, types, inheritance, and reflection,"" which suggests that some form of mathematical framework is discussed in the paper.
 - However, the abstract does not specify the type of mathematical framework used (e.g., type theory, category theory).
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework.
 - The abstract does not provide details about the theoretical foundations, proof methodology, or formal verification discussions related to the mathematical framework.","- ""Starting from software engineering goals, we examine the origins and paradigms of object-oriented programming.""
  - ""mathematical models for objects, types, inheritance, and reflection are reviewed.""
  - ""Language design alternatives for objects, classes, inheritance, and object-based concurrency are then explored,""
  - ""What are its paradigms?""",,"- The abstract mentions examining the ""paradigms"" of object-oriented programming, which suggests a focus on understanding different programming paradigms.
 - The exploration of ""language design alternatives"" and ""mathematical models"" implies a discussion of how different elements within object-oriented programming are integrated or interact.
 - However, there is no explicit mention of a ""Programming Paradigm Integration Approach"" or specific mechanisms, models, constraints, or techniques related to integrating different programming paradigms.
 - The abstract does not provide details on how different paradigms are integrated or interact, nor does it mention any novel translation or embedding techniques.","- ""Finally, we briefly speculate on what may come after object-oriented programming.""
  - ""Starting from software engineering goals, we examine the origins and paradigms of object-oriented programming.""
  - ""Language design alternatives for objects, classes, inheritance, and object-based concurrency are then explored, and mathematical models for objects, types, inheritance, and reflection are reviewed.""
  - ""What are its goals? What are its origins? What are its paradigms? What are its design alternatives? What are its models of concurrency? What are its formal computational models?""",,"- The abstract does not mention ""genericity and abstraction mechanisms"" or any related terms such as ""generic programming,"" ""abstraction,"" or ""type requirements.""
 - The focus of the abstract is on the conceptual evolution of object-oriented programming, including its goals, origins, paradigms, design alternatives, concurrency models, and formal computational models.
 - There is no specific section or mention of a ""generic programming methodology section"" or ""type system discussions"" that would typically address genericity and abstraction mechanisms.
 - The abstract does not provide any information on mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.","- ""Language design alternatives for objects, classes, inheritance, and object-based concurrency are then explored, and mathematical models for objects, types, inheritance, and reflection are reviewed.""
  - ""Starting from software engineering goals, we examine the origins and paradigms of object-oriented programming.""
  - ""We address the following questions for object-oriented programming: What are its goals? What are its origins? What are its paradigms? What are its design alternatives? What are its models of concurrency? What are its formal computational models? What comes after object-oriented programming?""
  - ""Finally, we briefly speculate on what may come after object-oriented programming.""",,"- The abstract indicates that the study addresses fundamental questions about object-oriented programming (OOP), such as its goals, origins, paradigms, design alternatives, models of concurrency, and formal computational models. This suggests a comprehensive review and analysis of OOP's theoretical foundations.
 - The exploration of language design alternatives and mathematical models for OOP concepts like objects, classes, inheritance, and reflection implies a theoretical contribution by providing new insights into these areas.
 - The speculation on what comes after OOP suggests a forward-looking perspective, potentially identifying future directions or theoretical advancements in programming language design.
 - The abstract does not explicitly mention specific novel insights or theoretical advancements beyond existing approaches, but the comprehensive examination and speculation on future directions imply a contribution to the theoretical understanding of OOP."
Reactive Imperative Programming with Dataflow Constraints,"C. Demetrescu, Irene Finocchi, Andrea Ribichini",10.1145/2623200,https://doi.org/10.1145/2623200,ACM Transactions on Programming Languages and Systems,1,2014,"1. Primitive Name: Reactive Memory Locations
  Definition: Memory that can be read and written like ordinary memory but logs dependencies when accessed by constraints.
  Orthogonality Score: High
 

 2. Primitive Name: Constraints
  Definition: Commands in the host language that are automatically re-evaluated when the reactive memory locations they depend on are changed.
  Orthogonality Score: High","- Type of mathematical framework: Iterative process to find a common fixpoint
 - Specific mathematical properties guaranteed: Convergence to a common fixpoint, deterministic results
 - Proof techniques used: Results from function iterations
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Altering the semantics of operations for reading and modifying objects to integrate dataflow constraints into imperative languages.
 - Interaction models between paradigms: Using reactive memory locations and constraints written as ordinary commands in the host language.
 - Constraints or challenges in paradigm integration: Programmers are not forced to use special data types, which was a limitation in previous approaches.
 - Any novel translation or embedding techniques: Not explicitly mentioned beyond altering operation semantics.","- Definition of ""concept"" used: Constraints are defined using ordinary statements of the host language, allowing for genericity across different types.
 - Mechanisms for representing generic abstractions: Constraints can be written as arbitrary code, including loops, conditionals, function calls, and recursion, and can reference variables indirectly via pointers.
 - Minimal type requirements identified: Not explicitly mentioned; relies on the host language's type system.
 - Static checking or optimization strategies: Not explicitly mentioned; automatic dependency detection is a dynamic mechanism.","- Integration of one-way dataflow constraints into imperative languages for performance-critical reactive applications.
 - Generic constraints between objects of arbitrary types without requiring special data types.
 - Use of reactive memory locations and constraints as key notions for efficient incremental computations.
 - Formal semantics for the framework.
 - Handling of cyclic constraints, enabling solutions to previously unsolvable problems.
 - Flexibility in scheduling mechanisms and proof of convergence to the least common fixpoint.","- ""Our approach hinges upon two key notions: reactive memory locations and constraints.""
  - ""If the value stored in a reactive memory location ℓ is changed, all constraints depending on ℓ (i.e., all constraints c such that (ℓ, c) ∈ D) are automatically reexecuted.""
  - ""The main feature of a constraint is its sensitivity to modifications of reactive objects: a constraint is automatically re-evaluated whenever any of the reactive locations it depends on is changed, either by the imperative program, or by another constraint.""
  - ""Constraints are written as ordinary commands of the host imperative language and can be added and removed dynamically at run time.""",,"- The paper identifies two key conceptual primitives: ""reactive memory locations"" and ""constraints.""
 - Reactive memory locations are defined as memory that can be read and written like ordinary memory but with the additional feature of logging dependencies when accessed by constraints.
 - Constraints are defined as commands in the host language that are automatically re-evaluated when the reactive memory locations they depend on are changed.
 - These primitives are orthogonal as they serve distinct purposes: reactive memory locations are about data storage and dependency tracking, while constraints are about computation and automatic re-evaluation.
 - The level of abstraction is high as these primitives are fundamental to the framework and can be applied across various programming contexts.","- ""We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers.""
  - ""In Section 2 we abstract our mechanism showing how to extend an elementary imperative language to support one-way dataflow constraints using reactive memory.""
  - ""We formally describe our mixed imperative/dataflow computational model by defining the interactions between these modes and providing a formal semantics of our mechanism.""
  - ""In Section 3 we discuss convergence of the dataflow constraint solver by modeling the computation as an iterative process that aims at finding a common fixpoint for the current set of constraints.""
  - ""Using results from the theory of function iterations [15], we show that any arbitrary collection of inflationary one-way constraints has the desired property.""
  - ""We can now discuss convergence properties of our solver:
 

 PROOF (SKETCH). Consider the sequence S 0 , S 1 , . . . of scheduling sets resulting from a recursive application of rule SOLVER-2 terminated by rule SOLVER-1 (see Figure 4 ), with S 0 = S.""
  - ""Assuming that functions in Lemma 1 and Theorem 1 are also monotonic, it is possible to prove that the solver always converges to the least common fixpoint, yielding deterministic results independently of the scheduling order.""
  - ""A more general approach, which we follow in our work, consists of modeling dataflow constraint solving as an iterative process that aims at finding a common fixpoint for the current set of constraints.""",,"- The paper provides a formal semantics for the dataflow constraint system, indicating a structured mathematical framework.
 - The framework is based on an iterative process to find a common fixpoint, which suggests a focus on fixed-point theory.
 - The use of inflationary functions and the discussion of monotonicity imply a framework that guarantees convergence properties.
 - The proof techniques involve sketching the convergence properties using results from function iterations, indicating a reliance on mathematical theories related to iterative processes.
 - The framework is designed to ensure deterministic results regardless of scheduling order, which is a specific mathematical property guaranteed by the framework.
 - The paper does not explicitly mention a specific type of mathematical framework like type theory or category theory, but it does discuss formal semantics and iterative processes.","- ""In this article, we show that one-way dataflow constraints, largely explored in the context of interactive applications, can be seamlessly integrated in any imperative language and can be used as a general paradigm for writing performance-critical reactive applications that require efficient incremental computations.""
  - ""The constraint-solving mechanism is handled transparently by altering the semantics of elementary operations of the host language for reading and modifying objects.""
  - ""Differently from previous approaches, programmers are not forced to use any special data types provided by the language extension, and can resort to the full range of conventional constructs for accessing and manipulating objects offered by the host language.""
  - ""our framework supports all the other features that have been recognized to be important in the design of dataflow constraint systems [38], including:
 

 Arbitrary code: constraints consist of arbitrary code that is legal in the underlying imperative language, thus including loops, conditionals, function calls, and recursion.""
  - ""Our approach hinges upon two key notions: reactive memory locations and constraints.""
  - ""DC has exactly the same syntax as C/C++, but operations that read or modify objects have a different semantics.""
  - ""Constraints are written as ordinary commands of the host imperative language and can be added and removed dynamically at run time.""
  - ""the whole constraint solving mechanism is handled transparently by altering the semantics of elementary operations of the host imperative language for reading and modifying objects.""",,"- The paper discusses the integration of dataflow constraints into imperative languages, specifically C/C++, by altering the semantics of operations for reading and modifying objects. This is a key integration mechanism.
 - The interaction model involves using reactive memory locations and constraints that are written as ordinary commands in the host language, allowing for dynamic addition and removal.
 - The paper highlights that programmers are not forced to use special data types, which is a constraint or challenge in previous approaches.
 - The framework supports arbitrary code within constraints, which is a novel aspect as it allows for complex logic within constraints.
 - The paper does not mention any specific novel translation or embedding techniques beyond altering the semantics of operations.","- ""In our framework, programmers can define ordinary statements of the imperative host language that enforce constraints between objects stored in special memory locations designated as “reactive.” Reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures.""
  - ""Constraints are written as ordinary commands of the host imperative language and can be added and removed dynamically at run time.""
  - ""Differently from previous approaches, programmers are not forced to use any special data types provided by the language extension, and can resort to the full range of conventional constructs for accessing and manipulating objects offered by the host language.""
  - ""Arbitrary code: constraints consist of arbitrary code that is legal in the underlying imperative language, thus including loops, conditionals, function calls, and recursion.""
  - ""Address dereferencing: constraints are able to reference variables indirectly via pointers.""
  - ""Automatic dependency detection: constraints automatically detect the reactive memory locations they depend on during their evaluation, so there is no need for programmers to explicitly declare dependencies, which are also allowed to vary over time.""",,"- The paper discusses a framework where constraints can be defined using ordinary statements of the host language, which implies a level of genericity in terms of the types of objects that can be used.
 - The ability to use any legal type in the host language, including primitive types, pointers, arrays, and structures, suggests a broad mechanism for representing generic abstractions.
 - The mention of ""arbitrary code"" and ""address dereferencing"" indicates flexibility in how constraints can be defined and interact with memory locations.
 - The automatic dependency detection mechanism suggests a dynamic approach to managing dependencies, which is a form of abstraction.
 - The paper does not explicitly discuss minimal type requirements or static checking strategies, but the focus on using existing language constructs implies a reliance on the host language's type system.","- ""In this article, we show that one-way dataflow constraints, largely explored in the context of interactive applications, can be seamlessly integrated in any imperative language and can be used as a general paradigm for writing performance-critical reactive applications that require efficient incremental computations.""
  - ""Our Contributions. We present a general-purpose framework where programmers can specify generic one-way constraints between objects of arbitrary types stored in reactive memory locations.""
  - ""Differently from previous approaches, programmers are not forced to use any special data types provided by the language extension, and can resort to the full range of conventional constructs for accessing and manipulating objects offered by the host language.""
  - ""Our approach hinges upon two key notions: reactive memory locations and constraints.""
  - ""We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers.""
  - ""We discuss common coding idioms and relevant applications to reactive scenarios, including incremental computation, observer design pattern, data structure repair, and software visualization.""
  - ""Differently from previous approaches to solving one-way dataflow constraints [6,17,26,27], which were targeted to acyclic dependencies, our abstract machine can handle the most general case of cyclic constraints embedded within an imperative program.""
  - ""This opens up the possibility to address problems that would not be solvable using acyclic dataflow graphs, backed up with a formal machinery to help designers prove their convergence properties (Section 3.1).""
  - ""We remark that any scheduling mechanism may be used for selecting from S the next constraint to be evaluated: in this abstract model we rely on a function pick that implements any appropriate scheduling strategy.""
  - ""Assuming that functions in Lemma 1 and Theorem 1 are also monotonic, it is possible to prove that the solver always converges to the least common fixpoint, yielding deterministic results independently of the scheduling order.""",,"- The paper introduces a novel framework that integrates one-way dataflow constraints into imperative languages, which is a significant theoretical contribution as it expands the applicability of dataflow constraints beyond interactive applications.
 - The framework allows for generic constraints between objects of arbitrary types, which is a theoretical advancement over previous approaches that required special data types.
 - The use of reactive memory locations and constraints as key notions is a theoretical innovation that enables efficient incremental computations.
 - The provision of a formal semantics for the framework is a theoretical contribution that ensures a solid foundation for understanding and analyzing the behavior of the system.
 - The ability to handle cyclic constraints is a significant theoretical advancement, as it allows for solving problems that were previously unsolvable with acyclic dataflow graphs.
 - The flexibility in scheduling mechanisms and the proof of convergence to the least common fixpoint are theoretical contributions that enhance the robustness and predictability of the framework."
On the Semantics of ReFLect as a Basis for a Reflective Theorem Prover,"T. Melham, Raphael Cohn, Ian Childs",-,-,arXiv.org,7,2013,Not specified (the abstract does not explicitly define conceptual primitives or their characteristics),"- Type of mathematical framework: Lambda-calculus, combinatory logic, higher-order logic (LCF paradigm)
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Unification of object- and meta-languages, intermixing program evaluation and logical deduction through reflection mechanisms.
 - Interaction models between paradigms: Integration of functional programming (ML) and logical reasoning.
 - Constraints or challenges in paradigm integration: Difficulties with the semantics of reFLect as currently defined.
 - Any novel translation or embedding techniques: Minimal modification of the type system to address semantic difficulties.",Generic programming not extensively addressed,"- Key novel insights: Exploration of reFLect's semantics, integration of object- and meta-languages in a higher-order logic theorem prover.
 - Theoretical advancements: Unification of object- and meta-languages, introduction of a primitive data type for abstract syntax trees.
 - Potential implications: Novel approach to combining program evaluation and logical deduction, potential improvements in programming language design for hardware verification.","- ""We identify some difficulties with the semantics of reFLect as currently defined, and propose a minimal modification of the type system that avoids these problems.""
  - ""The aim is to intermix program evaluation and logical deduction through reflection mechanisms.""
  - ""Following the LCF paradigm, this is intended to serve as the object language of a higher-order logic theorem prover for specification and reasoning - but one in which object- and meta-languages are unified.""
  - ""ReFLect is similar to ML, but has a primitive data type whose elements are the abstract syntax trees of reFLect expressions themselves.""
  - ""This paper explores the semantics of a combinatory fragment of reFLect, the lambda-calculus underlying a functional language used by Intel Corporation for hardware design and verification.""",,"- The abstract mentions that ReFLect has a ""primitive data type whose elements are the abstract syntax trees of reFLect expressions themselves."" This suggests a conceptual primitive related to the representation of abstract syntax trees within the language.
 - The mention of ""reflection mechanisms"" implies another conceptual primitive related to the intermixing of program evaluation and logical deduction.
 - The abstract does not provide explicit definitions or names for these primitives, nor does it discuss their orthogonality or level of abstraction.
 - The focus is on the semantics and modifications to the type system rather than explicitly defining conceptual primitives.","- ""This paper explores the semantics of a combinatory fragment of reFLect, the lambda-calculus underlying a functional language used by Intel Corporation for hardware design and verification.""
  - ""ReFLect is similar to ML, but has a primitive data type whose elements are the abstract syntax trees of reFLect expressions themselves.""
  - ""We identify some difficulties with the semantics of reFLect as currently defined, and propose a minimal modification of the type system that avoids these problems.""
  - ""Following the LCF paradigm, this is intended to serve as the object language of a higher-order logic theorem prover for specification and reasoning - but one in which object- and meta-languages are unified.""
  - ""The aim is to intermix program evaluation and logical deduction through reflection mechanisms.""",,"- The abstract mentions that reFLect is based on lambda-calculus, which is a type of mathematical framework used in functional programming and logic.
 - The mention of ""combinatory fragment"" suggests a focus on combinatory logic, which is a part of type theory.
 - The reference to the LCF (Logic for Computable Functions) paradigm indicates a connection to higher-order logic, which is a mathematical framework used for theorem proving.
 - The abstract discusses the unification of object- and meta-languages, which is a characteristic of reflective systems in type theory.
 - The mention of ""reflection mechanisms"" implies the use of reflective techniques in the mathematical framework.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, nor does it detail limitations or constraints of the framework.","- ""The aim is to intermix program evaluation and logical deduction through reflection mechanisms.""
  - ""Following the LCF paradigm, this is intended to serve as the object language of a higher-order logic theorem prover for specification and reasoning - but one in which object- and meta-languages are unified.""
  - ""We identify some difficulties with the semantics of reFLect as currently defined, and propose a minimal modification of the type system that avoids these problems.""
  - ""ReFLect is similar to ML, but has a primitive data type whose elements are the abstract syntax trees of reFLect expressions themselves.""",,"- The abstract mentions that ReFLect is similar to ML, indicating a connection between functional programming (ML) and the reflective capabilities of ReFLect.
 - The integration of object- and meta-languages suggests a unification of different programming paradigms, specifically functional programming and logical reasoning.
 - The aim to ""intermix program evaluation and logical deduction through reflection mechanisms"" implies a mechanism for integrating different paradigms by allowing for the evaluation of programs and logical deductions within the same framework.
 - The mention of ""some difficulties with the semantics of reFLect"" and a proposed ""minimal modification of the type system"" suggests challenges in integrating these paradigms and a strategy to address these challenges.","- ""The aim is to intermix program evaluation and logical deduction through reflection mechanisms.""
  - ""We identify some difficulties with the semantics of reFLect as currently defined, and propose a minimal modification of the type system that avoids these problems.""
  - ""Following the LCF paradigm, this is intended to serve as the object language of a higher-order logic theorem prover for specification and reasoning - but one in which object- and meta-languages are unified.""
  - ""ReFLect is similar to ML, but has a primitive data type whose elements are the abstract syntax trees of reFLect expressions themselves.""
  - ""This paper explores the semantics of a combinatory fragment of reFLect, the lambda-calculus underlying a functional language used by Intel Corporation for hardware design and verification.""",,"- The abstract discusses the semantics of reFLect, a functional language used for hardware design and verification, which is similar to ML but includes a unique data type based on abstract syntax trees.
 - The focus is on the integration of object and meta-languages within a higher-order logic theorem prover, which suggests a level of abstraction but does not explicitly address generic programming.
 - The mention of ""reflection mechanisms"" implies some form of abstraction, but it is not explicitly linked to generic programming.
 - The abstract does not provide specific details on generic programming methodology, type system discussions, or abstraction mechanism explanations that are directly related to genericity and abstraction mechanisms.
 - The focus is more on the semantics and type system modifications rather than generic programming or abstraction mechanisms.","- ""This paper explores the semantics of a combinatory fragment of reFLect, the lambda-calculus underlying a functional language used by Intel Corporation for hardware design and verification.""
  - ""We identify some difficulties with the semantics of reFLect as currently defined, and propose a minimal modification of the type system that avoids these problems.""
  - ""ReFLect is similar to ML, but has a primitive data type whose elements are the abstract syntax trees of reFLect expressions themselves.""
  - ""The aim is to intermix program evaluation and logical deduction through reflection mechanisms.""
  - ""Following the LCF paradigm, this is intended to serve as the object language of a higher-order logic theorem prover for specification and reasoning - but one in which object- and meta-languages are unified.""",,"- The abstract discusses the exploration of the semantics of reFLect, which is a novel aspect as it involves understanding the underlying lambda-calculus and its application in hardware design and verification.
 - The mention of reFLect being similar to ML but with a unique primitive data type indicates a theoretical advancement in terms of language design, as it introduces a new way of handling abstract syntax trees.
 - The integration of object- and meta-languages within a higher-order logic theorem prover is a significant theoretical contribution, as it unifies these typically separate components.
 - The aim to intermix program evaluation and logical deduction through reflection mechanisms suggests a novel approach to combining programming and logical reasoning, which is a theoretical innovation.
 - The proposal of a minimal modification to the type system to address existing difficulties indicates a theoretical advancement in resolving semantic issues, which is a contribution to the field."
On integration of programming paradigms,A. Mycroft,10.1145/234528.234735,https://doi.org/10.1145/234528.234735,CSUR,5,1996,si,si,si,si,si,"- ""The aim of this paper is to expound an algebraic view of such integration.""
  - ""Integrating subprograms written in varying source languages Si, i ∈ {1, 2} intuitively represents writing in the union of these languages; actually what we mean is a target language expressive enough to express concepts from all the source languages.""
  - ""If the languages all had a single sort (syntactic category) then this could be the language generated by the union of the constructors of the source languages.""
  - ""More thought leads us to a target language T which has embeddings θi : Si → T""
  - ""The θi should be injective at the semantic level thus, given si, s ′ i ∈ Si, we require [[si]] 6= [[s ′ i]] ⇒ [[θisi]] 6= [[θis ′ i]].""
  - ""There are various alternative forms of interaction possible: the least expressive is a pairing constructor which allows us write a program (s1, s2) consisting of programs si ∈ Si""
  - ""If there are operators (e.g. ‘;’) which we wish to identify in the Si then we can require [[(s1, s2); (s ′ 1 , s 2 )]] = [[(s1; s ′ 1 , s2; s ′ 2""
  - ""This is handled by adding constructors to T which represent the interaction (correspondence) between constructs in the Si.""",,"- The abstract discusses an algebraic view of integrating programming paradigms, which suggests a theoretical framework for conceptual primitives.
 - The concept of a ""target language T"" with ""embeddings θi : Si → T"" implies a primitive related to language integration.
 - The requirement for injectivity at the semantic level suggests a primitive related to semantic consistency.
 - The mention of a ""pairing constructor"" and operators like ';' suggests primitives related to program composition and interaction.
 - The abstract does not explicitly list or define specific conceptual primitives, but it discusses elements that could be considered as such in the context of integrating programming paradigms.","- ""The aim of this paper is to expound an algebraic view of such integration.""
  - ""Work with related aims but differing starting points can be found in the “Action Semantics” approach [2] and the “Monads” view of feature composition (see e.g. [1]).""
  - ""Integrating subprograms written in varying source languages Si, i ∈ {1, 2} intuitively represents writing in the union of these languages; actually what we mean is a target language expressive enough to express concepts from all the source languages.""
  - ""If the languages all had a single sort (syntactic category) then this could be the language generated by the union of the constructors of the source languages.""
  - ""More thought leads us to a target language T which has embeddings θi : Si → T . The θi should be injective at the semantic level thus, given si, s ′ i ∈ Si, we require [[si]] 6= [[s ′ i]] ⇒ [[θisi]] 6= [[θis ′ i]].""
  - ""There are various alternative forms of interaction possible: the least expressive is a pairing constructor which allows us write a program (s1, s2) consisting of programs si ∈ Si (as they cannot yet interact it is pointless to discuss whether evaluation happens in parallel or not).""
  - ""If there are operators (e.g. ‘;’) which we wish to identify in the Si then we can require [[(s1, s2); (s ′ 1 , s 2 )]] = [[(s1; s ′ 1 , s2; s ′ 2""
  - ""This is handled by adding constructors to T which represent the interaction (correspondence) between constructs in the Si.""",,"- The abstract mentions an ""algebraic view"" of integration, which suggests that the mathematical framework is based on algebraic concepts.
 - The reference to ""Action Semantics"" and ""Monads"" indicates that these frameworks are related to the work, but they are not explicitly stated as part of the mathematical framework used in this paper.
 - The discussion of a target language T with embeddings θi : Si → T and the requirement for injectivity at the semantic level suggests a focus on semantic properties and possibly category theory, as embeddings are a common concept in category theory.
 - The mention of constructors and the union of languages implies a type of algebraic structure, possibly related to type theory or category theory.
 - The abstract does not explicitly mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""The aim of this paper is to expound an algebraic view of such integration.""
  - ""Integrating subprograms written in varying source languages Si, i ∈ {1, 2} intuitively represents writing in the union of these languages; actually what we mean is a target language expressive enough to express concepts from all the source languages.""
  - ""If the languages all had a single sort (syntactic category) then this could be the language generated by the union of the constructors of the source languages.""
  - ""More thought leads us to a target language T which has embeddings θi : Si → T . The θi should be injective at the semantic level thus, given si, s ′ i ∈ Si, we require [[si]] 6= [[s ′ i]] ⇒ [[θisi]] 6= [[θis ′ i]].""
  - ""There are various alternative forms of interaction possible: the least expressive is a pairing constructor which allows us write a program (s1, s2) consisting of programs si ∈ Si (as they cannot yet interact it is pointless to discuss whether evaluation happens in parallel or not).""
  - ""If there are operators (e.g. ‘;’) which we wish to identify in the Si then we can require [[(s1, s2); (s ′ 1 , s 2 )]] = [[(s1; s ′ 1 , s2; s ′ 2""
  - ""In practice we require more complex interaction: for example, if S1 is Pascal and S2 is Haskell, we might desire variables effectively to coincide, so that writing x in S1 affects reading x in S2 (or more structured constructs to access a procedure in S1 with values from S2).""
  - ""This is handled by adding constructors to T which represent the interaction (correspondence) between constructs in the Si.""
  - ""This in general causes surprising degrees of complexity.""",,"- The abstract discusses an ""algebraic view of such integration,"" indicating a theoretical approach to integrating different programming paradigms.
 - The integration involves creating a target language that can express concepts from all source languages, suggesting a focus on semantic embeddings.
 - The use of embeddings θi : Si → T implies a mechanism for translating or embedding source languages into a target language.
 - The abstract mentions a pairing constructor as a basic form of interaction, which allows for combining programs from different paradigms.
 - More complex interactions are achieved by adding constructors that represent correspondence between constructs in different paradigms, such as variable coincidence or procedure access.
 - The abstract notes that this integration process can lead to surprising degrees of complexity, highlighting a challenge in paradigm integration.","- ""The aim of this paper is to expound an algebraic view of such integration.""
  - ""Integrating subprograms written in varying source languages Si, i ∈ {1, 2} intuitively represents writing in the union of these languages; actually what we mean is a target language expressive enough to express concepts from all the source languages.""
  - ""If the languages all had a single sort (syntactic category) then this could be the language generated by the union of the constructors of the source languages.""
  - ""More thought leads us to a target language T which has embeddings θi : Si → T""
  - ""The θi should be injective at the semantic level thus, given si, s ′ i ∈ Si, we require [[si]] 6= [[s ′ i]] ⇒ [[θisi]] 6= [[θis ′ i]].""
  - ""There are various alternative forms of interaction possible: the least expressive is a pairing constructor which allows us write a program (s1, s2) consisting of programs si ∈ Si (as they cannot yet interact it is pointless to discuss whether evaluation happens in parallel or not).""
  - ""If there are operators (e.g. ‘;’) which we wish to identify in the Si then we can require [[(s1, s2); (s ′ 1 , s 2 )]] = [[(s1; s ′ 1 , s2; s ′ 2""
  - ""In practice we require more complex interaction: for example, if S1 is Pascal and S2 is Haskell, we might desire variables effectively to coincide, so that writing x in S1 affects reading x in S2 (or more structured constructs to access a procedure in S1 with values from S2).""
  - ""This is handled by adding constructors to T which represent the interaction (correspondence) between constructs in the Si.""",,"- The abstract discusses the integration of programming paradigms, focusing on an algebraic view. This suggests a focus on abstract representations rather than specific generic programming methodologies.
 - The concept of ""concept"" is related to the integration of different programming languages into a coherent whole, where a target language is expressive enough to represent concepts from all source languages.
 - Mechanisms for representing generic abstractions are hinted at through the use of embeddings (θi : Si → T) and the requirement for injectivity at the semantic level. This implies a way to abstractly represent different language constructs within a unified framework.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, which are typical components of generic programming.
 - The focus is more on the integration and interaction between different programming paradigms rather than specific generic programming techniques or type systems.","- ""The aim of this paper is to expound an algebraic view of such integration.""
  - ""Work with related aims but differing starting points can be found in the “Action Semantics” approach [2] and the “Monads” view of feature composition (see e.g. [1]).""
  - ""Integrating subprograms written in varying source languages Si, i ∈ {1, 2} intuitively represents writing in the union of these languages; actually what we mean is a target language expressive enough to express concepts from all the source languages.""
  - ""More thought leads us to a target language T which has embeddings θi : Si → T . The θi should be injective at the semantic level thus, given si, s ′ i ∈ Si, we require [[si]] 6= [[s ′ i]] ⇒ [[θisi]] 6= [[θis ′ i]].""
  - ""There are various alternative forms of interaction possible: the least expressive is a pairing constructor which allows us write a program (s1, s2) consisting of programs si ∈ Si (as they cannot yet interact it is pointless to discuss whether evaluation happens in parallel or not).""
  - ""In practice we require more complex interaction: for example, if S1 is Pascal and S2 is Haskell, we might desire variables effectively to coincide, so that writing x in S1 affects reading x in S2 (or more structured constructs to access a procedure in S1 with values from S2).""
  - ""This is handled by adding constructors to T which represent the interaction (correspondence) between constructs in the Si.""",,"- The abstract introduces an ""algebraic view of such integration,"" which suggests a novel theoretical contribution by providing a new perspective on integrating programming paradigms.
 - The mention of ""related aims but differing starting points"" indicates that this work builds upon existing approaches like ""Action Semantics"" and ""Monads,"" but with a distinct focus on algebraic integration.
 - The concept of a ""target language T"" with embeddings from source languages is a theoretical advancement, as it provides a framework for integrating different paradigms into a coherent whole.
 - The requirement for injective embeddings at the semantic level is a key theoretical contribution, ensuring that the integration preserves the semantic integrity of the source languages.
 - The discussion of various interaction forms, including pairing constructors and more complex interactions, highlights theoretical advancements in enabling communication between different programming paradigms.
 - The potential implications for programming language design are significant, as this work could inform the development of languages that can seamlessly integrate different paradigms, enhancing programming ease and flexibility."
The Concurrent Constraint Programming Research Programmes,V. Saraswat,10.1007/3-540-60299-2_36,https://doi.org/10.1007/3-540-60299-2_36,International Conference on Principles and Practice of Constraint Programming,1,1995,"1. Primitive Name: Monotonic Accumulation of Information
  Definition: Mathematical models of computation characterized by monotonic accumulation of information
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Control Features
  Definition: General and fully abstract models for different combinations of control features
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Encapsulated Non-Determinism
  Definition: Emphasis on encapsulated non-determinism in languages like AKL
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Declarative Modeling
  Definition: Explicit declarative modeling of systems and processes
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Constraints
  Definition: Constraints arise naturally in analyzing and modeling physical systems
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Time Representation and Time-Based Control Constructs
  Definition: Flexible representation of time and time-based control constructs for modeling physical systems
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention the type of mathematical framework or specific proof techniques used),"- Specific integration mechanisms proposed: Combination of concurrent logic programming and constraint logic programming; development of languages like AKL; integration of ideas from synchronous programming for discrete timed and hybrid CCP.
 - Interaction models between paradigms: CCP as a foundational paradigm for concurrent computation; extension to constraint logic programming.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Novel combination of concurrent logic programming and constraint logic programming in the style of process algebras.
 - Development of mathematical models of computation characterized by monotonic accumulation of information.
 - General and fully abstract models for different combinations of control features and connections between operational semantics and logical deduction.
 - Use of CCP as a basis for model-based computing and development of languages like AKL with encapsulated non-determinism.
 - Integration of ideas from synchronous programming for discrete timed and hybrid CCP.","- ""Concurrent constraint programming (CCP) was introduced eight years ago as a simple combination of ideas from concurrent logic programming and constraint logic programming, developed in the style of process algebras.""
  - ""CCP has been explored as a foundational paradigm for concurrent computation, resulting in the development of mathematical models of computation characterized by monotonic accumulation of information.""
  - ""Several concrete results have been obtained, including general and fully abstract models for different combinations of control features, and connections between operational semantics and logical deduction.""
  - ""CCP has been pursued as a clean conceptualization of concurrent logic programming — leading for example, to work on failure-free systems for distributed computation, such as Janus — and as an extension to constraint logic programming, as in the development of the language AKL, which emphasizes encapsulated non-determinism.""
  - ""CCP has been used as the basis for instantiating an approach to software development (called model-based computing) based on explicit declarative modeling of the systems and processes at hand, and on the systematic, rigorous generation from these models of software for simulating, controlling, diagnosing and documenting these systems.""
  - ""Constraints arise very naturally in analyzing and modeling physical systems, and CCP languages therefore provide a powerful declarative cum procedural formalism for this approach.""
  - ""However, a flexible representation of time, and time-based control constructs, is crucial for modeling physical systems; and this focus has led to the development of discrete timed and hybrid CCP, obtained by integrating in ideas from synchronous programming.""",,"- The abstract discusses the development of Concurrent Constraint Programming (CCP) as a combination of ideas from concurrent logic programming and constraint logic programming, developed in the style of process algebras. This suggests that the conceptual primitives are related to these foundational elements.
 - The mention of ""mathematical models of computation characterized by monotonic accumulation of information"" implies that one of the conceptual primitives is the monotonic accumulation of information, which is a fundamental concept in CCP.
 - The abstract also refers to ""general and fully abstract models for different combinations of control features,"" which suggests that control features are another set of conceptual primitives.
 - The development of languages like AKL, which emphasizes ""encapsulated non-determinism,"" indicates that non-determinism is a conceptual primitive in CCP.
 - The use of CCP for ""model-based computing"" and the emphasis on ""explicit declarative modeling"" suggest that declarative modeling is a conceptual primitive.
 - The mention of ""constraints"" and their natural occurrence in physical systems implies that constraints are a fundamental conceptual primitive in CCP.
 - The development of ""discrete timed and hybrid CCP"" suggests that time representation and time-based control constructs are also conceptual primitives.","- ""CCP has been explored as a foundational paradigm for concurrent computation, resulting in the development of mathematical models of computation characterized by monotonic accumulation of information.""
  - ""Several concrete results have been obtained, including general and fully abstract models for different combinations of control features, and connections between operational semantics and logical deduction.""
  - ""Constraints arise very naturally in analyzing and modeling physical systems, and CCP languages therefore provide a powerful declarative cum procedural formalism for this approach.""",,"- The abstract mentions that CCP has been explored as a foundational paradigm for concurrent computation, which suggests a focus on theoretical foundations.
 - It states that mathematical models of computation have been developed, characterized by ""monotonic accumulation of information,"" which implies a specific mathematical property.
 - The mention of ""general and fully abstract models"" and ""connections between operational semantics and logical deduction"" suggests a formal verification approach, possibly involving proof techniques.
 - However, the abstract does not specify the type of mathematical framework (e.g., type theory, category theory) used to formalize these properties.
 - There is no explicit mention of specific proof techniques or limitations of the framework in the abstract.","- ""Concurrent constraint programming (CCP) was introduced eight years ago as a simple combination of ideas from concurrent logic programming and constraint logic programming, developed in the style of process algebras.""
  - ""CCP has been explored as a foundational paradigm for concurrent computation, resulting in the development of mathematical models of computation characterized by monotonic accumulation of information.""
  - ""CCP has been pursued as a clean conceptualization of concurrent logic programming — leading for example, to work on failure-free systems for distributed computation, such as Janus — and as an extension to constraint logic programming, as in the development of the language AKL, which emphasizes encapsulated non-determinism.""
  - ""CCP has been used as the basis for instantiating an approach to software development (called model-based computing) based on explicit declarative modeling of the systems and processes at hand, and on the systematic, rigorous generation from these models of software for simulating, controlling, diagnosing and documenting these systems.""
  - ""Constraints arise very naturally in analyzing and modeling physical systems, and CCP languages therefore provide a powerful declarative cum procedural formalism for this approach.""
  - ""a flexible representation of time, and time-based control constructs, is crucial for modeling physical systems; and this focus has led to the development of discrete timed and hybrid CCP, obtained by integrating in ideas from synchronous programming.""",,"- The abstract describes CCP as a combination of ideas from concurrent logic programming and constraint logic programming, indicating an integration of these paradigms.
 - The development of mathematical models and the emphasis on monotonic accumulation of information suggest a theoretical integration strategy.
 - The mention of CCP being used as a foundational paradigm for concurrent computation and its extension to constraint logic programming indicates interaction models between these paradigms.
 - The development of languages like AKL and the integration of ideas from synchronous programming for discrete timed and hybrid CCP suggest specific integration mechanisms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.","- ""Concurrent constraint programming (CCP) was introduced eight years ago as a simple combination of ideas from concurrent logic programming and constraint logic programming, developed in the style of process algebras.""
  - ""CCP has been explored as a foundational paradigm for concurrent computation, resulting in the development of mathematical models of computation characterized by monotonic accumulation of information.""
  - ""Several concrete results have been obtained, including general and fully abstract models for different combinations of control features, and connections between operational semantics and logical deduction.""
  - ""CCP has been pursued as a clean conceptualization of concurrent logic programming — leading for example, to work on failure-free systems for distributed computation, such as Janus — and as an extension to constraint logic programming, as in the development of the language AKL, which emphasizes encapsulated non-determinism.""
  - ""CCP has been used as the basis for instantiating an approach to software development (called model-based computing) based on explicit declarative modeling of the systems and processes at hand, and on the systematic, rigorous generation from these models of software for simulating, controlling, diagnosing and documenting these systems.""
  - ""Constraints arise very naturally in analyzing and modeling physical systems, and CCP languages therefore provide a powerful declarative cum procedural formalism for this approach.""",,"- The abstract discusses the development of concurrent constraint programming (CCP) as a combination of concurrent logic programming and constraint logic programming, which suggests a focus on conceptual abstraction by integrating different programming paradigms.
 - The mention of ""mathematical models of computation characterized by monotonic accumulation of information"" and ""general and fully abstract models"" indicates a focus on abstraction mechanisms, particularly in terms of mathematical modeling.
 - The development of languages like AKL, which emphasizes ""encapsulated non-determinism,"" suggests a mechanism for representing generic abstractions by encapsulating non-deterministic behavior.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, which are typically associated with generic programming methodologies.
 - The focus on ""model-based computing"" and ""explicit declarative modeling"" implies a conceptual abstraction mechanism, but it does not explicitly address generic programming in terms of type systems or static checking.","- ""Concurrent constraint programming (CCP) was introduced eight years ago as a simple combination of ideas from concurrent logic programming and constraint logic programming, developed in the style of process algebras.""
  - ""CCP has been explored as a foundational paradigm for concurrent computation, resulting in the development of mathematical models of computation characterized by monotonic accumulation of information.""
  - ""Several concrete results have been obtained, including general and fully abstract models for different combinations of control features, and connections between operational semantics and logical deduction.""
  - ""CCP has been pursued as a clean conceptualization of concurrent logic programming — leading for example, to work on failure-free systems for distributed computation, such as Janus — and as an extension to constraint logic programming, as in the development of the language AKL, which emphasizes encapsulated non-determinism.""
  - ""CCP has been used as the basis for instantiating an approach to software development (called model-based computing) based on explicit declarative modeling of the systems and processes at hand, and on the systematic, rigorous generation from these models of software for simulating, controlling, diagnosing and documenting these systems.""
  - ""Constraints arise very naturally in analyzing and modeling physical systems, and CCP languages therefore provide a powerful declarative cum procedural formalism for this approach.""
  - ""However, a flexible representation of time, and time-based control constructs, is crucial for modeling physical systems; and this focus has led to the development of discrete timed and hybrid CCP, obtained by integrating in ideas from synchronous programming.""",,"- The abstract introduces Concurrent Constraint Programming (CCP) as a novel combination of concurrent logic programming and constraint logic programming, developed in the style of process algebras. This represents a key novel insight by integrating different programming paradigms.
 - The development of mathematical models of computation characterized by monotonic accumulation of information is a theoretical advancement, as it provides a foundational paradigm for concurrent computation.
 - The mention of general and fully abstract models for different combinations of control features and connections between operational semantics and logical deduction indicates theoretical advancements beyond existing approaches, as these models and connections are not typically found in other programming paradigms.
 - The use of CCP as a basis for model-based computing and the development of languages like AKL, which emphasizes encapsulated non-determinism, are theoretical contributions that have potential implications for programming language design, particularly in handling complex physical systems.
 - The integration of ideas from synchronous programming to develop discrete timed and hybrid CCP is another theoretical innovation, addressing the need for flexible time representation and control constructs in modeling physical systems."
Lazy Functional Programs in a Concurrent Environment,"L. Feijs, M. Reniers",10.1093/comjnl/40.9.572,https://doi.org/10.1093/comjnl/40.9.572,Computer/law journal,0,1997,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: Algebra of Communicating Processes (ACP e τ )
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Use of Algebra of Communicating Processes (ACP e τ)
 - Interaction models between paradigms: Bridging gap between functional and process-oriented worlds
 - Constraints or challenges in paradigm integration: Not mentioned
 - Novel translation or embedding techniques: Use of ""abstract functional program"" as an intermediate concept",Generic programming not extensively addressed,"- Key novel insights: Functional programs can behave as reactive systems with lazy evaluation using Landin-style stream I/O.
 - Theoretical advancements: Using Algebra of Communicating Processes (ACP e τ) to analyze communication behavior; bridging the gap between functional and process-oriented worlds.
 - Potential implications: Abstracting away from specific language details with 'abstract functional program' concept; integrating functional and process-oriented paradigms for better specification and reasoning.","- ""We abstract from the details of the particular programming language by using an intermediate concept of'abstract functional program.""
  - ""We propose to use the Algebra of Communicating Processes (ACP e τ ) for that purpose.""
  - ""Functional programming languages like Gofer are attractive for programming the data transformations of a reactive system.""
  - ""The mechanism of Landin-style stream input/output (I/O) makes it possible to write functional programs, which behave as reactive systems when executed with lazy evaluation.""
  - ""The term rewriting system of the functional language, the operational semantics of the I/O mechanism and the process equations of a program are described and their relationships are analysed.""",,"- The abstract discusses the use of Landin-style stream I/O and lazy evaluation in functional programming, which are key concepts in the study but not explicitly defined as conceptual primitives.
 - The mention of ""Algebra of Communicating Processes (ACP e τ )"" suggests a theoretical framework used for analysis, but it is not explicitly defined as a conceptual primitive.
 - The abstract refers to ""term rewriting system,"" ""operational semantics,"" and ""process equations,"" which are related to the methodology and theoretical framework, but again, these are not explicitly defined as conceptual primitives.
 - The concept of ""abstract functional program"" is mentioned as an intermediate concept, but it is not detailed as a specific primitive.
 - Overall, the abstract does not explicitly define any conceptual primitives as requested by the question.","- ""We propose to use the Algebra of Communicating Processes (ACP e τ ) for that purpose.""
  - ""The term rewriting system of the functional language, the operational semantics of the I/O mechanism and the process equations of a program are described and their relationships are analysed.""",,"- The abstract mentions the use of the ""Algebra of Communicating Processes (ACP e τ )"", which is a specific mathematical framework. This indicates that the type of mathematical framework used is process algebra.
 - The mention of ""term rewriting system"", ""operational semantics"", and ""process equations"" suggests that these are part of the formal verification discussions and theoretical foundations.
 - The abstract does not explicitly mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework. However, it does imply that these elements are part of the analysis.
 - The focus on bridging the gap between functional and process-oriented worlds suggests that the framework is used to formalize and guarantee properties related to communication behavior.","- ""The mechanism of Landin-style stream input/output (I/O) makes it possible to write functional programs, which behave as reactive systems when executed with lazy evaluation.""
  - ""Functional programming languages like Gofer are attractive for programming the data transformations of a reactive system.""
  - ""But although the I/O behaviour can be programmed in such languages too, the functional paradigm lacks the capabilities for specification and reasoning which are needed to analyse the communication behaviour of the program and its environment.""
  - ""We propose to use the Algebra of Communicating Processes (ACP e τ ) for that purpose.""
  - ""The present paper attempts to bridge the gap between the functional and the process-oriented worlds.""
  - ""The term rewriting system of the functional language, the operational semantics of the I/O mechanism and the process equations of a program are described and their relationships are analysed.""
  - ""We abstract from the details of the particular programming language by using an intermediate concept of'abstract functional program.""",,"- The abstract discusses the integration of functional programming with process-oriented programming, specifically mentioning the use of the Algebra of Communicating Processes (ACP e τ) to address the limitations of the functional paradigm in handling communication behavior.
 - The integration approach involves using ACP e τ to bridge the gap between functional and process-oriented programming, indicating a theoretical integration strategy.
 - The abstract mentions the description and analysis of relationships between term rewriting systems, operational semantics, and process equations, which suggests a comparative analysis of these elements across paradigms.
 - The use of an ""abstract functional program"" as an intermediate concept implies a novel translation or embedding technique to abstract away from specific language details.
 - The abstract does not explicitly mention specific integration mechanisms or interaction models beyond the use of ACP e τ, nor does it detail constraints or challenges in paradigm integration.","- ""The mechanism of Landin-style stream input/output (I/O) makes it possible to write functional programs, which behave as reactive systems when executed with lazy evaluation.""
  - ""Functional programming languages like Gofer are attractive for programming the data transformations of a reactive system.""
  - ""the functional paradigm lacks the capabilities for specification and reasoning which are needed to analyse the communication behaviour of the program and its environment.""
  - ""We propose to use the Algebra of Communicating Processes (ACP e τ ) for that purpose.""
  - ""The present paper attempts to bridge the gap between the functional and the process-oriented worlds.""
  - ""The term rewriting system of the functional language, the operational semantics of the I/O mechanism and the process equations of a program are described and their relationships are analysed.""
  - ""We abstract from the details of the particular programming language by using an intermediate concept of'abstract functional program.""",,"- The abstract discusses the use of functional programming languages like Gofer for reactive systems, but it does not explicitly mention generic programming or abstraction mechanisms in the context of genericity.
 - The focus is on bridging the gap between functional and process-oriented worlds, which involves using the Algebra of Communicating Processes (ACP e τ) for specification and reasoning.
 - The abstract mentions abstracting from the details of a particular programming language by using an ""abstract functional program,"" which suggests a form of abstraction but not specifically in the context of generic programming.
 - There is no mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.","- ""The mechanism of Landin-style stream input/output (I/O) makes it possible to write functional programs, which behave as reactive systems when executed with lazy evaluation.""
  - ""Functional programming languages like Gofer are attractive for programming the data transformations of a reactive system.""
  - ""We abstract from the details of the particular programming language by using an intermediate concept of'abstract functional program.""
  - ""The term rewriting system of the functional language, the operational semantics of the I/O mechanism and the process equations of a program are described and their relationships are analysed.""
  - ""the functional paradigm lacks the capabilities for specification and reasoning which are needed to analyse the communication behaviour of the program and its environment.""
  - ""We propose to use the Algebra of Communicating Processes (ACP e τ ) for that purpose.""
  - ""The present paper attempts to bridge the gap between the functional and the process-oriented worlds.""",,"- The abstract discusses the use of Landin-style stream I/O to enable functional programs to behave as reactive systems with lazy evaluation, which is a novel insight into how functional programming can be applied in reactive systems.
 - It highlights a limitation of the functional paradigm in specifying and reasoning about communication behavior, which is a key theoretical contribution by identifying a gap in current approaches.
 - The proposal to use the Algebra of Communicating Processes (ACP e τ) is a theoretical advancement beyond existing approaches, as it provides a new framework for analyzing communication behavior in functional programs.
 - The attempt to bridge the gap between functional and process-oriented worlds is a significant theoretical contribution, as it integrates two different programming paradigms.
 - The use of an intermediate concept of 'abstract functional program' is a theoretical innovation that abstracts away from specific language details, allowing for more general applicability.
 - The analysis of relationships between term rewriting systems, operational semantics, and process equations provides a deeper theoretical understanding of how these components interact."
A Data Flow Language for Hybrid Query and Programming Languages,"K. Rose, Lionel Villard, N. Sato",10.1007/978-3-642-29822-6_19,https://doi.org/10.1007/978-3-642-29822-6_19,Fuji International Symposium on Functional and Logic Programming,0,2012,"1. Primitive Name: trix
  Definition: Formalizes data flow mechanisms used in low-level descriptions of algorithms for databases and programming constructs.
  Orthogonality Score: Not specified
 2. Primitive Name: data flow equivalence
  Definition: Equational reasoning used to show optimizations correct.
  Orthogonality Score: Not specified",Not specified (the abstract does not explicitly mention the type of mathematical framework or specific properties guaranteed),"- Specific integration mechanisms proposed: trix as a formalism for data flow mechanisms
 - Interaction models between paradigms: unified reasoning about program equivalence
 - Constraints or challenges in paradigm integration: Not mentioned
 - Novel translation or embedding techniques: Translation of programming patterns into trix",Generic programming not extensively addressed,"- Key novel insights: Formalization of data flow mechanisms in trix for unified database and programming constructs.
 - Theoretical advancements: Concise expression of database operators and functional evaluation; use of ""data flow equivalence"" equational reasoning for optimization validation.
 - Potential implications for programming language design: Use of trix as an intermediate language to improve performance on standard benchmarks.","- ""Specifically, we present trix formally, illustrate how programming patterns (specifically queries) translate into trix,""
  - ""we present trix, which formalizes the data flow mechanisms used in low level descriptions of algorithms that implement data base as well as programming constructs.""
  - ""use “data flow equivalence” equational reasoning to show some common optimizations correct.""
  - ""the formalism permits unified reasoning about the equivalence of programs of each and all of these paradigms.""
  - ""the data flow formalism permits concise expression of physical data base operators and functional evaluation,""",,"- The abstract mentions ""trix"" as a formalism that formalizes data flow mechanisms, which suggests it is a conceptual primitive for reconstructing programming paradigms.
 - The data flow formalism is described as permitting concise expression of physical database operators and functional evaluation, indicating it is a primitive for these aspects.
 - The abstract does not provide explicit definitions for specific primitives beyond ""trix"" and ""data flow equivalence,"" but these are central to the paper's focus.
 - The level of abstraction is high, as ""trix"" is an intermediate language used for unified reasoning across different paradigms.
 - Orthogonality is implied by the ability to apply ""data flow equivalence"" equational reasoning across different programming paradigms, but no specific score is provided.","- ""the data flow formalism permits concise expression of physical data base operators and functional evaluation, and that the formalism permits unified reasoning about the equivalence of programs of each and all of these paradigms.""
  - ""we present trix, which formalizes the data flow mechanisms used in low level descriptions of algorithms that implement data base as well as programming constructs.""
  - ""use “data flow equivalence” equational reasoning to show some common optimizations correct.""",,"- The abstract mentions that ""trix"" formalizes data flow mechanisms, which suggests a mathematical framework is used to formalize these mechanisms.
 - The term ""data flow formalism"" implies a structured approach to representing data flow, which could be part of a mathematical framework.
 - The use of ""data flow equivalence"" and ""equational reasoning"" suggests a type of mathematical framework that involves equational logic or similar proof techniques.
 - However, the abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""we present trix, which formalizes the data flow mechanisms used in low level descriptions of algorithms that implement data base as well as programming constructs.""
  - ""show how the use of trix as an intermediate language can improve performance for some standard benchmarks.""
  - ""use “data flow equivalence” equational reasoning to show some common optimizations correct.""
  - ""illustrate how programming patterns (specifically queries) translate into trix,""
  - ""the data flow formalism permits concise expression of physical data base operators and functional evaluation, and that the formalism permits unified reasoning about the equivalence of programs of each and all of these paradigms.""",,"- The abstract introduces ""trix"" as a formalism that integrates data flow mechanisms from both database and programming constructs. This suggests a specific integration mechanism where trix acts as a common language for different paradigms.
 - The mention of ""unified reasoning about the equivalence of programs"" implies an interaction model where different paradigms can be compared and optimized using trix.
 - The translation of programming patterns into trix indicates a novel translation technique that facilitates integration.
 - The use of ""data flow equivalence"" equational reasoning suggests a theoretical integration strategy that ensures optimizations are correct across paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the use of trix as an intermediate language to improve performance, which could imply addressing performance-related challenges.","- ""we present trix, which formalizes the data flow mechanisms used in low level descriptions of algorithms that implement data base as well as programming constructs.""
  - ""Specifically, we present trix formally, illustrate how programming patterns (specifically queries) translate into trix, and use “data flow equivalence” equational reasoning to show some common optimizations correct.""
  - ""the data flow formalism permits concise expression of physical data base operators and functional evaluation, and that the formalism permits unified reasoning about the equivalence of programs of each and all of these paradigms.""
  - ""Finally we show how the use of trix as an intermediate language can improve performance for some standard benchmarks.""",,"- The abstract discusses the formalization of data flow mechanisms using ""trix,"" which suggests a focus on data flow formalism rather than generic programming or abstraction mechanisms.
 - The mention of ""unified reasoning about the equivalence of programs"" implies a focus on equivalence and optimization rather than genericity or abstraction.
 - The abstract does not explicitly mention generic programming, type systems, or abstraction mechanisms, which are key components of genericity and abstraction.
 - The focus is on the use of ""trix"" as an intermediate language for performance improvement, which does not directly relate to generic programming or abstraction mechanisms.","- ""Finally we show how the use of trix as an intermediate language can improve performance for some standard benchmarks.""
  - ""Specifically, we present trix formally, illustrate how programming patterns (specifically queries) translate into trix, and use “data flow equivalence” equational reasoning to show some common optimizations correct.""
  - ""the data flow formalism permits concise expression of physical data base operators and functional evaluation, and that the formalism permits unified reasoning about the equivalence of programs of each and all of these paradigms.""
  - ""we present trix, which formalizes the data flow mechanisms used in low level descriptions of algorithms that implement data base as well as programming constructs.""",,"- The abstract introduces ""trix,"" a formalization of data flow mechanisms, which is a novel contribution as it provides a unified framework for both database and programming constructs.
 - The data flow formalism allows for concise expression of database operators and functional evaluation, which is a theoretical advancement as it simplifies complex operations.
 - The use of ""data flow equivalence"" equational reasoning to validate optimizations is a theoretical contribution, as it provides a method for ensuring the correctness of optimizations.
 - The potential implication for programming language design is the use of trix as an intermediate language, which can improve performance on standard benchmarks, indicating a theoretical contribution to language design."
"Merging interactive, modular, and object-oriented programming",S. Tung,-,-,-,3,1992,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: $\lambda$-calculus
 - Specific mathematical properties guaranteed: Formal description of propagating variable definitions and module interfaces, support for recursive modules
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: $\lambda\sb{imp}$ language for interactive modular programming, IMP system for practical implementation, IMOOP for object-oriented integration.
 - Interaction models between paradigms: $\lambda\sb{imp}$ language for interactive and modular integration, IMP for interactive and modular, IMOOP for object-oriented integration.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Merging interactive, modular, and object-oriented programming paradigms to allow flexible use of each paradigm as needed.
 - Theoretical advancements: Extension of $\lambda$-calculus to support interactive modular programming with $\lambda\sb{imp}$ language; support for recursive modules.
 - Potential implications: Enhanced flexibility and efficiency in software development through seamless integration of different programming paradigms.","- ""Interactive, modular, and object-oriented programming are three important programming paradigms.""
  - ""The primary benefit of merging these three paradigms is that the programmer can use either paradigm where appropriate.""
  - ""In order to merge interactive and modular programming, the programmer must be allowed to modify variable bindings and module interfaces during program development.""
  - ""The semantics of these modifications is specified with the $\lambda\sb{imp}$ language which extends $\lambda$-calculus to support interactive modular programming.""
  - ""The $\lambda\sb{imp}$ language supports recursive modules, that is, it allows the import/export relation of modules to contain cycles.""
  - ""IMOOP extends IMP with support for object-oriented programming.""
  - ""It uses IMP's ability to export variables, to rename imported variables, and to define recursive modules to provide an object system that offers many advantages.""",,"- The abstract discusses the merging of three programming paradigms: interactive, modular, and object-oriented. These are not conceptual primitives but rather paradigms being integrated.
 - The $\lambda\sb{imp}$ language is mentioned as extending $\lambda$-calculus to support interactive modular programming, which suggests it is a tool or framework rather than a conceptual primitive.
 - The abstract does not explicitly define any conceptual primitives. Instead, it focuses on the integration of programming paradigms and the features of the $\lambda\sb{imp}$ language and the IMOOP system.
 - There is no mention of specific conceptual primitives or their definitions in the abstract.","- ""This semantics gives a formal description of the notion of propagating variable definitions and module interfaces.""
  - ""The $\lambda\sb{imp}$ language supports recursive modules, that is, it allows the import/export relation of modules to contain cycles.""
  - ""The semantics of these modifications is specified with the $\lambda\sb{imp}$ language which extends $\lambda$-calculus to support interactive modular programming.""",,"- The abstract mentions the use of the $\lambda\sb{imp}$ language, which is an extension of $\lambda$-calculus. This suggests that the mathematical framework used is based on $\lambda$-calculus, which is a type of mathematical framework used in theoretical computer science.
 - The $\lambda\sb{imp}$ language is used to specify the semantics of modifications in interactive modular programming, indicating that it provides a formal description of how variable definitions and module interfaces propagate.
 - The support for recursive modules implies that the framework can handle complex relationships between modules, which is a specific mathematical property guaranteed by the framework.
 - There is no mention of specific proof techniques or limitations of the framework in the abstract.","- ""Interactive, modular, and object-oriented programming are three important programming paradigms.""
  - ""This dissertation describes an approach of merging interactive, modular, and object-oriented programming by presenting the definition, design, and implementation of the $\lambda\sb{imp}$ language, the IMP system, and the IMOOP system.""
  - ""The primary benefit of merging these three paradigms is that the programmer can use either paradigm where appropriate.""
  - ""In order to merge interactive and modular programming, the programmer must be allowed to modify variable bindings and module interfaces during program development.""
  - ""The ability to modify one or more modules at a time is provided with a window-based user interface that strongly relates modules with files, edit windows, and a read-eval-print loop with multiple evaluation contexts.""
  - ""The semantics of these modifications is specified with the $\lambda\sb{imp}$ language which extends $\lambda$-calculus to support interactive modular programming.""
  - ""The $\lambda\sb{imp}$ language supports recursive modules, that is, it allows the import/export relation of modules to contain cycles.""
  - ""The design and implementation of IMP addresses many practical problems of supporting interactive modular programming for the Scheme programming language.""
  - ""IMOOP extends IMP with support for object-oriented programming.""
  - ""It uses IMP's ability to export variables, to rename imported variables, and to define recursive modules to provide an object system that offers many advantages.""",,"- The abstract discusses the integration of three programming paradigms: interactive, modular, and object-oriented programming.
 - The integration approach involves the development of the $\lambda\sb{imp}$ language, the IMP system, and the IMOOP system, which are designed to merge these paradigms.
 - The $\lambda\sb{imp}$ language is used to specify the semantics of modifications to variable bindings and module interfaces, which is a key mechanism for integrating interactive and modular programming.
 - The IMP system addresses practical problems related to interactive modular programming, such as efficient variable lookup and project compilation.
 - IMOOP extends IMP by incorporating object-oriented programming features, using mechanisms like exporting variables and defining recursive modules to provide an object system.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the integration mechanisms described.","- ""Interactive programming encourages experimental programming and fast prototyping and is most valuable for solving problems that are not well understood.""
  - ""Modular programming is indispensable for large-scale program development and is also useful for smaller programs.""
  - ""Object-oriented programming features classes, objects, and inheritance and is suitable for many real world applications.""
  - ""The primary benefit of merging these three paradigms is that the programmer can use either paradigm where appropriate.""
  - ""The ability to modify one or more modules at a time is provided with a window-based user interface that strongly relates modules with files, edit windows, and a read-eval-print loop with multiple evaluation contexts.""
  - ""The semantics of these modifications is specified with the $\lambda\sb{imp}$ language which extends $\lambda$-calculus to support interactive modular programming.""
  - ""The $\lambda\sb{imp}$ language supports recursive modules, that is, it allows the import/export relation of modules to contain cycles.""
  - ""IMOOP extends IMP with support for object-oriented programming. It uses IMP's ability to export variables, to rename imported variables, and to define recursive modules to provide an object system that offers many advantages.""
  - ""These advantages include a flexible and efficient slot-access mechanism with strong encapsulation, a simple approach for constructing generic functions, a flexible mechanism for handling conflicts resulting from multiple inheritance, and tight integration of modular programming and object-oriented programming.""",,"- The abstract discusses the merging of interactive, modular, and object-oriented programming paradigms, but it does not explicitly focus on generic programming or conceptual abstraction mechanisms.
 - The mention of ""a simple approach for constructing generic functions"" in the context of IMOOP suggests some level of genericity, but it does not provide detailed mechanisms or definitions related to generic programming.
 - There is no explicit mention of a definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The abstract primarily focuses on the integration of different programming paradigms rather than delving into specific generic programming methodologies or type system discussions.","- ""This dissertation describes an approach of merging interactive, modular, and object-oriented programming by presenting the definition, design, and implementation of the $\lambda\sb{imp}$ language, the IMP system, and the IMOOP system.""
  - ""The primary benefit of merging these three paradigms is that the programmer can use either paradigm where appropriate.""
  - ""In order to merge interactive and modular programming, the programmer must be allowed to modify variable bindings and module interfaces during program development.""
  - ""The semantics of these modifications is specified with the $\lambda\sb{imp}$ language which extends $\lambda$-calculus to support interactive modular programming.""
  - ""The $\lambda\sb{imp}$ language supports recursive modules, that is, it allows the import/export relation of modules to contain cycles.""
  - ""IMOOP extends IMP with support for object-oriented programming.""
  - ""It uses IMP's ability to export variables, to rename imported variables, and to define recursive modules to provide an object system that offers many advantages.""",,"- The abstract discusses the merging of three programming paradigms: interactive, modular, and object-oriented. This integration is a novel insight as it allows programmers to use different paradigms as needed.
 - The $\lambda\sb{imp}$ language is a theoretical contribution as it extends $\lambda$-calculus to support interactive modular programming, providing a formal description of variable and module interface modifications.
 - The support for recursive modules in $\lambda\sb{imp}$ is a theoretical advancement, as it enables complex module relationships.
 - The IMOOP system extends these contributions by integrating object-oriented programming, offering advantages such as flexible slot-access mechanisms and conflict resolution in multiple inheritance.
 - The potential implications for programming language design include the ability to seamlessly integrate different programming paradigms, enhancing flexibility and efficiency in software development."
"Unifying Programming Languages and Databases: Scoping, Metadata, and Process Communication","T. Merrett, Heping Shang",-,-,International Workshop/Symposium on Database Programming Languages,2,1992,Not specified (the abstract does not explicitly define conceptual primitives or provide precise definitions),Not specified,No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Systematic investigation into the connection between programming languages and relational databases; support for efficient operations on bulk data.
 - Theoretical advancements: Integration of multiple programming paradigms; emphasis on orthogonality and simplicity in syntax.
 - Potential implications: Unified framework for database programming languages; flexibility and adaptability in language design.","- ""We are systematically investigating fundamental concepts in programming languages and their connection with the central ideas of relational databases.""
  - ""The language should support efficient operations on bulk data, too large to fit into primary memory.""
  - ""The language should follow the structured, imperative tradition of ALGOL 60, but with support for alternative paradigms, such as functional and object-oriented.""
  - ""By thorough exploitation of the language/database concepts adopted, and insistence on orthogonality, the language should employ a minimum number of concepts and thus a very simple syntax.""
  - ""The present paper discusses four important ingredients of the language we intend to design and implement.""
  - ""We have implemented a scoping mechanism and are exploring refinements.""
  - ""We have implemented four types of metadata.""
  - ""We are implementing an approach to interprocess communication and synchronization.""",,"- The abstract discusses the integration of programming languages and databases, focusing on fundamental concepts and their connections.
 - It mentions the language should support bulk data operations, follow structured and imperative traditions, and include alternative paradigms like functional and object-oriented programming.
 - The emphasis on orthogonality suggests a focus on simplicity and minimalism in the language's design.
 - The abstract mentions specific components such as scoping mechanisms, metadata types, and interprocess communication, which are likely part of the conceptual primitives.
 - However, the abstract does not explicitly define these primitives or provide detailed definitions.
 - The level of abstraction and orthogonality is implied by the focus on simplicity and minimalism, but specific scores or definitions are not provided.","- ""We are systematically investigating fundamental concepts in programming languages and their connection with the central ideas of relational databases.""
  - ""The language should support efficient operations on bulk data, too large to fit into primary memory.""
  - ""The language should follow the structured, imperative tradition of ALGOL 60, but with support for alternative paradigms, such as functional and object-oriented.""
  - ""By thorough exploitation of the language/database concepts adopted, and insistence on orthogonality, the language should employ a minimum number of concepts and thus a very simple syntax.""
  - ""The present paper discusses four important ingredients of the language we intend to design and implement.""
  - ""We have implemented a scoping mechanism and are exploring refinements.""
  - ""We have implemented four types of metadata.""
  - ""We are implementing an approach to interprocess communication and synchronization.""",,"- The abstract discusses the design and implementation of a database programming language, focusing on its characteristics and features such as scoping, metadata, and process communication.
 - There is no mention of a specific mathematical framework, such as type theory or category theory, being used to formalize or guarantee properties of the conceptual primitives.
 - The abstract does not provide details on theoretical foundations, proof methodology, or formal verification discussions related to a mathematical framework.
 - The focus is on the design and implementation aspects rather than on the mathematical underpinnings or formal verification techniques.","- ""By thorough exploitation of the language/database concepts adopted, and insistence on orthogonality, the language should employ a minimum number of concepts and thus a very simple syntax.""
  - ""The language should follow the structured, imperative tradition of ALGOL 60, but with support for alternative paradigms, such as functional and object-oriented.""",,"- The abstract mentions that the language should support alternative paradigms such as functional and object-oriented, in addition to the structured, imperative tradition of ALGOL 60. This indicates an intention to integrate different programming paradigms.
 - The mention of ""support for alternative paradigms"" suggests that the language is designed to accommodate multiple paradigms, but it does not specify how these paradigms are integrated or interact.
 - The abstract does not provide specific integration mechanisms, interaction models, constraints, or novel translation techniques for integrating these paradigms.
 - The focus on ""orthogonality"" and a ""very simple syntax"" implies a design goal of simplicity and consistency, but it does not detail how this is achieved in terms of paradigm integration.","- ""We are systematically investigating fundamental concepts in programming languages and their connection with the central ideas of relational databases.""
  - ""The language should support efficient operations on bulk data, too large to fit into primary memory.""
  - ""The language should follow the structured, imperative tradition of ALGOL 60, but with support for alternative paradigms, such as functional and object-oriented.""
  - ""By thorough exploitation of the language/database concepts adopted, and insistence on orthogonality, the language should employ a minimum number of concepts and thus a very simple syntax.""
  - ""The present paper discusses four important ingredients of the language we intend to design and implement.""
  - ""We have implemented a scoping mechanism and are exploring refinements.""
  - ""We have implemented four types of metadata.""
  - ""We are implementing an approach to interprocess communication and synchronization.""",,"- The abstract discusses the integration of programming languages and databases, focusing on concepts like scoping, metadata, and process communication.
 - It mentions the language should support multiple paradigms (structured, imperative, functional, object-oriented), which suggests some level of abstraction.
 - The emphasis on ""orthogonality"" and a ""minimum number of concepts"" implies a focus on simplicity and potentially generic mechanisms.
 - However, there is no explicit mention of generic programming or abstraction mechanisms in the abstract.
 - The abstract does not provide specific details on mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus seems to be more on the integration of programming languages and databases rather than generic programming methodologies.","- ""We are systematically investigating fundamental concepts in programming languages and their connection with the central ideas of relational databases.""
  - ""Our intention is to identify related notions and to generalize other notions in order to produce a database programming language with the following characteristics.""
  - ""The language should support efficient operations on bulk data, too large to fit into primary memory.""
  - ""The language should follow the structured, imperative tradition of ALGOL 60, but with support for alternative paradigms, such as functional and object-oriented.""
  - ""By thorough exploitation of the language/database concepts adopted, and insistence on orthogonality, the language should employ a minimum number of concepts and thus a very simple syntax.""
  - ""The present paper discusses four important ingredients of the language we intend to design and implement.""",,"- The abstract discusses a systematic investigation into the connection between programming languages and relational databases, which suggests a novel approach to integrating these two areas.
 - The intention to identify and generalize related notions indicates a theoretical contribution towards creating a unified framework for database programming languages.
 - The language is designed to support efficient operations on large data sets, which is a key novelty in terms of handling bulk data.
 - The integration of multiple programming paradigms (structured, imperative, functional, object-oriented) within a single language is a theoretical advancement, as it offers flexibility and adaptability.
 - The emphasis on orthogonality and simplicity in syntax is a theoretical contribution, as it aims to reduce complexity and improve usability.
 - The discussion of four important ingredients of the language suggests a comprehensive approach to language design, which is a theoretical contribution."
Foundations of Choreographies Achievements during the project : summary of a collection of papers with significant results,"L. Cruz-Filipe, F. Montesi",-,-,-,0,2016,Not specified (the abstract does not explicitly list or define the conceptual primitives),Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),No specific integration approach described (the abstract focuses on the development and analysis of choreographic programming rather than integrating it with other paradigms),Generic programming not extensively addressed,"- Key novel insights: Introduction of Core Choreographies (CC) as a canonical model for choreographic programming, achieving Turing machine computational power with minimal requirements.
 - Theoretical advancements: CC provides a simple and representative model for theoretical analysis, facilitating formal definitions of parallel execution and expressivity analysis.
 - Potential implications: Standardization of choreographic programming through CC, which can be embedded in most choreography languages.","- ""CC helps in formally defining parallel execution in choreographies (quantifying concurrent behaviour) and lends itself to the analysis of the expressivity of choreography primitives.""
  - ""CC includes only the core primitives that can be found in most choreography languages, restricted to the minimal requirements to achieve the computational power of Turing machines.""
  - ""Case in point, the standard construct of label selection (communication of a choice) can be encoded as standard value communication, preserving expressivity and, interestingly, projectability of choreographies at the same time.""
  - ""In particular, local computation at processes is severely restricted, and therefore nontrivial computations must be implemented by using communications.""
  - ""Our first contribution [8] is a canonical model for choreographic programming, called Core Choreographies (CC).""",,"- The abstract mentions a canonical model called Core Choreographies (CC), which includes core primitives found in most choreography languages.
 - These primitives are restricted to the minimal requirements necessary to achieve the computational power of Turing machines, indicating a focus on fundamental operations.
 - The abstract specifies that local computation is severely restricted, implying that the primitives focus on communication rather than local processing.
 - The mention of ""quantifying concurrent behaviour"" and ""analysis of the expressivity of choreography primitives"" suggests that the primitives are designed to capture and analyze concurrent interactions.
 - The example of label selection being encoded as standard value communication indicates a specific primitive related to communication choices.
 - However, the abstract does not explicitly list or define each primitive, nor does it provide a detailed explanation of their orthogonality.","- ""The paradigm of Choreographic Programming [12] was introduced to address these problems.""
  - ""Choreographies syntactically disallow writing mismatched I/O actions, using the “Alice and Bob” notation of security protocols [14].""
  - ""An EndPoint Projection (EPP) can then be used to synthesise faithful implementations in process models, which are guaranteed to be deadlock-free by construction [2, 15].""
  - ""Our first contribution [8] is a canonical model for choreographic programming, called Core Choreographies (CC).""
  - ""CC includes only the core primitives that can be found in most choreography languages, restricted to the minimal requirements to achieve the computational power of Turing machines.""
  - ""CC is both representative of the paradigm (it is embeddable in most choreography languages) and simple enough to analyse from a theoretical perspective.""
  - ""CC helps in formally defining parallel execution in choreographies (quantifying concurrent behaviour) and lends itself to the analysis of the expressivity of choreography primitives.""",,"- The abstract mentions the use of ""Choreographic Programming"" as a paradigm, which suggests a theoretical framework for programming concurrent and distributed systems.
 - The mention of ""Choreographies syntactically disallow writing mismatched I/O actions"" implies a formal structure for ensuring correctness in communication actions.
 - The use of ""EndPoint Projection (EPP)"" to synthesize implementations that are ""guaranteed to be deadlock-free by construction"" indicates a mathematical framework that ensures certain properties, such as deadlock freedom.
 - The introduction of ""Core Choreographies (CC)"" as a canonical model suggests a simplified framework for theoretical analysis, focusing on core primitives and minimal requirements for Turing machine computational power.
 - The abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory, nor does it detail specific proof techniques or limitations.","- ""The paradigm of Choreographic Programming [12] was introduced to address these problems.""
  - ""Choreographies syntactically disallow writing mismatched I/O actions, using the “Alice and Bob” notation of security protocols [14].""
  - ""An EndPoint Projection (EPP) can then be used to synthesise faithful implementations in process models, which are guaranteed to be deadlock-free by construction [2, 15].""
  - ""Our first contribution [8] is a canonical model for choreographic programming, called Core Choreographies (CC).""
  - ""CC includes only the core primitives that can be found in most choreography languages, restricted to the minimal requirements to achieve the computational power of Turing machines.""
  - ""CC is both representative of the paradigm (it is embeddable in most choreography languages) and simple enough to analyse from a theoretical perspective.""",,"- The abstract discusses the introduction of the Choreographic Programming paradigm as a solution to problems in concurrent and distributed systems programming.
 - It mentions that choreographies syntactically prevent mismatched I/O actions, which is a mechanism for ensuring consistency across different communication protocols.
 - The use of EndPoint Projection (EPP) is highlighted as a method to synthesize implementations that are deadlock-free, which is a form of integration mechanism.
 - The Core Choreographies (CC) model is described as a canonical model that includes core primitives found in most choreography languages, indicating a form of integration by standardizing these primitives.
 - The abstract does not explicitly discuss the integration of different programming paradigms beyond the context of choreographic programming itself. It focuses on the development and analysis of choreographic programming rather than integrating it with other paradigms.","- ""The paradigm of Choreographic Programming [12] was introduced to address these problems.""
  - ""In this paradigm, programmers declaratively write the communications that they wish to take place in programs called choreographies.""
  - ""Our first contribution [8] is a canonical model for choreographic programming, called Core Choreographies (CC).""
  - ""CC includes only the core primitives that can be found in most choreography languages, restricted to the minimal requirements to achieve the computational power of Turing machines.""
  - ""In particular, local computation at processes is severely restricted, and therefore nontrivial computations must be implemented by using communications.""
  - ""CC is both representative of the paradigm (it is embeddable in most choreography languages) and simple enough to analyse from a theoretical perspective.""",,"- The abstract discusses the paradigm of Choreographic Programming, which involves declaratively writing communications in programs called choreographies. This suggests a focus on communication rather than generic programming or abstraction mechanisms.
 - The introduction of Core Choreographies (CC) as a canonical model for choreographic programming indicates a focus on simplifying and standardizing choreography languages rather than exploring generic programming or abstraction.
 - The abstract mentions that CC includes only core primitives and restricts local computation, which implies a focus on minimal requirements for computational power rather than genericity or abstraction.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract, which suggests that these topics are not extensively addressed.","- ""Our first contribution [8] is a canonical model for choreographic programming, called Core Choreographies (CC).""
  - ""CC includes only the core primitives that can be found in most choreography languages, restricted to the minimal requirements to achieve the computational power of Turing machines.""
  - ""The paradigm of Choreographic Programming [12] was introduced to address these problems.""
  - ""CC is both representative of the paradigm (it is embeddable in most choreography languages) and simple enough to analyse from a theoretical perspective.""
  - ""CC helps in formally defining parallel execution in choreographies (quantifying concurrent behaviour) and lends itself to the analysis of the expressivity of choreography primitives.""
  - ""Building on CC, we then study the following foundational questions on choreographies.""",,"- The abstract introduces the paradigm of Choreographic Programming as a solution to challenges in concurrent and distributed systems programming. This is a foundational concept rather than a novel insight specific to this study.
 - The introduction of Core Choreographies (CC) as a canonical model is highlighted as a significant contribution. This model is novel because it distills choreographic programming to its core primitives, making it both representative and simple enough for theoretical analysis.
 - The CC model is theoretically significant because it achieves the computational power of Turing machines with minimal requirements, which is a novel insight into the fundamental capabilities of choreographic programming.
 - The CC model facilitates the formal definition of parallel execution and analysis of expressivity, which are theoretical advancements beyond existing approaches. These aspects are crucial for understanding the foundational questions of choreographies.
 - The potential implications for programming language design are implicit in the development of a canonical model that can be embedded in most choreography languages, suggesting a standardized approach to choreographic programming."
A minimalist two-level foundation for constructive mathematics,M. Maietti,10.1016/j.apal.2009.01.006,https://doi.org/10.1016/j.apal.2009.01.006,Annals of Pure and Applied Logic,82,2008,"1. Primitive Name: Collection
  Definition: A fundamental concept in the intensional level (mTT) used to implement power collections of sets as quotients.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Forget-Restore Principle
  Definition: A conceptual framework guiding the design of the extensional level (emTT) by abstracting over equalities of intensional concepts.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Canonical Isomorphisms
  Definition: Used to interpret the extensional level (emTT) in a quotient model over the intensional level (mTT).
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Type Judgement
  Definition: Expresses that something is a specific type in the typed calculus mTT.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Type Equality Judgement
  Definition: Expresses when two types are equal in the typed calculus mTT.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Term Judgement
  Definition: Expresses that something is a term of a certain type in the typed calculus mTT.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Term Equality Judgement
  Definition: Expresses the definitional equality between terms of the same type in the typed calculus mTT.
  Orthogonality Score: Not discussed
 

 8. Primitive Name: Mono Propositions
  Definition: Propositions in emTT that are inhabited by at most one proof.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Two-level theory consisting of intensional type theory (Minimal Type Theory, mTT) and extensional set theory (emTT)
 - Specific mathematical properties guaranteed: Satisfaction of ""proofs-as-programs"" paradigm, consistency with formal Church thesis and axiom of choice
 - Proof techniques used: Interpretation of extensional level in quotient model over intensional level using canonical isomorphisms
 - Limitations or constraints: Avoidance of axiom of choice in intensional level, use of specific version of Minimal Type Theory without ξ-rule","- Specific integration mechanisms proposed: Interpretation of emTT in a quotient model built over mTT using canonical isomorphisms.
 - Interaction models between paradigms: Transforming undecidable judgements in emTT into decidable ones in mTT.
 - Constraints or challenges in paradigm integration: Forgetting information about equality between types and terms in the extensional level.
 - Novel translation or embedding techniques: Interpreting emTT in a quotient model over mTT.",Generic programming not extensively addressed,"- Introduction of a two-level foundation for constructive mathematics combining intensional and extensional type theories.
 - Use of a quotient model to interpret the extensional level over the intensional one.
 - Adoption of an intensional type theory without the ξ-rule for lambda-terms.
 - Development of categories Q(mTT) and Q(mTT dp) with specific properties.
 - Insight into the implications of identifying propositions as sets in terms of the axiom of choice.","- ""The intensional level of our two-level foundation is essentially obtained by extending the typed calculus introduced in [MS05], and called Minimal Type Theory (for short mTT), with the notion of ""collection"" and corresponding constructors needed to implement the power collection of a set as a quotient.""
  - ""the typed calculus mTT is written in the style of Martin-Löf's type theory [NPS90] by means of the following four kinds of judgements:
 

 that is the type judgement (expressing that something is a specific type), the type equality judgement (expressing when two types are equal), the term judgement (expressing that something is a term of a certain type) and the term equality judgement (expressing the definitional equality between terms of the same type), respectively, all under a context Γ.""
  - ""The main idea behind the design of emTT goes back to that of toolbox in [SV98], and it follows the forget-restore principle conceived by G. Sambin and introduced there.""",,"- The paper discusses a two-level foundation for constructive mathematics, with an intensional level (mTT) and an extensional level (emTT).
 - The intensional level, mTT, is based on Minimal Type Theory extended with collections and constructors for power collections.
 - The extensional level, emTT, is interpreted in a quotient model over mTT, using canonical isomorphisms.
 - The paper mentions the forget-restore principle as a conceptual framework for designing emTT.
 - The typed calculus mTT is structured around four types of judgements: type, type equality, term, and term equality.
 - emTT is characterized by mono propositions and small propositions, which are inhabited by at most one proof.","- ""We present a two-level theory to formalize constructive mathematics as advocated in a previous paper with G. Sambin.""
  - ""One level is given by an intensional type theory, called Minimal type theory.""
  - ""The other level is given by an extensional set theory that is interpreted in the first one by means of a quotient model.""
  - ""This two-level theory has two main features: it is minimal among the most relevant foundations for constructive mathematics; it is constructive thanks to the way the extensional level is linked to the intensional one which fulfills the “proofs-as-programs” paradigm and acts as a programming language.""
  - ""The intensional level of our two-level foundation is essentially obtained by extending the typed calculus introduced in [MS05], and called Minimal Type Theory (for short mTT), with the notion of ""collection"" and corresponding constructors needed to implement the power collection of a set as a quotient.""
  - ""The extensional level of our two-level foundation is taken to be an extensional dependent type theory with quotients, called emTT.""
  - ""We will interpret our extensional theory emTT in a quotient model built over mTT.""
  - ""The category Q(mTT) comes naturally equipped with an indexed category (or split fibration) satisfying the universal property of comprehension""
  - ""the indexed category P q validates first-order intuitionistic logic with equality, namely it is an intuitionistic hyperdoctrine in the sense of [See83]""",,"- The paper presents a two-level mathematical framework for constructive mathematics, consisting of an intensional type theory (Minimal Type Theory, mTT) and an extensional set theory (emTT).
 - The intensional level is based on type theory, specifically extending Minimal Type Theory with collections and quotients.
 - The extensional level is an extensional dependent type theory with quotients, interpreted in a quotient model over the intensional level.
 - The framework is designed to be minimal and constructive, fulfilling the ""proofs-as-programs"" paradigm.
 - The mathematical properties guaranteed include the satisfaction of the ""proofs-as-programs"" requirement, consistency with the formal Church thesis and the axiom of choice, and the ability to formalize constructive mathematics.
 - The proof techniques used involve interpreting the extensional level in a quotient model over the intensional level, using canonical isomorphisms to ensure validity.
 - The framework is limited by the need to avoid the validity of the axiom of choice in the intensional level, which is achieved by restricting elimination rules for propositions.
 - The framework is also constrained by the use of a specific version of Minimal Type Theory without the ξ-rule for lambda-terms, which affects the realizability interpretation.","- ""the interpretation of emTT into the quotient model over mTT makes visible the validity of such a principle. Indeed, in emTT we work with undecidable judgements, while those of mTT are decidable. The interpretation of emTT into mTT restores the forgotten information of emTT undecidable judgements by transforming them into decidable ones, once the lost information has been recovered.""
  - ""The intensional level of our two-level foundation is essentially obtained by extending the typed calculus introduced in [MS05], and called Minimal Type Theory (for short mTT), with the notion of ""collection"" and corresponding constructors needed to implement the power collection of a set as a quotient.""
  - ""the extensional level is designed over the intensional one only by forgetting information about equality between types and terms that can be restored, and hence it is implemented only via a quotient construction performed on the intensional level.""
  - ""The extensional level of our two-level foundation is taken to be an extensional dependent type theory with quotients, called emTT.""",,"- The paper discusses a two-level foundation for constructive mathematics, with an intensional level (mTT) and an extensional level (emTT).
 - The integration mechanism proposed is the interpretation of the extensional level (emTT) in a quotient model built over the intensional level (mTT), using canonical isomorphisms.
 - The interaction model involves transforming undecidable judgements in emTT into decidable ones in mTT, indicating a way to integrate the two levels by restoring forgotten information.
 - The constraint or challenge is the need to forget information about equality between types and terms in the extensional level, which is then restored through the quotient construction.
 - The novel translation technique involves interpreting emTT in a quotient model over mTT, which allows for the integration of the two levels.","- ""The desire of representing power collections of sets together with proof irrelevance of propositions is a key motivation to work in a two-level foundation.""
  - ""In order to interpret the power collection of a set as a quotient of propositional functions, to mTT we add the collection of small propositions prop s and the collection of functions from a set towards prop s""
  - ""The main idea behind the design of emTT goes back to that of toolbox in [SV98], and it follows the forget-restore principle conceived by G. Sambin and introduced there. According to this principle, extensional concepts must be abstractions of intensional concepts as result of forgetting irrelevant computational information, that can be restored when implementing these extensional concepts back at the intensional level.""
  - ""The intensional level of our two-level foundation is essentially obtained by extending the typed calculus introduced in [MS05], and called Minimal Type Theory (for short mTT), with the notion of ""collection"" and corresponding constructors needed to implement the power collection of a set as a quotient.""",,"- The paper discusses the use of ""collections"" and ""quotients"" as part of its type theory, which can be related to generic programming concepts. However, these are more focused on type theory and set theory rather than generic programming in the traditional sense.
 - The ""forget-restore principle"" is a mechanism for abstraction, where extensional concepts are derived from intensional ones by forgetting computational details. This is a form of abstraction but not specifically related to generic programming.
 - The paper does not explicitly address generic programming or abstraction mechanisms in the context of generic programming. The focus is on type theory and constructive mathematics rather than generic programming methodologies.
 - There is no mention of static checking or optimization strategies related to generic programming.","- ""The main contributions of this paper are the following:
 

 -We introduce a two-level foundation for constructive mathematics where both levels are given by type theories à la Martin-Löf: one called mTT is intensional and the other called emTT is extensional.""
  - ""We adopt an intensional version of mTT without the ξ-rule for lambda-terms, after noticing from [CR00, BCRS98] that its presence is irrelevant to interpret the extensional level via quotients.""
  - ""The extensional level emTT is interpreted in a quotient model à la Bishop built over the intensional one mTT by means of canonical isomorphisms.""
  - ""The category Q(mTT dp ) enjoys the same properties as Q(mTT), but in addition is also locally cartesian closed (i.e. with dependent products).""",,"- The paper introduces a novel two-level foundation for constructive mathematics, combining intensional and extensional type theories. This is a key theoretical contribution as it provides a new framework for formalizing constructive mathematics.
 - The use of a quotient model to interpret the extensional level over the intensional one is a significant theoretical advancement. It allows for the integration of extensional concepts into an intensional framework, which is a novel approach.
 - The adoption of an intensional type theory without the ξ-rule for lambda-terms is a theoretical innovation. It simplifies the interpretation of the extensional level and aligns with the ""proofs-as-programs"" paradigm.
 - The development of categories Q(mTT) and Q(mTT dp) with specific properties such as being lex and locally cartesian closed is a theoretical contribution. These categories provide a structured framework for understanding the properties of the quotient model.
 - The paper highlights the implications of identifying propositions as sets in terms of validating the axiom of choice, which is a critical theoretical insight into the nature of constructive mathematics."
Exploiting parallelism in functional languages: a “paradigm-oriented” approach,F. Rabhi,-,-,-,37,1995,"1. Primitive Name: Parallel Algorithmic Structures (or Skeletons)
  Definition: Captures the behavior of a parallel programming paradigm and acts as a template in the design of an algorithm.
  Orthogonality Score: Not specified
 2. Primitive Name: Iterative Transformation Paradigm (or Geometric Parallelism)
  Definition: A paradigm discussed in detail for developing and transforming programs into efficient and portable implementations.
  Orthogonality Score: Not specified",Not specified (the abstract does not mention a mathematical framework or its characteristics),No specific integration approach described (the abstract implies a structured approach using skeletons and functional languages but does not provide explicit details on integration mechanisms or models),Generic programming not extensively addressed,"- Key novel insights: The use of parallel algorithmic structures (skeletons) to control parallelism efficiently; the role of functional languages in simplifying parallel programming through implicit parallelism.
 - Theoretical advancements: Presentation of parallel programming paradigms and their structures; framework for iterative transformation paradigm; recognition of horizontal and vertical parallelism.
 - Potential implications for programming language design: Simplification of parallel programming through structured approaches; potential for more efficient and portable implementations.","- ""A structure captures the behaviour of a parallel programming paradigm and acts as a template in the design of an algorithm.""",,"- The abstract mentions ""parallel algorithmic structures (or skeletons)"" as a key concept for controlling parallelism in algorithms. This suggests that these structures are conceptual primitives used to design algorithms.
 - The term ""structure"" is defined as capturing the behavior of a parallel programming paradigm and acting as a template for algorithm design. This indicates that these structures are fundamental elements used to construct programming paradigms.
 - The abstract specifically mentions the ""iterative transformation paradigm (or geometric parallelism)"" as one of the paradigms discussed in detail. This implies that this paradigm is a conceptual primitive defined in the study.
 - The abstract does not provide explicit definitions or orthogonality scores for these primitives, nor does it mention multiple sets of primitives. Therefore, the specific primitives mentioned are the ""parallel algorithmic structures (or skeletons)"" and the ""iterative transformation paradigm (or geometric parallelism).""","- ""Deriving parallelism automatically from functional programs is simple in theory but very few practical implementations have been realised.""
  - ""Such parallelism could be more eeciently controlled if parallel algorithmic structures (or skeletons) are used in the design of algorithms.""
  - ""A structure captures the behaviour of a parallel programming paradigm and acts as a template in the design of an algorithm.""
  - ""The iterative transformation paradigm (or geometric parallelism) is discussed in detail and a framework under which programs can be developed and transformed into eecient and portable implementations is presented.""
  - ""Following this principle, a typical parallelising compiler for functional languages would have the structure displayed in Fig. 1.1.""
  - ""Given an arbitrary functional program, the rst phase analyses this program to detect parallelism, and encodes decisions such as evaluation order, partitioning of data, load balancing and granularity control in the form of annotations (e.g. (Burton 1987)).""
  - ""There are two forms of inherent parallelism: horizontal and vertical parallelism (Kelly 1989).""",,"- The abstract discusses the use of parallel algorithmic structures (skeletons) to control parallelism, which suggests a structured approach to parallel programming.
 - It mentions the iterative transformation paradigm and geometric parallelism, indicating a focus on specific programming paradigms rather than a general mathematical framework.
 - The abstract describes a compiler structure for analyzing and annotating programs for parallelism, but it does not specify a mathematical framework for formalizing or guaranteeing properties.
 - There is no mention of theoretical foundations, proof methodology, or formal verification discussions in the abstract.
 - The abstract does not provide details on the type of mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""Their implicit parallelism eliminates the need to explicitly decompose a program into concurrent tasks, and to provide the necessary communication and synchronisation between these tasks.""
  - ""It is now argued that functional languages could play an important role in the development of parallel applications.""
  - ""A structure captures the behaviour of a parallel programming paradigm and acts as a template in the design of an algorithm.""
  - ""Deriving parallelism automatically from functional programs is simple in theory but very few practical implementations have been realised.""",,"- The abstract discusses the use of parallel algorithmic structures (skeletons) to control parallelism, which suggests a structured approach to integrating different programming paradigms.
 - It mentions defining a structure for each parallel programming paradigm, indicating a systematic integration strategy.
 - The focus on functional languages and their implicit parallelism suggests a paradigm integration approach that leverages these languages' inherent properties.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques, but it implies a structured approach to paradigm integration through the use of skeletons and functional languages.","- ""Deriving parallelism automatically from functional programs is simple in theory but very few practical implementations have been realised.""
  - ""A structure captures the behaviour of a parallel programming paradigm and acts as a template in the design of an algorithm.""
  - ""Their implicit parallelism eliminates the need to explicitly decompose a program into concurrent tasks, and to provide the necessary communication and synchronisation between these tasks.""
  - ""Following this principle, a typical parallelising compiler for functional languages would have the structure displayed in Fig. 1.1.""
  - ""It is now argued that functional languages could play an important role in the development of parallel applications.""",,"- The abstract discusses the use of parallel algorithmic structures (or skeletons) as a mechanism for controlling parallelism, which can be seen as a form of abstraction.
 - The concept of ""structure"" is used to capture the behavior of parallel programming paradigms, acting as templates for algorithm design.
 - The paper presents a framework for developing and transforming programs into efficient and portable implementations, which implies some level of abstraction.
 - The abstract mentions the implicit parallelism of functional languages, which eliminates the need for explicit decomposition and synchronization, suggesting a level of abstraction in programming.
 - However, there is no explicit mention of generic programming methodology, type system discussions, or specific abstraction mechanisms related to genericity.
 - The focus is on parallelism and functional languages rather than generic programming or abstraction mechanisms.","- ""It is now argued that functional languages could play an important role in the development of parallel applications.""
  - ""There are two forms of inherent parallelism: horizontal and vertical parallelism (Kelly 1989).""
  - ""Their implicit parallelism eliminates the need to explicitly decompose a program into concurrent tasks, and to provide the necessary communication and synchronisation between these tasks.""
  - ""Following this principle, a typical parallelising compiler for functional languages would have the structure displayed in Fig. 1.1.""
  - ""Deriving parallelism automatically from functional programs is simple in theory but very few practical implementations have been realised.""",,"- The abstract discusses the challenge of deriving parallelism from functional programs and suggests that using parallel algorithmic structures (skeletons) could improve efficiency. This indicates a theoretical contribution by proposing a structured approach to parallelism.
 - The paper presents various parallel programming paradigms and defines structures for them, which is a theoretical advancement in organizing and understanding parallel programming concepts.
 - The focus on the iterative transformation paradigm and its framework suggests a novel insight into how programs can be transformed into efficient and portable implementations.
 - The abstract highlights the role of functional languages in parallel applications, emphasizing their implicit parallelism as a theoretical contribution by simplifying the need for explicit decomposition and synchronization.
 - The mention of horizontal and vertical parallelism indicates a theoretical contribution by recognizing and categorizing different forms of inherent parallelism."
Multi-paradigm Programming through Graph Rewriting: Case for Support 2 Background 2.1 Previous Work Declarative Programming Multi-paradigm Programming,"Sanjiva Prasad, A. Giacalone, Prateek Mishra",-,-,-,0,-,Not specified (the abstract does not provide explicit definitions or names for conceptual primitives),Not specified (the abstract mentions graph rewriting as a basis but does not provide specific details on the mathematical framework characteristics),"- Specific integration mechanisms proposed: Graph rewriting as the basis for multi-paradigm languages.
 - Interaction models between paradigms: Combining process and functional programming, and functional and concurrent logic programming.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Searching for primitives for concurrent computation based on graph rewriting.",Generic programming not extensively addressed (the abstract focuses on graph rewriting and multi-paradigm languages but does not provide specific details on generic programming methodology or type system discussions),"- Key novel insights: The use of extended graph rewriting as a basis for multi-paradigm languages.
 - Theoretical advancements: Integration of process and functional programming, and functional and concurrent logic programming; identification of a core model of graph rewriting; development of primitives for concurrent computation.
 - Potential implications: Enhanced support for parallel architectures; more elegant integration of non-declarative styles in declarative languages.","- ""The project aims to demonstrate that extended notions of graph rewriting can act as the basis for practical implementations of multi-paradigm languages, based on largely declarative principles.""
  - ""The languages chosen will combine process and functional programming on the one hand and functional and concurrent logic programming on the other.""
  - ""The objective is to support implementations on both sequential and parallel architectures.""
  - ""The precursor to the main project will be research to identify a core model of graph rewriting able to support the chosen language paradigms.""
  - ""This model will have restricted capabilities but will be chosen to allow efficient sequential implementation.""
  - ""By extending established techniques, the project will develop an implementation for sequential machines, based on the core model, and focussing primarily on integration of functional and process paradigms.""
  - ""The project will finally study truly parallel implementation of multi-paradigm languages.""
  - ""A study will search for primitives for concurrent computation based on graph rewriting.""
  - ""Implementation experiments will involve direct implementation of such primitives.""",,"- The abstract discusses the use of ""extended notions of graph rewriting"" as a basis for multi-paradigm languages, which suggests that graph rewriting is a conceptual primitive.
 - The project aims to combine different programming paradigms (process, functional, concurrent logic), indicating that these paradigms are conceptual primitives being integrated.
 - The mention of a ""core model of graph rewriting"" suggests that this is a fundamental primitive for supporting various language paradigms.
 - The abstract mentions searching for ""primitives for concurrent computation based on graph rewriting,"" which implies that these primitives are related to concurrent computation.
 - The abstract does not provide explicit definitions or names for these primitives, nor does it discuss their orthogonality or level of abstraction in detail.","- ""The project aims to demonstrate that extended notions of graph rewriting can act as the basis for practical implementations of multi-paradigm languages, based on largely declarative principles.""
  - ""The precursor to the main project will be research to identify a core model of graph rewriting able to support the chosen language paradigms.""
  - ""This model will have restricted capabilities but will be chosen to allow efficient sequential implementation.""
  - ""By extending established techniques, the project will develop an implementation for sequential machines, based on the core model, and focussing primarily on integration of functional and process paradigms.""
  - ""A study will search for primitives for concurrent computation based on graph rewriting.""
  - ""Implementation experiments will involve direct implementation of such primitives.""
  - ""Declarative languages have attracted considerable attention over the last decade because of their concise and powerful notation, theoretical clarity, practical benefits such as automatic heap space management, and perceived potential for exploiting implicit parallelism.""
  - ""Those concerned to exploit lazy evaluation can use the Hope + language developed at ICSTM during the Flagship project or the Clean language [BruEL87] from the University of Nijmegen, based directly on graph rewriting principles.""",,"- The abstract mentions the use of ""extended notions of graph rewriting"" as the basis for multi-paradigm languages, which suggests a mathematical framework based on graph rewriting principles.
 - The project aims to identify a ""core model of graph rewriting"" that supports various language paradigms, indicating a focus on graph rewriting as a theoretical foundation.
 - The abstract does not explicitly mention specific mathematical properties guaranteed by this framework, nor does it detail proof techniques or limitations.
 - The mention of ""graph rewriting principles"" in the context of languages like Hope + and Clean suggests that graph rewriting is a key mathematical framework, but the abstract does not provide further details on its characteristics.","- ""The project aims to demonstrate that extended notions of graph rewriting can act as the basis for practical implementations of multi-paradigm languages, based on largely declarative principles.""
  - ""The languages chosen will combine process and functional programming on the one hand and functional and concurrent logic programming on the other.""
  - ""The objective is to support implementations on both sequential and parallel architectures.""
  - ""The precursor to the main project will be research to identify a core model of graph rewriting able to support the chosen language paradigms.""
  - ""By extending established techniques, the project will develop an implementation for sequential machines, based on the core model, and focussing primarily on integration of functional and process paradigms.""
  - ""The project will finally study truly parallel implementation of multi-paradigm languages.""
  - ""A study will search for primitives for concurrent computation based on graph rewriting.""
  - ""Implementation experiments will involve direct implementation of such primitives.""
  - ""Initially, task granularity and work distribution will mirror the process structures of user programs.""",,"- The abstract discusses the integration of different programming paradigms through the use of graph rewriting. This is a specific integration mechanism proposed by the study.
 - The integration involves combining process and functional programming, as well as functional and concurrent logic programming. This indicates the interaction models between these paradigms.
 - The study aims to support implementations on both sequential and parallel architectures, which suggests a focus on flexibility and adaptability in paradigm integration.
 - The identification of a core model of graph rewriting is a key step in the integration process, as it will be used to support the chosen language paradigms.
 - The study also involves searching for primitives for concurrent computation based on graph rewriting, which is a novel translation or embedding technique.
 - The abstract mentions that the project will focus on the integration of functional and process paradigms, indicating a specific area of focus within the broader integration approach.","- ""The project aims to demonstrate that extended notions of graph rewriting can act as the basis for practical implementations of multi-paradigm languages, based on largely declarative principles.""
  - ""The languages chosen will combine process and functional programming on the one hand and functional and concurrent logic programming on the other.""
  - ""The objective is to support implementations on both sequential and parallel architectures.""
  - ""The precursor to the main project will be research to identify a core model of graph rewriting able to support the chosen language paradigms.""
  - ""This model will have restricted capabilities but will be chosen to allow efficient sequential implementation.""
  - ""By extending established techniques, the project will develop an implementation for sequential machines, based on the core model, and focussing primarily on integration of functional and process paradigms.""
  - ""A study will search for primitives for concurrent computation based on graph rewriting.""
  - ""Declarative languages have attracted considerable attention over the last decade because of their concise and powerful notation, theoretical clarity, practical benefits such as automatic heap space management, and perceived potential for exploiting implicit parallelism.""",,"- The abstract discusses the use of graph rewriting as a basis for multi-paradigm languages, which suggests a focus on abstraction mechanisms through graph rewriting.
 - The project aims to integrate different programming paradigms, which implies a need for genericity in the programming methodology.
 - The mention of a ""core model of graph rewriting"" suggests a mechanism for representing generic abstractions, as it is intended to support multiple language paradigms.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the focus on declarative principles and graph rewriting implies a theoretical basis that could involve type systems and optimization strategies.
 - The abstract does not provide specific details on generic programming methodology or type system discussions, but it does emphasize the integration of different paradigms and the use of graph rewriting, which are related to abstraction mechanisms.","- ""The project aims to demonstrate that extended notions of graph rewriting can act as the basis for practical implementations of multi-paradigm languages, based on largely declarative principles.""
  - ""The languages chosen will combine process and functional programming on the one hand and functional and concurrent logic programming on the other.""
  - ""The objective is to support implementations on both sequential and parallel architectures.""
  - ""The precursor to the main project will be research to identify a core model of graph rewriting able to support the chosen language paradigms.""
  - ""By extending established techniques, the project will develop an implementation for sequential machines, based on the core model, and focussing primarily on integration of functional and process paradigms.""
  - ""The project will finally study truly parallel implementation of multi-paradigm languages.""
  - ""A study will search for primitives for concurrent computation based on graph rewriting.""
  - ""Declarative languages have attracted considerable attention over the last decade because of their concise and powerful notation, theoretical clarity, practical benefits such as automatic heap space management, and perceived potential for exploiting implicit parallelism.""
  - ""A barrier may be that they either refuse to countenance non-declarative styles, or accommodate them in ways which are inelegant and/or violate the theoretical basis which made the languages attractive in the first place.""",,"- The abstract discusses the use of ""extended notions of graph rewriting"" as a basis for multi-paradigm languages, which suggests a novel approach to integrating different programming paradigms.
 - The integration of process and functional programming, as well as functional and concurrent logic programming, represents a theoretical advancement by combining these paradigms in a way that supports both sequential and parallel architectures.
 - The identification of a ""core model of graph rewriting"" is a theoretical contribution as it aims to provide a foundational framework for these multi-paradigm languages.
 - The focus on developing primitives for concurrent computation based on graph rewriting is a theoretical innovation that could enhance the potential for parallelism in programming languages.
 - The abstract highlights the limitations of current declarative systems and suggests that the proposed approach could address these limitations by providing a more elegant and theoretically sound way to integrate non-declarative styles."
Mini-Foc A Kernel Calculus for Certified Computer Algebra [Ongoing work],"Stephane Fetcher, L. Liquori",-,-,-,0,2005,"1. Primitive Name: Certified Components (Collections)
  Definition: Specified and implemented step by step with formal properties and proofs.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Classic Object-Oriented Features
  Definition: Use of classic oriented-object features.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Module Features
  Definition: Use of module features like interfaces and encapsulation of data representation.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Multiple Inheritance
  Definition: Part of the Mini-Foc kernel.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Late Binding
  Definition: Part of the Mini-Foc kernel.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Overriding
  Definition: Part of the Mini-Foc kernel.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Interfaces
  Definition: Part of the Mini-Foc kernel.
  Orthogonality Score: Not discussed
 

 8. Primitive Name: Encapsulation of Data Representation
  Definition: Part of the Mini-Foc kernel.
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention the type of mathematical framework or specific mathematical properties guaranteed),"- Specific integration mechanisms proposed: Integration of object-oriented programming features (multiple inheritance, late binding, overriding, interfaces, encapsulation of data representation) with module-based programming.
 - Interaction models between paradigms: Not mentioned.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.","- Definition of ""concept"" used: Mathematical structures like Groups and Rings are used as concepts.
 - Mechanisms for representing generic abstractions: Subtyping relations and certified components called Collections.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Formal syntax, semantics, and type system are specified.","- Key novel insights: The Foc language requires proofs of correctness for implementations, ensuring software reliability. Reusability of code and correctness proofs is emphasized.
 - Theoretical advancements: Certified components called Collections are formally specified and implemented. Mini-Foc kernel focuses on programming aspects with multiple inheritance, late binding, overriding, interfaces, and encapsulation.
 - Potential implications: Formal specification of syntax, semantics, and type system for Mini-Foc provides a foundational framework for programming language design.","- ""The Foc language is designed to bring solutions on the reliability of the software, in particular on the development and the reusing of certified libraries, especially for Certified Computer Algebra.""
  - ""The project develops a language called Foc, where any implementation must come with a proof of its correctness.""
  - ""In this context, reusability of the code, but also of the correctness proofs is of very important concern: a tool written for mathematical Groups should be available for the mathematical Rings, provided the system knows that every Ring is a Group, wich can be faithfully modeled by suitable subtyping relation.""
  - ""this formal language allows to implement certified components called Collections.""
  - ""These collections are specified and implemented step by step: the programmer describes formally – the properties of the algorithm, – the context in which they are executed, – the data representation and proves formally that the implemented algorithms satisfies the specified properties.""
  - ""This programming paradigm implies the use of classic oriented-object features and the use of module features like interfaces and encapsulation of data representation.""
  - ""To answer to this question, we propose a kernel of Foc called Mini-Foc.""
  - ""Thus, the main ingredients of Mini-Foc, are multiple inheritance, late binding, overriding, interfaces and encapsulation of the data representation.""
  - ""We specify formally the syntax, the semantics and the type system.""",,"- The abstract discusses the Foc language and its focus on reliability and certified libraries, particularly for Certified Computer Algebra.
 - It mentions the importance of reusability of code and correctness proofs, which are key conceptual primitives in the context of programming paradigms.
 - The abstract highlights the use of ""certified components called Collections,"" which are specified and implemented with formal properties and proofs, indicating a focus on formal specification and verification as conceptual primitives.
 - The programming paradigm described involves classic object-oriented features and module features like interfaces and encapsulation, suggesting these as conceptual primitives.
 - The Mini-Foc kernel is introduced as a subset of Foc, focusing on programming aspects with specific features like multiple inheritance, late binding, overriding, interfaces, and encapsulation of data representation.
 - These features are explicitly listed as the main ingredients of Mini-Foc, indicating they are conceptual primitives defined by the study.","- ""The Foc language is designed to bring solutions on the reliability of the software, in particular on the development and the reusing of certified libraries, especially for Certified Computer Algebra.""
  - ""The project develops a language called Foc, where any implementation must come with a proof of its correctness.""
  - ""This includes of course pre- and post- condition statements, but also proofs of purely mathematical theorems.""
  - ""These collections are specified and implemented step by step: the programmer describes formally – the properties of the algorithm, – the context in which they are executed, – the data representation and proves formally that the implemented algorithms satisfies the specified properties.""
  - ""This programming paradigm implies the use of classic oriented-object features and the use of module features like interfaces and encapsulation of data representation.""
  - ""We specify formally the syntax, the semantics and the type system.""",,"- The abstract mentions the development of certified libraries and the need for proofs of correctness, which suggests a focus on formal verification.
 - The mention of ""proofs of purely mathematical theorems"" indicates that the framework involves mathematical proofs, but it does not specify the type of mathematical framework (e.g., type theory, category theory).
 - The abstract discusses the formal specification of syntax, semantics, and type systems, which are typical components of a formal verification framework.
 - However, the abstract does not explicitly mention the type of mathematical framework used (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - The abstract does not provide details on proof techniques used or limitations/constraints of the framework.","- ""The Foc language is designed to bring solutions on the reliability of the software, in particular on the development and the reusing of certified libraries, especially for Certified Computer Algebra.""
  - ""The project develops a language called Foc, where any implementation must come with a proof of its correctness.""
  - ""This programming paradigm implies the use of classic oriented-object features and the use of module features like interfaces and encapsulation of data representation.""
  - ""This conception of the object oriented programming brings the question where the Foc language is situated in relation to others more classic object-oriented languages.""
  - ""To answer to this question, we propose a kernel of Foc called Mini-Foc.""
  - ""Thus, the main ingredients of Mini-Foc, are multiple inheritance, late binding, overriding, interfaces and encapsulation of the data representation.""
  - ""We specify formally the syntax, the semantics and the type system.""",,"- The abstract discusses the integration of programming paradigms by mentioning the use of ""classic oriented-object features"" and ""module features like interfaces and encapsulation of data representation."" This suggests an integration of object-oriented programming (OOP) with module-based programming.
 - The mention of ""multiple inheritance, late binding, overriding, interfaces and encapsulation of the data representation"" in Mini-Foc indicates specific integration mechanisms, as these are typical features of OOP that are being integrated into the Foc language.
 - The abstract does not explicitly discuss interaction models between paradigms or constraints/challenges in paradigm integration. It focuses more on the features and design of Mini-Foc rather than the interactions or challenges.
 - There is no mention of novel translation or embedding techniques in the abstract.","- ""The Foc language is designed to bring solutions on the reliability of the software, in particular on the development and the reusing of certified libraries, especially for Certified Computer Algebra.""
  - ""The project develops a language called Foc, where any implementation must come with a proof of its correctness.""
  - ""this formal language allows to implement certified components called Collections.""
  - ""This programming paradigm implies the use of classic oriented-object features and the use of module features like interfaces and encapsulation of data representation.""
  - ""To answer to this question, we propose a kernel of Foc called Mini-Foc.""
  - ""Thus, the main ingredients of Mini-Foc, are multiple inheritance, late binding, overriding, interfaces and encapsulation of the data representation.""
  - ""We specify formally the syntax, the semantics and the type system.""",,"- The abstract discusses the Foc language and its focus on reliability and certified libraries, which implies a strong emphasis on generic programming and abstraction mechanisms.
 - The mention of reusability of code and correctness proofs for different mathematical structures (Groups and Rings) suggests a generic programming approach.
 - The use of subtyping relations to model mathematical structures indicates a mechanism for representing generic abstractions.
 - The abstract mentions the implementation of certified components called Collections, which are specified and implemented step by step, suggesting a structured approach to abstraction.
 - The programming paradigm includes classic object-oriented features and module features like interfaces and encapsulation, which are typical mechanisms for abstraction.
 - The Mini-Foc kernel is introduced to focus on the programming aspect, with features like multiple inheritance, late binding, and interfaces, which are relevant to generic programming.
 - The abstract specifies the formal syntax, semantics, and type system, which are essential for static checking and optimization strategies.","- ""The Foc language is designed to bring solutions on the reliability of the software, in particular on the development and the reusing of certified libraries, especially for Certified Computer Algebra.""
  - ""The project develops a language called Foc, where any implementation must come with a proof of its correctness.""
  - ""this formal language allows to implement certified components called Collections.""
  - ""These collections are specified and implemented step by step: the programmer describes formally – the properties of the algorithm, – the context in which they are executed, – the data representation and proves formally that the implemented algorithms satisfies the specified properties.""
  - ""This programming paradigm implies the use of classic oriented-object features and the use of module features like interfaces and encapsulation of data representation.""
  - ""To answer to this question, we propose a kernel of Foc called Mini-Foc.""
  - ""Thus, the main ingredients of Mini-Foc, are multiple inheritance, late binding, overriding, interfaces and encapsulation of the data representation.""
  - ""We specify formally the syntax, the semantics and the type system.""",,"- The abstract introduces the Foc language as a novel approach to ensuring software reliability by requiring proofs of correctness for implementations, which is a significant theoretical contribution.
 - The emphasis on reusability of both code and correctness proofs is a key insight, as it addresses a common challenge in software development.
 - The use of certified components called Collections and the formal specification and implementation process are theoretical advancements beyond existing approaches, as they provide a structured method for ensuring correctness.
 - The introduction of Mini-Foc as a kernel of Foc highlights a theoretical contribution by focusing on the programming aspects of Foc, which can be seen as a simplification or core version of the language.
 - The formal specification of syntax, semantics, and type system for Mini-Foc indicates a theoretical contribution to programming language design by providing a foundational framework for future developments."
Design principles for highly reusable concurrent object-oriented systems,"Emilio García Roselló, José Ayude Vazquez, José B. García-Schofield, M. P. Cota",10.5381/jot.2002.1.1.a3,https://doi.org/10.5381/jot.2002.1.1.a3,Journal of Object Technology,4,2002,"1. Principle of Concurrency Independence
  Definition: The form of a program is independent of the concurrent behaviour of objects it manipulates.
  Orthogonality Score: High
 

 2. Principle of Data Type Orthogonality
  Definition: All objects should be allowed to have any permitted concurrent behaviour, irrespective of their type.
  Orthogonality Score: High
 

 3. Principle of Concurrency Identification
  Definition: The identification of the concurrent behaviour of an object is orthogonal to the universe of discourse of the system, and therefore it can't be related to the type system.
  Orthogonality Score: High
 

 4. Principle of Orthogonality of Concurrent Concerns
  Definition: Concurrency can be considered as formed by the orthogonal concerns of activity, interaction and synchronization.
  Orthogonality Score: High",Not specified,"- Specific integration mechanisms proposed: Separation of concerns
 - Interaction models between paradigms: Orthogonality of concurrent concerns (activity, interaction, synchronization)
 - Constraints or challenges in paradigm integration: Achieving total transparency in concurrency due to explicit code needs
 - Novel translation or embedding techniques: Extending Java with sublanguages for synchronization policies and object creation","- Definition of ""concept"" used: Separation of concepts and powerful composition rules.
 - Mechanisms for representing generic abstractions: Separate description of object aspects, composition at runtime, abstract classes (SyncClass), and mapping classes (MapClass).
 - Minimal type requirements identified: Data type orthogonality, concurrency identification orthogonal to type system.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Introduction of orthogonal design principles for concurrent object-oriented systems to improve reusability and adaptability.
 - Proposal of four specific principles: concurrency independence, data type orthogonality, concurrency identification, and orthogonality of concurrent concerns.
 - Theoretical advancement by separating concurrent concerns into activity, interaction, and synchronization.
 - Addressing the inheritance anomaly through orthogonality between concurrency and inheritance mechanisms.
 - Potential implications for programming language design: higher reusability and expressive power.","- ""we propose the definition of orthogonal concurrency principles which serve as unified guidelines to design highly reusable concurrent object-oriented languages.""",,"- The paper proposes a set of conceptual primitives in the form of design principles for concurrent object-oriented systems.
 - The first set of principles includes concurrency independence, data type orthogonality, and concurrency identification. These are defined as guidelines for designing systems where concurrency is orthogonal to the program's form, data types are not limited by concurrency, and concurrency identification is separate from the type system.
 - The paper also introduces a principle of orthogonality of concurrent concerns, which breaks down concurrency into activity, interaction, and synchronization. This suggests a further level of abstraction and orthogonality in designing concurrent systems.
 - The level of abstraction is high as these principles are intended to guide the design of programming languages and systems rather than specific implementation details.
 - The orthogonality score is high as these principles aim to ensure that different aspects of concurrency are independent and do not interfere with each other.","- ""In programming languages design the fact is well accepted that expressive power and reusability of a language is directly related with separation of the concepts it includes and with availability of powerful composition rules to combine them.""
  - ""Several authors have pointed out this general orthogonality principle in different aspects of language design, like Strachey (Strachey, 1967) and later Tennent (Tennent, 1977) who formulated the design general principles of correspondence, abstraction and data type completeness.""
  - ""The latter is an especially outstanding example. In order to integrate persistence in such a way that the resulting system would offer high software consistency, productivity, reusability and adaptability, orthogonal design of this aspect was investigated and some principles were defined, which specify the features a system should show to be considered orthogonally persistent (Atkinson & Morrison, 1995)""
  - ""Basing on the arguments and works previously described, we propose the definition of orthogonal concurrency principles which serve as unified guidelines to design highly reusable concurrent object-oriented languages.""
  - ""An object system that shows all these principles is considered orthogonally concurrent. It's clear that any system that adheres to these principles would present a high degree of reusability and expressive power.""
  - ""The use of the MOP allows us to implement policies which are more difficult to convey by just bearing in mind the object's states.""",,"- The paper discusses the importance of orthogonality in language design, which is a principle rather than a specific mathematical framework.
 - The authors reference principles of correspondence, abstraction, and data type completeness, which are foundational concepts in programming language design but not a specific mathematical framework.
 - The paper focuses on the design principles for orthogonal concurrency and persistence, which are more about software engineering principles than a mathematical framework.
 - There is no mention of a specific mathematical framework such as type theory or category theory being used to formalize or guarantee properties.
 - The paper does not discuss formal verification or proof techniques in a mathematical context.","- ""Designing a concurrent object oriented language isn’t an easy task. After many years of research, the merging of concurrency and object oriented paradigms hasn’t been achieved in a totally satisfactory way.""
  - ""Approaches based on separation of concerns appear to point to the development of models which achieve effectively those requirements.""
  - ""We‘ll propose these principles basing on well-known principles of design of programming languages and orthogonal persistence.""
  - ""In this work we describe the approximation we've followed in our attempt to set some guidelines to design a COOL that overcome s these problems.""
  - ""We'll show that thanks to these principles, we have been able to design a COOL, named CoJava, which effectively achieves the separation of the concerns that describe object functionality and concurrency, thus offering higher reusability than previous proposed COOL's.""
  - ""CoJava has been designed applying our principles to offer a high degree of orthogonality , which results in better reusability than previous models.""
  - ""CoJava has been implemented as an extension of Java (Gosling, 1996) , extending it in two ways: (1) it provides a sublanguage that allows description of synchronization policies, based on synchronization and mapping classes, and (2) a sublanguage for creating objects by means of compositions of the behavioural aspects defined in the language.""",,"- The paper discusses the integration of concurrency and object-oriented paradigms, which is a key aspect of programming paradigm integration.
 - The authors propose the use of ""separation of concerns"" as a mechanism to integrate these paradigms effectively, which is a specific integration mechanism.
 - The paper introduces the concept of ""orthogonality of concurrent concerns,"" which involves separating activity, interaction, and synchronization as distinct concerns. This is an interaction model between paradigms.
 - The authors highlight the challenge of achieving total transparency in concurrency due to the need for explicit code in defining synchronization policies, which is a constraint in paradigm integration.
 - The paper describes CoJava as an implementation of these principles, which involves extending Java with sublanguages for synchronization policies and object creation. This can be seen as a novel translation or embedding technique.","- ""In programming languages design the fact is well accepted that expressive power and reusability of a language is directly related with separation of the concepts it includes and with availability of powerful composition rules to combine them.""
  - ""The principle of data type orthogonality should be understood as claiming for all objects as first-class objects with regard to concurrency.That is, all objects should be allowed to have all range of supported concurrent behaviours, irrespective of their type.""
  - ""The language supports a separate description of the different aspects of an object at the conceptual level, and their composition at runtime.""
  - ""Synchronization policies are generic, reusable, and can be combined with any type of object, without restriction.""
  - ""Mapping classes prevent the inclusion of synchronization code of any kind in the functional class, or code that depends on functionality in the synchronization class, promoting the independence of both components.""
  - ""SyncClass are abstract classes defining synchronization. In a SyncClass we can define abstract states and abstract methods.""
  - ""MapClass are in charge of the establishment of a correspondence between the abstract states and methods of a synchronization class and concrete methods of the functional class.""",,"- The paper discusses the importance of separating concepts and having powerful composition rules, which is relevant to generic programming.
 - The principle of data type orthogonality suggests that all objects should be treated as first-class objects regarding concurrency, which aligns with generic programming principles.
 - The principle of concurrency identification implies that concurrency is orthogonal to the type system, which is a key aspect of generic programming.
 - The language design allows for separate descriptions of object aspects and their composition at runtime, which is a mechanism for representing generic abstractions.
 - Synchronization policies are described as generic and reusable, indicating a focus on generic programming.
 - The use of abstract classes (SyncClass) and mapping classes (MapClass) provides a mechanism for representing generic abstractions and ensuring minimal type requirements.
 - The paper does not explicitly mention static checking or optimization strategies, but the focus on orthogonality and separation of concerns suggests a structured approach to abstraction.","- ""we propose the definition of orthogonal concurrency principles which serve as unified guidelines to design highly reusable concurrent object-oriented languages.""
  - ""In this essay we argu e that the establishment of orthogonal design principles should be useful in this respect, as it was in other fields of object systems research.""
  - ""In fact, inheritance anomaly can be easily seen as a lack of orthogonality between concurrency and inheritance mechanisms""
  - ""we think that usefulness of our principles as helpful design guidelines for COOL's has been shown.""
  - ""we have proposed four principles, based on well-known principles and works of programming languages design, orthogonal persistence and separation of concurrent concerns.""",,"- The paper introduces the concept of orthogonal design principles for concurrent object-oriented systems, which is a novel approach to improving reusability and adaptability.
 - The authors propose four specific principles: concurrency independence, data type orthogonality, concurrency identification, and orthogonality of concurrent concerns. These principles are designed to guide the development of highly reusable concurrent object-oriented languages.
 - The paper highlights the importance of separating concurrent concerns into activity, interaction, and synchronization, which is a theoretical advancement beyond existing approaches that often treat concurrency as a monolithic concern.
 - The authors argue that their principles address the inheritance anomaly by ensuring orthogonality between concurrency and inheritance mechanisms, which is a significant theoretical contribution.
 - The paper discusses how these principles can lead to higher reusability and expressive power in programming languages, which has potential implications for future language design."
Semantic formalization in mathematical modeling languages,"F. Vicuña, A. M. Geoffrion, M. A. Melkanoff",-,-,-,12,1990,Not specified (the abstract does not provide explicit definitions for specific conceptual primitives),"- Type of mathematical framework: Attribute grammar formalism
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The use of attribute grammar formalism as a design paradigm for mathematical modeling languages.
 - Theoretical advancements: Rigorous formalization of mathematical modeling languages using attribute grammar equations; simplification of model design through automatic deduction of missing constructs.
 - Potential implications: Making modeling less error-prone by providing explicit semantic formalization; potential for automatic generation of modeling environment tools.","- ""We begin by identifying the areas where semantic formalization is needed in selected modeling languages for mathematical programming.""
  - ""The purpose of this dissertation is to promote semantic formalization in mathematical modeling languages by showing the feasibility of employing an attribute grammar formalism as a design paradigm for some of the major components of an OR modeling environment.""
  - ""Next, we propose equations for various areas that we identify as amenable to language simplification via the automatic deduction of missing language constructs.""
  - ""Then, using SML (Structured Modeling Language) as an example, we propose and show the feasibility of supporting the complete static semantics of mathematical modeling languages through attribute grammar equations.""
  - ""Finally, we validate our approach by implementing a prototype modeling environment which enforces the full syntax and semantics of SML, and by testing it using a large number of models from a variety of domains.""",,"- The abstract discusses the use of ""attribute grammar formalism"" as a design paradigm for semantic formalization in mathematical modeling languages. This suggests that attribute grammar equations are a key conceptual primitive in the study.
 - The mention of ""supporting the complete static semantics of mathematical modeling languages through attribute grammar equations"" indicates that these equations are used to formalize the semantics of the modeling languages.
 - The abstract does not provide explicit definitions for specific conceptual primitives beyond the use of attribute grammar equations. It does not list specific primitives or provide detailed definitions for them.
 - The study focuses on the application of attribute grammar formalism to support semantic formalization, but it does not specify individual conceptual primitives or their definitions.","- ""The purpose of this dissertation is to promote semantic formalization in mathematical modeling languages by showing the feasibility of employing an attribute grammar formalism as a design paradigm for some of the major components of an OR modeling environment.""
  - ""we propose and show the feasibility of supporting the complete static semantics of mathematical modeling languages through attribute grammar equations.""
  - ""We conclude that it is possible to use attribute grammars to rigorously formalize a mathematical modeling language, and to automatically generate modeling environment tools.""",,"- The abstract mentions the use of ""attribute grammar formalism"" as a design paradigm for semantic formalization in mathematical modeling languages. This indicates that the mathematical framework used is based on attribute grammars.
 - Attribute grammars are a type of formal system used to define the syntax and semantics of programming languages, which aligns with the goal of formalizing mathematical modeling languages.
 - The abstract does not specify any particular mathematical properties guaranteed by this framework, nor does it mention specific proof techniques or limitations of the framework.
 - The focus is on the feasibility of using attribute grammars for semantic formalization and automatic generation of modeling environment tools, rather than detailing specific mathematical properties or proof methodologies.","- ""Finally, we validate our approach by implementing a prototype modeling environment which enforces the full syntax and semantics of SML, and by testing it using a large number of models from a variety of domains.""
  - ""Next, we propose equations for various areas that we identify as amenable to language simplification via the automatic deduction of missing language constructs.""
  - ""Then, using SML (Structured Modeling Language) as an example, we propose and show the feasibility of supporting the complete static semantics of mathematical modeling languages through attribute grammar equations.""
  - ""We begin by identifying the areas where semantic formalization is needed in selected modeling languages for mathematical programming.""
  - ""The purpose of this dissertation is to promote semantic formalization in mathematical modeling languages by showing the feasibility of employing an attribute grammar formalism as a design paradigm for some of the major components of an OR modeling environment.""",,"- The abstract discusses the use of attribute grammar formalism as a design paradigm for mathematical modeling languages, specifically focusing on semantic formalization.
 - It mentions the application of attribute grammar equations to support the static semantics of mathematical modeling languages, which could be seen as a mechanism for integrating different language constructs.
 - The abstract does not explicitly mention the integration of different programming paradigms or specific integration mechanisms, interaction models, constraints, or novel translation techniques.
 - The focus is on semantic formalization within a specific language (SML) rather than integrating multiple programming paradigms.","- ""We begin by identifying the areas where semantic formalization is needed in selected modeling languages for mathematical programming.""
  - ""Finally, we validate our approach by implementing a prototype modeling environment which enforces the full syntax and semantics of SML, and by testing it using a large number of models from a variety of domains.""
  - ""Next, we propose equations for various areas that we identify as amenable to language simplification via the automatic deduction of missing language constructs.""
  - ""Then, using SML (Structured Modeling Language) as an example, we propose and show the feasibility of supporting the complete static semantics of mathematical modeling languages through attribute grammar equations.""
  - ""The purpose of this dissertation is to promote semantic formalization in mathematical modeling languages by showing the feasibility of employing an attribute grammar formalism as a design paradigm for some of the major components of an OR modeling environment.""",,"- The abstract discusses the use of ""attribute grammar formalism"" as a design paradigm, which suggests a focus on formalizing the semantics of mathematical modeling languages rather than generic programming or abstraction mechanisms.
 - The mention of ""semantic formalization"" and ""static semantics"" indicates a focus on defining and enforcing the meaning and structure of modeling languages, but does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not provide specific details on generic programming methodology, type system discussions, or abstraction mechanism explanations, which are key components of genericity and abstraction mechanisms.
 - The focus is on semantic formalization and the use of attribute grammar equations to support this formalization, rather than on generic programming or abstraction.","- ""The purpose of this dissertation is to promote semantic formalization in mathematical modeling languages by showing the feasibility of employing an attribute grammar formalism as a design paradigm for some of the major components of an OR modeling environment.""
  - ""We begin by identifying the areas where semantic formalization is needed in selected modeling languages for mathematical programming.""
  - ""Then, using SML (Structured Modeling Language) as an example, we propose and show the feasibility of supporting the complete static semantics of mathematical modeling languages through attribute grammar equations.""
  - ""Next, we propose equations for various areas that we identify as amenable to language simplification via the automatic deduction of missing language constructs.""
  - ""Finally, we validate our approach by implementing a prototype modeling environment which enforces the full syntax and semantics of SML, and by testing it using a large number of models from a variety of domains.""
  - ""We conclude that it is possible to use attribute grammars to rigorously formalize a mathematical modeling language, and to automatically generate modeling environment tools.""",,"- The abstract highlights the novelty of using attribute grammar formalism as a design paradigm for mathematical modeling languages, which is a new approach to semantic formalization.
 - The study identifies areas where semantic formalization is needed, which is a key insight into the limitations of current modeling languages.
 - The use of attribute grammar equations to support the complete static semantics of mathematical modeling languages is a theoretical advancement, as it provides a rigorous method for formalizing these languages.
 - The proposal of equations for language simplification through automatic deduction of missing constructs is another theoretical contribution, as it offers a way to simplify model design.
 - The validation of this approach through a prototype implementation demonstrates its feasibility and potential implications for programming language design, particularly in making modeling less error-prone."
Para-functional programming: a paradigm for programming multiprocessor systems,"P. Hudak, Lauren Smith",10.1145/512644.512667,https://doi.org/10.1145/512644.512667,ACM-SIGACT Symposium on Principles of Programming Languages,63,1986,Not specified (the abstract does not explicitly define conceptual primitives),"- Type of mathematical framework: Denotational semantics using execution trees
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Use of annotations to explicitly express program-machine mappings.
 - Interaction models between paradigms: Not explicitly discussed.
 - Constraints or challenges in paradigm integration: Minor constraints for annotations.
 - Novel translation or embedding techniques: Experimental language called ParAlfl.",Generic programming not extensively addressed,"- Key novel insights: Introduction of explicit programmer control over program-to-machine mapping in functional languages.
 - Theoretical advancements: Use of annotations that maintain functional semantics, development of ""para-functional"" programming methodology, and formal denotational description using execution trees.
 - Potential implications: Enhanced expressiveness and control over parallelism in functional programming languages, potentially influencing future programming language design.","- ""This paper is concerned with ways to allow the programmer to <i>explicitly</i> express this mapping of program to machine, by using annotations that, given a few minor constraints, cannot alter the functional semantics of the program.""
  - ""We also give a formal denotational description of the mapping semantics using a notion of <i>execution trees.</i>This""
  - ""We show through several detailed examples the expressiveness and conciseness of the resulting ""para-functional"" programming methodology, using an experimental language called <i>ParAlfl</i> based on our ideas.""
  - ""Yet it is often the case that one knows precisely the <i>optimal decomposition</i> for execution on a particular machine, and one can never expect a compiler to determine such optimal mappings in all cases.""
  - ""One of the most important pragmatic advantages of functional languages is that concurrency in a program is <i>implicit</i> -- there is no need for special constructs to express parallelism as is required in most conventional languages.""",,"- The abstract discusses the implicit concurrency in functional languages and the need for explicit mapping of programs to machines.
 - It introduces the concept of ""para-functional"" programming, which involves using annotations to express this mapping without altering the functional semantics.
 - The abstract mentions the use of an experimental language called ""ParAlfl"" and a formal denotational description using ""execution trees,"" but it does not explicitly define conceptual primitives.
 - The focus is on methodology and theoretical framework rather than specific conceptual primitives.
 - The abstract does not provide explicit definitions or names for conceptual primitives, nor does it discuss their level of abstraction or orthogonality.","- ""We also give a formal denotational description of the mapping semantics using a notion of <i>execution trees.</i>This""",,"- The abstract mentions a ""formal denotational description of the mapping semantics using a notion of <i>execution trees.</i>"" This suggests that the mathematical framework used involves denotational semantics, which is a method for assigning meanings to programming languages.
 - The use of ""execution trees"" implies a structured approach to describing the execution of programs, which is a common technique in denotational semantics.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.
 - The abstract does not specify the type of mathematical framework beyond the use of denotational semantics and execution trees.","- ""We also give a formal denotational description of the mapping semantics using a notion of <i>execution trees.</i>This""
  - ""We show through several detailed examples the expressiveness and conciseness of the resulting ""para-functional"" programming methodology, using an experimental language called <i>ParAlfl</i> based on our ideas.""
  - ""This paper is concerned with ways to allow the programmer to <i>explicitly</i> express this mapping of program to machine, by using annotations that, given a few minor constraints, cannot alter the functional semantics of the program.""
  - ""Yet it is often the case that one knows precisely the <i>optimal decomposition</i> for execution on a particular machine, and one can never expect a compiler to determine such optimal mappings in all cases.""
  - ""One of the most important pragmatic advantages of functional languages is that concurrency in a program is <i>implicit</i> -- there is no need for special constructs to express parallelism as is required in most conventional languages.""",,"- The abstract discusses the integration of functional programming with parallel processing, focusing on how to explicitly map programs to machines.
 - The ""para-functional"" programming methodology is introduced as a way to integrate functional programming with parallelism, using annotations to specify program-machine mappings.
 - The use of annotations is a specific integration mechanism proposed to allow explicit expression of concurrency without altering functional semantics.
 - The abstract mentions the use of an experimental language called ParAlfl, which suggests a novel translation or embedding technique for integrating functional programming with parallelism.
 - The abstract does not explicitly discuss interaction models between paradigms or constraints/challenges in paradigm integration beyond the mention of minor constraints for annotations.",,,"- The abstract discusses the implicit concurrency in functional languages and the need for explicit mapping of programs to machines, which is related to abstraction but not specifically generic programming.
 - The focus is on ""para-functional"" programming methodology and the use of annotations to express program-to-machine mapping, which is more about concurrency and parallelism than generic programming.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanisms specifically related to genericity.
 - The abstract does not provide information on minimal type requirements, static checking, or optimization strategies related to generic programming.",,,"- The abstract highlights the implicit concurrency in functional languages as a key advantage, but notes that optimal decomposition for specific machines often requires explicit programmer input.
 - The paper introduces a novel approach by allowing programmers to explicitly express program-to-machine mappings using annotations, which is a theoretical contribution as it enhances the expressiveness of functional programming.
 - The use of annotations that do not alter functional semantics is a key theoretical advancement, as it maintains the integrity of functional programming principles while allowing for more control over parallelism.
 - The development of a ""para-functional"" programming methodology and the use of an experimental language (ParAlfl) demonstrate a theoretical contribution by providing a new framework for programming multiprocessor systems.
 - The formal denotational description of mapping semantics using execution trees is a theoretical advancement, as it provides a rigorous framework for understanding and analyzing the proposed methodology."
Higher-Order Causal Stream Functions in Sig from First Principles,"B. T. Widemann, M. Lepper",-,-,Software Engineering,0,2016,"1. Primitive Name: Sequential Composition
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 2. Primitive Name: Parallel Composition
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 3. Primitive Name: Delay
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed
 4. Primitive Name: Apply
  Definition: Not explicitly defined
  Orthogonality Score: Not discussed","- Type of mathematical framework: Coalgebraic semantics
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Rephrasing coalgebraic concepts in basic mathematical notation, demonstrating how language features are shaped by semantic structure.
 - Theoretical advancements: Making coalgebraic semantics more accessible and understandable.
 - Potential implications: Introduction to coalgebraic semantics and explication of Sig language design, potentially influencing programming language design.","- ""We demonstrate how the language features characteristic of its paradigms, namely sequential and parallel composition for applicative style, delay for data flow, and apply for higher-order functional programming, are shaped naturally by the semantic structure.""
  - ""In the present paper, we rephrase the coalgebraic concepts relevant for the Sig language semantics in basic mathematical notation.""
  - ""Universal coalgebra is an expressive theoretical framework for behavioral semantics, but traditionally phrased in abstract categorical language, and generally considered inaccessible.""
  - ""Its core has been designed to admit concise coalgebraic semantics.""
  - ""The Sig programming language is a total functional, clocked synchronous data-flow language.""",,"- The abstract mentions that the Sig language is a ""total functional, clocked synchronous data-flow language,"" which suggests that these characteristics are fundamental to its design.
 - The core of Sig is designed to admit ""concise coalgebraic semantics,"" indicating that coalgebraic concepts are central to its theoretical framework.
 - The paper aims to rephrase coalgebraic concepts in ""basic mathematical notation,"" which implies that these concepts are being redefined or reinterpreted in a more accessible form.
 - The abstract lists specific language features: ""sequential and parallel composition for applicative style, delay for data flow, and apply for higher-order functional programming."" These are likely the conceptual primitives as they are described as being ""shaped naturally by the semantic structure.""
 - The abstract does not provide explicit definitions for these primitives, nor does it discuss their orthogonality or level of abstraction.","- ""Thus the present paper serves two purposes, as a gentle, self-contained and applied introduction to coalgebraic semantics, and as an explication of the Sig core language denotational and operational design.""
  - ""In the present paper, we rephrase the coalgebraic concepts relevant for the Sig language semantics in basic mathematical notation.""
  - ""Universal coalgebra is an expressive theoretical framework for behavioral semantics, but traditionally phrased in abstract categorical language, and generally considered inaccessible.""",,"- The abstract mentions ""Universal coalgebra"" as a theoretical framework, which is a type of mathematical framework. This indicates that the mathematical framework used is coalgebraic semantics.
 - The abstract states that coalgebraic concepts are rephrased in ""basic mathematical notation,"" suggesting a simplification or reinterpretation of the framework for better accessibility.
 - The abstract does not specify any particular mathematical properties guaranteed by this framework, nor does it mention specific proof techniques or limitations.
 - The focus is on rephrasing coalgebraic concepts and serving as an introduction to coalgebraic semantics, rather than detailing specific mathematical properties or proof methodologies.","- ""We demonstrate how the language features characteristic of its paradigms, namely sequential and parallel composition for applicative style, delay for data flow, and apply for higher-order functional programming, are shaped naturally by the semantic structure.""
  - ""Its core has been designed to admit concise coalgebraic semantics.""
  - ""The Sig programming language is a total functional, clocked synchronous data-flow language.""",,"- The abstract mentions that the Sig language is a ""total functional, clocked synchronous data-flow language,"" which suggests it integrates different programming paradigms such as functional and data-flow programming.
 - The mention of ""sequential and parallel composition for applicative style, delay for data flow, and apply for higher-order functional programming"" indicates that these are features characteristic of the paradigms integrated within the Sig language.
 - The abstract does not explicitly discuss specific integration mechanisms, interaction models, constraints, or novel translation techniques. It focuses on how these features are ""shaped naturally by the semantic structure,"" which implies a theoretical integration strategy.
 - The abstract does not provide detailed information on how these paradigms interact or any specific challenges in their integration.","- ""The Sig programming language is a total functional, clocked synchronous data-flow language.""
  - ""Universal coalgebra is an expressive theoretical framework for behavioral semantics, but traditionally phrased in abstract categorical language, and generally considered inaccessible.""
  - ""We demonstrate how the language features characteristic of its paradigms, namely sequential and parallel composition for applicative style, delay for data flow, and apply for higher-order functional programming, are shaped naturally by the semantic structure.""
  - ""In the present paper, we rephrase the coalgebraic concepts relevant for the Sig language semantics in basic mathematical notation.""
  - ""Its core has been designed to admit concise coalgebraic semantics.""",,"- The abstract discusses the Sig programming language and its coalgebraic semantics, which suggests a focus on theoretical and semantic aspects rather than generic programming or abstraction mechanisms.
 - The mention of ""coalgebraic concepts"" and ""basic mathematical notation"" indicates a focus on theoretical frameworks rather than practical programming mechanisms.
 - The abstract does not mention any specific mechanisms for generic programming, type systems, or abstraction mechanisms that are typically associated with genericity and abstraction.
 - The focus is on the language's design and semantics rather than on generic programming methodologies or type system discussions.","- ""The Sig programming language is a total functional, clocked synchronous data-flow language.""
  - ""Its core has been designed to admit concise coalgebraic semantics.""
  - ""Universal coalgebra is an expressive theoretical framework for behavioral semantics, but traditionally phrased in abstract categorical language, and generally considered inaccessible.""
  - ""In the present paper, we rephrase the coalgebraic concepts relevant for the Sig language semantics in basic mathematical notation.""
  - ""We demonstrate how the language features characteristic of its paradigms, namely sequential and parallel composition for applicative style, delay for data flow, and apply for higher-order functional programming, are shaped naturally by the semantic structure.""
  - ""Thus the present paper serves two purposes, as a gentle, self-contained and applied introduction to coalgebraic semantics, and as an explication of the Sig core language denotational and operational design.""",,"- The abstract mentions that the Sig programming language is designed to admit concise coalgebraic semantics, which suggests a theoretical contribution in making coalgebraic semantics more accessible.
 - The rephrasing of coalgebraic concepts in basic mathematical notation is a novel insight, as it makes these concepts more accessible and understandable, which is a theoretical advancement beyond existing approaches.
 - The demonstration of how language features are shaped by the semantic structure is a key novel insight, as it provides a deeper understanding of the language's design.
 - The paper serves as an introduction to coalgebraic semantics and an explication of the Sig language's design, which implies potential implications for programming language design by making coalgebraic semantics more accessible and applicable."
A Formalization of Concepts for Generic Programming,"Jeremiah Willcock, Jaakko Järvi, A. Lumsdaine, D. Musser",-,-,-,17,2004,Not specified (the abstract does not explicitly list or define specific conceptual primitives),Not specified (the abstract does not mention a specific mathematical framework or its characteristics),No specific integration approach described,"- Definition of ""concept"": A set of abstractions (such as types) whose membership is determined by a set of requirements.
 - Mechanisms for representing generic abstractions: A unified framework for realizing concept approximations in existing languages.
 - Minimal type requirements identified: Seeking to identify the minimal requirements on types necessary for correct and efficient execution of an algorithm or family of algorithms.
 - Static checking or optimization strategies: Concepts are not explicitly represented in traditional programming languages, affecting static checking and optimization.","The paper provides a unified framework for realizing concept approximations in existing languages, offering a language-independent definition of concepts. This addresses the lack of explicit representation of concepts in traditional programming languages, particularly in C++, and has implications for improving static checking and optimization. It represents a theoretical advancement beyond existing language-specific approaches.","- ""The term concept is used in this context to mean a set of abstractions (such as types) whose membership is determined by a set of requirements.""
  - ""Generic programming starts with algorithms, seeking to identify the minimal requirements on types necessary for correct and efficient execution of an algorithm or family of algorithms, leading to generic algorithms that can be applied to arguments of many different types.""
  - ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages, and we present such descriptions for several popular languages used for generic programming.""",,"- The abstract discusses the concept of ""concepts"" in generic programming, which are defined as ""a set of abstractions (such as types) whose membership is determined by a set of requirements."" This suggests that the conceptual primitives are related to these abstractions and requirements.
 - The abstract mentions that the paper provides a ""unified framework for realizing concept approximations in existing languages,"" indicating that the study likely defines or discusses conceptual primitives in this context.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It provides a general framework for understanding concepts but does not detail the specific primitives or their definitions.
 - The abstract does not mention any specific names or definitions of conceptual primitives, nor does it discuss their orthogonality or level of abstraction.","- ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages,""
  - ""The term concept is used in this context to mean a set of abstractions (such as types) whose membership is determined by a set of requirements.""
  - ""Generic programming starts with algorithms, seeking to identify the minimal requirements on types necessary for correct and efficient execution of an algorithm or family of algorithms,""
  - ""Despite their importance, concepts are not explicitly represented in traditional programming languages.""
  - ""Generic programming is a paradigm for systematic design and classification of software components for optimal reuse.""",,"- The abstract discusses the concept of generic programming and the importance of concepts in this context, but it does not explicitly mention any mathematical framework used to formalize or guarantee properties of these concepts.
 - There is no mention of specific mathematical properties, proof techniques, or limitations related to a mathematical framework.
 - The abstract focuses on the definition and application of concepts in programming languages rather than on a mathematical framework.
 - The phrase ""unified framework"" is used, but it refers to a framework for realizing concept approximations in existing languages, not a mathematical framework.","- ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages, and we present such descriptions for several popular languages used for generic programming.""
  - ""Despite their importance, concepts are not explicitly represented in traditional programming languages.""
  - ""The term concept is used in this context to mean a set of abstractions (such as types) whose membership is determined by a set of requirements.""
  - ""Generic programming starts with algorithms, seeking to identify the minimal requirements on types necessary for correct and efficient execution of an algorithm or family of algorithms, leading to generic algorithms that can be applied to arguments of many different types.""
  - ""Generic programming is a paradigm for systematic design and classification of software components for optimal reuse.""",,"- The abstract discusses generic programming as a paradigm, which is a systematic approach to designing software components for reuse. However, it does not explicitly mention the integration of different programming paradigms.
 - The focus is on the concept of generic programming and the lack of explicit representation of concepts in traditional programming languages, particularly C++.
 - The abstract mentions a unified framework for realizing concept approximations in existing languages, but this is more about providing a framework for understanding concepts rather than integrating different paradigms.
 - There is no mention of specific integration mechanisms, interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.","- ""Generic programming is a paradigm for systematic design and classification of software components for optimal reuse.""
  - ""Generic programming starts with algorithms, seeking to identify the minimal requirements on types necessary for correct and efficient execution of an algorithm or family of algorithms, leading to generic algorithms that can be applied to arguments of many different types.""
  - ""The term concept is used in this context to mean a set of abstractions (such as types) whose membership is determined by a set of requirements.""
  - ""Despite their importance, concepts are not explicitly represented in traditional programming languages.""
  - ""C++, in particular, lacks any means to express concepts, which has forced all concept development to be done outside the language and thus be unavailable to C++ compilers for static checking or optimization.""
  - ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages, and we present such descriptions for several popular languages used for generic programming.""",,"- The abstract defines generic programming as a paradigm for systematic design and classification of software components for optimal reuse, indicating a focus on genericity.
 - The term ""concept"" is defined as a set of abstractions determined by a set of requirements, which is central to the abstraction mechanism in generic programming.
 - The abstract mentions that generic programming involves identifying minimal type requirements for algorithms, which is a key aspect of genericity and abstraction.
 - It notes that traditional programming languages, particularly C++, lack explicit representation of concepts, which affects static checking and optimization.
 - The paper provides a unified framework for concept approximations in existing languages, suggesting a mechanism for representing generic abstractions.","- ""Generic programming is a paradigm for systematic design and classification of software components for optimal reuse.""
  - ""Generic programming starts with algorithms, seeking to identify the minimal requirements on types necessary for correct and efficient execution of an algorithm or family of algorithms, leading to generic algorithms that can be applied to arguments of many different types.""
  - ""The term concept is used in this context to mean a set of abstractions (such as types) whose membership is determined by a set of requirements.""
  - ""Despite their importance, concepts are not explicitly represented in traditional programming languages.""
  - ""C++, in particular, lacks any means to express concepts, which has forced all concept development to be done outside the language and thus be unavailable to C++ compilers for static checking or optimization.""
  - ""Several other languages do have features than can approximate certain aspects of concepts, but what is missing is a uniform, language-independent definition of concepts.""
  - ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages, and we present such descriptions for several popular languages used for generic programming.""",,"- The abstract discusses the paradigm of generic programming and its focus on identifying minimal type requirements for algorithms, which is a foundational concept in the field.
 - It highlights the lack of explicit representation of concepts in traditional programming languages, particularly in C++, which has significant implications for static checking and optimization.
 - The paper addresses this gap by providing a ""unified framework for realizing concept approximations in existing languages,"" which is a novel theoretical contribution.
 - This framework offers a language-independent definition of concepts, which is a theoretical advancement beyond existing approaches that are language-specific.
 - The potential implications for programming language design are significant, as it could lead to better support for generic programming and more efficient use of concepts across different languages."
"Join inverse rig categories for reversible functional programming, and beyond","R. Kaarsgaard, Mathys Rennela",10.4204/EPTCS.351.10,https://doi.org/10.4204/EPTCS.351.10,Mathematical Foundations of Programming Semantics,6,2021,"1. Primitive Name: Join Inverse Rig Categories
  Definition: A join inverse category equipped with a join-preserving inverse product and a join-preserving disjointness tensor, with natural isomorphisms distributing products over sums.
  Orthogonality Score: High (distinct combination of existing mathematical structures)","- Type of mathematical framework: Category theory, specifically join inverse rig categories
 - Specific mathematical properties guaranteed: Decidable equality, decidable pattern matching, modeling of reversible computing
 - Proof techniques used: Axiomatization of categorical models, construction of denotational models using join inverse rig categories
 - Limitations or constraints of the framework: Not explicitly mentioned","- Specific integration mechanisms proposed: Join inverse rig categories as a model for reversible computing, integrating Rfun, Theseus, and reversible flowcharts.
 - Interaction models between paradigms: Categorical structure of join inverse rig categories facilitates integration.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Embedding different reversible programming languages into join inverse rig categories.",Generic programming not extensively addressed,"- Introduction of ""join inverse rig categories"" as a new theoretical framework for reversible computing.
 - Broad applicability of join inverse rig categories to multiple reversible programming languages (Rfun, Theseus, reversible flowcharts).
 - Axiomatization of categorical models for reversible computing, providing a comprehensive theoretical framework.
 - Potential implications for programming language design by providing a theoretical foundation for reversible languages.","- ""We conclude our study in Section 6 with a definition of categorical models of reversible computing as join inverse rig categories with decidable equality and decidable pattern matching.""
  - ""we introduce join inverse rig categories, the natural marriage of join inverse categories and rig categories, which we show can be used to model the language Rfun, under reasonable assumptions.""
  - ""Definition 3.4. A join inverse rig category is a join inverse category equipped with a join-preserving inverse product pb, 1q and a join-preserving disjointness tensor p', 0q, such that there are natural isomorphisms X b pY ' Zq""
  - ""In this setting, join inverse rig categories are join inverse categories equipped with monoidal products X bY and monoidal sums X 'Y for every pair of objects X and Y , together with a isomorphisms which distribute products over sums and annihilate products with the additive unit, subject to preservation of joins and the usual coherence laws of rig categories.""",,"- The paper introduces ""join inverse rig categories"" as a conceptual primitive for modeling reversible computing, specifically for the language Rfun.
 - These categories are defined as a combination of join inverse categories and rig categories, which provides a framework for reversible computing.
 - The definition includes specific components such as monoidal products and sums, isomorphisms, and preservation of joins, which are fundamental to the structure of these categories.
 - The paper also discusses the axiomatization of these categories for reversible computing, indicating their role as conceptual primitives in this context.
 - The level of abstraction is high, as these categories are abstract mathematical structures used to model programming paradigms.
 - The orthogonality of these primitives is implied by their definition as a distinct combination of existing mathematical structures (join inverse categories and rig categories), suggesting they are orthogonal to other primitives in the field.","- ""We investigate the formal semantics of the reversible functional programming language Rfun.""
  - ""we introduce join inverse rig categories, the natural marriage of join inverse categories and rig categories, which we show can be used to model the language Rfun, under reasonable assumptions.""
  - ""These categories turn out to be a particularly natural fit for reversible computing as a whole, as they encompass models for other reversible programming languages, notably Theseus and reversible flowcharts.""
  - ""In order to construct denotational models of the terms of the language Rfun, we adopt the categorical formalism of join inverse rig categories.""
  - ""We conclude our study in Section 6 with a definition of categorical models of reversible computing as join inverse rig categories with decidable equality and decidable pattern matching.""
  - ""The present work focuses on join inverse categories. The definition of such categories relies on the fact that in a restriction category C, every hom-set CpA, Bq gives rise to a poset when equipped with the following partial order: f ď g if and only if g ˝f""
  - ""In a join inverse category, every restriction idempotent e has a pseudocomplement e K given by Ž e 1 PCpeq e 1 where Cpeq""
  - ""Join inverse categories are canonically enriched in domains [5,28]. This has the pleasant property that any morphism scheme, i.e., Scott-continuous function HompX,Y q Ñ HompX,Y q has a fixed-point: Theorem 2.9 ( [5,28]).""
  - ""We are finally ready to take on the semantics of function definitions and programs in Rfun. This is comparatively much simpler. Like expressions, the semantics of function definitions is given parametrised by a program context ξ""",,"- The paper uses category theory as the mathematical framework to formalize and guarantee properties of the conceptual primitives in reversible computing, specifically focusing on join inverse rig categories.
 - The framework is used to model the language Rfun and other reversible programming languages like Theseus and reversible flowcharts.
 - The mathematical properties guaranteed by this framework include the ability to model reversible computing, decidable equality, and decidable pattern matching.
 - The proof techniques used involve the axiomatization of categorical models and the use of join inverse rig categories to construct denotational models.
 - The framework is enriched in domains, allowing for fixed points in morphism schemes, which is useful for modeling recursive functions.
 - The limitations or constraints of the framework are not explicitly mentioned in the paper, but it is noted that the framework is particularly suited for reversible computing.","- ""Reversible computing is a computational paradigm in which computations are deterministic in both the forward and backward direction, so that programs have well-defined forward and backward semantics.""
  - ""These categories turn out to be a particularly natural fit for reversible computing as a whole, as they encompass models for other reversible programming languages, notably Theseus and reversible flowcharts.""
  - ""join inverse rig categories are join inverse categories equipped with monoidal products X bY and monoidal sums X 'Y for every pair of objects X and Y , together with a isomorphisms which distribute products over sums and annihilate products with the additive unit, subject to preservation of joins and the usual coherence laws of rig categories.""
  - ""Join inverse rig categories also turn out to constitute a model for structured reversible flowcharts, as studied in [19].""
  - ""Rig categories and groupoids have previously been considered in connection with reversible computing. Notably, the Π family [9,26] of reversible programming languages, as well as the language CoreFun [25], are essentially term languages for dagger rig categories.""
  - ""The notion of a distributive inverse category [18] is also strongly related to our approach.""",,"- The paper discusses the integration of different programming paradigms through the lens of join inverse rig categories, which are proposed as a model for reversible computing.
 - The integration mechanism involves using join inverse rig categories to model various reversible programming languages, such as Rfun, Theseus, and reversible flowcharts.
 - The interaction model between paradigms is facilitated by the categorical structure of join inverse rig categories, which allows for the integration of different languages through their common categorical framework.
 - The paper does not explicitly mention specific constraints or challenges in paradigm integration, but it implies that the use of join inverse rig categories provides a unified framework for different reversible languages.
 - The novel translation or embedding technique involves using join inverse rig categories to embed different reversible programming languages, providing a common semantic framework for these languages.","- ""Our work involves an unorthodox way of thinking about the denotational semantics of a function in a functional programming language to be explicitly constructed piecemeal by the (partial) denotations of its individual branches.""
  - ""In order to construct denotational models of the terms of the language Rfun, we adopt the categorical formalism of join inverse rig categories.""
  - ""The syntax of the programming language Rfun can be summarised by the following grammars: Left Expressions l""
  - ""l | let l out""
  - ""f l out in e | case l of tl i Ñ e i u m i""1""
  - ""f x fi e Programs q""
  - ""The values of Rfun are of the form cpv 1 , . . . , v n q for n ě 0, where c is some constructor name, and each v i is a value.""
  - ""We conclude our study in Section 6 with a definition of categorical models of reversible computing as join inverse rig categories with decidable equality and decidable pattern matching.""",,"- The paper focuses on the categorical formalism of join inverse rig categories for modeling reversible computing, particularly with the language Rfun. This suggests a focus on abstracting away from specific implementation details to capture the essence of reversible computing.
 - The use of categorical formalism implies a high level of abstraction, as categories are used to model the structure and behavior of reversible computing systems.
 - The paper discusses the syntax and semantics of Rfun, which includes mechanisms for pattern matching and function definitions. These are forms of abstraction, as they allow for generic programming by defining functions that can operate on various data types.
 - The paper does not explicitly discuss generic programming methodologies or type systems in detail, nor does it mention static checking or optimization strategies related to genericity.
 - The focus is more on the categorical models and their application to reversible computing rather than on generic programming or abstraction mechanisms in the traditional sense.","- ""We investigate the formal semantics of the reversible functional programming language Rfun. For this purpose, we introduce join inverse rig categories, the natural marriage of join inverse categories and rig categories, which we show can be used to model the language Rfun, under reasonable assumptions.""
  - ""These categories turn out to be a particularly natural fit for reversible computing as a whole, as they encompass models for other reversible programming languages, notably Theseus and reversible flowcharts.""
  - ""In order to construct denotational models of the terms of the language Rfun, we adopt the categorical formalism of join inverse rig categories.""
  - ""join inverse rig categories are join inverse categories equipped with monoidal products X bY and monoidal sums X 'Y for every pair of objects X and Y , together with a isomorphisms which distribute products over sums and annihilate products with the additive unit, subject to preservation of joins and the usual coherence laws of rig categories.""
  - ""The present work provides a building block in the study of reversible computing through the lens of category theory.""
  - ""Join inverse rig categories also turn out to constitute a model for structured reversible flowcharts, as studied in [19].""
  - ""With arguably weak categorical assumptions, we showcase the strengths of join inverse category theory in the study of the semantics of reversible programming.""",,"- The paper introduces a new theoretical framework called ""join inverse rig categories,"" which is a combination of join inverse categories and rig categories. This is a novel contribution as it provides a new categorical model for reversible computing.
 - The paper demonstrates that these categories are not only applicable to the reversible functional programming language Rfun but also to other reversible programming languages like Theseus and reversible flowcharts. This broad applicability is a significant theoretical advancement.
 - The work focuses on the axiomatization of categorical models for reversible computing, which is a theoretical contribution beyond existing approaches that may not have provided such a comprehensive framework.
 - The use of join inverse rig categories to model reversible computing languages suggests potential implications for programming language design, as it provides a theoretical foundation for designing reversible languages.
 - The paper highlights the strengths of join inverse category theory in the study of reversible programming semantics, indicating a theoretical advancement in understanding and modeling reversible computing."
Advances in Distributed Computing (ADC) and Colloquium on Combining Paradigms for Software Development (CCPSD),"S. Abramsky, T. Maibaum, Colloquium on Trees in Algebra",-,-,-,1,1991,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract lists various techniques and areas of focus but does not explicitly specify a single mathematical framework or its characteristics),"- Specific integration mechanisms proposed: CCS for OO and LP, combining interaction and automation in process algebra verification.
 - Interaction models between paradigms: Relationship between algebraic module specifications and program modules.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Actor-oriented system specification with dynamic logic, formally based component description language.",Generic programming not extensively addressed,"- Novel insights: Extended expansion theorem, concurrent abstract machines, knowledge and probability in distributed systems, proving termination of logic programs by exploiting term properties.
 - Theoretical advancements: Parametric order-sorted types in logic programming, non-standard interpretations of LOTOS specifications, new technique for strictness analysis, using higher order logic for modelling real-time protocols.
 - Potential implications for programming language design: Advancements in verification methods, formal specification of object systems, structuring specifications in-the-large and in-the-small.","- ""CCS for OO and LP.- An extended expansion theorem.- Concurrent abstract machines.-""
  - ""Knowledge and probability in distributed systems: Abstract.-""
  - ""Verification methods for finite systems.-""
  - ""Interactive interworking for interoperating systems.-""
  - ""Formal specification of object systems.-""
  - ""On the relationship between algebraic module specifications and program modules.-""
  - ""Testing against formal specifications: A theoretical view.-""
  - ""Construction and reuse of formal program developments.-""
  - ""A theory of program modifications.-""
  - ""Proving termination of logic programs by exploiting term properties.-""
  - ""Parametric order-sorted types in logic programming.-""
  - ""Exploiting non-determinism through laziness in guarded functional languages.-""
  - ""Non-standard interpretations of LOTOS specifications.-""
  - ""A new technique for strictness analysis.-""
  - ""Using higher order logic for modelling real-time protocols.-""
  - ""Combining interaction and automation in process algebra verification.-""
  - ""Refining interfaces of communicating systems.-""
  - ""Structuring specifications in-the-large and in-the-small: Higher-order functions, dependent types and inheritance in SPECTRAL.-""
  - ""Actor-oriented system specification with dynamic logic.-""
  - ""Towards a formally based component description language.-""
  - ""On addition schemes.-""
  - ""Efficient code motion and an adaption to strength reduction.-""
  - ""On narrowing strategies for partial non-strict functions.-""
  - ""From reduction machines to narrowing machines.-""
  - ""The evaluation transformer model of reduction and its correctness.""",,"- The abstract provides a list of topics and techniques related to distributed computing and software development paradigms, but it does not explicitly define conceptual primitives.
 - The abstract mentions various theoretical and methodological approaches, such as CCS for OO and LP, concurrent abstract machines, and formal specification of object systems, but these are not explicitly defined as conceptual primitives.
 - There is no clear indication of specific conceptual primitives being proposed or defined in the abstract.
 - The abstract focuses on presenting a range of topics and techniques rather than defining fundamental conceptual primitives.","- ""CCS for OO and LP.- An extended expansion theorem.-""
  - ""Concurrent abstract machines.-""
  - ""Verification methods for finite systems.-""
  - ""Formal specification of object systems.-""
  - ""On the relationship between algebraic module specifications and program modules.-""
  - ""Testing against formal specifications: A theoretical view.-""
  - ""Construction and reuse of formal program developments.-""
  - ""A theory of program modifications.-""
  - ""Proving termination of logic programs by exploiting term properties.-""
  - ""Parametric order-sorted types in logic programming.-""
  - ""Exploiting non-determinism through laziness in guarded functional languages.-""
  - ""Non-standard interpretations of LOTOS specifications.-""
  - ""A new technique for strictness analysis.-""
  - ""Using higher order logic for modelling real-time protocols.-""
  - ""Combining interaction and automation in process algebra verification.-""
  - ""Refining interfaces of communicating systems.-""
  - ""Structuring specifications in-the-large and in-the-small: Higher-order functions, dependent types and inheritance in SPECTRAL.-""
  - ""Actor-oriented system specification with dynamic logic.-""
  - ""Towards a formally based component description language.-""
  - ""On addition schemes.-""
  - ""Efficient code motion and an adaption to strength reduction.-""
  - ""On narrowing strategies for partial non-strict functions.-""
  - ""From reduction machines to narrowing machines.-""
  - ""The evaluation transformer model of reduction and its correctness.""",,"- The abstract mentions several topics related to formal verification and theoretical foundations, such as ""CCS for OO and LP,"" ""Concurrent abstract machines,"" and ""Verification methods for finite systems."" These suggest a focus on process algebra and concurrent systems.
 - The mention of ""Formal specification of object systems"" and ""On the relationship between algebraic module specifications and program modules"" indicates the use of formal specification techniques, possibly involving algebraic module specifications.
 - The abstract references ""Parametric order-sorted types in logic programming"" and ""Using higher order logic for modelling real-time protocols,"" which suggests the use of type theory and higher-order logic as part of the mathematical framework.
 - The mention of ""Proving termination of logic programs by exploiting term properties"" and ""Combining interaction and automation in process algebra verification"" indicates the use of proof techniques related to logic programming and process algebra.
 - The abstract does not explicitly mention limitations or constraints of the framework, nor does it specify a single overarching mathematical framework like type theory or category theory. Instead, it lists various techniques and areas of focus.","- ""CCS for OO and LP.-""
  - ""On the relationship between algebraic module specifications and program modules.-""
  - ""Combining interaction and automation in process algebra verification.-""
  - ""Structuring specifications in-the-large and in-the-small: Higher-order functions, dependent types and inheritance in SPECTRAL.-""
  - ""Actor-oriented system specification with dynamic logic.-""
  - ""Towards a formally based component description language.-""",,"- The abstract mentions ""CCS for OO and LP,"" which suggests an integration of different programming paradigms, specifically the integration of CCS (Communicating Sequential Processes) with object-oriented (OO) and logic programming (LP) paradigms.
 - The phrase ""On the relationship between algebraic module specifications and program modules"" implies a discussion on how different module specifications can be integrated or related, which is a part of paradigm integration.
 - ""Combining interaction and automation in process algebra verification"" suggests a method for integrating interaction and automation, which could be part of a broader integration strategy.
 - ""Structuring specifications in-the-large and in-the-small: Higher-order functions, dependent types and inheritance in SPECTRAL"" indicates a focus on structuring specifications across different scales, which might involve integrating different paradigms.
 - ""Actor-oriented system specification with dynamic logic"" and ""Towards a formally based component description language"" suggest novel approaches to system specification and component description, which could involve integrating different paradigms.","- ""CCS for OO and LP.-""
  - ""Formal specification of object systems.-""
  - ""On the relationship between algebraic module specifications and program modules.-""
  - ""Construction and reuse of formal program developments.-""
  - ""A theory of program modifications.-""
  - ""Parametric order-sorted types in logic programming.-""
  - ""Exploiting non-determinism through laziness in guarded functional languages.-""
  - ""Structuring specifications in-the-large and in-the-small: Higher-order functions, dependent types and inheritance in SPECTRAL.-""
  - ""Actor-oriented system specification with dynamic logic.-""",,"- The abstract mentions several topics related to programming and software development, but it does not explicitly focus on generic programming or abstraction mechanisms.
 - The mention of ""CCS for OO and LP"" suggests some discussion of concurrent systems and object-oriented programming, but it does not directly address genericity or abstraction.
 - ""Formal specification of object systems"" and ""On the relationship between algebraic module specifications and program modules"" might imply some level of abstraction, but again, these are not explicitly linked to generic programming.
 - ""Parametric order-sorted types in logic programming"" is the closest mention to generic programming, as it involves type systems and could relate to abstraction mechanisms.
 - ""Structuring specifications in-the-large and in-the-small: Higher-order functions, dependent types and inheritance in SPECTRAL"" suggests some discussion of abstraction mechanisms, but it is not explicitly about generic programming.
 - Overall, while there are mentions of concepts related to abstraction and type systems, the abstract does not extensively address generic programming or provide detailed mechanisms for representing generic abstractions.","- ""CCS for OO and LP.- An extended expansion theorem.-""
  - ""Concurrent abstract machines.-""
  - ""Knowledge and probability in distributed systems: Abstract.-""
  - ""Verification methods for finite systems.-""
  - ""Interactive interworking for interoperating systems.-""
  - ""Formal specification of object systems.-""
  - ""On the relationship between algebraic module specifications and program modules.-""
  - ""Testing against formal specifications: A theoretical view.-""
  - ""Construction and reuse of formal program developments.-""
  - ""A theory of program modifications.-""
  - ""Proving termination of logic programs by exploiting term properties.-""
  - ""Parametric order-sorted types in logic programming.-""
  - ""Exploiting non-determinism through laziness in guarded functional languages.-""
  - ""Non-standard interpretations of LOTOS specifications.-""
  - ""A new technique for strictness analysis.-""
  - ""Using higher order logic for modelling real-time protocols.-""
  - ""Combining interaction and automation in process algebra verification.-""
  - ""Refining interfaces of communicating systems.-""
  - ""Structuring specifications in-the-large and in-the-small: Higher-order functions, dependent types and inheritance in SPECTRAL.-""
  - ""Actor-oriented system specification with dynamic logic.-""
  - ""Towards a formally based component description language.-""
  - ""On addition schemes.-""
  - ""Efficient code motion and an adaption to strength reduction.-""
  - ""On narrowing strategies for partial non-strict functions.-""
  - ""From reduction machines to narrowing machines.-""
  - ""The evaluation transformer model of reduction and its correctness.""",,"- The abstract lists several topics related to theoretical contributions in distributed computing and software development, such as CCS for OO and LP, concurrent abstract machines, and verification methods for finite systems. These suggest novel insights into how concurrent systems can be formally specified and verified.
 - The mention of ""an extended expansion theorem"" implies a theoretical advancement in the field of process algebra, which is a significant contribution to understanding and modeling concurrent systems.
 - The focus on ""knowledge and probability in distributed systems"" and ""proving termination of logic programs by exploiting term properties"" indicates advancements in understanding and managing uncertainty and termination in distributed systems, which are crucial for reliable programming language design.
 - The abstract also highlights advancements in logic programming, such as ""parametric order-sorted types"" and ""exploiting non-determinism through laziness,"" which are novel theoretical contributions to the field.
 - The mention of ""non-standard interpretations of LOTOS specifications"" and ""a new technique for strictness analysis"" suggests innovative approaches to analyzing and optimizing programming languages.
 - The abstract discusses ""using higher order logic for modelling real-time protocols,"" which is a significant theoretical contribution to the design of real-time systems.
 - The focus on ""combining interaction and automation in process algebra verification"" and ""refining interfaces of communicating systems"" indicates advancements in verifying and optimizing communication protocols, which are essential for distributed systems.
 - The abstract also mentions ""structuring specifications in-the-large and in-the-small,"" which suggests a theoretical contribution to how specifications are structured and managed in software development."
Multi-paradigm Logic Programming a Simple Operational Model for Concurrent Functional Logic Programming,M. Hanus,-,-,-,0,2007,"1. Primitive Name: Narrowing
  Definition: Combines efficient evaluation principles of functional languages with the problem-solving capabilities of logic programming.
  Orthogonality Score: Not specified
 2. Primitive Name: Residuation
  Definition: Restricts the combination of narrowing but adds the possibility of concurrent computations.
  Orthogonality Score: Not specified",Not specified (the abstract does not mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Narrowing and residuation
 - Interaction models between paradigms: Not mentioned
 - Constraints or challenges in paradigm integration: Not mentioned
 - Any novel translation or embedding techniques: Not mentioned",Generic programming not extensively addressed,"- Key novel insights: Integration of residuation and narrowing in operational semantics.
 - Theoretical advancements: Combining efficient evaluation from functional languages with problem-solving capabilities of logic programming and adding concurrency.
 - Potential implications: Offers features of all three programming paradigms, potentially leading to more versatile and efficient programming languages.","- ""In this paper we specify an operational semantics which combines the most important operational principles of functional logic languages, namely residuation and narrowing.""
  - ""Residuation restricts this combination but adds the possibility of concurrent computations.""",,"- The abstract mentions two key operational principles: ""residuation"" and ""narrowing."" These are described as combining the evaluation principles of functional languages with the problem-solving capabilities of logic programming.
 - ""Narrowing"" is defined as combining efficient evaluation principles of functional languages with the problem-solving capabilities of logic programming.
 - ""Residuation"" is described as restricting the combination of narrowing but adding the possibility of concurrent computations.
 - The abstract does not provide explicit definitions or orthogonality scores for these primitives, nor does it mention any other conceptual primitives.
 - The focus is on how these principles are combined to offer features of multiple programming paradigms, rather than defining them as standalone conceptual primitives.","- ""In this paper we specify an operational semantics which combines the most important operational principles of functional logic languages, namely residuation and narrowing.""
  - ""Residuation restricts this combination but adds the possibility of concurrent computations.""",,"- The abstract discusses the operational semantics of combining functional and logic programming principles, specifically mentioning residuation and narrowing. However, it does not explicitly mention any mathematical framework used to formalize these concepts.
 - There is no mention of a specific type of mathematical framework such as type theory or category theory.
 - The abstract does not provide details on specific mathematical properties guaranteed by the framework or any proof techniques used.
 - There is no discussion of limitations or constraints of the framework in the abstract.","- ""In this paper we specify an operational semantics which combines the most important operational principles of functional logic languages, namely residuation and narrowing.""
  - ""Residuation restricts this combination but adds the possibility of concurrent computations.""",,"- The abstract discusses the integration of functional and logic programming paradigms through the operational semantics that combines residuation and narrowing.
 - Narrowing is identified as a mechanism that integrates functional and logic programming by combining efficient evaluation principles with problem-solving capabilities.
 - Residuation is mentioned as a mechanism that restricts the combination but enables concurrent computations, indicating a specific integration mechanism.
 - The abstract suggests that the combination of these principles offers features of all three programming paradigms (functional, logic, and concurrent), implying a novel integration approach.
 - There is no explicit mention of interaction models, constraints, or novel translation techniques in the abstract.","- ""Residuation restricts this combination but adds the possibility of concurrent computations.""
  - ""In this paper we specify an operational semantics which combines the most important operational principles of functional logic languages, namely residuation and narrowing.""",,"- The abstract focuses on operational semantics and the combination of principles from functional and logic programming paradigms.
 - It discusses the operational principles of residuation and narrowing, which are related to the evaluation and problem-solving aspects of programming languages.
 - There is no mention of generic programming, abstraction mechanisms, type systems, or static checking strategies in the abstract.
 - The abstract does not provide any information on the definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The focus is on operational semantics and the integration of programming paradigms rather than generic programming or abstraction mechanisms.","- ""In this paper we specify an operational semantics which combines the most important operational principles of functional logic languages, namely residuation and narrowing.""
  - ""Residuation restricts this combination but adds the possibility of concurrent computations.""",,"- The abstract introduces a novel operational semantics that integrates two key principles: residuation and narrowing. This integration is a theoretical contribution as it combines the strengths of functional and logic programming paradigms.
 - The combination of narrowing and residuation is highlighted as a unique theoretical advancement. Narrowing brings efficient evaluation from functional languages, while residuation adds concurrency, which are significant theoretical contributions.
 - The abstract suggests that this combination offers features of all three programming paradigms (functional, logic, and concurrent), which implies a potential implication for programming language design. This integration could lead to more versatile and efficient programming languages.
 - The abstract does not mention any specific implementation details, focusing instead on the theoretical framework and its implications, which aligns with the request to focus on theoretical innovations."
Programming in Higher-Order Logic,Alwen Tiu,-,-,-,139,2009,"1. Primitive Name: Goal-Directed Proof Search
  Definition: Logic programming identified with goal-directed proof search.
  Orthogonality Score: Not discussed
 2. Primitive Name: Logical Connectives as Instructions
  Definition: Logical connectives seen as instructions for proof search.
  Orthogonality Score: Not discussed
 3. Primitive Name: Conjunction as Instruction
  Definition: Conjunction (A ∧ B) as an instruction to prove A and B.
  Orthogonality Score: Not discussed
 4. Primitive Name: Disjunction as Instruction
  Definition: Disjunction (A ∨ B) as an instruction to prove A or B.
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),No specific integration approach described (the abstract discusses extensions and theoretical strategies but does not explicitly detail integration mechanisms or models),Generic programming not extensively addressed,"- Key novel insights: Identification of logic programming with goal-directed proof search; logical connectives seen as instructions for proof search.
 - Theoretical advancements: Redefining logic programming; addressing completeness of goal-directed search strategy.
 - Potential implications: Redefining logic programming could influence programming language design by focusing on goal-directed proof search.","- ""The important foundational question is whether such a goal-directed search strategy is complete, i.e., whether any valid consequence relation can be derived using this search strategy.""
  - ""logical connectives should be seen as instructions for proof search.""
  - ""Similarly, to prove a goal A∨B in a goal-directed manner means we have to prove A or B.""
  - ""When one is concerned only with proof search, one could view the conjunction A ∧ B as an instruction of search: prove A and prove B.""
  - ""In this programming paradigm, a program is usually represented as a set of formulae (typically, first-order formulae) and computation is specified as search for a particular consequence (also called a goal) of this set of formula.""",,"- The abstract discusses the use of logic as a programming language, where programs are represented as sets of formulae and computation is about finding a specific consequence or goal.
 - It identifies logic programming with goal-directed proof search, suggesting that this is a fundamental conceptual primitive.
 - Logical connectives are seen as instructions for proof search, which implies they are conceptual primitives guiding the search process.
 - The abstract provides specific examples of how conjunction and disjunction are used as instructions for proof search, indicating these are conceptual primitives.
 - The focus on goal-directed search and the completeness of this strategy suggests that these are key conceptual primitives in reconstructing programming paradigms.","- ""In this course we examine the use of logic as a programming language.""
  - ""a program is usually represented as a set of formulae (typically, first-order formulae) and computation is specified as search for a particular consequence (also called a goal) of this set of formula.""
  - ""Roughly speaking, this is nothing more than theorem proving, i.e., deriving a consequence from a logical theory, albeit in a rather specific way.""
  - ""As a programming language, pure Prolog lacks many important constructs that often make it inadequate for sophisticated programming tasks.""
  - ""In this lecture, we shall look at those extensions which are purely logical.""
  - ""In particular, we shall look at an extension of Prolog, called λProlog, which incorporates, to some degrees, notions such as higher-order programming, modules and abstract data types.""
  - ""In the search for purely logical extensions of Prolog, a group of researchers was led to re-examining one fundamental question: what really is logic programming?""
  - ""More specifically, logical connectives should be seen as instructions for proof search.""
  - ""The important foundational question is whether such a goal-directed search strategy is complete, i.e., whether any valid consequence relation can be derived using this search strategy.""",,"- The abstract discusses the use of logic as a programming language, which implies a mathematical framework based on logical theories.
 - The mention of ""first-order formulae"" and ""theorem proving"" suggests a framework rooted in first-order logic.
 - The abstract does not explicitly mention a specific type of mathematical framework like type theory or category theory.
 - The focus on ""goal-directed proof search"" and the completeness of this strategy indicates a proof methodology centered around logical consequence and theorem proving.
 - The abstract does not specify any particular mathematical properties guaranteed by the framework or specific proof techniques used.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""In this course we examine the use of logic as a programming language.""
  - ""a program is usually represented as a set of formulae (typically, first-order formulae) and computation is specified as search for a particular consequence (also called a goal) of this set of formula.""
  - ""pure Prolog lacks many important constructs that often make it inadequate for sophisticated programming tasks.""
  - ""Numerous attempts have been made to extend Prolog in various ways to incorporate one feature or another, and in some of these extensions, the connection to logic is somewhat lost, or at best, marginalised.""
  - ""In this lecture, we shall look at those extensions which are purely logical.""
  - ""In particular, we shall look at an extension of Prolog, called λProlog, which incorporates, to some degrees, notions such as higher-order programming, modules and abstract data types.""
  - ""In the search for purely logical extensions of Prolog, a group of researchers was led to re-examining one fundamental question: what really is logic programming?""
  - ""logical connectives should be seen as instructions for proof search.""",,"- The abstract discusses the use of logic as a programming language, specifically focusing on Prolog and its extensions.
 - It mentions that pure Prolog lacks certain constructs, which implies a need for integration or extension to incorporate these features.
 - The abstract highlights the extension of Prolog to λProlog, which includes higher-order programming, modules, and abstract data types, suggesting an integration of these features into the logic programming paradigm.
 - The focus on ""purely logical extensions"" and the re-examination of what constitutes logic programming indicate an integration approach that maintains a logical foundation.
 - The identification of logic programming with goal-directed proof search suggests a theoretical integration strategy where logical connectives are used as instructions for proof search.
 - However, the abstract does not explicitly discuss specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques beyond the extension to λProlog.","- ""In this programming paradigm, a program is usually represented as a set of formulae (typically, first-order formulae) and computation is specified as search for a particular consequence (also called a goal) of this set of formula.""
  - ""As a programming language, pure Prolog lacks many important constructs that often make it inadequate for sophisticated programming tasks. This ranges from low-level issues such as support for networking, I/O, etc., to the more conceptual level issues such as a (logical) notion of control, data types, modules and higher-order programming.""
  - ""In particular, we shall look at an extension of Prolog, called λProlog, which incorporates, to some degrees, notions such as higher-order programming, modules and abstract data types.""
  - ""In the search for purely logical extensions of Prolog, a group of researchers was led to re-examining one fundamental question: what really is logic programming?""
  - ""More specifically, logical connectives should be seen as instructions for proof search.""
  - ""The important foundational question is whether such a goal-directed search strategy is complete, i.e., whether any valid consequence relation can be derived using this search strategy.""",,"- The abstract discusses the use of logic as a programming language, focusing on theorem proving and goal-directed proof search. This suggests a focus on logical programming rather than generic programming.
 - The mention of λProlog and its incorporation of higher-order programming, modules, and abstract data types indicates some level of abstraction, but it does not explicitly address generic programming or abstraction mechanisms.
 - The abstract does not provide a definition of ""concept"" used in the context of generic programming or abstraction.
 - There is no mention of mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.
 - The focus is on logical programming and extensions to Prolog rather than generic programming methodologies or type system discussions.","- ""Then a logical system can be seen as a logic programming language if goal-directed search in""
  - ""More specifically, logical connectives should be seen as instructions for proof search.""
  - ""In this course we examine the use of logic as a programming language.""
  - ""The important foundational question is whether such a goal-directed search strategy is complete, i.e., whether any valid consequence relation can be derived using this search strategy.""
  - ""In this programming paradigm, a program is usually represented as a set of formulae (typically, first-order formulae) and computation is specified as search for a particular consequence (also called a goal) of this set of formula.""",,"- The abstract discusses the use of logic as a programming language, which is a foundational concept rather than a novel insight.
 - The identification of logic programming with goal-directed proof search is a key theoretical contribution, as it redefines the essence of logic programming.
 - The view of logical connectives as instructions for proof search is a novel insight that advances the theoretical understanding of logic programming.
 - The question of whether the goal-directed search strategy is complete is a theoretical advancement, as it addresses a fundamental issue in logic programming.
 - The abstract does not explicitly mention potential implications for programming language design, but the redefinition of logic programming and the focus on goal-directed proof search could have implications for how programming languages are designed and understood."
"Session-Based Concurrency, Reactively","Mauricio Cano, Jaime Arias, Jorge A. Pérez",10.1007/978-3-319-60225-7_6,https://doi.org/10.1007/978-3-319-60225-7_6,Formal Techniques for (Networked and) Distributed Systems,5,2017,"1. Primitive Name: Synchronous Reactive Programming Paradigm
  Definition: A uniform foundation for session-based concurrency that integrates declarative and reactive behaviors.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: ReactiveML Constructs
  Definition: Constructs in ReactiveML that enable seamless integration of session-based constructs with declarative and reactive behaviors.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Signals
  Definition: Used to mimic names in session π-calculi for communication.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Queues
  Definition: Used in RMLq to manage asynchronous communication.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Handler Processes
  Definition: Implement output-input transmission between queues in RMLq.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Synchronous reactive programming paradigm
 - Specific mathematical properties guaranteed: Name invariance, compositionality, operational correspondence (soundness and completeness)
 - Proof techniques used: Demonstrating satisfaction of encoding criteria
 - Limitations or constraints of the framework: Focus on synchronous reactive programming, specific encoding criteria","- Specific integration mechanisms proposed: Encoding session-based calculi into ReactiveML using signals to mimic names in session π-calculi.
 - Interaction models between paradigms: Using signals in ReactiveML to integrate session-based concurrency with declarative, reactive, timed, and contextual behaviors.
 - Constraints or challenges in paradigm integration: Previous extensions of session π-calculi did not comprehensively address the integration of declarative, reactive, timed, and contextual behaviors.
 - Novel translation or embedding techniques: Using a continuation-passing style to model variables in π using RML signals, and using queues in RMLq for asynchronous communication.",Generic programming not extensively addressed,"- Novelty: Introduction of the synchronous reactive programming paradigm as a uniform foundation for session-based concurrency.
 - Theoretical Advancements: Correct encodings of session-based calculi into ReactiveML, integrating session-based concurrency with declarative, reactive, timed, and contextual behaviors.
 - Potential Implications: Provides a solid theoretical basis for studying session-based concurrency; potential for integrating session-based concurrency with other programming paradigms in language design.","- ""we propose the synchronous reactive programming paradigm as a uniform foundation for session-based concurrency.""
  - ""We present correct encodings of session-based calculi into ReactiveML, a synchronous reactive programming language.""
  - ""Our encodings enable us to integrate, in a seamless and uniform way, session-based constructs as ""macros"" in ReactiveML programs with declarative and reactive constructs.""
  - ""we use signals in ReactiveML to mimick names in session π-calculi.""
  - ""The main intuition in translating aπ into RMLq is to use the queues of RMLq coupled with a handler process that implements the output-input transmission between queues.""",,"- The paper introduces the synchronous reactive programming paradigm as a foundational concept for session-based concurrency, indicating a shift towards reactive programming as a conceptual primitive.
 - The use of ReactiveML as a target language suggests that reactive programming constructs are fundamental to the approach.
 - The integration of session-based constructs into ReactiveML programs implies that these constructs are conceptual primitives within the paradigm.
 - The use of signals in ReactiveML to mimic names in session π-calculi suggests that signals are a conceptual primitive for communication.
 - The translation of aπ into RMLq involves using queues and handler processes, indicating that these are also conceptual primitives for managing asynchronous communication.","- ""we propose the synchronous reactive programming paradigm as a uniform foundation for session-based concurrency.""
  - ""We present correct encodings of session-based calculi into ReactiveML, a synchronous reactive programming language.""
  - ""Our encodings bridge the gap between process specifications and concurrent programs in which session-based concurrency seamlessly coexists with declarative, reactive, timed, and contextual behaviors.""
  - ""We consider ReactiveML, a programming language based on SRP [16,15], as target language in our developments.""
  - ""ReactiveML is a general purpose functional language with a well-defined formal semantics.""
  - ""Our technical contributions are two correct encodings of session π-calculi into ReactiveML.""
  - ""The Formal Notion of Encoding We define notions of language, translation, and encoding by adapting those from Gorla's framework for relative expressiveness [9].""
  - ""Definition 12 (Encoding). Let L s = P s , -→ s , ≈ s and L t = P t , -→ t , ≈ t be languages; also let • , ψ • be a translation between them (cf. Def. 11). We say that such a translation is an encoding if it satisfies the following criteria:
 

 1. Name invariance: For all S ∈ P s and substitution σ, there exists σ such that Sσ = S σ , with ψ • (σ(x)) = σ (ψ • (x)), for any x ∈ V s . 2. Compositionality: Let res s (•, •) and par s (•, •) (resp. res t (•, •) and par t (•, •)) denote restriction and parallel composition operators in P s (resp. P t ). Then, we define: res s ( x, P ) = res t (ψ • ( x), P ) and par s (P, Q) = par t ( P , Q ). 3. Operational correspondence, i.e., it is sound and complete: (1) Soundness: For all S ∈ P s , if S -→ s S , there exists T ∈ P t such that S =⇒ t T and T ≈ t S .
 

 (2) Completeness: For all S ∈ P s and T ∈ P t , if S =⇒ t T , there exists S such that S =⇒ s S and T ≈ t S""
  - ""Theorem 1. Translation • f , ψ • f is an encoding, in the sense of Def. 12.""",,"- The paper uses the synchronous reactive programming paradigm as a mathematical framework to formalize session-based concurrency.
 - The framework is based on ReactiveML, a programming language with a well-defined formal semantics, which is used to encode session-based calculi.
 - The paper defines notions of language, translation, and encoding, adapting Gorla's framework for relative expressiveness, which provides a theoretical foundation for the encodings.
 - The encoding criteria include name invariance, compositionality, and operational correspondence (soundness and completeness), which are specific mathematical properties guaranteed by the framework.
 - The proof techniques used involve demonstrating that the translations satisfy these encoding criteria, as shown in Theorem 1.
 - The limitations or constraints of the framework are not explicitly discussed in terms of mathematical properties but are implied by the focus on synchronous reactive programming and the specific encoding criteria.","- ""Here we propose the synchronous reactive programming paradigm as a uniform foundation for session-based concurrency.""
  - ""We present correct encodings of session-based calculi into ReactiveML, a synchronous reactive programming language.""
  - ""Our encodings bridge the gap between process specifications and concurrent programs in which session-based concurrency seamlessly coexists with declarative, reactive, timed, and contextual behaviors.""
  - ""We rely on synchronous reactive programming (SRP) and ReactiveML, which already have the ingredients for seamlessly integrating declarative, reactive behavior into session-based concurrency.""
  - ""we use signals in ReactiveML to mimick names in session π-calculi.""
  - ""Our encodings enable us to integrate, in a seamless and uniform way, session-based constructs as ""macros"" in ReactiveML programs with declarative and reactive constructs.""
  - ""We have shown that ReactiveML can correctly encode session-based concurrency, covering both synchronous and asynchronous (queue-based) communications.""",,"- The paper proposes the synchronous reactive programming paradigm as a foundation for integrating session-based concurrency with other programming paradigms like declarative, reactive, timed, and contextual behaviors.
 - The integration mechanism involves encoding session-based calculi into ReactiveML, which is a synchronous reactive programming language. This encoding allows for the seamless integration of different paradigms.
 - The interaction model between paradigms is facilitated by using signals in ReactiveML to mimic names in session π-calculi, effectively creating a bridge between process specifications and concurrent programs.
 - The paper does not explicitly mention constraints or challenges in paradigm integration, but it implies that previous extensions of session π-calculi did not comprehensively address the integration of declarative, reactive, timed, and contextual behaviors.
 - The novel translation technique involves using a continuation-passing style to model variables in π using RML signals, and the use of queues in RMLq to handle asynchronous communication.","- ""we propose the synchronous reactive programming paradigm as a uniform foundation for session-based concurrency.""
  - ""Our encodings bridge the gap between process specifications and concurrent programs in which session-based concurrency seamlessly coexists with declarative, reactive, timed, and contextual behaviors.""
  - ""We consider ReactiveML, a programming language based on SRP [16,15], as target language in our developments.""
  - ""Our technical contributions are two correct encodings of session π-calculi into ReactiveML.""
  - ""Our encodings enable us to integrate, in a seamless and uniform way, session-based constructs as ""macros"" in ReactiveML programs with declarative and reactive constructs.""
  - ""ReactiveML is a general purpose functional language with a well-defined formal semantics.""
  - ""we use signals in ReactiveML to mimick names in session π-calculi.""
  - ""our encodings are executable (well-typed) Reac-tiveML programs, our results have a direct practical character, which serves to bridge the gap between specifications in process models and actual concurrent programs.""",,"- The paper focuses on integrating session-based concurrency with declarative and reactive behaviors using the synchronous reactive programming paradigm.
 - It uses ReactiveML as a target language, which is a general-purpose functional language with formal semantics.
 - The paper discusses encodings of session π-calculi into ReactiveML, which suggests a focus on abstraction mechanisms for integrating different programming paradigms.
 - The use of signals in ReactiveML to mimic names in session π-calculi indicates a mechanism for representing generic abstractions.
 - The paper mentions that the encodings are well-typed, which implies some level of static checking or optimization.
 - However, the paper does not explicitly discuss generic programming methodology, type system discussions, or detailed abstraction mechanism explanations beyond the integration of session-based concurrency with reactive programming.","- ""Here we propose the synchronous reactive programming paradigm as a uniform foundation for session-based concurrency.""
  - ""We present correct encodings of session-based calculi into ReactiveML, a synchronous reactive programming language.""
  - ""Our encodings bridge the gap between process specifications and concurrent programs in which session-based concurrency seamlessly coexists with declarative, reactive, timed, and contextual behaviors.""
  - ""We rely on synchronous reactive programming (SRP) and ReactiveML, which already have the ingredients for seamlessly integrating declarative, reactive behavior into session-based concurrency.""
  - ""We have shown that ReactiveML can correctly encode session-based concurrency, covering both synchronous and asynchronous (queue-based) communications.""
  - ""Our encodings are executable: as such, they enable to integrate session-based concurrency in actual RML programs featuring declarative, reactive, timed, and contextual behavior.""
  - ""Interestingly, since ReactiveML has a well-defined semantics, it already offers a firm basis for both foundational and practical studies on session-based concurrency.""
  - ""We conjecture a similar result for ([•]), under an extension of [18] with queues.""",,"- The paper introduces the synchronous reactive programming paradigm as a novel foundation for session-based concurrency, which is a key theoretical contribution.
 - The authors provide correct encodings of session-based calculi into ReactiveML, which is a significant theoretical advancement as it bridges the gap between process specifications and concurrent programs.
 - The integration of session-based concurrency with declarative, reactive, timed, and contextual behaviors in ReactiveML is a novel insight, as it addresses limitations in existing process models like the π-calculus.
 - The use of ReactiveML, with its well-defined semantics, provides a solid theoretical basis for studying session-based concurrency, which is a theoretical advancement.
 - The potential implications for programming language design include the integration of session-based concurrency with other programming paradigms, which could lead to more comprehensive and flexible programming languages."
A Calculus of Gamma Programs,"C. Hankin, D. L. Métayer, David Sands",10.1007/3-540-57502-2_57,https://doi.org/10.1007/3-540-57502-2_57,International Workshop on Languages and Compilers for Parallel Computing,68,1992,"1. Primitive Name: Conditional Multiset Rewriting
  Definition: A minimal language paradigm
  Orthogonality Score: Not discussed
 2. Primitive Name: Sequential Operators
  Definition: For combining Gamma programs
  Orthogonality Score: Not discussed
 3. Primitive Name: Parallel Operators
  Definition: For combining Gamma programs
  Orthogonality Score: Not discussed",Not specified (the paper does not explicitly mention the type of mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Introduction of sequential and parallel operators for combining Gamma programs.
 - Theoretical advancements: Study of conditions for transforming sequential composition into parallel composition and vice versa.
 - Potential implications: Enhancing adaptability and efficiency of programs on various target architectures, particularly for highly parallel machines.","- ""Gamma is a minimal language based on conditional multiset rewriting.""
  - ""The main focus of the paper is to give conditions under which sequential composition can be transformed into parallel composition and vice versa.""
  - ""We introduce here sequential and parallel operators for combining Gamma programs and we study their properties.""",,"- The paper introduces Gamma as a ""minimal language based on conditional multiset rewriting,"" which suggests that conditional multiset rewriting is a fundamental concept or primitive in the Gamma paradigm.
 - The introduction of ""sequential and parallel operators for combining Gamma programs"" implies that these operators are conceptual primitives used to construct and manipulate Gamma programs.
 - The focus on transforming sequential composition into parallel composition and vice versa indicates that these transformations are key primitives in adapting programs for different architectures.
 - The paper does not explicitly list or define these primitives in a separate section, but they are implied through the description of the Gamma language and its operators.","- ""The main focus of the paper is to give conditions under which sequential composition can be transformed into parallel composition and vice versa.""
  - ""Such transformations are especially valuable for adapting Gamma programs for execution on a particular target architecture.""
  - ""We introduce here sequential and parallel operators for combining Gamma programs and we study their properties.""
  - ""Gamma is a minimal language based on conditional multiset rewriting.""",,"- The paper discusses Gamma, a language based on conditional multiset rewriting, which suggests a focus on formal properties related to rewriting systems.
 - The introduction of sequential and parallel operators and the study of their properties imply a theoretical framework that likely involves formal verification techniques.
 - The focus on transforming sequential composition into parallel composition and vice versa suggests a mathematical framework that deals with equivalences and transformations, possibly involving category theory or similar algebraic structures.
 - However, the paper does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) used to formalize these properties.
 - There is no explicit mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the provided text.","- ""Such transformations are especially valuable for adapting Gamma programs for execution on a particular target architecture.""
  - ""The main focus of the paper is to give conditions under which sequential composition can be transformed into parallel composition and vice versa.""
  - ""We introduce here sequential and parallel operators for combining Gamma programs and we study their properties.""
  - ""Gamma is a minimal language based on conditional multiset rewriting.""",,"- The paper discusses Gamma, a language based on conditional multiset rewriting, which is a specific programming paradigm.
 - The introduction of sequential and parallel operators for combining Gamma programs suggests a focus on integrating different execution modes within the Gamma paradigm rather than integrating different programming paradigms.
 - The paper's focus on transforming sequential composition into parallel composition and vice versa is about optimizing program execution on different architectures, not about integrating different programming paradigms.
 - There is no mention of integrating different programming paradigms or discussing interactions between different paradigms, nor are there any novel translation or embedding techniques for paradigm integration mentioned.","- ""Such transformations are especially valuable for adapting Gamma programs for execution on a particular target architecture.""
  - ""We introduce here sequential and parallel operators for combining Gamma programs and we study their properties.""
  - ""The main focus of the paper is to give conditions under which sequential composition can be transformed into parallel composition and vice versa.""
  - ""Gamma is a minimal language based on conditional multiset rewriting.""",,"- The paper focuses on the introduction of sequential and parallel operators for combining Gamma programs and the conditions for transforming between these compositions. This suggests a focus on program composition and transformation rather than generic programming or abstraction mechanisms.
 - The abstract mentions the language's minimal nature and its application to parallel machines, but it does not explicitly address generic programming or abstraction mechanisms.
 - The paper does not mention any specific mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies related to generic programming.
 - The focus on program transformation and execution on target architectures does not align with the typical concerns of generic programming or abstraction mechanisms.","- ""We introduce here sequential and parallel operators for combining Gamma programs and we study their properties.""
  - ""Such transformations are especially valuable for adapting Gamma programs for execution on a particular target architecture.""
  - ""The main focus of the paper is to give conditions under which sequential composition can be transformed into parallel composition and vice versa.""",,"- The paper introduces new operators for combining Gamma programs, which is a novel insight as it expands the capabilities of the Gamma language.
 - The study of properties related to these operators, particularly the conditions for transforming sequential composition into parallel composition and vice versa, represents a theoretical advancement. This is because it provides a framework for optimizing program execution on different architectures.
 - The potential implications for programming language design are significant, as these transformations can enhance the adaptability and efficiency of programs on various target architectures. This is particularly relevant for highly parallel machines, where such transformations can significantly impact performance."
The epistemology of programming language paradigms,"F. Gobbo, M. Benini",-,-,-,0,2013,Not specified (the abstract does not explicitly define conceptual primitives or their definitions),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The paper provides insights into how programmers' knowledge changes when choosing one programming language over another.
 - Theoretical advancements: The application of the ""method of levels of abstraction by Floridi (2008)"" to analyze four prototypical paradigms is a unique theoretical contribution. The analysis provides a structure for simulating language constructions and clarifies epistemological commitments and hidden levels of abstraction.
 - Potential implications: Understanding epistemological commitments and hidden levels of abstraction can inform the design of future programming languages.","- ""Furthermore, it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""
  - ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""",,"- The abstract mentions the use of ""the method of levels of abstraction by Floridi (2008)"" which suggests that this method is central to the analysis of programming paradigms.
 - The analysis involves ""four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based,"" indicating that these paradigms are the focus of the study.
 - The abstract does not explicitly define specific conceptual primitives or provide their definitions. Instead, it discusses the analysis of paradigms and the clarification of epistemological commitments.
 - The mention of ""levels of abstraction that get hidden"" implies a focus on abstraction levels, but it does not specify any particular primitives.
 - The abstract does not provide any information on the orthogonality of the primitives or any specific definitions for them.","- ""it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""
  - ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""",,"- The abstract mentions the use of ""the method of levels of abstraction by Floridi (2008)"" as a framework for analysis. This suggests a theoretical foundation based on levels of abstraction.
 - The analysis involves simulating language constructions, which implies a focus on structural properties and possibly formal verification.
 - The abstract does not explicitly mention a specific mathematical framework like type theory or category theory.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is more on epistemological commitments and levels of abstraction rather than a detailed mathematical framework.","- ""it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""
  - ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""",,"- The abstract mentions the use of the ""method of levels of abstraction"" to analyze different programming paradigms. This suggests a theoretical framework for understanding how these paradigms relate to each other.
 - The phrase ""each language’ constructions can be canonically simulated by another language"" implies a form of integration or translation between paradigms, as it suggests that the structures of one language can be represented in another.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques. It focuses more on the epistemological commitments and levels of abstraction rather than detailed integration strategies.
 - The abstract does not provide explicit details on how the integration is achieved or what specific mechanisms are used for interaction between paradigms.","- ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""
  - ""it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""",,"- The abstract mentions the use of the ""method of levels of abstraction by Floridi (2008)"" which suggests a focus on abstraction mechanisms.
 - The analysis of prototypical paradigms implies a discussion on how different programming languages can simulate each other's constructions, which relates to abstraction.
 - The mention of ""epistemological commitments"" and ""levels of abstraction that get hidden"" suggests a focus on conceptual abstraction.
 - However, there is no specific mention of generic programming, type systems, or static checking strategies in the abstract.
 - The abstract does not provide a definition of ""concept"" used, nor does it mention mechanisms for representing generic abstractions or minimal type requirements.","- ""This paper addresses the research question of what changes in terms of the programmers’ knowledge in choosing one programming language instead of another.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""
  - ""Furthermore, it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""
  - ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""",,"- The abstract mentions that the paper addresses the research question of how programmers' knowledge changes when choosing one programming language over another. This suggests a novel insight into the epistemological aspects of programming language selection.
 - The use of the ""method of levels of abstraction by Floridi (2008)"" indicates a theoretical advancement by applying this method to analyze different programming paradigms. This is a unique approach as it applies an existing method to a new context.
 - The analysis provides a structure for simulating language constructions, which is a theoretical contribution as it offers a framework for understanding how different languages can be related to each other.
 - The clarification of epistemological commitments and hidden levels of abstraction within each paradigm is a theoretical advancement as it sheds light on the underlying assumptions and abstractions in programming languages.
 - The potential implications for programming language design are implicit in the analysis and clarification of epistemological commitments, as understanding these aspects can inform the design of future programming languages."
A Causal Model anda Declarative ProgrammingLanguagefor Concurrent,"SystemsKarsten, Bohlmann",-,-,-,0,1996,"1. Primitive Name: Declarativity
  Definition: Definition of a model with mathematical values representing systems or runs of systems, and a syntax mapped into the model by denotational semantics.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Causality
  Definition: Full modeling of computational phenomena without losing parallelism or interactions.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Programming
  Definition: Provision of an operational semantics for language implementation.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Reflexive Domains
  Definition: Model based on reflexive domains, not power domains.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Typed Lambda-Calculus with Recursion
  Definition: Language incorporating typed lambda-calculus with recursion.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Concurrent Structures
  Definition: Interactions related by causal ordering and external choice.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Continuations
  Definition: Capturing branching-time structure in the model.
  Orthogonality Score: Not discussed
 

 8. Primitive Name: Pomsets
  Definition: Representing graphically the runs of a system.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory (reflexive domains, typed lambda-calculus)
 - Specific mathematical properties guaranteed: Use of denotational and operational semantics, continuations, pomsets
 - Proof techniques used: Not explicitly mentioned
 - Limitations or constraints of the framework: Not explicitly mentioned","No specific integration approach described (the abstract mentions generalization of object-oriented paradigm and use of functional programming, but does not detail specific integration mechanisms or models)","- Definition of ""concept"" used: Mathematical values representing systems or runs of systems.
 - Mechanisms for representing generic abstractions: Typed lambda-calculus with recursion.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Novel insights: Compositionally defining concurrent structures with causal ordering and external choice; mapping branching-time structures to pomsets.
 - Theoretical advancements: Use of reflexive domains; incorporation of typed lambda-calculus with recursion; generalization of the object-oriented paradigm.
 - Potential implications: Provides a comprehensive framework for concurrent systems; ensures consistency and completeness in language design; offers a structured way to handle complex interactions.","- ""Declarativity: De nition of (1) a model whose elements are mathematical values each of which represents a system, or a run of a system, in a direct and intuitive way; (2) a syntax whose expressions are mapped into the model by a denotational semantics.""
  - ""The branching-time structure of its compositional semantics, resulting from choices and value-passing interactions and captured in the model by \continuations"",""
  - ""The language generalizes the object-oriented paradigm.""
  - ""Using the full power of functional programming, we can compositionally de ne so-called Concurrent Structures, which are (bidirectional, overlapping) interactions related by causal ordering and external choice.""
  - ""A model based on re exive domains | not power domains | and a corresponding language incorporating typed lambda-calculus with recursion are introduced.""
  - ""Causality: Full modeling of the relevant computational phenomena, i.e., without losing parallelism (by interleaving) or interactions (by hiding of \internal""""
  - ""Programming: As opposed to speci cation. In particular, provision of an operational semantics that is concrete enough to serve as the basis for language implementation.""",,"- The abstract discusses several key concepts that can be considered as conceptual primitives for reconstructing programming paradigms. These include:
  - ""Declarativity"" which involves defining a model with mathematical values representing systems or runs of systems, and a syntax mapped into the model by denotational semantics.
  - ""Causality"" which focuses on modeling computational phenomena without losing parallelism or interactions.
  - ""Programming"" which involves operational semantics for language implementation.
  - ""Reflexive domains"" and ""typed lambda-calculus with recursion"" are introduced as part of the model and language.
  - ""Concurrent Structures"" are defined as interactions related by causal ordering and external choice.
  - ""Continuations"" are used to capture branching-time structure in the model.
  - ""Pomsets"" are used to represent graphically the runs of a system.","- ""A model based on re exive domains | not power domains | and a corresponding language incorporating typed lambda-calculus with recursion are introduced.""
  - ""Declarativity: De nition of (1) a model whose elements are mathematical values each of which represents a system, or a run of a system, in a direct and intuitive way; (2) a syntax whose expressions are mapped into the model by a denotational semantics.""
  - ""The branching-time structure of its compositional semantics, resulting from choices and value-passing interactions and captured in the model by \continuations"",""
  - ""We also provide the language with an operational semantics which is equivalent to the denotational semantics and discuss as an example the well-known alternating-bit protocol.""
  - ""The language generalizes the object-oriented paradigm.""",,"- The abstract mentions a ""model based on reflexive domains"" and ""typed lambda-calculus with recursion,"" which suggests a type theory framework.
 - The use of ""denotational semantics"" and ""operational semantics"" indicates a focus on formal verification through these semantic methods.
 - The mention of ""continuations"" and ""pomsets"" suggests specific mathematical properties related to concurrency and process modeling.
 - The abstract does not explicitly mention proof techniques or limitations of the framework, but it does provide a comparison with other approaches, which might imply some implicit constraints or differences.","- ""The branching-time structure of its compositional semantics, resulting from choices and value-passing interactions and captured in the model by \continuations"",""
  - ""Using the full power of functional programming, we can compositionally de ne so-called Concurrent Structures, which are (bidirectional, overlapping) interactions related by causal ordering and external choice.""
  - ""The language generalizes the object-oriented paradigm.""",,"- The abstract mentions that the language ""generalizes the object-oriented paradigm,"" which suggests an integration of object-oriented programming with other paradigms.
 - The use of ""the full power of functional programming"" indicates an integration of functional programming paradigms.
 - The mention of ""Concurrent Structures"" and ""causal ordering and external choice"" suggests a model for interaction between different programming paradigms, particularly in handling concurrency.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques beyond the generalization of the object-oriented paradigm and the use of functional programming.","- ""Declarativity: De nition of (1) a model whose elements are mathematical values each of which represents a system, or a run of a system, in a direct and intuitive way; (2) a syntax whose expressions are mapped into the model by a denotational semantics.""
  - ""The branching-time structure of its compositional semantics, resulting from choices and value-passing interactions and captured in the model by \continuations"",""
  - ""Using the full power of functional programming, we can compositionally de ne so-called Concurrent Structures, which are (bidirectional, overlapping) interactions related by causal ordering and external choice.""
  - ""The language generalizes the object-oriented paradigm.""
  - ""A model based on re exive domains | not power domains | and a corresponding language incorporating typed lambda-calculus with recursion are introduced.""",,"- The abstract discusses a model and language that incorporate typed lambda-calculus with recursion, which suggests a focus on functional programming principles. This is relevant to generic programming as it often involves abstracting over types and functions.
 - The mention of ""re exive domains"" and ""typed lambda-calculus"" indicates a type system that supports abstraction and genericity, as these concepts are fundamental to functional programming and can be used to represent generic abstractions.
 - The abstract does not explicitly mention ""minimal type requirements"" or ""static checking or optimization strategies,"" but the use of typed lambda-calculus implies some level of type checking.
 - The abstract does not provide detailed information on specific mechanisms for representing generic abstractions or static checking strategies, but it does suggest a focus on declarative and functional programming principles that are conducive to generic programming.","- ""This work presents an approach to the linguistic treatment of concurrent systems which has three main objectives: Declarativity: De nition of (1) a model whose elements are mathematical values each of which represents a system, or a run of a system, in a direct and intuitive way; (2) a syntax whose expressions are mapped into the model by a denotational semantics.""
  - ""Causality: Full modeling of the relevant computational phenomena, i.e., without losing parallelism (by interleaving) or interactions (by hiding of \internal""""
  - ""Programming: As opposed to speci cation. In particular, provision of an operational semantics that is concrete enough to serve as the basis for language implementation.""
  - ""A model based on re exive domains | not power domains | and a corresponding language incorporating typed lambda-calculus with recursion are introduced.""
  - ""Using the full power of functional programming, we can compositionally de ne so-called Concurrent Structures, which are (bidirectional, overlapping) interactions related by causal ordering and external choice.""
  - ""The language generalizes the object-oriented paradigm.""
  - ""The branching-time structure of its compositional semantics, resulting from choices and value-passing interactions and captured in the model by \continuations"",""
  - ""We also provide the language with an operational semantics which is equivalent to the denotational semantics and discuss as an example the well-known alternating-bit protocol.""
  - ""A comparison with other approaches to concurrency is given, in particular with process algebra, whose key features contrast precisely with our three objectives.""",,"- The abstract introduces a novel approach to the linguistic treatment of concurrent systems with three main objectives: declarativity, causality, and programming. This suggests a comprehensive theoretical framework that addresses multiple aspects of concurrent systems.
 - The use of reflexive domains instead of power domains and the incorporation of typed lambda-calculus with recursion represent theoretical advancements in modeling concurrent systems.
 - The ability to compositionally define concurrent structures with causal ordering and external choice is a key novel insight, as it provides a structured way to handle complex interactions.
 - The generalization of the object-oriented paradigm indicates a theoretical contribution by expanding the applicability of this paradigm to concurrent systems.
 - The mapping of branching-time structures to pomsets offers a new way to represent and analyze concurrent system runs, which is a theoretical innovation.
 - The provision of both denotational and operational semantics that are equivalent is a significant theoretical contribution, as it ensures consistency and completeness in the language design.
 - The comparison with process algebra highlights the unique features of this approach, contrasting with existing methods and indicating a theoretical advancement."
Engineering UToPiA - Formal Semantics for CML,J. Woodcock,10.1007/978-3-319-06410-9_3,https://doi.org/10.1007/978-3-319-06410-9_3,World Congress on Formal Methods,20,2014,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Unifying Theories of Programming (UTP)
 - Specific mathematical properties guaranteed: Composition via Galois connections
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Use of Galois connections to compose paradigms.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Not explicitly mentioned beyond Galois connections.",Generic programming not extensively addressed,"- Key novel insights: Application of UTP to define semantic domains for CML, integration of multiple paradigms within CML.
 - Theoretical advancements: Use of Galois connections to compose paradigms, semantically open design for extensibility, compositional formal definition for reuse.
 - Potential implications: Demonstrates UTP's scalability to industrial-strength languages, provides a framework for integrating diverse programming paradigms.","- ""We describe the semantic domains for Compass Modelling Language (CML), using Hoare & He’s Unifying Theories of Programming (UTP).""
  - ""Our semantics deals separately with each paradigm, composing them with Galois connections, leading to a natural contract language for all constructs in all paradigms.""
  - ""A key objective is to be semantically open, allowing further paradigms to be added, such as process mobility, continuous physical models, and stochastic processes.""
  - ""CML is a semantically heterogeneous language, with state-rich imperative constructs based on VDM, communication and concurrency based on CSP, object orientation with object references, and discrete time based on Timed CSP.""",,"- The abstract discusses the use of Unifying Theories of Programming (UTP) to define semantic domains for the Compass Modelling Language (CML), which suggests that UTP is a foundational framework for defining conceptual primitives.
 - CML is described as a semantically heterogeneous language, incorporating various paradigms such as VDM, CSP, object orientation, and discrete time, which are likely conceptual primitives or components of the language.
 - The abstract mentions that the semantics deal separately with each paradigm and compose them using Galois connections, indicating a method for integrating these primitives.
 - However, the abstract does not explicitly list or define specific conceptual primitives beyond mentioning the paradigms and their bases (e.g., VDM, CSP).
 - The level of abstraction and orthogonality of these primitives are not explicitly discussed in the abstract.","- ""We describe the semantic domains for Compass Modelling Language (CML), using Hoare & He’s Unifying Theories of Programming (UTP).""
  - ""The work backs our claim that use of UTP scales up to industrial-strength languages: Unifying Theories of Programming in Action (UToPiA).""
  - ""The result is a compositional formal definition of a complex language, with the individual parts being available for reuse in other language definitions.""
  - ""Our semantics deals separately with each paradigm, composing them with Galois connections, leading to a natural contract language for all constructs in all paradigms.""
  - ""CML is a semantically heterogeneous language, with state-rich imperative constructs based on VDM, communication and concurrency based on CSP, object orientation with object references, and discrete time based on Timed CSP.""",,"- The abstract mentions the use of ""Hoare & He’s Unifying Theories of Programming (UTP)"" as the mathematical framework for formalizing the semantics of CML. This indicates that UTP is the type of mathematical framework used.
 - The abstract describes CML as ""semantically heterogeneous,"" suggesting that UTP is used to integrate different paradigms such as VDM, CSP, and Timed CSP. This implies that UTP provides a way to compose these different paradigms.
 - The use of ""Galois connections"" is mentioned as a method for composing these paradigms, which is a specific mathematical property guaranteed by the framework.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used beyond the composition via Galois connections.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""The result is a compositional formal definition of a complex language, with the individual parts being available for reuse in other language definitions.""
  - ""Our semantics deals separately with each paradigm, composing them with Galois connections, leading to a natural contract language for all constructs in all paradigms.""
  - ""A key objective is to be semantically open, allowing further paradigms to be added, such as process mobility, continuous physical models, and stochastic processes.""
  - ""CML is a semantically heterogeneous language, with state-rich imperative constructs based on VDM, communication and concurrency based on CSP, object orientation with object references, and discrete time based on Timed CSP.""",,"- The abstract describes CML as a ""semantically heterogeneous language,"" indicating that it integrates multiple programming paradigms such as VDM, CSP, object orientation, and discrete time.
 - The integration mechanism proposed is the use of ""Galois connections"" to compose these paradigms, which suggests a mathematical framework for integrating different semantic domains.
 - The abstract mentions that the semantics are dealt with separately for each paradigm, which implies a modular approach to integration.
 - The goal of being ""semantically open"" suggests that the integration approach is designed to be extensible, allowing for the addition of new paradigms.
 - The abstract does not explicitly mention interaction models between paradigms or specific constraints or challenges in paradigm integration.
 - There is no mention of novel translation or embedding techniques beyond the use of Galois connections.","- ""The result is a compositional formal definition of a complex language, with the individual parts being available for reuse in other language definitions.""
  - ""Our semantics deals separately with each paradigm, composing them with Galois connections, leading to a natural contract language for all constructs in all paradigms.""
  - ""A key objective is to be semantically open, allowing further paradigms to be added, such as process mobility, continuous physical models, and stochastic processes.""
  - ""CML is a semantically heterogeneous language, with state-rich imperative constructs based on VDM, communication and concurrency based on CSP, object orientation with object references, and discrete time based on Timed CSP.""",,"- The abstract discusses CML as a ""semantically heterogeneous language,"" which suggests a focus on integrating different programming paradigms rather than generic programming or abstraction mechanisms specifically.
 - The mention of being ""semantically open"" and allowing further paradigms to be added indicates a level of flexibility and extensibility, but this is more about the language's design philosophy rather than generic programming or abstraction mechanisms.
 - The use of Galois connections to compose different paradigms suggests a method for integrating different semantic domains, but this is not explicitly related to generic programming or abstraction mechanisms.
 - There is no mention of generic programming methodology, type system discussions, or specific abstraction mechanisms in the abstract.","- ""We describe the semantic domains for Compass Modelling Language (CML), using Hoare & He’s Unifying Theories of Programming (UTP).""
  - ""CML is a semantically heterogeneous language, with state-rich imperative constructs based on VDM, communication and concurrency based on CSP, object orientation with object references, and discrete time based on Timed CSP.""
  - ""A key objective is to be semantically open, allowing further paradigms to be added, such as process mobility, continuous physical models, and stochastic processes.""
  - ""Our semantics deals separately with each paradigm, composing them with Galois connections, leading to a natural contract language for all constructs in all paradigms.""
  - ""The result is a compositional formal definition of a complex language, with the individual parts being available for reuse in other language definitions.""
  - ""The work backs our claim that use of UTP scales up to industrial-strength languages: Unifying Theories of Programming in Action (UToPiA).""",,"- The abstract describes the use of Unifying Theories of Programming (UTP) to define the semantic domains for Compass Modelling Language (CML), which is a novel application of UTP to a complex, heterogeneous language.
 - CML's design as a semantically heterogeneous language, incorporating various paradigms (VDM, CSP, object orientation, Timed CSP), is a key theoretical contribution, as it demonstrates the integration of multiple programming paradigms within a single language framework.
 - The objective of being semantically open, allowing for the addition of further paradigms, suggests a theoretical advancement in terms of flexibility and extensibility in language design.
 - The use of Galois connections to compose different paradigms is a theoretical innovation, as it provides a formal method for integrating diverse programming constructs.
 - The compositional formal definition of CML, with reusable parts, is a significant theoretical contribution, as it enables the modular development and reuse of language components.
 - The claim that UTP scales up to industrial-strength languages is a theoretical advancement, as it demonstrates the applicability of UTP to complex, real-world programming languages."
The constraint-based paradigm: integrating object-oriented and rule-based programming,"M. van Biema, G. Maguire, S. Stolfo",10.1109/HICSS.1990.205206,https://doi.org/10.1109/HICSS.1990.205206,Twenty-Third Annual Hawaii International Conference on System Sciences,4,1990,"1. Primitive Name: Constraint-based invocation
  Definition: A generalization of traditional invocation where dispatch is done based on constraints that are arbitrary user-defined predicates.
  Orthogonality Score: Orthogonal
 2. Primitive Name: Instance inheritance
  Definition: A dual to class inheritance, structuring instances rather than classes.
  Orthogonality Score: Orthogonal
 3. Primitive Name: Procedural attachments
  Definition: Functions called in a data-driven manner, also known as active values or access-oriented programming.
  Orthogonality Score: Orthogonal",Not specified (the abstract does not mention any mathematical framework or its characteristics),"- Specific integration mechanisms proposed: constraint-based invocation, instance inheritance, procedural attachments
 - Interaction models between paradigms: orthogonal subparadigms
 - Constraints or challenges in paradigm integration: synergistic unification under a new paradigm rather than partial integration
 - Novel translation or embedding techniques: constraint-based invocation based on user-defined predicates, instance inheritance as a dual to class inheritance, procedural attachments for data-driven function calls","- Definition of ""concept"" used: The constraint-based model integrates object-oriented and rule-based paradigms.
 - Mechanisms for representing generic abstractions: Constraint-based invocation, instance inheritance, procedural attachments.
 - Minimal type requirements identified: Not mentioned.
 - Static checking or optimization strategies: Not mentioned.","- Key novel insights: Integration of object-oriented and rule-based paradigms, constraint-based invocation, instance inheritance, procedural attachments.
 - Theoretical advancements: Generalization of traditional object-oriented paradigms, use of arbitrary user-defined predicates for dispatch, structuring instances with instance inheritance.
 - Potential implications for programming language design: Synergistic unification of paradigms under a new subsuming paradigm rather than partial integration.","- ""The authors introduce a novel formalism that combines the object-oriented and rule-based paradigms in an elegant and orthogonal way.""
  - ""The constraint-based model is a generalization of traditional object-oriented paradigms and is based on three orthogonal subparadigms.""
  - ""The first is constraint-based invocation, which is a generalization of the traditional invocation where dispatch is done based on the types of the arguments.""
  - ""In constraint-based invocation, dispatch is done based on constraints that are arbitrary user-defined predicates.""
  - ""The second subparadigm is instance inheritance, a dual to the concept of class inheritance in the sense that class inheritance structures classes and instance inheritance structures instances.""
  - ""The third is procedural attachments (also known as active values or access-oriented programming), where a function is called in a data-driven manner.""
  - ""The semantics of this concept are generalized to all objects in the constraint-based model.""",,"- The abstract introduces a ""novel formalism"" that integrates object-oriented and rule-based paradigms, indicating a new conceptual framework.
 - The ""constraint-based model"" is described as a generalization of traditional object-oriented paradigms, suggesting it is a higher-level abstraction.
 - The model is based on ""three orthogonal subparadigms,"" which are explicitly listed as conceptual primitives:
  1. **Constraint-based invocation**: This is defined as a generalization of traditional invocation, where dispatch is based on ""constraints that are arbitrary user-defined predicates.""
  2. **Instance inheritance**: Described as a dual to class inheritance, it structures instances rather than classes.
  3. **Procedural attachments**: Also known as active values or access-oriented programming, it involves functions being called in a data-driven manner.
 - The abstract emphasizes the orthogonality of these subparadigms, indicating they are designed to be independent and non-overlapping.
 - The level of abstraction is high, as these primitives are intended to generalize and unify existing paradigms.","- ""The authors introduce a novel formalism that combines the object-oriented and rule-based paradigms in an elegant and orthogonal way.""
  - ""The constraint-based model is a generalization of traditional object-oriented paradigms and is based on three orthogonal subparadigms.""
  - ""The first is constraint-based invocation, which is a generalization of the traditional invocation where dispatch is done based on the types of the arguments.""
  - ""The second subparadigm is instance inheritance, a dual to the concept of class inheritance in the sense that class inheritance structures classes and instance inheritance structures instances.""
  - ""The third is procedural attachments (also known as active values or access-oriented programming), where a function is called in a data-driven manner.""
  - ""A central philosophical argument is that so-called multiparadigm languages should be developed not by combination of paradigms in a partially integrated system, but by their synergistic unification under a new, subsuming paradigm.<<ETX>>""",,"- The abstract discusses the introduction of a novel formalism that integrates object-oriented and rule-based paradigms, but it does not explicitly mention any mathematical framework used to formalize or guarantee properties of these conceptual primitives.
 - The abstract focuses on the conceptual structure and philosophical arguments rather than providing details about a mathematical framework.
 - There is no mention of type theory, category theory, or any other specific mathematical framework in the abstract.
 - The abstract does not provide information on specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""The authors introduce a novel formalism that combines the object-oriented and rule-based paradigms in an elegant and orthogonal way.""
  - ""The constraint-based model is a generalization of traditional object-oriented paradigms and is based on three orthogonal subparadigms.""
  - ""The first is constraint-based invocation, which is a generalization of the traditional invocation where dispatch is done based on the types of the arguments.""
  - ""In constraint-based invocation, dispatch is done based on constraints that are arbitrary user-defined predicates.""
  - ""The second subparadigm is instance inheritance, a dual to the concept of class inheritance in the sense that class inheritance structures classes and instance inheritance structures instances.""
  - ""The third is procedural attachments (also known as active values or access-oriented programming), where a function is called in a data-driven manner.""
  - ""A central philosophical argument is that so-called multiparadigm languages should be developed not by combination of paradigms in a partially integrated system, but by their synergistic unification under a new, subsuming paradigm.<<ETX>>""",,"- The abstract introduces a ""novel formalism"" that integrates object-oriented and rule-based paradigms, indicating a specific integration approach.
 - The integration is described as ""elegant and orthogonal,"" suggesting a structured and harmonious interaction between the paradigms.
 - The constraint-based model is a generalization of traditional object-oriented paradigms, indicating a theoretical integration strategy.
 - Three specific integration mechanisms are proposed: constraint-based invocation, instance inheritance, and procedural attachments. These mechanisms are described as orthogonal subparadigms, suggesting a structured interaction model.
 - Constraint-based invocation involves dispatch based on user-defined predicates, which is a novel translation technique.
 - Instance inheritance is a dual to class inheritance, indicating a new way of structuring instances.
 - Procedural attachments involve calling functions in a data-driven manner, which is a novel embedding technique.
 - The abstract argues for synergistic unification under a new paradigm rather than partial integration, which addresses the challenge of integrating paradigms in a comprehensive manner.","- ""The authors introduce a novel formalism that combines the object-oriented and rule-based paradigms in an elegant and orthogonal way.""
  - ""The constraint-based model is a generalization of traditional object-oriented paradigms and is based on three orthogonal subparadigms.""
  - ""The first is constraint-based invocation, which is a generalization of the traditional invocation where dispatch is done based on the types of the arguments.""
  - ""In constraint-based invocation, dispatch is done based on constraints that are arbitrary user-defined predicates.""
  - ""The second subparadigm is instance inheritance, a dual to the concept of class inheritance in the sense that class inheritance structures classes and instance inheritance structures instances.""
  - ""The third is procedural attachments (also known as active values or access-oriented programming), where a function is called in a data-driven manner.""
  - ""The semantics of this concept are generalized to all objects in the constraint-based model.""
  - ""A central philosophical argument is that so-called multiparadigm languages should be developed not by combination of paradigms in a partially integrated system, but by their synergistic unification under a new, subsuming paradigm.<<ETX>>""",,"- The abstract discusses a novel formalism that integrates object-oriented and rule-based paradigms, which suggests a focus on abstraction mechanisms.
 - The constraint-based model is described as a generalization of traditional object-oriented paradigms, indicating a level of abstraction.
 - Constraint-based invocation is a mechanism that allows for dispatch based on user-defined predicates, which can be seen as a form of generic abstraction.
 - Instance inheritance is another mechanism that structures instances, which is a form of abstraction.
 - Procedural attachments generalize the semantics to all objects, suggesting a mechanism for representing generic abstractions.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does discuss the integration of paradigms, which implies a focus on abstraction.
 - The abstract does not provide specific details on generic programming methodology or type system discussions, but it does emphasize the synergistic unification of paradigms, which suggests a focus on abstraction mechanisms.","- ""The authors introduce a novel formalism that combines the object-oriented and rule-based paradigms in an elegant and orthogonal way.""
  - ""The constraint-based model is a generalization of traditional object-oriented paradigms and is based on three orthogonal subparadigms.""
  - ""The first is constraint-based invocation, which is a generalization of the traditional invocation where dispatch is done based on the types of the arguments.""
  - ""The second subparadigm is instance inheritance, a dual to the concept of class inheritance in the sense that class inheritance structures classes and instance inheritance structures instances.""
  - ""The third is procedural attachments (also known as active values or access-oriented programming), where a function is called in a data-driven manner.""
  - ""A central philosophical argument is that so-called multiparadigm languages should be developed not by combination of paradigms in a partially integrated system, but by their synergistic unification under a new, subsuming paradigm.<<ETX>>""",,"- The abstract introduces a ""novel formalism"" that integrates object-oriented and rule-based paradigms, indicating a key theoretical contribution.
 - The constraint-based model is described as a ""generalization of traditional object-oriented paradigms,"" suggesting an advancement beyond existing approaches.
 - The model is based on three orthogonal subparadigms: constraint-based invocation, instance inheritance, and procedural attachments. These are novel insights that contribute to the theoretical framework.
 - Constraint-based invocation generalizes traditional invocation by using arbitrary user-defined predicates, which is a theoretical advancement.
 - Instance inheritance is a new concept that structures instances, contrasting with class inheritance, which structures classes.
 - Procedural attachments generalize the semantics to all objects, which is a theoretical innovation.
 - The philosophical argument about synergistic unification under a new paradigm suggests a potential implication for programming language design, moving away from partial integration towards a unified approach."
Logical Foundations for DeclarativeObject-oriented Programming ?,"C. Kreitz, K. Lau, Mario Ornaghi",-,-,-,0,2007,"1. Primitive Name: Classes as First-Order Theories
  Definition: Classes are represented as first-order theories that contain logic programs as methods.
  Orthogonality Score: Not discussed
 2. Primitive Name: Methods as Logic Programs
  Definition: Methods are logic programs that are synthesised from their specifications (in classes).
  Orthogonality Score: Not discussed
 3. Primitive Name: Inheritance and Genericity
  Definition: Inheritance and genericity are represented by operations on first-order theories that preserve consistency and correctness.
  Orthogonality Score: Not discussed
 4. Primitive Name: Correctness of Classes
  Definition: Correctness of a class is defined as its adequacy, and class reuse corresponds to class composition that preserves adequacy.
  Orthogonality Score: Not discussed
 5. Primitive Name: Correctness of Programs
  Definition: Correctness of a program is defined wrt a specification: a program is correct if its (initial) model coincides with the interpretation of the specification.
  Orthogonality Score: Not discussed","- Type of mathematical framework: First-order logic
 - Specific mathematical properties guaranteed: Consistency and correctness of programs
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Representing classes as first-order theories and methods as logic programs.
 - Interaction models between paradigms: Declarative semantics applied to object-oriented programming.
 - Constraints or challenges in paradigm integration: Conventional object-oriented programming lacks declarative semantics.
 - Novel translation or embedding techniques: Defining classes and methods declaratively for reasoning about correctness and reuse.",Generic programming not extensively addressed,"- Key novel insights: Representation of classes as first-order theories and methods as logic programs for declarative object-oriented programming.
 - Theoretical advancements: Providing a logical basis for constructing correct and reusable programming systems, addressing the lack of suitable semantics in existing languages.
 - Potential implications: Framework for formal reasoning about programs, enabling formal program development with declarative semantics.","- ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""
  - ""Correctness of a class is deened as its adequacy, and class reuse corresponds to class composition that preserves adequacy.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Correctness of a program is deened wrt a speciication: a program is correct if its (initial) model coincides with the interpretation of the speciication in the""",,"- The abstract discusses the representation of classes as first-order theories and methods as logic programs, which are conceptual primitives in the context of declarative object-oriented programming.
 - Inheritance and genericity are mentioned as operations on these theories, indicating they are part of the conceptual framework.
 - The definition of correctness for classes and programs is provided, which is a key conceptual primitive in ensuring the reliability and reusability of programming systems.
 - The abstract does not explicitly mention a list of ""conceptual primitives"" but describes the foundational elements of their approach, which can be considered as conceptual primitives.","- ""We present a formalism for reasoning about declarative object-oriented programs.""
  - ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Our approach provides a logical basis for the construction of correct and reusable programming systems.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""
  - ""Correctness of a class is deened as its adequacy, and class reuse corresponds to class composition that preserves adequacy.""
  - ""Correctness of a program is deened wrt a speciication: a program is correct if its (initial) model coincides with the interpretation of the speciication in the""",,"- The abstract mentions the use of ""rst-order theories"" to represent classes, which suggests a mathematical framework based on first-order logic.
 - The mention of ""logic programs as methods"" and ""synthesised from their speciications"" indicates a focus on logical programming and formal specification.
 - The abstract discusses ""operations on such theories which preserve the consistency of these theories as well as the correctness of the programs,"" which implies a focus on maintaining logical consistency and correctness.
 - The use of ""isoinitial semantics"" suggests a specific mathematical property related to the interpretation of these theories.
 - The abstract does not explicitly mention type theory, category theory, or other specific mathematical frameworks beyond first-order logic and logic programming.
 - There is no explicit mention of proof techniques or limitations/constraints of the framework in the abstract.","- ""We present a formalism for reasoning about declarative object-oriented programs.""
  - ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Our approach provides a logical basis for the construction of correct and reusable programming systems.""
  - ""Our main motivation is formal program development, i.e. developing programs that are formally correct wrt their formal speciications.""
  - ""Object-oriented programming is widely used for software development in industry because it is seen to meet the key requirements of modularity, reusability, and reliability.""
  - ""However, conventional object-oriented programming (e.g. 12]) is based on the imperative programming paradigm, and does not have a declarative semantics.""
  - ""Declarative object-oriented programming languages have been proposed, by both the functional and logic programming communities.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""",,"- The abstract discusses the integration of declarative and object-oriented programming paradigms by representing classes as first-order theories and methods as logic programs. This suggests a theoretical integration strategy where declarative semantics are applied to object-oriented programming.
 - The mention of ""operations on such theories which preserve the consistency of these theories as well as the correctness of the programs"" implies a specific integration mechanism that ensures consistency and correctness across paradigms.
 - The abstract highlights the challenge of conventional object-oriented programming lacking declarative semantics, which is addressed by proposing a declarative approach to object-oriented programming.
 - The integration approach involves defining classes and methods declaratively, allowing for reasoning about correctness and reuse, which is a novel translation or embedding technique.","- ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Our approach provides a logical basis for the construction of correct and reusable programming systems.""
  - ""Our main motivation is formal program development, i.e. developing programs that are formally correct wrt their formal speciications.""
  - ""Our goal in this paper is to provide the necessary logical foundations for formal program development in an object-oriented paradigm which has a suitable (declarative) semantics for this purpose.""
  - ""Declarative object-oriented programming languages have been proposed, by both the functional and logic programming communities.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""
  - ""Both our classes and programs may be open, i.e. they may have parameters.""",,"- The abstract mentions that ""Inheritance, genericity and related concepts are represented by operations on such theories,"" indicating that genericity is addressed in terms of operations on first-order theories.
 - The focus on ""correct and reusable programming systems"" suggests that genericity is part of ensuring reusability, but the abstract does not provide specific mechanisms or definitions for generic programming.
 - The mention of ""classes are full rst-order theories (with isoinitial semantics)"" and ""methods are logic programs that are synthesised from their speciications"" implies a declarative approach to programming, which may involve genericity, but again, specific mechanisms are not detailed.
 - The abstract does not explicitly define ""concept"" or provide specific mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus is more on the logical foundations and declarative semantics rather than detailed generic programming methodologies or type system discussions.","- ""We present a formalism for reasoning about declarative object-oriented programs.""
  - ""Classes are represented as rst-order theories that contain logic programs as methods.""
  - ""Inheritance, genericity and related concepts are represented by operations on such theories which preserve the consistency of these theories as well as the correctness of the programs speciied by their axioms.""
  - ""Our approach provides a logical basis for the construction of correct and reusable programming systems.""
  - ""Our main motivation is formal program development, i.e. developing programs that are formally correct wrt their formal speciications.""
  - ""Our goal in this paper is to provide the necessary logical foundations for formal program development in an object-oriented paradigm which has a suitable (declarative) semantics for this purpose.""
  - ""Declarative object-oriented programming languages have been proposed, by both the functional and logic programming communities.""
  - ""These languages, though declarative in their methods, usually lack a suitable semantics for reasoning about formal object-oriented program development.""
  - ""Our main contribution is to deene classes and methods declaratively, such that classes are full rst-order theories (with isoinitial semantics), methods are logic programs that are synthesised from their speciications (in classes), and under our chosen (isoinitial) semantics, we can reason about the correctness, and correct reuse of both classes and their programs.""
  - ""Correctness of a class is deened as its adequacy, and class reuse corresponds to class composition that preserves adequacy.""
  - ""Correctness of a program is deened wrt a speciication: a program is correct if its (initial) model coincides with the interpretation of the speciication in the""",,"- The abstract introduces a novel formalism for reasoning about declarative object-oriented programs, which is a key theoretical contribution.
 - It represents classes as first-order theories and methods as logic programs, providing a logical basis for constructing correct and reusable programming systems.
 - The approach addresses the lack of suitable semantics in existing declarative object-oriented programming languages for formal program development.
 - The paper provides a new definition of classes and methods that allows for reasoning about correctness and reuse, which is a significant theoretical advancement.
 - The focus on formal program development and the provision of logical foundations for object-oriented programming with declarative semantics are unique contributions.
 - The abstract discusses the potential implications for programming language design by providing a framework for formal reasoning about programs, which is a theoretical innovation."
Types for Multi-Paradigm Modelling,"J. Lara, H. Vangheluwe",-,-,-,0,-,Not specified (the abstract does not explicitly list or define specific conceptual primitives),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Use of AToM3 for multi-formalism modelling, meta-modelling of formalisms, Formalism Transformation Graph (FTG) for automatic conversion between formalisms.
 - Interaction models between paradigms: Meta-modelling of formalisms within AToM3, automatic generation of tools for processing models.
 - Constraints or challenges in paradigm integration: Limitations of regular programming language types in multi-paradigm modelling.
 - Novel translation or embedding techniques: Use of graph grammars to manipulate types.",Generic programming not extensively addressed,"- Key novel insights: Inclusion of time representation and simulation in types.
 - Theoretical advancements: Integration of meta-modelling, multi-formalism modeling, and multiple abstraction levels; use of graph grammars for type manipulation.
 - Potential implications for programming language design: Enhanced type systems that incorporate temporal aspects and support multi-paradigm modeling.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""
  - ""AToM3 allows one to model different parts of a system using different formalisms.""
  - ""The formalisms themselves are modelled at a metalevel within an appropriate formalism.""
  - ""AToM3 uses the information found in the meta-models to automatically generate tools to process (create, edit, check, and generate simulators for) the models in the described formalism.""
  - ""Models can be automatically converted between formalisms thanks to information found in a Formalism Transformation Graph (FTG).""
  - ""The transformations are described at a meta-level by means of models in the graph-grammar formalism.""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the limitations of regular programming language types in multi-paradigm modeling and proposes the inclusion of time representation and simulation information in types.
 - It mentions the use of meta-modelling, multi-formalism modeling, and multiple abstraction levels, which are conceptual primitives in the context of multi-paradigm modeling.
 - The abstract describes AToM3, a tool that allows modeling different parts of a system using different formalisms, which implies a primitive related to formalism flexibility.
 - The use of meta-models and graph grammars to manipulate types suggests primitives related to meta-modelling and graph manipulation.
 - The abstract does not explicitly list or define specific conceptual primitives with precise definitions or orthogonality scores.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""
  - ""AToM3 uses the information found in the meta-models to automatically generate tools to process (create, edit, check, and generate simulators for) the models in the described formalism.""
  - ""Models can be automatically converted between formalisms thanks to information found in a Formalism Transformation Graph (FTG).""
  - ""The transformations are described at a meta-level by means of models in the graph-grammar formalism.""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the limitations of regular programming language types in multi-paradigm modeling and proposes enhancements to include time representation and simulation.
 - It mentions the use of meta-modelling, multi-formalism modeling, and multiple abstraction levels, which suggests a complex framework but does not specify a particular mathematical framework like type theory or category theory.
 - The abstract describes the use of graph grammars for manipulating types and the Formalism Transformation Graph (FTG) for converting models between formalisms, which are mathematical tools but not explicitly identified as part of a broader mathematical framework.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.
 - The focus is on the design and implementation of AToM3 and its capabilities rather than on a detailed mathematical framework.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""
  - ""AToM3 allows one to model different parts of a system using different formalisms.""
  - ""The formalisms themselves are modelled at a metalevel within an appropriate formalism.""
  - ""AToM3 uses the information found in the meta-models to automatically generate tools to process (create, edit, check, and generate simulators for) the models in the described formalism.""
  - ""Models can be automatically converted between formalisms thanks to information found in a Formalism Transformation Graph (FTG).""
  - ""The transformations are described at a meta-level by means of models in the graph-grammar formalism.""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the integration of different programming paradigms through the concept of ""multi-paradigm modelling,"" which involves combining meta-modelling, multi-formalism modelling, and multiple abstraction levels.
 - The integration mechanism proposed is the use of AToM3, a tool that allows different parts of a system to be modelled using different formalisms.
 - The interaction model between paradigms is facilitated by the meta-modelling of formalisms within AToM3, which enables automatic generation of tools for processing models.
 - The Formalism Transformation Graph (FTG) is a key component in integrating different formalisms by allowing automatic conversion between them.
 - Graph grammars are used to manipulate types, which is a novel technique for handling composite types in a multi-paradigm context.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, but it does highlight the limitations of regular programming language types in this context.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""The formalisms themselves are modelled at a metalevel within an appropriate formalism.""
  - ""AToM3 uses the information found in the meta-models to automatically generate tools to process (create, edit, check, and generate simulators for) the models in the described formalism.""
  - ""Models can be automatically converted between formalisms thanks to information found in a Formalism Transformation Graph (FTG).""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the limitations of regular programming language types in multi-paradigm modeling, which suggests a focus on abstraction mechanisms.
 - The mention of ""meta-modelling"" and ""multi-formalism modelling"" indicates a high level of abstraction, as it involves modeling models and using multiple formalisms.
 - The inclusion of time representation in types suggests a mechanism for representing generic abstractions, as it allows for more detailed and flexible modeling.
 - The use of meta-models to generate tools and the Formalism Transformation Graph (FTG) for converting models between formalisms implies a mechanism for representing generic abstractions and ensuring compatibility across different formalisms.
 - The mention of ""composite types"" and the use of graph grammars to manipulate types suggests a mechanism for representing complex abstractions and ensuring their consistency.
 - However, the abstract does not explicitly mention ""generic programming"" or provide detailed strategies for static checking or optimization.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""In particular, we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""
  - ""AToM3 allows one to model different parts of a system using different formalisms.""
  - ""The formalisms themselves are modelled at a metalevel within an appropriate formalism.""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the limitations of regular programming language types in multi-paradigm modeling, indicating a gap in current approaches that the study aims to address.
 - The proposal to include information about time representation and simulation in types is a novel insight, as it extends the traditional concept of types to incorporate temporal aspects.
 - The integration of meta-modelling, multi-formalism modeling, and multiple abstraction levels is a theoretical advancement, as it provides a comprehensive framework for handling complex modeling scenarios.
 - The use of graph grammars to manipulate types is a theoretical innovation, as it introduces a new method for type manipulation and analysis.
 - The abstract suggests that these contributions have implications for programming language design, particularly in how types are defined and used in multi-paradigm modeling contexts."
Four Concurrency Primitives for Haskell,Enno Scholz,-,-,-,15,1995,Not specified (the abstract mentions four primitives but does not specify their names or definitions),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),"- Specific integration mechanisms proposed: A monad for concurrent programming in Haskell that encapsulates other communication paradigms.
 - Interaction models between paradigms: Monads serve as a bridge between different paradigms.
 - Constraints or challenges in paradigm integration: Keeping the language small and rigorously defined while providing necessary communication constructs.
 - Novel translation or embedding techniques: Using a simple monad with purely functional abstractions to systematically construct more complex paradigms.","- Definition of ""concept"" used: The monad is used as a concept for abstraction.
 - Mechanisms for representing generic abstractions: Monads encapsulating other communication paradigms.
 - Minimal type requirements identified: Not explicitly mentioned, but implied by the focus on simplicity.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: Introduction of a minimalistic monad for concurrent programming in Haskell with only four primitives.
 - Theoretical advancements: Ability to construct more sophisticated communication paradigms from the basic monad; design principle to minimize concurrency primitives while maximizing purely functional abstractions.
 - Potential implications: Streamlined and rigorously defined languages with comprehensive communication constructs.","- ""The monad consists of only four primitives with a very simple semantics.""
  - ""monads encapsulating other, more sophisticated communication paradigms known from concurrent functional languages such as Concurrent ML, Facile, and Erlang can be naturally and systematically constructed from the built-in monad in a purely functional way.""
  - ""A monad for concurrent programming that is suitable for being built into Haskell is presented.""",,"- The abstract mentions that a monad for concurrent programming is presented, which is suitable for being built into Haskell. This indicates that the study focuses on a monadic approach to concurrency.
 - It explicitly states that the monad consists of ""only four primitives with a very simple semantics."" This suggests that the study defines four specific conceptual primitives for concurrent programming.
 - The abstract does not provide the specific names or definitions of these primitives, nor does it discuss their orthogonality or level of abstraction.
 - The mention of constructing more sophisticated communication paradigms from these primitives implies that they are foundational and likely orthogonal, but this is not explicitly stated.","- ""minimizing the number and complexity of the concurrency primitives and maximizing the use of purely functional abstractions in the design of concurrent languages helps to remedy a recurrent dilemma, namely, how to keep the language small and rigorously defined, yet to provide the programmer with all the communication constructs required.""
  - ""The monad consists of only four primitives with a very simple semantics.""
  - ""monads encapsulating other, more sophisticated communication paradigms known from concurrent functional languages such as Concurrent ML, Facile, and Erlang can be naturally and systematically constructed from the built-in monad in a purely functional way.""
  - ""A monad for concurrent programming that is suitable for being built into Haskell is presented.""
  - ""An interleaving implementation of the monad has been built by extending Mark Jones's Gofer environment to handle the concurrency primitives.""",,"- The abstract discusses the use of a monad for concurrent programming in Haskell, which is a functional programming language. This suggests a focus on functional programming principles rather than a specific mathematical framework like type theory or category theory.
 - The mention of ""four primitives with a very simple semantics"" and the ability to construct more sophisticated communication paradigms in a ""purely functional way"" indicates a focus on functional programming abstractions rather than a specific mathematical framework.
 - The abstract does not explicitly mention any theoretical foundations, proof methodology, or formal verification discussions related to a mathematical framework.
 - The focus on keeping the language ""small and rigorously defined"" suggests an emphasis on simplicity and functional programming principles rather than a specific mathematical framework.","- ""The paper argues that minimizing the number and complexity of the concurrency primitives and maximizing the use of purely functional abstractions in the design of concurrent languages helps to remedy a recurrent dilemma, namely, how to keep the language small and rigorously defined, yet to provide the programmer with all the communication constructs required.""
  - ""A number of examples demonstrate that monads encapsulating other, more sophisticated communication paradigms known from concurrent functional languages such as Concurrent ML, Facile, and Erlang can be naturally and systematically constructed from the built-in monad in a purely functional way.""
  - ""The monad consists of only four primitives with a very simple semantics.""
  - ""A monad for concurrent programming that is suitable for being built into Haskell is presented.""",,"- The abstract discusses the integration of different programming paradigms by introducing a monad for concurrent programming in Haskell. This suggests a specific integration mechanism where the monad is used to encapsulate other communication paradigms.
 - The mention of ""monads encapsulating other, more sophisticated communication paradigms"" indicates an interaction model where the monad serves as a bridge between different paradigms.
 - The abstract highlights the challenge of keeping the language small and rigorously defined while providing necessary communication constructs, which is a constraint in paradigm integration.
 - The approach of using a simple monad with purely functional abstractions is a novel translation or embedding technique that allows for systematic construction of more complex paradigms.","- ""The monad consists of only four primitives with a very simple semantics.""
  - ""minimizing the number and complexity of the concurrency primitives and maximizing the use of purely functional abstractions in the design of concurrent languages helps to remedy a recurrent dilemma, namely, how to keep the language small and rigorously defined, yet to provide the programmer with all the communication constructs required.""
  - ""A monad for concurrent programming that is suitable for being built into Haskell is presented.""
  - ""monads encapsulating other, more sophisticated communication paradigms known from concurrent functional languages such as Concurrent ML, Facile, and Erlang can be naturally and systematically constructed from the built-in monad in a purely functional way.""",,"- The abstract discusses the use of a monad for concurrent programming in Haskell, which is a form of abstraction mechanism. The monad is described as having ""very simple semantics,"" indicating a focus on simplicity and clarity in the abstraction.
 - The mention of constructing monads that encapsulate other communication paradigms suggests a mechanism for representing generic abstractions. This implies that the monad can be used to abstract over different communication paradigms, making it a generic abstraction mechanism.
 - The abstract emphasizes the importance of ""maximizing the use of purely functional abstractions,"" which aligns with the principles of generic programming. This suggests that the study approaches generic programming by focusing on functional abstractions.
 - There is no explicit mention of minimal type requirements, static checking, or optimization strategies in the abstract. However, the focus on simplicity and functional abstractions implies a minimalist approach to type requirements and potentially to static checking.
 - The abstract does not provide detailed discussions on type systems or specific static checking strategies, but it does highlight the use of functional abstractions as a mechanism for generic programming.","- ""A monad for concurrent programming that is suitable for being built into Haskell is presented.""
  - ""The monad consists of only four primitives with a very simple semantics.""
  - ""A number of examples demonstrate that monads encapsulating other, more sophisticated communication paradigms known from concurrent functional languages such as Concurrent ML, Facile, and Erlang can be naturally and systematically constructed from the built-in monad in a purely functional way.""
  - ""The paper argues that minimizing the number and complexity of the concurrency primitives and maximizing the use of purely functional abstractions in the design of concurrent languages helps to remedy a recurrent dilemma, namely, how to keep the language small and rigorously defined, yet to provide the programmer with all the communication constructs required.""",,"- The abstract introduces a novel monad for concurrent programming in Haskell, which is a key theoretical contribution. This monad is designed to be simple and minimalistic, consisting of only four primitives.
 - The ability to construct more sophisticated communication paradigms from this basic monad is highlighted, indicating a theoretical advancement in how concurrency can be approached in functional programming languages.
 - The paper argues for a design principle that minimizes concurrency primitives while maximizing purely functional abstractions. This is a theoretical contribution as it addresses a common dilemma in language design: balancing simplicity with functionality.
 - The potential implications for programming language design are significant, as this approach could lead to more streamlined and rigorously defined languages that still offer comprehensive communication constructs."
"Programming Paradigms, Turing Completeness and Computational Thinking",G. Michaelson,10.22152/programming-journal.org/2020/4/4,https://doi.org/10.22152/programming-journal.org/2020/4/4,"The Art, Science, and Engineering of Programming",3,2020,"1. Primitive Name: Decomposition
  Definition: The ability to break down a problem into sub-problems.
  Orthogonality Score: Not specified
 

 2. Primitive Name: Pattern recognition
  Definition: The ability to notice similarities, differences, properties, or trends in data.
  Orthogonality Score: Not specified
 

 3. Primitive Name: Pattern generalization
  Definition: The ability to extract unnecessary details and generalize those that are necessary in order to define a concept or idea in general terms.
  Orthogonality Score: Not specified
 

 4. Primitive Name: Algorithm design
  Definition: The ability to build a repeatable, step-by-step process to solve a particular problem.
  Orthogonality Score: Not specified
 

 5. Primitive Name: Sequence
  Definition: Command order, operator/procedure/function composition.
  Orthogonality Score: Not specified
 

 6. Primitive Name: Choice
  Definition: Conditional/case/guarded command/expression.
  Orthogonality Score: Not specified
 

 7. Primitive Name: Repetition
  Definition: Bounded/unbounded iteration/recursion.
  Orthogonality Score: Not specified","- Type of mathematical framework: Turing Completeness
 - Specific mathematical properties guaranteed: Unbounded computations over unbounded values, expressiveness
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: The paper challenges the traditional notion of distinct programming paradigms, suggesting they are closely related and part of a broader paradigm.
 - Theoretical advancements: It proposes a unified framework of Turing Complete computation and Computational Thinking, suggesting CT as the overarching methodology.
 - Potential implications for programming language design: Languages should be designed with a focus on Computational Thinking rather than adhering to specific paradigms.","- ""The basic structuring constructs common to all paradigms are: sequence e.g. command order, operator/procedure/function composition; choice e.g. conditional/case/guarded command/expression; repetition e.g. bounded/unbounded iteration/recursion.""
  - ""Control structures may be identified from traces of concrete computations by teasing out patterns and generalising them.""
  - ""CT may be used to systematically construct programs by interrogating concrete instances of problems.""
  - ""A central contention of this paper is that Computational Thinking (CT) is the paradigmatic methodology for Turing Complete (TC) computing.""",,"- The paper discusses Computational Thinking (CT) as a paradigmatic methodology for Turing Complete (TC) computing, which suggests that CT is a foundational concept for reconstructing programming paradigms.
 - The four elements of CT as defined by Kao are explicitly mentioned: Decomposition, Pattern recognition, Pattern generalization, and Algorithm design. These elements are conceptual primitives that underpin the methodology of CT.
 - The paper also discusses control structures and basic structuring constructs that are common to all paradigms, which can be considered as additional conceptual primitives.
 - The level of abstraction of these primitives is high, as they are fundamental concepts that apply across different programming paradigms.
 - The orthogonality of these primitives is not explicitly discussed in terms of a score, but they are presented as distinct and complementary elements of CT.","- ""Orthogonal to Turing Completeness is Felleisen's formal notion of expressiveness""
  - ""The Church-Turing hypothesis suggests that programming language components of different programming paradigms necessarily all have the same explanatory power.""
  - ""The notion of distinct programming paradigms, as opposed to permeable traditions of programming languages and methodologies, now seems anachronistic in Computer Science curricula, and should be revisited.""
  - ""Ultimately, all executable code must necessarily be realised on a physical computer as machine code, either directly through compilation, or indirectly through an interpreter itself ultimately realised as machine code.""
  - ""The primary requirement for a TC language is the capacity to describe unbounded computations over unbounded values.""",,"- The paper discusses Turing Completeness (TC) as a fundamental theoretical foundation, which is a mathematical framework that ensures a language can describe unbounded computations over unbounded values.
 - Felleisen's formal notion of expressiveness is mentioned, which is a mathematical property that compares the expressiveness of different languages.
 - The Church-Turing hypothesis is a key mathematical framework that underpins the paper's discussion on programming paradigms, suggesting that all TC languages have the same explanatory power.
 - The paper does not explicitly mention type theory, category theory, or other specific mathematical frameworks beyond Turing Completeness and expressiveness.
 - There is no detailed discussion on proof techniques or limitations of the framework in the provided text.","- ""It is argued that apparently disparate languages are closely related, and that programming methodologies are not necessarily tied to particular classes of languages.""
  - ""the language and methodology components of programming paradigms are closer to coexisting traditions within a unitary Computer Science paradigm, comprised of Turing Complete programming languages, and methodologies which may all be subsumed by Computational Thinking.""
  - ""It is easier to realise a programming methodology in a language that directly supports corresponding constructs, and, in practice, a pre-specified language will strongly influence the programming approach.""
  - ""Implementing strongly imperative designs in functional languages is more complicated, with copying substituting for in-place update.""
  - ""implementing functional designs that do not take strong advantage of functional abstraction is straightforward in procedural or OO languages, which now invariably support recursion.""
  - ""functional abstraction may be realised through jump tables or classes.""
  - ""The notion of distinct programming paradigms, as opposed to permeable traditions of programming languages and methodologies, now seems anachronistic in Computer Science curricula, and should be revisited.""",,"- The paper discusses the integration of programming paradigms by suggesting that they are not distinct but rather coexisting traditions within a unitary Computer Science paradigm.
 - It highlights that programming methodologies are not necessarily tied to specific language classes, indicating a flexible approach to integration.
 - The paper mentions that it is easier to implement methodologies in languages that support corresponding constructs, suggesting a practical integration mechanism.
 - It discusses the challenges of implementing imperative designs in functional languages and vice versa, indicating constraints in paradigm integration.
 - The paper suggests that functional abstraction can be realized through jump tables or classes, which could be considered a novel translation technique.
 - Overall, the paper does not propose a specific integration approach but rather emphasizes the interconnectedness and flexibility of programming paradigms.","- ""The contemporary taxonomic approach uses formal properties of languages to identify distinct programming paradigms. These may include: memory model -imperative/mutable v declarative/immutable; type system -weak v strong, static v dynamic, ad hoc v parametric polymorphism; evaluation mechanism -strict v lazy, specified v unspecified order; abstraction mechanism -data structure, class, object, procedural, functional.""
  - ""Functional programming seems markedly different as there is no concept of assignment to modify mutable memory. However, structured programming is also a key methodology for functional programming, once functions have been identified: sequence is equivalent to function composition and repetition to recursion, all functional languages have explicit selection constructs, and modern varieties provide case based function definitions.""
  - ""functional abstraction may be realised through jump tables or classes.""
  - ""Krishnamurthi focuses on a spectrum of language features through definitional interpreters, while Harper promotes understanding of programming languages in terms of types.""
  - ""van Roy [ ] uses a formal taxonomy, based on both operational properties and types, to identify thirty different programming ""paradigms"".""","- ""<table_quotation page_num=11 table_on_page=1>```markdown
 | year | author | proc/ imp | func | logic | OO | par/ conc | algs | other  |
 |------|-----------------|-----------|------|-------|-----|-----------|------|----------------------------------------------------------------------|
 | 1978 | Floyd [12] |  | |  |  |  | Y | |
 | 1986 | Gibbs & Tucker [16] | Y  | Y | Y  | Y  |  | | modular data flow  |
 | 1986 | Shriver [29] | Y  | | Y  | Y  |  | | non-proc visual  |
 | 1986 | Hailpern [18]  | Y  | Y | Y  | Y  |  | | access oriented data flow data structure oriented real time rules oriented |
 | 1989 | Wegner [36]  |  | |  |  |  | Y | distributed  |
 ```</table_quotation>""
  - ""<table_quotation page_num=13 table_on_page=1>```markdown
 | year | author | proc/imp | func | logic | OO | par/conc | algs | other |
 |------|---------------|----------|------|-------|-----|----------|------|----------------------------------------------------------------------------------------------------------------------------------------|
 | 1991 | ACM/IEEE [31] | Y | Y | Y  | Y  | Y | Y | |
 | 2001 | ACM/IEEE [27] | Y | Y |  | Y  | Y | | distributed<br>declarative<br>scripting<br>event driven |
 | 2013 | ACM/IEEE [28] | Y | Y |  | Y  | Y | | scripting<br>design: event driven,<br>component level,<br>data structure,<br>aspect oriented &<br>service oriented<br>learning agents<br>producer-consumer<br>hardware |
 | 2016 | AQA [1]  | Y | (Y) |  | Y  | | | high v low level  |
 | 2016 | SQA [2]  | Y | |  | Y  | Y | | |
 ```</table_quotation>""","- The paper discusses the concept of abstraction in terms of functional programming, where functions are composed and recursion is used, indicating a focus on functional abstraction.
 - The mention of ""abstraction mechanism -data structure, class, object, procedural, functional"" suggests that these are mechanisms for representing generic abstractions.
 - The paper does not explicitly define a ""concept"" in the context of generic programming, but it implies that concepts are related to functional abstraction and type systems.
 - There is no specific mention of minimal type requirements or static checking strategies in the context of generic programming.
 - The paper does not extensively address generic programming or provide detailed mechanisms for genericity and abstraction beyond the general discussion of functional programming and type systems.","- ""The notion of distinct programming paradigms, as opposed to permeable traditions of programming languages and methodologies, now seems anachronistic in Computer Science curricula, and should be revisited.""
  - ""Instead, the language and methodology components of programming paradigms are closer to coexisting traditions within a unitary Computer Science paradigm, comprised of Turing Complete programming languages, and methodologies which may all be subsumed by Computational Thinking.""
  - ""It is argued that apparently disparate languages are closely related, and that programming methodologies are not necessarily tied to particular classes of languages.""
  - ""This paper interrogates this idea of well characterised programming paradigms, and suggests that discriminating amongst them is fraught with problems.""
  - ""In future research, it would be worth providing more detailed analyses of each of the programming methodologies considered above, through their actual deployment from specification to program, for a common exemplar, alongside the use of strong CT.""",,"- The paper challenges the traditional notion of distinct programming paradigms, suggesting that they are not as separate as previously thought. This is a key novel insight as it questions the conventional understanding of programming paradigms.
 - The paper argues that programming languages and methodologies are part of a broader, unitary paradigm of Turing Complete computation and Computational Thinking. This is a theoretical advancement as it proposes a unified framework for understanding programming paradigms.
 - The central contention that Computational Thinking is the paradigmatic methodology for Turing Complete computing is a significant theoretical contribution. It suggests that CT can encompass various programming methodologies, which is a new perspective on how programming methodologies relate to each other.
 - The paper suggests that the concept of distinct programming paradigms is outdated and should be revisited. This has potential implications for programming language design, as it implies that languages should be designed with a focus on Computational Thinking rather than adhering to specific paradigms.
 - The call for future research to analyze programming methodologies in the context of Computational Thinking indicates a direction for further theoretical advancements in understanding how different methodologies can be integrated under the umbrella of CT."
Type Theory as a Unifying Paradigm for Modern Databases,"Christoph Dorn, Haikal Pribadi",10.1145/3583780.3615999,https://doi.org/10.1145/3583780.3615999,International Conference on Information and Knowledge Management,2,2023,Not specified (the abstract does not provide explicit names or definitions for the conceptual primitives),"- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Data integrity and logic consistency
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described (the abstract discusses a conceptual framework for integration but does not provide specific mechanisms or techniques),Generic programming not extensively addressed (the abstract discusses abstraction and type theory but lacks specific details on generic programming mechanisms),"- Key novel insights: Integration of high-level programming and reasoning techniques for future knowledge management systems.
 - Theoretical advancements: Novel type theoretical modeling and reasoning paradigm balancing semantic modeling with practical implementation.
 - Potential implications for programming language design: Reduces development and maintenance loads, prevents data integrity errors, and provides a unifying toolset for domain-specific applications.","- ""TypeQL is a multi-purpose database language rooted in these foundations: it is designed around the expressivity of natural language and backed by type theoretical principles.""
  - ""This rigorous high-level approach to database language reduces development and maintenance loads, preventing hard to spot data integrity and logic errors through its underlying type system,""
  - ""a novel type theoretical modeling and reasoning paradigm,""",,"- The abstract discusses a ""novel type theoretical modeling and reasoning paradigm,"" which suggests that the study is proposing a new set of conceptual primitives based on type theory.
 - TypeQL is mentioned as a ""multi-purpose database language rooted in these foundations,"" indicating that it is a key component of the paradigm.
 - The abstract highlights that TypeQL is ""designed around the expressivity of natural language and backed by type theoretical principles,"" which implies that the conceptual primitives are related to type theory and natural language expressivity.
 - The abstract does not provide explicit names or definitions for the conceptual primitives, nor does it mention their level of abstraction or orthogonality.
 - The focus on preventing ""hard to spot data integrity and logic errors through its underlying type system"" suggests that the primitives are related to ensuring data integrity and logic consistency, but again, no specific primitives are defined.","- ""TypeQL is a multi-purpose database language rooted in these foundations: it is designed around the expressivity of natural language and backed by type theoretical principles.""
  - ""a novel type theoretical modeling and reasoning paradigm,""
  - ""This rigorous high-level approach to database language reduces development and maintenance loads, preventing hard to spot data integrity and logic errors through its underlying type system,""",,"- The abstract mentions a ""novel type theoretical modeling and reasoning paradigm,"" indicating that the mathematical framework used is type theory.
 - TypeQL is described as being ""backed by type theoretical principles,"" further confirming the use of type theory as the mathematical framework.
 - The abstract highlights that the framework prevents ""hard to spot data integrity and logic errors through its underlying type system,"" suggesting that the framework guarantees certain properties related to data integrity and logic consistency.
 - There is no explicit mention of specific mathematical properties guaranteed, proof techniques used, or limitations or constraints of the framework in the abstract.","- ""This rigorous high-level approach to database language reduces development and maintenance loads, preventing hard to spot data integrity and logic errors through its underlying type system, while also providing a unifying toolset for a large class of domain-specific applications""
  - ""We argue that higher levels of abstraction including, in particular, the integration of high-level programming and reasoning techniques, will pave the way forward for future knowledge management systems.""
  - ""TypeQL is a multi-purpose database language rooted in these foundations: it is designed around the expressivity of natural language and backed by type theoretical principles.""
  - ""a novel type theoretical modeling and reasoning paradigm, which aims to strike a powerful balance between what can be naturally semantically modeled and what can be practically implemented.""",,"- The abstract mentions the integration of ""high-level programming and reasoning techniques,"" which suggests an approach to integrating different programming paradigms by focusing on higher levels of abstraction.
 - The introduction of a ""novel type theoretical modeling and reasoning paradigm"" implies a theoretical integration strategy that balances semantic modeling with practical implementation.
 - TypeQL is described as a ""multi-purpose database language"" that is ""rooted in these foundations,"" indicating that it is a tool for integrating different paradigms by providing a unified language.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, constraints, or novel translation techniques. It focuses more on the conceptual framework and benefits rather than detailed integration strategies.","- ""We argue that higher levels of abstraction including, in particular, the integration of high-level programming and reasoning techniques, will pave the way forward for future knowledge management systems.""
  - ""This rigorous high-level approach to database language reduces development and maintenance loads, preventing hard to spot data integrity and logic errors through its underlying type system, while also providing a unifying toolset for a large class of domain-specific applications""
  - ""TypeQL is a multi-purpose database language rooted in these foundations: it is designed around the expressivity of natural language and backed by type theoretical principles.""
  - ""a novel type theoretical modeling and reasoning paradigm, which aims to strike a powerful balance between what can be naturally semantically modeled and what can be practically implemented.""",,"- The abstract discusses the integration of high-level programming and reasoning techniques, which suggests a focus on abstraction mechanisms.
 - The mention of a ""novel type theoretical modeling and reasoning paradigm"" indicates a focus on type theory as a mechanism for abstraction.
 - TypeQL is described as being ""rooted in these foundations,"" suggesting that it is a tool for implementing these abstractions.
 - The abstract highlights the use of type theoretical principles to prevent data integrity and logic errors, which implies a form of static checking.
 - However, the abstract does not explicitly define ""concept"" or provide detailed mechanisms for representing generic abstractions, minimal type requirements, or specific static checking strategies.","- ""We argue that higher levels of abstraction including, in particular, the integration of high-level programming and reasoning techniques, will pave the way forward for future knowledge management systems.""
  - ""This rigorous high-level approach to database language reduces development and maintenance loads, preventing hard to spot data integrity and logic errors through its underlying type system, while also providing a unifying toolset for a large class of domain-specific applications""
  - ""a novel type theoretical modeling and reasoning paradigm, which aims to strike a powerful balance between what can be naturally semantically modeled and what can be practically implemented.""
  - ""TypeQL is a multi-purpose database language rooted in these foundations: it is designed around the expressivity of natural language and backed by type theoretical principles.""",,"- The abstract introduces a ""novel type theoretical modeling and reasoning paradigm,"" which suggests a new theoretical approach to data modeling and reasoning.
 - The integration of ""high-level programming and reasoning techniques"" indicates a theoretical advancement by combining these elements to enhance future knowledge management systems.
 - The mention of TypeQL as a ""multi-purpose database language"" backed by type theoretical principles implies a theoretical contribution in the design of database languages, particularly in its ability to balance semantic modeling with practical implementation.
 - The abstract highlights the potential implications for programming language design by reducing development and maintenance loads and preventing data integrity errors, which are theoretical contributions to the field of database language design."
Functional Programming and Parallel Processing,R. Lins,10.1007/3-540-62828-2_134,https://doi.org/10.1007/3-540-62828-2_134,International Conference on High Performance Computing for Computational Science,5,1996,Not specified (the abstract does not explicitly define any conceptual primitives or their definitions),"- Type of mathematical framework: λ-Calculus
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Theoretical grounding of functional programming in λ-Calculus, potential for extracting parallelism.
 - Theoretical advancements: Analysis of the evolution of functional programming paradigm, particularly in relation to parallel processing.
 - Potential implications: Grounding in λ-Calculus could inform more robust programming language design; extracting parallelism could enhance efficiency in parallel processing.","- ""A functional program is a set of function definitions.""
  - ""One of the many promises of functional programming was the possibility of extracting parallelism.""
  - ""The λ-Calculus, a theory of functions under recursion, offers a solid theoretic background to functional programming.""
  - ""Functional languages belong to a neat and very high-level programming paradigm.""",,"- The abstract mentions that functional languages are part of a ""neat and very high-level programming paradigm,"" which suggests a conceptual framework but does not explicitly define any primitives.
 - It states that a functional program is a ""set of function definitions,"" which could be considered a conceptual primitive, but it lacks a precise definition and does not specify orthogonality.
 - The mention of the λ-Calculus as a ""theory of functions under recursion"" provides a theoretical background, but again, no explicit primitives are defined or discussed in terms of orthogonality.
 - The abstract does not provide specific conceptual primitives or their definitions as requested by the question.","- ""The λ-Calculus, a theory of functions under recursion, offers a solid theoretic background to functional programming.""",,"- The abstract mentions the λ-Calculus as a theoretical background for functional programming, which is a mathematical framework.
 - The λ-Calculus is a type of mathematical framework that provides a foundation for functional programming.
 - The abstract does not specify any specific mathematical properties guaranteed by the λ-Calculus or any proof techniques used.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""This paper analyses the evolution of the functional programming paradigm under this outlook.""
  - ""One of the many promises of functional programming was the possibility of extracting parallelism.""
  - ""The λ-Calculus, a theory of functions under recursion, offers a solid theoretic background to functional programming.""
  - ""A functional program is a set of function definitions.""
  - ""Functional languages belong to a neat and very high-level programming paradigm.""",,"- The abstract primarily focuses on the functional programming paradigm and its theoretical background, particularly mentioning the λ-Calculus.
 - It discusses the potential for extracting parallelism, which is a characteristic of functional programming, but does not explicitly mention integration with other paradigms.
 - There is no mention of specific integration mechanisms, interaction models between paradigms, constraints or challenges in paradigm integration, or novel translation or embedding techniques.
 - The abstract does not provide any information on how different programming paradigms are integrated or interact with each other.","- ""A functional program is a set of function definitions.""
  - ""Functional languages belong to a neat and very high-level programming paradigm.""
  - ""This paper analyses the evolution of the functional programming paradigm under this outlook.""
  - ""One of the many promises of functional programming was the possibility of extracting parallelism.""
  - ""The λ-Calculus, a theory of functions under recursion, offers a solid theoretic background to functional programming.""",,"- The abstract discusses functional programming and its theoretical background, but it does not explicitly mention generic programming or abstraction mechanisms.
 - The focus is on the evolution of the functional programming paradigm and its potential for parallelism, not on genericity or abstraction.
 - There is no mention of a definition of ""concept"" used, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies.
 - The abstract does not contain a section on generic programming methodology, type system discussions, or abstraction mechanism explanations.","- ""The λ-Calculus, a theory of functions under recursion, offers a solid theoretic background to functional programming.""
  - ""One of the many promises of functional programming was the possibility of extracting parallelism.""
  - ""A functional program is a set of function definitions.""
  - ""This paper analyses the evolution of the functional programming paradigm under this outlook.""
  - ""Functional languages belong to a neat and very high-level programming paradigm.""",,"- The abstract mentions that functional languages are part of a ""neat and very high-level programming paradigm,"" which suggests a focus on theoretical aspects rather than practical implementation.
 - The reference to the λ-Calculus as a ""solid theoretic background"" indicates a theoretical contribution by grounding functional programming in established mathematical theory.
 - The mention of ""extracting parallelism"" as a promise of functional programming implies a theoretical contribution related to parallel processing, which is a significant aspect of the paper's focus.
 - The analysis of the ""evolution of the functional programming paradigm"" suggests a theoretical contribution by examining how the paradigm has developed over time, particularly in relation to parallel processing."
"Programming Languages and Systems : 11th European Symposium on Programming, ESOP 2002, held as part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2002, Grenoble, France, April 8-12, 2002 : proceedings",D. L. Métayer,-,-,-,3,2002,Not specified (the abstract does not explicitly define any conceptual primitives or provide their definitions),"- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Modular, extensible proof methods; dependency calculus
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Type checking systems code, typing and modularity, existential types for imperative languages, higher-order intensional type analysis, theory of second-order trees.
 - Theoretical advancements: Soft concurrent constraint programming, thread-modular verification for shared-memory programs, automatic complexity analysis, dependency analysis of mobile systems.
 - Potential implications for programming language design: Advancements in type systems, modularity, concurrent programming, and program analysis.","- ""Programming Paradigms.-""
  - ""Soft Concurrent Constraint Programming.-""
  - ""Programming Languages for Compressing Graphics.-""
  - ""An Accumulative Parallel Skeleton for All.-""
  - ""Higher-Order Intensional Type Analysis.-""
  - ""Lambda Calculus.-""
  - ""Branching Types.-""
  - ""Exceptions, Continuations and Macro-expressiveness.-""
  - ""A Theory of Second-Order Trees.-""",,"- The abstract mentions several topics related to programming paradigms, such as ""Programming Paradigms,"" ""Soft Concurrent Constraint Programming,"" and ""Programming Languages for Compressing Graphics."" These could be considered as areas where conceptual primitives might be defined.
 - However, the abstract does not explicitly list or define any specific conceptual primitives. It provides a list of topics and areas of focus but lacks detailed definitions or explanations of these primitives.
 - The abstract does not mention any specific methodology, theoretical framework, or results sections where conceptual primitives might be defined.
 - The level of abstraction and orthogonality of the primitives are not discussed in the abstract.","- ""Type Checking Systems Code.-""
  - ""Typing and Modularity.-""
  - ""Existential Types for Imperative Languages.-""
  - ""Another Type System for In-Place Update.-""
  - ""Higher-Order Intensional Type Analysis.-""
  - ""A Modular, Extensible Proof Method for Small-Step Flow Analyses.-""
  - ""A Prototype Dependency Calculus.-""
  - ""Automatic Complexity Analysis.-""
  - ""Thread-Modular Verification for Shared-Memory Programs.-""
  - ""Timing UDP: Mechanized Semantics for Sockets, Threads, and Failures.-""",,"- The abstract mentions several topics related to type systems and verification, which are key components of mathematical frameworks in programming languages.
 - ""Type Checking Systems Code,"" ""Typing and Modularity,"" and ""Existential Types for Imperative Languages"" suggest the use of type theory as a mathematical framework.
 - ""Higher-Order Intensional Type Analysis"" further supports the use of type theory, as it involves advanced type systems.
 - ""A Modular, Extensible Proof Method for Small-Step Flow Analyses"" and ""A Prototype Dependency Calculus"" indicate the use of proof methodologies, likely within a type theory framework.
 - ""Automatic Complexity Analysis"" and ""Thread-Modular Verification for Shared-Memory Programs"" suggest the application of these frameworks to analyze program properties.
 - The abstract does not explicitly mention category theory or other mathematical frameworks, nor does it specify limitations or constraints of the framework.","- ""Programming Paradigms.-""
  - ""Soft Concurrent Constraint Programming.-""
  - ""Programming Languages for Compressing Graphics.-""
  - ""An Accumulative Parallel Skeleton for All.-""
  - ""Higher-Order Intensional Type Analysis.-""
  - ""Lambda Calculus.-""
  - ""Branching Types.-""
  - ""Exceptions, Continuations and Macro-expressiveness.-""",,"- The abstract mentions ""Programming Paradigms"" as a topic, which suggests that the study might address integration or discussion of different programming paradigms.
 - ""Soft Concurrent Constraint Programming"" could imply a focus on integrating concurrent and constraint programming paradigms.
 - ""Programming Languages for Compressing Graphics"" might involve integrating graphics processing with programming languages, but it's not explicitly about paradigm integration.
 - ""An Accumulative Parallel Skeleton for All"" could suggest a mechanism for integrating parallel programming paradigms, but it's not clear if it's about integration across different paradigms.
 - ""Higher-Order Intensional Type Analysis,"" ""Lambda Calculus,"" ""Branching Types,"" and ""Exceptions, Continuations and Macro-expressiveness"" are topics related to programming languages and type systems, which might be relevant to paradigm integration, but they do not explicitly mention integration mechanisms or challenges.
 - The abstract does not provide specific details on integration mechanisms, interaction models, constraints, or novel translation techniques for integrating different programming paradigms.","- ""Type Checking Systems Code.-""
  - ""Typing and Modularity.-""
  - ""Mixin Modules in a Call-by-Value Setting.-""
  - ""Existential Types for Imperative Languages.-""
  - ""Another Type System for In-Place Update.-""
  - ""Higher-Order Intensional Type Analysis.-""
  - ""Branching Types.-""
  - ""A Modular, Extensible Proof Method for Small-Step Flow Analyses.-""",,"- The abstract mentions several topics related to type systems and modularity, which are relevant to generic programming and abstraction mechanisms. For example, ""Typing and Modularity"" and ""Mixin Modules in a Call-by-Value Setting"" suggest discussions on modular and generic programming concepts.
 - ""Existential Types for Imperative Languages"" and ""Another Type System for In-Place Update"" indicate discussions on type systems that could be related to genericity and abstraction.
 - ""Higher-Order Intensional Type Analysis"" and ""Branching Types"" suggest advanced type analysis techniques that might be used in generic programming.
 - ""A Modular, Extensible Proof Method for Small-Step Flow Analyses"" implies a focus on modular and extensible mechanisms, which could be related to generic programming methodologies.
 - However, the abstract does not explicitly mention a section or focus on ""Genericity and Abstraction Mechanisms"" or provide specific details on the definition of ""concept,"" mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.","- ""Invited Paper.- Type Checking Systems Code.- Typing and Modularity.- Mixin Modules in a Call-by-Value Setting.- Existential Types for Imperative Languages.- Another Type System for In-Place Update.-""
  - ""Programming Paradigms.- Soft Concurrent Constraint Programming.- Programming Languages for Compressing Graphics.- An Accumulative Parallel Skeleton for All.-""
  - ""Higher-Order Intensional Type Analysis.- Lambda Calculus.- Branching Types.- Exceptions, Continuations and Macro-expressiveness.-""
  - ""A Theory of Second-Order Trees.-""
  - ""Program Analysis: Applications.- Tool Support for Improving Test Coverage.- Data Space Oriented Tiling.- Propagation of Roundoff Errors in Finite Precision Computations: A Semantics Approach.-""
  - ""Asserting the Precision of Floating-Point Computations: A Simple Abstract Interpreter.-""
  - ""Program Analysis: Principles.- A Modular, Extensible Proof Method for Small-Step Flow Analyses.- A Prototype Dependency Calculus.-""
  - ""Automatic Complexity Analysis.-""
  - ""Distributed Programs: Verification and Analysis.- Thread-Modular Verification for Shared-Memory Programs.- Timing UDP: Mechanized Semantics for Sockets, Threads, and Failures.-""
  - ""Finite-Control Mobile Ambients.- Dependency Analysis of Mobile Systems.""",,"- The abstract lists various topics related to programming languages and systems, indicating a broad scope of theoretical contributions.
 - The mention of ""Type Checking Systems Code,"" ""Typing and Modularity,"" and ""Existential Types for Imperative Languages"" suggests novel insights into type systems and modularity, which are key theoretical contributions.
 - ""Higher-Order Intensional Type Analysis"" and ""A Theory of Second-Order Trees"" imply advancements in type analysis and theoretical foundations.
 - ""Soft Concurrent Constraint Programming"" and ""Thread-Modular Verification for Shared-Memory Programs"" indicate contributions to concurrent programming and verification.
 - ""Automatic Complexity Analysis"" and ""Dependency Analysis of Mobile Systems"" suggest theoretical advancements in program analysis and dependency management.
 - The abstract does not provide specific details on the novelty or theoretical contributions beyond these topics, but the variety of subjects covered suggests a comprehensive theoretical contribution to programming language design and analysis."
Types and operations (version 3),S. Ambroszkiewicz,-,-,-,0,2015,"1. Primitive Name: Type
  Definition: Reconstructed as concrete finite structures parameterized by natural numbers
  Orthogonality Score: Not specified
 2. Primitive Name: Operation (Function)
  Definition: Reconstructed as concrete finite structures parameterized by natural numbers
  Orthogonality Score: Not specified
 3. Primitive Name: Relation
  Definition: Reconstructed as part of the basic concepts revision
  Orthogonality Score: Not specified",Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),No specific integration approach described,"- Definition of ""concept"" used: Revision of basic concepts of type, function, and relation.
 - Mechanisms for representing generic abstractions: Simple generic method for constructing operations and types as concrete finite structures parameterized by natural numbers.
 - Minimal type requirements identified: Not mentioned.
 - Static checking or optimization strategies: Not mentioned.","- Key novel insights: Revision of basic concepts of type, function, and relation; introduction of a simple generic method for constructing operations and types as finite structures.
 - Theoretical advancements: The Universe as a grounding for formal theories; challenge to the paradigm of symbolic computation on higher order functionals.
 - Potential implications for programming language design: Innovations in non-von Neumann programming languages and functional hardware description languages.","- ""A revision of the basic concepts of type, function (called here operation), and relation is proposed.""
  - ""A simple generic method is presented for constructing operations and types as concrete finite structures parameterized by natural numbers.""
  - ""The paradigm that computations on higher order functionals can be done only symbolically (by term rewriting) is challenged.""",,"- The abstract mentions a ""revision of the basic concepts of type, function (called here operation), and relation,"" which suggests that these are the conceptual primitives being defined or redefined in the study.
 - The mention of a ""simple generic method"" for constructing operations and types indicates that these primitives are being redefined in terms of concrete finite structures parameterized by natural numbers.
 - The challenge to the paradigm of symbolic computation on higher order functionals implies a focus on these primitives in the context of higher order recursion and functional hardware description language.
 - The abstract does not provide explicit definitions or orthogonality scores for these primitives, nor does it specify multiple sets of primitives.","- ""It is argued that the Universe is not yet another formal theory but may be considered as a grounding for some formal theories.""
  - ""The method gives rise to build inductively so called Universe intended to contain all what can be effectively constructed at least in the sense assumed in the paper.""
  - ""A revision of the basic concepts of type, function (called here operation), and relation is proposed.""
  - ""The paradigm that computations on higher order functionals can be done only symbolically (by term rewriting) is challenged.""
  - ""A simple generic method is presented for constructing operations and types as concrete finite structures parameterized by natural numbers.""",,"- The abstract mentions a ""revision of the basic concepts of type, function (called here operation), and relation,"" which suggests a focus on type theory.
 - The use of ""concrete finite structures parameterized by natural numbers"" indicates a mathematical framework that involves type theory, as it deals with constructing types and operations.
 - The mention of building a ""Universe"" that is not another formal theory but a grounding for some formal theories implies a foundational approach, possibly related to type theory or category theory.
 - The challenge to the paradigm of symbolic computation by term rewriting suggests a critique of traditional proof techniques, but does not specify new proof techniques or limitations.
 - The abstract does not explicitly mention specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""Keywords: higher order objects, functionals, higher order recursion, functional hardware description language, non-von Neumann programming language""
  - ""The paradigm that computations on higher order functionals can be done only symbolically (by term rewriting) is challenged.""
  - ""A simple generic method is presented for constructing operations and types as concrete finite structures parameterized by natural numbers.""
  - ""A revision of the basic concepts of type, function (called here operation), and relation is proposed.""",,"- The abstract discusses a revision of basic concepts related to types, functions, and relations, which could imply a theoretical integration strategy.
 - The mention of a ""simple generic method"" for constructing operations and types suggests a potential integration mechanism, but it is not explicitly described as an integration approach.
 - The challenge to the paradigm that computations on higher order functionals can only be done symbolically suggests a novel approach, but it does not explicitly address integration between different programming paradigms.
 - The keywords mention ""non-von Neumann programming language,"" which could imply a focus on alternative programming paradigms, but again, there is no explicit discussion of integration mechanisms or strategies.
 - Overall, while the abstract touches on concepts that could relate to programming paradigm integration, it does not explicitly describe a specific integration approach or mechanisms.","- ""A revision of the basic concepts of type, function (called here operation), and relation is proposed.""
  - ""A simple generic method is presented for constructing operations and types as concrete finite structures parameterized by natural numbers.""
  - ""The paradigm that computations on higher order functionals can be done only symbolically (by term rewriting) is challenged.""
  - ""The method gives rise to build inductively so called Universe intended to contain all what can be effectively constructed at least in the sense assumed in the paper.""",,"- The abstract mentions a ""revision of the basic concepts of type, function (called here operation), and relation,"" which suggests a focus on conceptual abstraction.
 - The phrase ""A simple generic method is presented for constructing operations and types as concrete finite structures parameterized by natural numbers"" indicates a generic programming approach, as it involves constructing types and operations in a generic manner.
 - The mention of building a ""Universe intended to contain all what can be effectively constructed"" implies a mechanism for representing generic abstractions, as it suggests a comprehensive framework for constructing various types and operations.
 - The abstract does not explicitly mention minimal type requirements or static checking/optimization strategies, but it does challenge the paradigm of symbolic computation, which might imply alternative strategies for handling higher-order functionals.
 - The abstract does not provide detailed definitions of concepts or specific mechanisms for static checking or optimization, but it does suggest a focus on generic programming and conceptual abstraction.","- ""The paradigm that computations on higher order functionals can be done only symbolically (by term rewriting) is challenged.""
  - ""It is argued that the Universe is not yet another formal theory but may be considered as a grounding for some formal theories.""
  - ""The method gives rise to build inductively so called Universe intended to contain all what can be effectively constructed at least in the sense assumed in the paper.""
  - ""A simple generic method is presented for constructing operations and types as concrete finite structures parameterized by natural numbers.""
  - ""A revision of the basic concepts of type, function (called here operation), and relation is proposed.""",,"- The abstract proposes a ""revision of the basic concepts of type, function (called here operation), and relation,"" which suggests a novel theoretical contribution by re-examining fundamental concepts in a new light.
 - The introduction of a ""simple generic method"" for constructing operations and types as finite structures parameterized by natural numbers is a key novel insight, as it provides a new approach to constructing these elements.
 - The concept of the ""Universe"" as a grounding for formal theories rather than just another formal theory itself is a theoretical advancement, as it offers a foundational framework for other theories.
 - The challenge to the paradigm that computations on higher order functionals can only be done symbolically is a significant theoretical contribution, as it opens up new possibilities for computation methods.
 - The potential implications for programming language design are significant, as the new approach to constructing operations and types, and the challenge to existing paradigms, could lead to innovations in non-von Neumann programming languages and functional hardware description languages."
The Logical Structure of Concurrent Constraint Programming Languages (Abstract),P. Panangaden,10.1007/978-3-540-48654-1_11,https://doi.org/10.1007/978-3-540-48654-1_11,International Conference on Concurrency Theory,0,1994,Not specified (the abstract does not provide explicit definitions or names for conceptual primitives),"- Type of mathematical framework: Category theory
 - Specific mathematical properties guaranteed: Categorical formulation of first-order logic
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Use of hyperdoctrines as a categorical structure for denotational semantics.
 - Interaction models between paradigms: Extension of ideas to operational semantics and discussion of linear extensions.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: CCP languages are logics in a certain sense; combinators can be viewed as logical connectives.
 - Theoretical advancements: Denotational semantics forms a hyperdoctrine; extension to operational semantics and indeterminate languages.
 - Potential implications: Linear extension of CCP; understanding other formalisms for concurrent computation in the same way.","- ""The Concurrent Constraint Programming paradigm has been the subject of growing interest as the focus of a new paradigm for concurrent computation.""
  - ""We also describe a linear extension of concurrent constraint programming and discuss hyperdoctrines for such languages.""
  - ""What this connection shows is the combinators of determinate concurrent constraint programming can be viewed as logical connectives.""
  - ""the denotational semantics of determinate concurrent constraint programming languages forms a categorical structure called a hyperdoctrine which is used as the basis of the categorical formulation of first order logic.""
  - ""In fact these languages are logics in a certain sense that we make precise.""",,"- The abstract discusses the conceptual framework of Concurrent Constraint Programming (CCP) languages, particularly their relation to logic and the use of hyperdoctrines.
 - It mentions that CCP languages can be viewed as logics, indicating a conceptual primitive related to logical structure.
 - The use of hyperdoctrines as a categorical structure for denotational semantics suggests a primitive related to categorical formulation.
 - The mention of combinators being viewed as logical connectives implies a primitive related to logical operations.
 - The abstract does not provide explicit definitions or names for these primitives, nor does it discuss their orthogonality or level of abstraction.","- ""We also describe a linear extension of concurrent constraint programming and discuss hyperdoctrines for such languages.""
  - ""In the present work we extend these ideas to the operational semantics of these languages and thus make available similar analogies for the indeterminate concurrent constraint programming languages.""
  - ""the denotational semantics of determinate concurrent constraint programming languages forms a categorical structure called a hyperdoctrine which is used as the basis of the categorical formulation of first order logic.""",,"- The abstract mentions that the denotational semantics of determinate concurrent constraint programming languages forms a ""categorical structure called a hyperdoctrine."" This indicates that the mathematical framework used is based on category theory, as hyperdoctrines are a concept within this field.
 - The use of hyperdoctrines suggests that the framework is related to the categorical formulation of first-order logic, which is a specific mathematical property guaranteed by this framework.
 - The extension of these ideas to operational semantics and the discussion of hyperdoctrines for indeterminate languages imply that the framework is used to formalize and guarantee properties of these conceptual primitives.
 - The mention of a ""linear extension"" suggests additional mathematical properties or techniques, but the abstract does not specify these in detail.
 - The abstract does not explicitly mention proof techniques or limitations of the framework, so these aspects are not specified.","- ""The Concurrent Constraint Programming paradigm has been the subject of growing interest as the focus of a new paradigm for concurrent computation.""
  - ""Like logic programming it claims close relations to logic.""
  - ""In fact these languages are logics in a certain sense that we make precise.""
  - ""In recent work it was shown that the denotational semantics of determinate concurrent constraint programming languages forms a categorical structure called a hyperdoctrine which is used as the basis of the categorical formulation of first order logic.""
  - ""What this connection shows is the combinators of determinate concurrent constraint programming can be viewed as logical connectives.""
  - ""In the present work we extend these ideas to the operational semantics of these languages and thus make available similar analogies for the indeterminate concurrent constraint programming languages.""
  - ""We also describe a linear extension of concurrent constraint programming and discuss hyperdoctrines for such languages.""
  - ""The discussion concludes with an examination of the prospects for understanding other formalisms for concurrent computation in the same way.""",,"- The abstract discusses the integration of the Concurrent Constraint Programming (CCP) paradigm with logic programming, highlighting their close relations to logic.
 - It mentions that CCP languages can be viewed as logics, indicating a theoretical integration strategy where CCP is aligned with logical structures.
 - The use of hyperdoctrines as a categorical structure for denotational semantics suggests a specific integration mechanism, as it provides a framework for understanding CCP in terms of logical connectives.
 - The extension of these ideas to operational semantics and the discussion of linear extensions imply interaction models between paradigms, as they explore how CCP can be integrated with other formalisms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques.
 - Overall, the abstract describes a theoretical integration strategy that aligns CCP with logic programming through the use of hyperdoctrines and logical connectives.","- ""The Concurrent Constraint Programming paradigm has been the subject of growing interest as the focus of a new paradigm for concurrent computation.""
  - ""In fact these languages are logics in a certain sense that we make precise.""
  - ""the denotational semantics of determinate concurrent constraint programming languages forms a categorical structure called a hyperdoctrine which is used as the basis of the categorical formulation of first order logic.""
  - ""the combinators of determinate concurrent constraint programming can be viewed as logical connectives.""
  - ""We also describe a linear extension of concurrent constraint programming and discuss hyperdoctrines for such languages.""
  - ""The discussion concludes with an examination of the prospects for understanding other formalisms for concurrent computation in the same way.""",,"- The abstract discusses the logical structure of concurrent constraint programming languages, focusing on their relation to logic and the use of hyperdoctrines.
 - It mentions that these languages can be viewed as logics and that their combinators can be seen as logical connectives, which suggests a focus on logical abstraction rather than generic programming.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanisms specifically related to genericity.
 - The abstract does not provide any information on minimal type requirements, static checking, or optimization strategies related to generic programming.
 - The focus is on the logical and categorical structure of concurrent constraint programming languages rather than on generic programming.","- ""The Concurrent Constraint Programming paradigm has been the subject of growing interest as the focus of a new paradigm for concurrent computation.""
  - ""In fact these languages are logics in a certain sense that we make precise.""
  - ""In recent work it was shown that the denotational semantics of determinate concurrent constraint programming languages forms a categorical structure called a hyperdoctrine which is used as the basis of the categorical formulation of first order logic.""
  - ""What this connection shows is the combinators of determinate concurrent constraint programming can be viewed as logical connectives.""
  - ""In the present work we extend these ideas to the operational semantics of these languages and thus make available similar analogies for the indeterminate concurrent constraint programming languages.""
  - ""We also describe a linear extension of concurrent constraint programming and discuss hyperdoctrines for such languages.""
  - ""The discussion concludes with an examination of the prospects for understanding other formalisms for concurrent computation in the same way.""",,"- The abstract discusses the growing interest in Concurrent Constraint Programming (CCP) as a new paradigm for concurrent computation, indicating its novelty and relevance.
 - It highlights that CCP languages are logics in a certain sense, which is a novel insight as it establishes a precise connection between CCP and logic.
 - The mention of denotational semantics forming a hyperdoctrine, which is a categorical structure used in first-order logic, is a theoretical advancement. It shows that CCP can be understood through logical structures.
 - The extension of these ideas to operational semantics and indeterminate languages is a significant theoretical contribution, as it broadens the applicability of these logical analogies.
 - The description of a linear extension of CCP and the discussion of hyperdoctrines for such languages indicate further theoretical innovations, potentially impacting programming language design.
 - The examination of prospects for understanding other formalisms in the same way suggests potential implications for broader areas of concurrent computation."
An Axiomatic Semantics for Functional Reactive Programming,C. King,-,-,-,2,2008,Not specified (the abstract does not provide explicit names or definitions of the conceptual primitives),"- Type of mathematical framework: First-order linear temporal logic
 - Specific mathematical properties guaranteed: Not mentioned
 - Proof techniques used: Coq proof assistant
 - Limitations or constraints of the framework: Not mentioned","- Specific integration mechanisms proposed: Extension of functional languages with primitives that operate on state.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Any novel translation or embedding techniques: Use of first-order linear temporal logic for axiomatic semantics.",Generic programming not extensively addressed,"- Key novel insights: Identification of a minimal subset of primitives for FRP systems.
 - Theoretical advancements: Provision of axiomatic semantics using first-order linear temporal logic; formal proof of important properties using Coq.
 - Potential implications: Enhanced formal verification of FRP programs, contributing to more reliable programming language design.","- ""we identify several important properties of these primitives and prove that they are satisfied using the Coq proof assistant.""
  - ""This thesis aims to identify a minimal subset of primitives which captures the same set of behavior as these systems,""
  - ""to provide an axiomatic semantics for them using first-order linear temporal logic,""",,"- The abstract mentions the aim to identify a ""minimal subset of primitives"" but does not specify what these primitives are. It only indicates that the goal is to capture the same behavior as existing FRP systems.
 - The abstract discusses providing an ""axiomatic semantics"" for these primitives using first-order linear temporal logic, but again, it does not list or define any specific primitives.
 - The mention of ""important properties"" and their proof using the Coq proof assistant suggests that the study focuses on theoretical verification rather than explicitly defining the primitives.
 - Since the abstract does not provide explicit names or definitions of the conceptual primitives, we cannot extract them.","- ""to provide an axiomatic semantics for them using first-order linear temporal logic,""
  - ""with the aim of utilizing these semantics in formal verification of FRP programs.""
  - ""prove that they are satisfied using the Coq proof assistant.""",,"- The abstract mentions the use of ""first-order linear temporal logic"" as the mathematical framework for providing axiomatic semantics. This indicates the type of mathematical framework used.
 - The aim of utilizing these semantics in ""formal verification of FRP programs"" suggests that the framework is used for formal verification, which is a key aspect of guaranteeing properties.
 - The use of the ""Coq proof assistant"" indicates the proof technique used to prove properties of the primitives.
 - There is no mention of specific mathematical properties guaranteed or limitations/constraints of the framework in the abstract.","- ""Furthermore, we identify several important properties of these primitives and prove that they are satisfied using the Coq proof assistant.""
  - ""This thesis aims to identify a minimal subset of primitives which captures the same set of behavior as these systems, and to provide an axiomatic semantics for them using first-order linear temporal logic, with the aim of utilizing these semantics in formal verification of FRP programs.""
  - ""Functional reactive programming (FRP) is a paradigm extending functional languages with primitives which operate on state.""",,"- The abstract discusses the integration of functional programming with reactive programming by extending functional languages with primitives that operate on state. This indicates a paradigm integration approach where functional programming is enhanced with reactive elements.
 - The focus on identifying a minimal subset of primitives suggests a strategy to simplify and standardize the integration, which is a theoretical integration strategy.
 - The use of first-order linear temporal logic for axiomatic semantics provides a formal framework for understanding how these paradigms interact, which can be considered a novel translation or embedding technique.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, or constraints/challenges in paradigm integration beyond the general extension of functional languages with reactive primitives.
 - The abstract does not provide a detailed discussion of paradigm interactions or comparative analysis sections that would typically be found in a full paper or thesis.","- ""we identify several important properties of these primitives and prove that they are satisfied using the Coq proof assistant.""
  - ""to provide an axiomatic semantics for them using first-order linear temporal logic,""
  - ""This thesis aims to identify a minimal subset of primitives which captures the same set of behavior as these systems,""",,"- The abstract discusses identifying a ""minimal subset of primitives"" which suggests a focus on abstraction by reducing complexity to essential elements.
 - The use of ""axiomatic semantics"" and ""first-order linear temporal logic"" indicates a formal approach to defining and analyzing these primitives, which could relate to abstraction mechanisms.
 - The mention of ""important properties"" and their proof using the Coq proof assistant implies a focus on formal verification, which might involve static checking or optimization strategies.
 - However, the abstract does not explicitly mention generic programming, type systems, or specific mechanisms for representing generic abstractions.
 - The focus is more on formal semantics and verification rather than generic programming or abstraction mechanisms in the context of genericity.","- ""This thesis aims to identify a minimal subset of primitives which captures the same set of behavior as these systems,""
  - ""with the aim of utilizing these semantics in formal verification of FRP programs.""
  - ""we identify several important properties of these primitives and prove that they are satisfied using the Coq proof assistant.""
  - ""to provide an axiomatic semantics for them using first-order linear temporal logic,""",,"- The abstract mentions the identification of a ""minimal subset of primitives"" which is a novel insight as it aims to simplify the complexity of existing FRP systems by reducing the number of primitives needed to achieve the same functionality.
 - The provision of ""an axiomatic semantics for them using first-order linear temporal logic"" is a theoretical advancement as it introduces a formal framework for understanding and analyzing FRP systems, which is a step beyond existing approaches.
 - The use of ""first-order linear temporal logic"" for axiomatic semantics is a theoretical innovation as it applies a rigorous mathematical framework to FRP, enhancing the theoretical foundation of the field.
 - The aim to ""utilize these semantics in formal verification of FRP programs"" suggests a potential implication for programming language design, as it could lead to more reliable and verifiable FRP programs.
 - The identification and proof of ""important properties of these primitives"" using the Coq proof assistant is a theoretical contribution as it provides a formal proof of these properties, which is a significant advancement in the theoretical understanding of FRP."
Programming with Behaviors in an ML Framework - The Syntax and Semantics of LCS,"B. Berthomieu, Thierry Le Sergent",10.1007/3-540-57880-3_6,https://doi.org/10.1007/3-540-57880-3_6,European Symposium on Programming,26,1994,"1. Primitive Name: Action Prefixing
  Definition: A way to build behaviors by prefixing actions to other behaviors.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Compositions (Parallel, Choice, Catch)
  Definition: Basic forms of compositions for building behaviors.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Restrictions
  Definition: A way to delimit the scope of ports within behaviors.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Relabellings
  Definition: A way to rename ports within behaviors.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Rendez-vous
  Definition: A single communication and synchronization primitive over named ports.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Events (Signal and Catch)
  Definition: Implement an exception mechanism at process level.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Ports (Label and Extension)
  Definition: Components of ports for communication.
  Orthogonality Score: Not discussed
 

 8. Primitive Name: Operational Semantics
  Definition: Describes the behavior of LCS programs in terms of a transition system.
  Orthogonality Score: Not discussed
 

 9. Primitive Name: Expansion Relation
  Definition: Relates states constituted of a thread and a store.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Process algebra (CCS formalism), Type theory (Tagged Types)
 - Specific mathematical properties guaranteed: Observation congruence, Type safety
 - Proof techniques used: Transition system, Observation relation, Unification of tagged types
 - Limitations or constraints of the framework: Observation congruence does not capture nondeterminism due to side-effects and shared segments","- Specific integration mechanisms proposed: LCS extends Standard ML with concurrency and communication primitives based on CCS.
 - Interaction models between paradigms: LCS uses a sub-language of behavior expressions for parallel programming.
 - Constraints or challenges in paradigm integration: Ensuring type-safe communications between processes.
 - Novel translation or embedding techniques: Translation of LCS expressions into a core language; layered evaluation method.","The paper addresses genericity and abstraction through the use of behavior expressions based on CCS, ensuring type-safe communications with a specialized type system. It uses behavior type variables and enforces minimal type requirements by restricting port extensions to equality types. Static checking is achieved by ensuring consistent types for ports with intersecting scopes. Generic programming is addressed through these mechanisms, although not extensively focused on as a standalone topic.","- Integration of behavioral paradigms into a functional programming framework (LCS extending Standard ML with concurrency and communication primitives based on CCS).
 - Addressing theoretical challenges in CCS, such as expressiveness and handling of assignable values and side effects.
 - Novel typing system for behavior expressions to ensure type-safe communications.
 - Introduction of ""Tagged Types"" for behavior types, providing a formal framework applicable to other programming language features.
 - Behavioral approach in LCS is intuitive and powerful for parallel programming, with implications for future language design.","- ""LCS is an experimental high level asynchronous parallel programming language primarily aimed at exploring design, implementation and use of programming languages based upon the behavioral paradigms introduced by CSP and CCS.""
  - ""The language extends Standard ML with primitives for concurrency and communication based upon a higher order extension of the CCS formalism.""
  - ""Behaviors must not be confused with processes. Evaluation of a behavior expression does not produce a process, but rather a closure similar to a function value.""
  - ""Behaviors must be understood as interaction capabilities. The behavior constructs of LCS strictly include those of CCS.""
  - ""Expression stop denotes the behavior that has no communication capability; behaviors are built from stop, possibly recursively, by action prefixing, compositions, restrictions and relabellings.""
  - ""There are three basic forms of compositions: parallel (/\), choice (\/) and catch; the first two are inherited from CCS.""
  - ""The single communication and synchronization primitive is rendez-vous over named ports.""
  - ""Events, and the related event raising (signal) and event trappmg (catch) expressions, implement an exception mechanism at process level.""
  - ""Ports in LCS have two components: a label in the class of identifiers, and an extension.""
  - ""The language of expressions extends that of Standard ML with constructs for building behaviors.""
  - ""The typing rules for behavior expressions must enforce type-safe communications between processes.""
  - ""The operational semantics of LCS is obtained from the semantics of a richer ""core"" language.""
  - ""The expansion relation, written ~, relates states constituted of a thread (also called aprocess, indifferently) and a store.""
  - ""The communication relation, written =lx~>, also relates states.""","- ""(Page 7, Table 1) | expression  | is typed as | where  |
 \n|----------------|----------------------|-----------------------------------------------------------------------|
 \n| stop  | Stop  | :_a  |""
  - ""<table_quotation page_num=10 table_on_page=1>```
 | b,S g → b’,s’ | ⟨eE,g⟩,S ⇒ ⟨e,g⟩ \\ E,S | (e4) |
 |----------------------------------------------------|------------------------------------------|------|
 | ⟨b,g⟩,S ⇒ ⟨b’,g⟩,S+(g,s’) | ⟨e [R],g⟩,S ⇒ ⟨e,g⟩ // R,S  | (e5) |
 | e₁,S g → e₁’,s’ | ⟨e₁ | e₂,g⟩,S ⇒ ⟨e₁,g⟩ || ⟨e₂,g⟩,S  | (e6) |
 | ⟨p#v!e₁.e₂,g⟩,S ⇒ ⟨p#v!e₁.e₂,g⟩,S+(g,s’)  | ⟨e₁ + e₂,g⟩,S ⇒ ⟨e₁,g⟩ ++ ⟨e₂,g⟩,S  | (e7) |
 | g’ ∉ dom(S) | ⟨e₁ < e₂,g⟩,S ⇒ ⟨e₁,g⟩ << ⟨e₂,g⟩,S  | (e8) |
 | ⟨<e>,g⟩,S ⇒ ⟨e,g’⟩,S+(g’,S g) | b,S ⇒ b’,S’ | |
 | | C[b],S ⇒ C[b’],S’ | (e9) |
 ```</table_quotation>""","- The paper introduces LCS as a programming language that extends Standard ML with primitives for concurrency and communication based on the CCS formalism. This indicates that the conceptual primitives are related to concurrency and communication.
 - The language is described as having behavior constructs that include action prefixing, compositions (parallel, choice, catch), restrictions, and relabellings. These are identified as conceptual primitives for building behaviors.
 - The single communication and synchronization primitive is rendez-vous over named ports, which is another conceptual primitive.
 - Events and their related expressions (signal and catch) are also identified as primitives for implementing an exception mechanism.
 - Ports in LCS are defined with two components: a label and an extension, which are part of the conceptual primitives for communication.
 - The operational semantics and expansion relation are described in terms of threads and stores, indicating that these are also part of the conceptual framework.
 - The tables at the end of the paper provide further details on the typing rules and operational semantics, which are part of the conceptual primitives.","- ""The language extends Standard ML with primitives for concurrency and communication based upon a higher order extension of the CCS formalism.""
  - ""The operational semantics of LCS programs is detailed in Section 4 in terms of a transition system and an observation relation.""
  - ""The operational semantics of LCS is obtained from the semantics of a richer ""core"" language.""
  - ""The communication relation is defined in Table 4 .4 in which S, S' range over stores, b, b' range over threads and w, w' range over suspensions.""
  - ""Having defined an observation relation in the style of what has been done for CCS, we would like to take as semantics of LCS programs the observation congruence discussed in [13], or a congruence included in it such as the strong equivalence.""
  - ""So, not surprisingly, side-effects and shared segments together bring a kind of nondeterminism which is not properly captured by the observation congruence concept.""
  - ""observation congruence is a suitable semantics for the class of interference-free LCS programs.""
  - ""The typing rules for behavior expressions are summarized in Table 3 .1 ; other expressions of the language are typed as in SML.""
  - ""Behavior types are conveniently formalized as a particular subset of the ""Tagged Types"" introduced in [3] where their theory, including canonical forms and unification algorithms is developed in depth.""
  - ""Unification of Tagged Types is reducible to standard unification for first order terms.""",,"- The paper discusses the use of a higher-order extension of the CCS (Calculus of Communicating Systems) formalism, which is a process algebra used to describe concurrent systems. This indicates that the mathematical framework is based on process algebra.
 - The operational semantics of LCS is described using a transition system and an observation relation, which are common tools in process algebra for formalizing the behavior of concurrent systems.
 - The paper mentions the use of observation congruence, which is a concept from process algebra used to compare the behavior of processes. This suggests that the framework includes techniques from process algebra for proving behavioral equivalences.
 - The paper discusses the limitations of observation congruence in capturing nondeterminism due to side-effects and shared segments, indicating a constraint of the framework.
 - The typing rules for behavior expressions are formalized using ""Tagged Types,"" which are related to type theory. This suggests that type theory is part of the mathematical framework used for ensuring type safety.
 - The unification of tagged types is reducible to standard unification for first-order terms, indicating a connection to type theory and first-order logic.","- ""LCS is an experimental high level asynchronous parallel programming language primarily aimed at exploring design, implementation and use of programming languages based upon the behavioral paradigms introduced by CSP and CCS.""
  - ""The language extends Standard ML with primitives for concurrency and communication based upon a higher order extension of the CCS formalism.""
  - ""Syntactically, LCS is designed as an extension of Standard ML [14]. Processes are described in an ML framework, but parallel programming capabilities are provided through a specific sub-language of behavior expressions rather than as a set of functions.""
  - ""The language of behavior expressions is based on Robin Milner's Calculus of Communicating Systems [ 13], which is widely accepted as a convenient formalism for concurrency and communication.""
  - ""LCS proposes solutions to all these problems that, as far as possible, preserve the underlying theory of CCS and follow the SML design principles as well.""
  - ""The typing rules for behavior expressions must enforce type-safe communications between processes.""
  - ""The operational semantics of LCS is obtained from the semantics of a richer ""core"" language.""
  - ""The translation of LCS expressions into core expressions is summarized in Table 4 .1,""
  - ""The typing rules for behavior expressions are summarized in Table 3 .1""
  - ""LCS benefited from the results of the PFL experience, an early attempt to add CCS capabilities to ML [8].""
  - ""CML [17] and the language described in [5] are based on different grounds than LCS; they provide a strictly functional interface for concurrency and communication.""
  - ""LCS uses a layered evaluation method for achieving transparently the same effects.""",,"- The paper discusses the integration of the behavioral paradigm (CSP and CCS) with the functional programming paradigm (Standard ML) through the design of LCS.
 - LCS extends Standard ML with concurrency and communication primitives based on CCS, indicating a direct integration mechanism.
 - The language uses a sub-language of behavior expressions to provide parallel programming capabilities, which is a novel approach compared to using functions.
 - The typing rules for behavior expressions ensure type-safe communications, addressing a constraint in integrating paradigms.
 - The operational semantics and translation into a core language suggest a theoretical integration strategy.
 - The paper compares LCS with other languages like CML and PFL, highlighting different approaches to paradigm integration.
 - The use of a layered evaluation method is a novel technique for achieving transparent effects in paradigm integration.","- ""The language of behavior expressions is based on Robin Milner's Calculus of Communicating Systems [ 13], which is widely accepted as a convenient formalism for concurrency and communication.""
  - ""LCS proposes solutions to all these problems that, as far as possible, preserve the underlying theory of CCS and follow the SML design principles as well.""
  - ""The typing rules for behavior expressions must enforce type-safe communications between processes.""
  - ""A simple rule ensures this: whenever their scopes intersect, ports with the same label must transmit values of the same type and must have extensions of the same type.""
  - ""In addition, port extensions must be restricted to values of types admitting equality in the Standard ML sense since comparing extensions for equality is needed to determine actual communications capabilities at run time.""
  - ""Syntactically, LCS behavior types are built from special type variables called behavior type variables and written a, _b, etc., possibly prefixed by a finite number of fields of the form {label : extension_type # message_type] where extension_type is an equality type.""
  - ""Behavior types thus constitute a strict subset of all types. Semantically, behavior types may be read as total functions assigning types to labels.""
  - ""The typing rules for behavior expressions are summarized in Table 3 .1 ; other expressions of the language are typed as in SML.""",,"- The paper discusses the use of Robin Milner's Calculus of Communicating Systems (CCS) as a foundational formalism for concurrency and communication, which is a conceptual abstraction mechanism. This indicates a focus on using established theoretical frameworks to guide the design of the language.
 

 - LCS extends Standard ML with behavior expressions, which are based on CCS, to provide a higher level of abstraction for programming concurrent systems. This suggests that the language aims to abstract away some of the complexities involved in concurrent programming by using a formal system.
 

 - The paper emphasizes type safety in communications between processes, which is a critical aspect of generic programming. The type system ensures that ports with the same label transmit values of the same type and have extensions of the same type, which is a form of static checking.
 

 - The use of behavior type variables and the restriction of port extensions to values admitting equality in Standard ML are mechanisms for representing generic abstractions. These mechanisms allow for a flexible yet type-safe way to handle communications in concurrent systems.
 

 - The paper describes behavior types as a strict subset of all types, which can be seen as a way to enforce minimal type requirements while allowing for genericity in the types of behaviors that can be expressed.
 

 - The typing rules for behavior expressions, as summarized in Table 3.1, provide a formalized approach to ensuring type safety and consistency, which is an optimization strategy for preventing runtime errors related to type mismatches.","- ""LCS is an high level asynchronous parallel programming language primarily aimed at exploring design, implementation and use of programming languages based upon the behavioral paradigm.""
  - ""The language extends Standard ML with primitives for concurrency and communication based upon a higher order extension of the CCS formalism.""
  - ""LCS proposes solutions to all these problems that, as far as possible, preserve the underlying theory of CCS and follow the SML design principles as well.""
  - ""The typing rules for behavior expressions must enforce type-safe communications between processes.""
  - ""Behavior types are conveniently formalized as a particular subset of the ""Tagged Types"" introduced in [3] where their theory, including canonical forms and unification algorithms is developed in depth.""
  - ""Among the spin-offs of the experiment is an original method for typing behaviors that, in the more general setting of [3] can be used for typing a variety of other features of programming languages.""
  - ""Our experience with users of the system over the last years taught us that newcomers to parallel programming adapt quickly to the set of high level programming primitives provided by its behavioral interface; the behavioral approach helps intuition and, yet, is powerful enough to write real size applications.""
  - ""It is hoped that practising with the concepts implemented will prompt desirable refinements of the language, such as, for instance, introduction of some synchrony or stronger forms of label passing.""",,"- The paper introduces LCS as a novel programming language that extends Standard ML with concurrency and communication primitives based on a higher-order extension of CCS. This is a key theoretical contribution as it integrates behavioral paradigms into a functional programming framework.
 - The development of LCS addresses several theoretical challenges in CCS, such as expressiveness and the handling of assignable values and side effects, while preserving the underlying theory of CCS. This is a significant theoretical advancement.
 - The paper introduces a novel typing system for behavior expressions, which ensures type-safe communications. This is a theoretical contribution as it provides a method for enforcing consistency in communications, which is crucial for parallel programming.
 - The use of ""Tagged Types"" for behavior types is another theoretical innovation, as it provides a formal framework for typing behaviors. This method can be applied to other features of programming languages, indicating its broader theoretical implications.
 - The paper suggests that the behavioral approach in LCS is intuitive and powerful for parallel programming, which has implications for the design of future programming languages.
 - The potential for future refinements, such as introducing synchrony or stronger label passing, indicates areas for further theoretical exploration and contribution."
Integrating destructive assignment and lazy evaluation in the multiparadigm language G-2,J. Placer,10.1145/130973.130978,https://doi.org/10.1145/130973.130978,SIGP,6,1992,"1. Primitive Name: Block
  Definition: A linguistic feature introduced to reconcile destructive assignment and lazy evaluation.
  Orthogonality Score: Not specified",Not specified,"- Specific integration mechanisms proposed: Introduction of a ""block"" to reconcile destructive assignment and lazy evaluation.
 - Interaction models between paradigms: Not explicitly described.
 - Constraints or challenges in paradigm integration: Reconciling time-independent and time-dependent features.
 - Any novel translation or embedding techniques: The use of a ""block"" to support multiple paradigms.",Generic programming not extensively addressed,"- Key novel insights: Integration of seemingly incompatible paradigmatic attributes; reconciliation of time-independent and time-dependent features.
 - Theoretical advancements: Introduction of a new linguistic feature called a ""block"" to reconcile destructive assignment and lazy evaluation.
 - Potential implications: Significant contribution to the design of multiparadigm languages; potential for future programming language design to integrate diverse paradigms more effectively.","- ""Finally we examine how the block supports many of the paradigms included in G-2 in a simple and direct manner.""
  - ""We focus on a new linguistic feature, called a block, that was introduced into G-2 in order to reconcile the facilities of destructive assignment and lazy evaluation.""
  - ""finding an appropriate level of integration for such diverse elements can be a significant contribution to a broadly multiparadigm language design.""
  - ""Among the most formidable of these antagonists are the time-independent and the time-dependent features of the diverse paradigms that are to be integrated into the language design.""
  - ""In order to design a broadly multiparadigm language, i.e., a language that directly supports several diverse programming paradigms, one must integrate a number of seemingly incompatible paradigmatic attributes.""",,"- The abstract discusses the integration of diverse programming paradigms, specifically mentioning the reconciliation of ""time-independent and time-dependent features"" and ""destructive assignment and lazy evaluation."" These are conceptual elements that are integrated into the language design.
 - The abstract introduces a ""new linguistic feature, called a block,"" which is used to reconcile these elements. This suggests that the ""block"" is a conceptual primitive used in the language design.
 - The abstract does not provide explicit definitions for these primitives beyond their role in reconciling different paradigmatic attributes.
 - There is no mention of multiple sets of primitives or any discussion of the level of abstraction and orthogonality of these primitives.","- ""Finally we examine how the block supports many of the paradigms included in G-2 in a simple and direct manner.""
  - ""We focus on a new linguistic feature, called a block, that was introduced into G-2 in order to reconcile the facilities of destructive assignment and lazy evaluation.""
  - ""finding an appropriate level of integration for such diverse elements can be a significant contribution to a broadly multiparadigm language design.""
  - ""Among the most formidable of these antagonists are the time-independent and the time-dependent features of the diverse paradigms that are to be integrated into the language design.""
  - ""In order to design a broadly multiparadigm language, i.e., a language that directly supports several diverse programming paradigms, one must integrate a number of seemingly incompatible paradigmatic attributes.""",,"- The abstract discusses the integration of diverse programming paradigms and the introduction of a new linguistic feature called a ""block"" to reconcile destructive assignment and lazy evaluation.
 - There is no mention of a specific mathematical framework, such as type theory or category theory, being used to formalize or guarantee properties of the conceptual primitives.
 - The abstract does not provide details on theoretical foundations, proof methodology, or formal verification discussions related to a mathematical framework.
 - The focus is on the integration of programming paradigms and the introduction of a new linguistic feature, rather than on mathematical frameworks or formal verification.","- ""finding an appropriate level of integration for such diverse elements can be a significant contribution to a broadly multiparadigm language design.""
  - ""Among the most formidable of these antagonists are the time-independent and the time-dependent features of the diverse paradigms that are to be integrated into the language design.""
  - ""In order to design a broadly multiparadigm language, i.e., a language that directly supports several diverse programming paradigms, one must integrate a number of seemingly incompatible paradigmatic attributes.""
  - ""Finally we examine how the block supports many of the paradigms included in G-2 in a simple and direct manner.""
  - ""We focus on a new linguistic feature, called a block, that was introduced into G-2 in order to reconcile the facilities of destructive assignment and lazy evaluation.""",,"- The abstract discusses the integration of diverse programming paradigms in the language G-2, indicating a focus on reconciling seemingly incompatible attributes.
 - It highlights the challenge of integrating time-independent and time-dependent features, which are fundamental to different paradigms.
 - The introduction of a ""block"" as a linguistic feature is specifically mentioned as a mechanism to reconcile destructive assignment and lazy evaluation, which are paradigmatic attributes.
 - The abstract suggests that this block supports multiple paradigms in a simple and direct manner, implying a novel integration strategy.
 - However, the abstract does not provide detailed interaction models between paradigms or specific constraints or challenges beyond the general mention of reconciling incompatible attributes.","- ""In order to design a broadly multiparadigm language, i.e., a language that directly supports several diverse programming paradigms, one must integrate a number of seemingly incompatible paradigmatic attributes.""
  - ""Finally we examine how the block supports many of the paradigms included in G-2 in a simple and direct manner.""
  - ""We focus on a new linguistic feature, called a block, that was introduced into G-2 in order to reconcile the facilities of destructive assignment and lazy evaluation.""
  - ""finding an appropriate level of integration for such diverse elements can be a significant contribution to a broadly multiparadigm language design.""
  - ""Among the most formidable of these antagonists are the time-independent and the time-dependent features of the diverse paradigms that are to be integrated into the language design.""",,"- The abstract discusses the integration of diverse programming paradigms in the language G-2, which suggests a focus on multiparadigm programming rather than generic programming specifically.
 - The mention of ""time-independent and time-dependent features"" and ""destructive assignment and lazy evaluation"" indicates a focus on integrating different programming paradigms rather than generic programming mechanisms.
 - The abstract does not explicitly mention generic programming, abstraction mechanisms, type systems, or static checking strategies, which are key components of generic programming.
 - The focus on a ""block"" as a linguistic feature to reconcile different paradigms does not directly relate to generic programming or abstraction mechanisms.","- ""In order to design a broadly multiparadigm language, i.e., a language that directly supports several diverse programming paradigms, one must integrate a number of seemingly incompatible paradigmatic attributes.""
  - ""finding an appropriate level of integration for such diverse elements can be a significant contribution to a broadly multiparadigm language design.""
  - ""Among the most formidable of these antagonists are the time-independent and the time-dependent features of the diverse paradigms that are to be integrated into the language design.""
  - ""Finally we examine how the block supports many of the paradigms included in G-2 in a simple and direct manner.""
  - ""We focus on a new linguistic feature, called a block, that was introduced into G-2 in order to reconcile the facilities of destructive assignment and lazy evaluation.""",,"- The abstract discusses the integration of ""seemingly incompatible paradigmatic attributes"" in a multiparadigm language, which suggests a theoretical contribution in reconciling diverse programming paradigms.
 - The mention of ""time-independent and time-dependent features"" indicates a focus on integrating different temporal aspects of programming paradigms, which is a theoretical advancement.
 - The introduction of a ""new linguistic feature, called a block"" to reconcile ""destructive assignment and lazy evaluation"" is a key novel insight, as it addresses a significant challenge in multiparadigm language design.
 - The abstract implies that this integration and the introduction of the ""block"" feature are significant contributions to the design of multiparadigm languages, which has potential implications for future programming language design."
The Common Model for the Communication and Synchronization Primitives,Petr Haná,-,-,-,0,2008,Not specified (the abstract does not explicitly list or define specific conceptual primitives),Not specified (the abstract does not provide details on a mathematical framework),No specific integration approach described (the abstract mentions a common model and uniform description but lacks specific details on integration mechanisms or challenges),Generic programming not extensively addressed,"- Key novel insights: Presentation of a common model for describing interaction primitives.
 - Theoretical advancements: Uniform description of common paradigms in parallel and distributed computing using the shared persistent data space model based on asynchronous PRAM.
 - Potential implications: Potential for improving or standardizing programming language design for parallel and distributed computing.","- ""The purpose of this work is to present a common mo del for description of the commonly used primitives for interaction.""
  - ""The attempt is mad e to uniformly describe the most of common paradigms used in the programming languages for parallel and distributed computing.""",,"- The abstract mentions the purpose of presenting a common model for describing commonly used primitives for interaction, indicating that the study focuses on conceptual primitives related to interaction in parallel and distributed computing.
 - It states that the attempt is made to uniformly describe common paradigms, suggesting that the primitives are related to these paradigms.
 - The shared persistent data space model based on asynchronous PRAM is used to describe interaction primitives, which implies that this model is a tool for defining these primitives.
 - However, the abstract does not explicitly list or define specific conceptual primitives. It only mentions the use of a model to describe them.
 - There is no mention of the level of abstraction or orthogonality of the primitives in the abstract.","- ""The purpose of this work is to present a common mo del for description of the commonly used primitives for interaction.""
  - ""The attempt is mad e to uniformly describe the most of common paradigms used in the programming languages for parallel and distributed computing.""",,"- The abstract mentions the use of a ""shared persistent data space model based on asynchronous PRAM"" as a tool for describing interaction primitives. This suggests a focus on a specific model rather than a broad mathematical framework.
 - There is no mention of a specific type of mathematical framework such as type theory or category theory.
 - The abstract does not provide details on specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the model rather than a comprehensive mathematical framework for formalization and verification.","- ""The attempt is mad e to uniformly describe the most of common paradigms used in the programming languages for parallel and distributed computing.""
  - ""The purpose of this work is to present a common mo del for description of the commonly used primitives for interaction.""",,"- The abstract mentions the presentation of a ""common model"" for describing interaction primitives, which suggests an integration approach by providing a unified framework.
 - The attempt to ""uniformly describe"" common paradigms indicates an effort to integrate different programming paradigms by standardizing their description.
 - The use of the ""shared persistent data space model based on asynchronous PRAM"" as a tool for describing interaction primitives implies a specific integration mechanism, as it provides a common framework for interaction across different paradigms.
 - However, the abstract does not explicitly mention specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques. It focuses on the uniform description and the use of a shared model.","- ""The attempt is mad e to uniformly describe the most of common paradigms used in the programming languages for parallel and distributed computing.""
  - ""The purpose of this work is to present a common mo del for description of the commonly used primitives for interaction.""",,"- The abstract mentions the presentation of a ""common model"" for describing interaction primitives, which suggests a focus on abstraction.
 - The use of a ""shared persistent data space model based on asynchronous PRAM"" indicates a mechanism for representing abstractions, as it provides a framework for describing interaction primitives.
 - The abstract does not explicitly mention ""generic programming"" or ""type system discussions,"" which are key components of genericity and abstraction mechanisms.
 - There is no mention of ""minimal type requirements"" or ""static checking or optimization strategies,"" which are typically part of generic programming methodologies.
 - The focus appears to be on creating a common model for interaction primitives rather than on generic programming or abstraction mechanisms specifically.","- ""The attempt is mad e to uniformly describe the most of common paradigms used in the programming languages for parallel and distributed computing.""
  - ""The purpose of this work is to present a common mo del for description of the commonly used primitives for interaction.""",,"- The abstract mentions the presentation of a ""common model"" for describing interaction primitives, which suggests a novel theoretical contribution by providing a unified framework.
 - The attempt to ""uniformly describe"" common paradigms in parallel and distributed computing indicates a theoretical advancement by standardizing descriptions across different paradigms.
 - The use of the ""shared persistent data space model based on asynchronous PRAM"" as a tool for describing interaction primitives implies a theoretical innovation in how these primitives are conceptualized and integrated.
 - The abstract does not explicitly mention potential implications for programming language design, but the development of a common model and uniform description could imply potential for improving or standardizing programming language design for parallel and distributed computing."
Formal Definition of an Agent-Object Programming Language,"Francesco Pagliarecci, L. Spalazzi, G. Capuzzi",10.1109/CTS.2006.44,https://doi.org/10.1109/CTS.2006.44,International Conference on Collaboration Technologies and Systems,5,2006,Not specified (the abstract does not explicitly list or define specific conceptual primitives),"- Type of mathematical framework: Rewriting logic language Maude
 - Specific mathematical properties guaranteed: Not specified
 - Proof techniques used: Model checking, proving properties
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Integration of agent-oriented and object-oriented programming paradigms.
 - Interaction models between paradigms: Reasoning about object-oriented concepts alongside agent-oriented concepts.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Use of Maude for formal specification.",Generic programming not extensively addressed,"- Key novel insights: Integration of agent-oriented and object-oriented programming paradigms; formal definition of Alan in Maude.
 - Theoretical advancements: Formal specification of Alan in Maude; integration of agent-oriented concepts with object-oriented principles.
 - Potential implications: Development of more robust and analyzable programming languages; use of formal modeling and reasoning techniques like model checking and property proving.","- ""We define the formal specification of Alan in the rewriting logic language Maude.""
  - ""Alan is a programming language that aims to integrate both the agent-oriented and the object-oriented programming.""
  - ""We want to explore how we can reason in terms of encapsulation, inheritance, polymorphism, and so on while we program in terms of the the beliefs, the desires, and the plans of an agent.""
  - ""This paper presents a formal definition of Alan.""",,"- The abstract mentions that Alan integrates both agent-oriented and object-oriented programming paradigms, indicating a focus on combining these two approaches.
 - It highlights the exploration of reasoning in terms of encapsulation, inheritance, and polymorphism, which are traditional object-oriented programming concepts.
 - The abstract also mentions programming in terms of ""the beliefs, the desires, and the plans of an agent,"" which are conceptual primitives from the agent-oriented paradigm.
 - The formal specification is defined using the rewriting logic language Maude, which suggests a formal framework for these primitives but does not explicitly list them in the abstract.
 - The abstract does not provide explicit definitions or a list of conceptual primitives beyond these general concepts.","- ""We define the formal specification of Alan in the rewriting logic language Maude.""",,"- The abstract mentions that the formal specification of the Alan programming language is defined using the ""rewriting logic language Maude."" This indicates that the mathematical framework used is based on rewriting logic, which is a type of mathematical framework.
 - The use of Maude suggests that the framework supports formal modeling and reasoning, which includes model checking and proving properties. This implies that the framework is capable of guaranteeing specific mathematical properties related to these activities.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used beyond the general capabilities of Maude. However, it does imply that the framework allows for analyzing programs and proving properties, which are common applications of rewriting logic.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""We define the formal specification of Alan in the rewriting logic language Maude.""
  - ""Alan is a programming language that aims to integrate both the agent-oriented and the object-oriented programming.""
  - ""We want to explore how we can reason in terms of encapsulation, inheritance, polymorphism, and so on while we program in terms of the the beliefs, the desires, and the plans of an agent.""",,"- The abstract mentions that Alan integrates both agent-oriented and object-oriented programming paradigms, indicating an integration approach.
 - The integration involves reasoning about object-oriented concepts (encapsulation, inheritance, polymorphism) alongside agent-oriented concepts (beliefs, desires, plans), suggesting a theoretical integration strategy.
 - The use of Maude for formal specification implies a novel translation or embedding technique, as it allows for formal modeling and reasoning about Alan programs.
 - The abstract does not explicitly mention specific integration mechanisms, interaction models, or constraints/challenges in paradigm integration, but it does highlight the integration of paradigms and the use of Maude for formal specification.","- ""Alan is a programming language that aims to integrate both the agent-oriented and the object-oriented programming.""
  - ""We want to explore how we can reason in terms of encapsulation, inheritance, polymorphism, and so on while we program in terms of the the beliefs, the desires, and the plans of an agent.""
  - ""We define the formal specification of Alan in the rewriting logic language Maude.""
  - ""This paper presents a formal definition of Alan.""",,"- The abstract discusses the integration of agent-oriented and object-oriented programming paradigms in the Alan language, which suggests a focus on conceptual abstraction by combining different programming paradigms.
 - The mention of ""encapsulation, inheritance, polymorphism"" indicates that these are mechanisms for representing generic abstractions, as they are fundamental concepts in object-oriented programming that support abstraction.
 - The use of Maude for formal specification implies a focus on formal modeling and reasoning, which can include static checking and optimization strategies.
 - However, the abstract does not explicitly mention ""generic programming"" or provide detailed information on minimal type requirements or specific static checking strategies.
 - The focus is more on the formal definition and operational semantics rather than generic programming methodologies or type system discussions.","- ""Alan is a programming language that aims to integrate both the agent-oriented and the object-oriented programming.""
  - ""This paper presents a formal definition of Alan.""
  - ""We define the formal specification of Alan in the rewriting logic language Maude.""
  - ""this paper represents the first step towards a complete formal definition of the operational semantics of Alan.""
  - ""We want to explore how we can reason in terms of encapsulation, inheritance, polymorphism, and so on while we program in terms of the the beliefs, the desires, and the plans of an agent.""",,"- The abstract introduces Alan as a programming language that integrates both agent-oriented and object-oriented programming paradigms, which is a novel approach as it combines two distinct programming methodologies.
 - The formal definition of Alan in Maude represents a theoretical advancement by providing a rigorous framework for understanding and analyzing the language.
 - The integration of agent-oriented concepts (beliefs, desires, plans) with object-oriented principles (encapsulation, inheritance, polymorphism) is a key novel insight, as it offers a new perspective on how to reason about programming.
 - The use of Maude for formal specification opens up possibilities for formal modeling and reasoning, which is a theoretical contribution as it enables advanced analysis and verification techniques such as model checking and property proving.
 - The potential implications for programming language design include the development of more robust and analyzable languages by integrating agent-oriented and object-oriented paradigms."
Ludics Programming I: Interactive Proof Search,"A. Saurin, Inria Futurs",-,-,-,0,2007,Not specified (the abstract does not provide explicit definitions for conceptual primitives beyond general frameworks),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),"- Specific integration mechanisms proposed: Not explicitly mentioned
 - Interaction models between paradigms: Ludics as a new theory to study interaction
 - Constraints or challenges in paradigm integration: Not explicitly mentioned
 - Any novel translation or embedding techniques: Interactive proof search procedure",Generic programming not extensively addressed,"- Key novel insights: Introduction of Ludics as a new theory to study interaction; computation as interactive proof search.
 - Theoretical advancements: New computational model for logic programming based on Ludics; integration of Ludics into logic programming.
 - Potential implications: Potential for innovation in programming language design through the use of interactive proof search.","- ""we introduce the interactive proof search procedure and study some of its properties.""
  - ""The use of proofs to model computation led to the modelling of two main programming paradigms which are functional programming and logic programming.""
  - ""In Ludics, everything is built on interaction or in an i nteractive way.""
  - ""Girard introduced Ludics [12] as a new theory to study interaction.""
  - ""While functional programming is based on proof normalization, logic programming is based on proof search.""",,"- The abstract discusses the relationship between proof theory and computation, highlighting the modeling of functional and logic programming paradigms.
 - It mentions that functional programming is based on proof normalization, and logic programming is based on proof search, which are conceptual primitives in these paradigms.
 - The introduction of Ludics as a new theory to study interaction suggests that interaction is a key conceptual primitive in this context.
 - The abstract does not provide explicit definitions for these primitives beyond their association with proof normalization and proof search.
 - There is no mention of specific conceptual primitives defined by the study beyond the general framework of Ludics and interactive proof search.","- ""Proof theory and Computation are research areas which have very strong relationships: new concepts in logic and proof theory often apply to the theory of programming languages.""
  - ""The use of proofs to model computation led to the modelling of two main programming paradigms which are functional programming and logic programming.""
  - ""While functional programming is based on proof normalization, logic programming is based on proof search.""
  - ""Girard introduced Ludics [12] as a new theory to study interaction.""
  - ""In Ludics, everything is built on interaction or in an i nteractive way.""
  - ""we introduce the interactive proof search procedure and study some of its properties.""",,"- The abstract discusses the relationship between proof theory and computation, indicating a focus on logical foundations.
 - It mentions the use of proofs to model computation, specifically highlighting proof normalization for functional programming and proof search for logic programming.
 - The introduction of Ludics as a new theory to study interaction suggests that Ludics is the mathematical framework being explored.
 - The abstract does not explicitly mention the type of mathematical framework (e.g., type theory, category theory) or specific mathematical properties guaranteed.
 - There is no mention of specific proof techniques used or limitations/constraints of the framework.
 - The abstract does not provide detailed information about the mathematical framework characteristics as requested.","- ""we introduce the interactive proof search procedure and study some of its properties.""
  - ""In Ludics, everything is built on interaction or in an i nteractive way.""
  - ""Girard introduced Ludics [12] as a new theory to study interaction.""
  - ""While functional programming is based on proof normalization, logic programming is based on proof search.""
  - ""The use of proofs to model computation led to the modelling of two main programming paradigms which are functional programming and logic programming.""",,"- The abstract discusses the integration of functional programming and logic programming paradigms through the use of proofs to model computation.
 - It highlights that functional programming is based on proof normalization, while logic programming is based on proof search, indicating a theoretical integration strategy.
 - The introduction of Ludics as a new theory to study interaction suggests an interaction model between paradigms, focusing on interactive proof search.
 - The abstract does not explicitly mention specific integration mechanisms, constraints, or novel translation techniques, but it implies a theoretical integration strategy through the use of Ludics.
 - The focus on interactive proof search suggests a novel approach to integrating these paradigms, but specific mechanisms or challenges are not detailed in the abstract.","- ""The use of proofs to model computation led to the modelling of two main programming paradigms which are functional programming and logic programming.""
  - ""Proof theory and Computation are research areas which have very strong relationships: new concepts in logic and proof theory often apply to the theory of programming languages.""
  - ""In this paper, which is the first of a series investigating a ne w computational model for logic programming based on Ludics, namely computation as interactive proof search, we introduce the interactive proof search procedure and study some of its properties.""
  - ""In Ludics, everything is built on interaction or in an i nteractive way.""
  - ""Girard introduced Ludics [12] as a new theory to study interaction.""",,"- The abstract discusses the relationship between proof theory and computation, focusing on programming paradigms like functional and logic programming.
 - It introduces Ludics as a new theory for studying interaction, which is central to the paper's focus on interactive proof search.
 - The abstract does not mention generic programming or abstraction mechanisms explicitly.
 - There is no discussion of generic programming methodology, type systems, or abstraction mechanisms in the abstract.
 - The focus is on interactive proof search and Ludics, not on genericity or abstraction.","- ""Girard introduced Ludics [12] as a new theory to study interaction.""
  - ""In this paper, which is the first of a series investigating a ne w computational model for logic programming based on Ludics, namely computation as interactive proof search, we introduce the interactive proof search procedure and study some of its properties.""
  - ""The use of proofs to model computation led to the modelling of two main programming paradigms which are functional programming and logic programming.""",,"- The abstract discusses the relationship between proof theory and computation, highlighting the modeling of functional and logic programming paradigms. This suggests a theoretical contribution in understanding these paradigms through proof theory.
 - The introduction of Ludics as a new theory to study interaction indicates a novel insight into how interaction can be theoretically approached in programming.
 - The paper introduces a new computational model for logic programming based on Ludics, specifically focusing on ""computation as interactive proof search."" This represents a theoretical advancement beyond existing approaches by integrating Ludics into logic programming.
 - The study of the interactive proof search procedure and its properties implies a theoretical contribution to understanding how this process can be applied in programming language design.
 - The abstract does not explicitly mention potential implications for programming language design, but the introduction of a new computational model suggests potential for innovation in this area."
The Recursion Schemes of Scientific Models : A Multi-Paradigm Study of the Logistic Map in Haskell,B. T. Widemann,-,-,-,0,2012,Not specified (the abstract does not explicitly define conceptual primitives or their characteristics),Not specified (the abstract does not explicitly mention a mathematical framework or its characteristics),No specific integration approach described,"- Definition of ""concept"" used: Recursion schemes and separation of computation and recursion.
 - Mechanisms for representing generic abstractions: Static typing and higher-order functions.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Implied through static typing.","- Key novel insights: Separation of computation and recursion scheme in the Squiggol approach; correspondence between stereotypic modelling tasks and simple recursion patterns.
 - Theoretical advancements: Use of Haskell to promote abstraction and reuse; enabling interactive and executable models; summarizing scientific modelling logic in a concise language.
 - Potential implications for programming language design: Advancements in functional programming for scientific computing; educational implications for teaching recursion theory.","- ""the general logic of scientific modelling is summarized in a concise and familiar language, blazing the trail for truly functional, real-world, non-number-crunching, scientific computing.""
  - ""Static typing and higher-order functions promote abstraction and reuse, whereas immediately executable models make interactive approaches, adequate for modelling living systems, easy and convenient.""
  - ""The Haskell implementation of the recursion framework and its applications is discussed.""
  - ""each stereotypic modelling task corresponds to a simple and well-understood recursion pattern, and vice versa.""
  - ""The Squiggol approach to recursive algorithms separates computation and recursion scheme.""",,"- The abstract discusses the Squiggol approach, which separates computation and recursion scheme, suggesting that these are conceptual primitives in the study.
 - The mention of ""each stereotypic modelling task corresponds to a simple and well-understood recursion pattern"" implies that recursion patterns are another set of primitives.
 - The use of Haskell and the emphasis on ""static typing and higher-order functions"" suggest that these are also conceptual primitives, as they are highlighted as beneficial for abstraction and reuse.
 - The abstract does not provide explicit definitions for these primitives, nor does it mention their orthogonality or level of abstraction.
 - The abstract focuses more on the application and benefits of these concepts rather than defining them explicitly.","- ""The Haskell implementation of the recursion framework and its applications is discussed.""
  - ""From the perspective of functional programming, the general logic of scientific modelling is summarized in a concise and familiar language, blazing the trail for truly functional, real-world, non-number-crunching, scientific computing.""
  - ""The Squiggol approach to recursive algorithms separates computation and recursion scheme.""
  - ""Static typing and higher-order functions promote abstraction and reuse, whereas immediately executable models make interactive approaches, adequate for modelling living systems, easy and convenient.""",,"- The abstract mentions the use of the ""Squiggol approach to recursive algorithms,"" which suggests a focus on recursion schemes. However, it does not explicitly mention a specific mathematical framework like type theory or category theory.
 - The mention of ""Haskell implementation"" indicates that the programming language Haskell is used, which is known for its strong type system and functional programming paradigm. This implies a connection to type theory, but it is not explicitly stated as a mathematical framework.
 - The abstract highlights ""static typing and higher-order functions,"" which are features of functional programming languages like Haskell. These are related to type theory but are not explicitly described as part of a mathematical framework.
 - There is no mention of specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the abstract.","- ""The Squiggol approach to recursive algorithms separates computation and recursion scheme.""
  - ""Static typing and higher-order functions promote abstraction and reuse, whereas immediately executable models make interactive approaches, adequate for modelling living systems, easy and convenient.""
  - ""the general logic of scientific modelling is summarized in a concise and familiar language, blazing the trail for truly functional, real-world, non-number-crunching, scientific computing.""
  - ""The Haskell implementation of the recursion framework and its applications is discussed.""
  - ""each stereotypic modelling task corresponds to a simple and well-understood recursion pattern, and vice versa.""",,"- The abstract discusses the Squiggol approach, which separates computation and recursion scheme, indicating a focus on recursion patterns rather than explicit integration mechanisms between different programming paradigms.
 - The mention of Haskell implementation suggests a focus on functional programming, but there is no explicit discussion of integrating different programming paradigms.
 - The abstract highlights benefits such as static typing and higher-order functions, which are features of functional programming, but does not describe how these are integrated with other paradigms.
 - There is no mention of specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques in the abstract.","- ""The Squiggol approach to recursive algorithms separates computation and recursion scheme.""
  - ""The Haskell implementation of the recursion framework and its applications is discussed.""
  - ""Static typing and higher-order functions promote abstraction and reuse,""
  - ""the general logic of scientific modelling is summarized in a concise and familiar language,""",,"- The abstract mentions the ""Squiggol approach to recursive algorithms,"" which suggests a focus on recursion schemes. This could imply a form of generic programming, as recursion schemes are often used to abstract away specific implementation details.
 - The mention of ""Static typing and higher-order functions"" indicates mechanisms for abstraction and reuse, which are key components of generic programming. Static typing can help ensure type safety and genericity, while higher-order functions can abstract away specific implementation details.
 - The use of Haskell, a language known for its strong type system and support for functional programming, suggests a focus on type system discussions and abstraction mechanisms. Haskell's type system is designed to support generic programming through type classes and polymorphism.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but the emphasis on static typing implies some level of static checking.","- ""The Squiggol approach to recursive algorithms separates computation and recursion scheme.""
  - ""each stereotypic modelling task corresponds to a simple and well-understood recursion pattern, and vice versa.""
  - ""The Haskell implementation of the recursion framework and its applications is discussed.""
  - ""Static typing and higher-order functions promote abstraction and reuse, whereas immediately executable models make interactive approaches, adequate for modelling living systems, easy and convenient.""
  - ""From the perspective of functional programming, the general logic of scientific modelling is summarized in a concise and familiar language, blazing the trail for truly functional, real-world, non-number-crunching, scientific computing.""",,"- The abstract introduces the Squiggol approach, which separates computation and recursion scheme, a novel insight in how to structure recursive algorithms.
 - It highlights that each modelling task corresponds to a simple recursion pattern, indicating a theoretical advancement in understanding the relationship between modelling tasks and recursion patterns.
 - The use of Haskell to implement the recursion framework is mentioned, but the focus is on the theoretical benefits such as abstraction and reuse, rather than implementation details.
 - The abstract suggests that this approach enables interactive and executable models, which is a theoretical contribution to the field of scientific computing.
 - The study provides a concise summary of scientific modelling logic from a functional programming perspective, which is a theoretical advancement in understanding the general logic of scientific models.
 - The material has implications for teaching recursion theory to natural scientists, indicating a potential impact on educational approaches."
Tackling the awkward squad for reactive programming: the actor-reactor model,"Sam Van den Vonder, Joeri De Koster, Florian Myter, W. Meuter",10.1145/3141858.3141863,https://doi.org/10.1145/3141858.3141863,REBLS@SPLASH,18,2017,Not specified (the paper mentions the Actor-Reactor model but does not provide explicit definitions or lists of conceptual primitives),Not specified,"- Specific integration mechanisms proposed: Actor-Reactor model
 - Interaction models between paradigms: Evaluation of reactive languages and frameworks (Akka, Flapjax, FrTime, ReactJS, REScala, RxJS)
 - Constraints or challenges in paradigm integration: Preventing reactive parts from becoming non-reactive
 - Any novel translation or embedding techniques: Not explicitly mentioned",Generic programming not extensively addressed,"The paper proposes a novel Actor-Reactor model that allows for the integration of non-reactive code into reactive programs without compromising their reactivity. This model serves as a basis for future language designs, addressing code characteristics that do not map onto the reactive programming paradigm.","- ""We propose a novel Actor-Reactor model that can serve as the basis for future language designs that allow a programmer to use the awkward squad without making the reactive parts of the program accidentally non-reactive.""
  - ""Similarly, in this paper, we identify a number of code characteristics that do not map onto the reactive programming paradigm but that are present in many real life reactive programs.""
  - ""The ""Stella"" language interpreter is written by ourselves and is distributed under the ""Creative Commons Attribution NonCommercial (CC-BY-NC)"".""",,"- The paper discusses the identification of code characteristics that do not fit into the reactive programming paradigm, which suggests a focus on conceptual primitives related to reactive programming.
 - The proposal of a ""novel Actor-Reactor model"" implies that this model is a conceptual primitive or set of primitives designed to address issues in reactive programming.
 - The mention of the ""Stella"" language interpreter suggests it might be related to the implementation or testing of these primitives, but it does not explicitly define the primitives themselves.
 - The paper does not provide explicit definitions or lists of conceptual primitives beyond the mention of the Actor-Reactor model.","- ""In his famous paper entitled ""Tackling the Awkward Squad"", Peyton Jones studies how features that traditionally did not fit in the functional programming paradigm can be added to a functional language via careful language design (e.g. using monads), instead of allowing programmers to sprinkle around impure expressions and ad-hoc library calls, thereby turning the entire program into a non-functional program.""
  - ""The ""Stella"" language interpreter is written by ourselves and is distributed under the ""Creative Commons Attribution NonCommercial (CC-BY-NC)"".""
  - ""This artefact provides all code samples that are used in the paper, as well as the code samples that were used to guide the evaluation of other reactive languages and frameworks (Akka, Flapjax, FrTime, ReactJS, REScala, and RxJS).""
  - ""We propose a novel Actor-Reactor model that can serve as the basis for future language designs that allow a programmer to use the awkward squad without making the reactive parts of the program accidentally non-reactive.""",,"- The paper discusses the use of monads as a way to add features to functional programming languages, which suggests a type theory framework.
 - The introduction of the Actor-Reactor model implies a conceptual framework for reactive programming, but it does not explicitly mention a mathematical framework.
 - The paper focuses on code samples and language design rather than formal mathematical frameworks or proof methodologies.
 - There is no explicit mention of a mathematical framework, specific mathematical properties guaranteed, proof techniques used, or limitations of the framework in the provided text.","- ""We propose a novel Actor-Reactor model that can serve as the basis for future language designs that allow a programmer to use the awkward squad without making the reactive parts of the program accidentally non-reactive.""
  - ""The ""Stella"" language interpreter is written by ourselves and is distributed under the ""Creative Commons Attribution NonCommercial (CC-BY-NC)"".""
  - ""This artefact provides all code samples that are used in the paper, as well as the code samples that were used to guide the evaluation of other reactive languages and frameworks (Akka, Flapjax, FrTime, ReactJS, REScala, and RxJS).""
  - ""Similarly, in this paper, we identify a number of code characteristics that do not map onto the reactive programming paradigm but that are present in many real life reactive programs.""
  - ""In his famous paper entitled ""Tackling the Awkward Squad"", Peyton Jones studies how features that traditionally did not fit in the functional programming paradigm can be added to a functional language via careful language design (e.g. using monads), instead of allowing programmers to sprinkle around impure expressions and ad-hoc library calls, thereby turning the entire program into a non-functional program.""",,"- The paper discusses the integration of programming paradigms by referencing Peyton Jones' work on adding features to functional programming using monads. This suggests a theoretical integration strategy.
 - The authors propose a novel Actor-Reactor model, which is a specific integration mechanism aimed at integrating reactive programming with other paradigms.
 - The paper mentions the evaluation of various reactive languages and frameworks, indicating a comparative analysis that could involve interaction models between paradigms.
 - The mention of the ""awkward squad"" and the need to prevent reactive parts from becoming non-reactive suggests constraints or challenges in paradigm integration.
 - The paper does not explicitly mention novel translation or embedding techniques, but the Actor-Reactor model could be considered a novel approach to integration.","- ""Similarly, in this paper, we identify a number of code characteristics that do not map onto the reactive programming paradigm but that are present in many real life reactive programs.""
  - ""In his famous paper entitled ""Tackling the Awkward Squad"", Peyton Jones studies how features that traditionally did not fit in the functional programming paradigm can be added to a functional language via careful language design (e.g. using monads), instead of allowing programmers to sprinkle around impure expressions and ad-hoc library calls, thereby turning the entire program into a non-functional program.""
  - ""We propose a novel Actor-Reactor model that can serve as the basis for future language designs that allow a programmer to use the awkward squad without making the reactive parts of the program accidentally non-reactive.""
  - ""The ""Stella"" language interpreter is written by ourselves and is distributed under the ""Creative Commons Attribution NonCommercial (CC-BY-NC)"".""
  - ""This artefact provides all code samples that are used in the paper, as well as the code samples that were used to guide the evaluation of other reactive languages and frameworks (Akka, Flapjax, FrTime, ReactJS, REScala, and RxJS).""",,"- The paper discusses the concept of adding features to functional programming languages using careful language design, such as monads, to maintain functional purity. This suggests a focus on abstraction mechanisms.
 - The introduction of the Actor-Reactor model implies a mechanism for representing generic abstractions, as it aims to integrate non-reactive code characteristics into reactive programming.
 - The paper does not explicitly define a ""concept"" in terms of generic programming or provide detailed mechanisms for representing generic abstractions.
 - There is no mention of minimal type requirements or static checking/optimization strategies in the provided text.
 - The paper does not extensively address generic programming methodology or type system discussions beyond the mention of monads and the Actor-Reactor model.","- ""We propose a novel Actor-Reactor model that can serve as the basis for future language designs that allow a programmer to use the awkward squad without making the reactive parts of the program accidentally non-reactive.""
  - ""Similarly, in this paper, we identify a number of code characteristics that do not map onto the reactive programming paradigm but that are present in many real life reactive programs.""
  - ""The ""Stella"" language interpreter is written by ourselves and is distributed under the ""Creative Commons Attribution NonCommercial (CC-BY-NC)"".""",,"- The paper identifies code characteristics that do not fit into the reactive programming paradigm, which is a key insight into the challenges faced by reactive programming.
 - The proposal of the Actor-Reactor model is a novel theoretical contribution, as it provides a new framework for integrating non-reactive code into reactive programs without compromising their reactivity.
 - The development of the Stella language interpreter is a practical implementation of the Actor-Reactor model, but the focus on theoretical contributions suggests that the novelty lies in the model itself rather than its implementation.
 - The paper does not provide a detailed conclusion or discussion section that explicitly outlines the novelty and theoretical contributions, but the abstract and introduction suggest that the Actor-Reactor model is the primary theoretical innovation."
Read/write factorizable programs,"Siddharth Bhaskar, J. Simonsen",10.1017/S0956796823000023,https://doi.org/10.1017/S0956796823000023,Journal of functional programming,0,2023,"1. Primitive Name: Successor (Increment)
  Definition: A function that increments a natural number.
  Orthogonality Score: High
 

 2. Primitive Name: Constant 0
  Definition: A constant representing the number 0.
  Orthogonality Score: High
 

 3. Primitive Name: Predecessor (Decrement)
  Definition: A function that decrements a natural number.
  Orthogonality Score: High
 

 4. Primitive Name: Equals-Zero Test
  Definition: A function that tests if a natural number is 0.
  Orthogonality Score: High
 

 5. Primitive Name: Cons (Prepend Character)
  Definition: A function that prepends a character to a string.
  Orthogonality Score: High
 

 6. Primitive Name: Head (First Character)
  Definition: A function that returns the first character of a string.
  Orthogonality Score: High
 

 7. Primitive Name: Tail (Delete First Character)
  Definition: A function that deletes the first character of a string.
  Orthogonality Score: High
 

 8. Primitive Name: Empty String Test
  Definition: A function that tests if a string is empty.
  Orthogonality Score: High
 

 9. Primitive Name: Counting Module Constants
  Definition: Constants for maximum and minimum values in a counting module.
  Orthogonality Score: High
 

 10. Primitive Name: Counting Module Addition
  Definition: An operation that adds values within a counting module.
  Orthogonality Score: High
 

 11. Primitive Name: Counting Module Subtraction
  Definition: An operation that subtracts values within a counting module.
  Orthogonality Score: High
 

 12. Primitive Name: Counting Module Comparison
  Definition: An operation that compares values within a counting module.
  Orthogonality Score: High
 

 13. Primitive Name: Index Constants
  Definition: Constants for maximum and minimum indices.
  Orthogonality Score: High
 

 14. Primitive Name: Index Predecessor (Decrement Index)
  Definition: A function that decrements an index.
  Orthogonality Score: High
 

 15. Primitive Name: Index Equality to Zero
  Definition: A function that tests if an index is 0.
  Orthogonality Score: High
 

 16. Primitive Name: Bit (Return Bit at Index)
  Definition: A function that returns the bit at a given index.
  Orthogonality Score: High",p,"- Specific integration mechanisms proposed: Introduction of read/write-factorizable (RW-factorizable) programs with a type system enforcing data to be either destructed or constructed.
 - Interaction models between paradigms: Translation between RW-factorizable and bit-length programs to establish equivalence in computational power.
 - Constraints or challenges in paradigm integration: Non-nested stipulation to prevent exponential output lengths; use of bit-length computability as a technical device.
 - Novel translation or embedding techniques: Dagger, diamond, length, and bit transformations for converting between RW-factorizable and bit-length programs.","- Definition of ""concept"" used: The paper uses a type system to enforce the separation of data into destructible and constructible types.
 - Mechanisms for representing generic abstractions: The use of a map from RW variables and function symbols to bit-length variables and function symbols.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Ensuring consistency and correctness in the transformation process.","- Introduction of read/write factorizable programs as an extension of cons-free programming.
 - Capture of functional complexity classes FP and FL using RW-factorizable programs.
 - Compilation framework between RW-factorizable and bit-length programs.
 - Syntactic composition of RW-factorizable programs.
 - Potential implications for programming language design: exploring higher orders, non-determinism, and other data types.","- ""The primitive operations associated with certain data types can be separated into constructors and destructors.""
  - ""over the natural numbers, the successor (or increment) function and the constant 0 are constructors, whereas the predecessor (or decrement) function and equals-zero test are destructors.""
  - ""Over strings on some fixed alphabet , the cons function, which prepends a given character onto a given string, is a constructor, as is the constant naming the empty string. On the other hand, the head function, which isolates the first character of a given string, and the tail function, which deletes it, are destructors, as is the relation which tests whether a string is empty.""
  - ""The types in an RW-factorizable program are 2, R, and W . The types in a bit-length program are 2, I, and C.""
  - ""Definition 8. For any n ∈ ω, the counting module C(n) is a data type whose domain is the set n = {0, 1, . . . , n -1}, and whose primitives consist of constants naming the maximum (n -1), minimum (0), and 1, plus operations of addition, subtraction, and comparison and equality tests.""
  - ""Definition 9. For any string x ∈ 2 , the set of indices I( x) is a data type whose domain is |x| + 1 = {0, 1, . . . , |x|}, and whose primitives consist of constants naming the maximum (|x|), minimum (0), predecessor (which decrements the index), equality to zero, and bit (which returns the bit of the input at the given index).""
  - ""Definition 10. There are three atomic type symbols, 2, I, and C, denoting the type of booleans, indices, and counting modules respectively.""
  - ""Definition 11. For a BL-type symbol α, we write α (x, n) to denote the type obtained by specializing each coordinate of α to x or n as appropriate.""
  - ""Definition 12. Fix an infinite set Var α of variables of type α, for each BL-type α, and an infinite set RFsymb β→α of BL-function symbols of type β → α, for each function type β → α.""
  - ""Definition 13. A bit-length term is explicit in case it contains no occurrence of a recursive function symbol. It is tail-recursive in case no recursive function symbol occurs inside any other recursive call, primitive call, or if clause.""
  - ""Definition 15. For any bit-length program p, input string x ∈ 2 , seed n ∈ ω, term T of type α, environment ρ binding the free variables of T, and value v of type α(x, n), we define the relation x, n, ρ p T → v according to the inference rules in Figure 4""
  - ""Definition 17. Fix a string x, natural number n, and program p, and let ρ T → v mean x, n, ρ p T → v.""
  - ""Definition 18. Let f : 2 → 2 , λ : ω → ω, p be a bit-length program whose head recursive function symbol has type C → 2, and q be a bit-length program whose head recursive function symbol has type C.""
  - ""Definition 19. Let 2 † = 2 and R † = I, and extend this to product and function types coordinate-wise.""
  - ""Definition 20. For RW variables x not of type W and function symbols f not containing any type W , let x → x † and f → f † be a map from RW-factorizable variables and function symbols into bit-length variables and function symbols, so that for example, if x is of type τ , then x † is of type τ""
  - ""Definition 21. Define a map T → T † from W -free RW-factorizable terms to bit-length terms by:""
  - ""Definition 24. Let ρ be an RW environment, i.e., a partial, finite map from RW variables to RW data. For a string x ∈ 2 , we say that ρ is an x-environment in case for every variable x of type R, ρ( x) is a suffix of x, and similarly, for every variable""
  - ""Definition 25. For each recursive function symbol f : β × W → W , let f be a recursive function symbol of type β † → 2.""
  - ""Definition 26. We define a transformation T → T from RW terms of type W to bit-length terms of type 2 as follows:""
  - ""Definition 27. Given an RW-factorizable program p of type R → W , we define the bitlength program p by extending p † as follows.""
  - ""Definition 28. For each recursive function symbol f of type β × W → W or β → W , let f be a recursive function symbol of type β † → C.""
  - ""Definition 29. We define a transformation T → T from RW-terms of type W to bit-length terms of type C as follows:""
  - ""Definition 30. Given an RW-factorizable program p of type R → W , we define the bitlength program p by extending p by adding the following lines for each recursive function symbol of output type W""
  - ""Definition 31. For a value v of type W , let v = |v|.""
  - ""Definition 32. For each function symbol f of type β × W → W or β → W , let f b be a recursive function symbol of type β † × C → 2.""
  - ""Definition 33. We define a transformation T → T b from RW terms of type W to bit-length terms of type 2 as follows.""
  - ""Definition 34. Given an RW-factorizable program p of type R → W , we define the bitlength program p b by extending p as follows""
  - ""Definition 35. A RW term term with global input is obtained by extending the formation rules of Figure 1 by the additional axiom in : R.""
  - ""Definition 36. For any RW product term α, let α R be α × R.""
  - ""Definition 37. Suppose T is a term in which only the variable x may occur. (Call this an x-term for brevity.) Let n be the length of the type of x.""
  - ""Definition 38. Suppose the cons-free program with global input p consists of the lines""
  - ""Definition 39. Let 2 ‡ = 2, I ‡ = R, and C ‡ = R k""
  - ""Definition 40. Fix an injection x → x ‡ from bit-length variables to RW variables such that if x has type α, x ‡ has type α""
  - ""Definition 41. Define a map T → T † from bit-length terms to cons-free terms with global input by:""
  - ""Definition 47. Given a term T of type α, we define the term T g of type α g as follows:""
  - ""Definition 48. Given a program p = (f i (x i ) = T i ) 0≤i≤k , let program p (g) be defined by combining the programs p g and q g , then adding new lines ((f i ) g ((x i ) g ) = (T i ) g ) 0≤i≤k on top.""",,"- The paper discusses various conceptual primitives related to data types and operations within the context of cons-free and RW-factorizable programming paradigms.
 - The primitives are defined for different data types such as natural numbers, strings, and bit-length programs.
 - For natural numbers, the primitives include successor (increment), constant 0, predecessor (decrement), and equals-zero test.
 - For strings, the primitives include cons (prepend a character), head (first character), tail (delete first character), and empty string test.
 - The paper also defines primitives for bit-length programs, including counting modules and indices.
 - The counting module primitives include constants for maximum and minimum values, addition, subtraction, and comparison.
 - Index primitives include constants for maximum and minimum indices, predecessor (decrement index), equality to zero, and bit (return bit at index).
 - The paper provides detailed definitions for these primitives in terms of their domains and operations.
 - The level of abstraction is high as these primitives are fundamental operations that can be combined to perform complex computations.
 - The orthogonality of these primitives is evident as they are designed to be independent and composable, allowing for flexible programming constructs.","- ""we introduce programs with data that can either only be destructed or only be constructed, which we enforce by a type system on the program variables.""
  - ""The types in an RW-factorizable program are 2, R, and W""
  - ""The types in a bit-length program are 2, I, and C.""
  - ""We equip programs with a standard, call-by-value, environment-based big-step semantics.""
  - ""The central results of this paper are that
 

 • RW-factorizable string programs of type R → W which are non-nested capture exactly the class FP of polynomial-time functions, and • RW-factorizable strings programs of type R → W which are tail-recursive capture exactly the class FL of logarithmic-space functions.""
  - ""The beating technical heart of this paper consists of four program transformations in Section 6, two in Section 7, and one in Section 8.""
  - ""We develop most transformations according to a common template: first describing a transformation of types, then of variables and values, then of terms and programs, and finally proving correctness.""
  - ""The present paper falls squarely into a long tradition of characterizing complexity classes by function algebras, programming languages, and related models of computation, a topic known as implicit computational complexity (ICC).""
  - ""Many of these results are obtained by imposing a type system on a base programming language, as we do in this paper.""
  - ""We assume a basic familiarity with syntax and semantics of first-order functional programming languages, Turing machines, the Turing machine complexity classes P (polynomial time) and L (logarithmic space), and their functional variants FP and FL.""
  - ""The semantics of a program p is the partial function denoted by [[p]""
  - ""A program p computes a partial function f in case [[p] ] is identical to f as a partial function.""
  - ""The proof of the next lemma is postponed to Appendix A.""
  - ""The proof of the next result is postponed to Appendix A.""",,"- The paper uses a type system to enforce the properties of read/write factorizable programs, indicating a reliance on type theory as a mathematical framework.
 - The paper discusses the use of a type system to ensure that data can either only be destructed or only be constructed, which is a key property guaranteed by the framework.
 - The paper mentions the use of a ""call-by-value, environment-based big-step semantics,"" which is a specific proof technique used to formalize the behavior of programs.
 - The paper discusses the characterization of complexity classes using function algebras and programming languages, which is a broader context for the mathematical framework used.
 - The paper mentions that the transformations are developed according to a common template, which includes proving correctness, indicating a structured approach to formal verification.
 - The paper assumes familiarity with first-order functional programming languages and Turing machines, suggesting that these are part of the theoretical foundations.
 - The paper uses a notation like [[p]] to denote the partial function computed by a program, which is a formal way to express program semantics.
 - The paper mentions that proofs are postponed to appendices, indicating that detailed formal proofs are part of the framework.","- ""In this paper, we cleanly extend the cons-free paradigm to encompass functional complexity classes.""
  - ""we introduce programs with data that can either only be destructed or only be constructed, which we enforce by a type system on the program variables.""
  - ""We call the resulting programs read/write- (or RW-)factorizable, show that RW-factorizable string programs capture exactly the class FP of polynomial-time functions, and that tail-recursive RW-factorizable programs capture exactly the class FL of logarithmic-space functions.""
  - ""The central results of this paper are that
 

 • RW-factorizable string programs of type R → W which are non-nested capture exactly the class FP of polynomial-time functions, and • RW-factorizable strings programs of type R → W which are tail-recursive capture exactly the class FL of logarithmic-space functions.""
  - ""The purpose of the non-nested stipulation is to exclude nested recursive programs like leap from line (1), whose outputs can have length exponential in the length of the inputs.""
  - ""Our results illustrate this phenomenon in a particularly clear way.""
  - ""Both the capturing and composition results utilize the same technical device, namely bit-length computability of a function, which is introduced in this paper.""
  - ""We now show how to compile an RW-factorizable program into a pair of bit-length programs that properly computes the same function.""
  - ""In this section, we show how to compile a pair of bit-length programs into a single RW-factorizable program, thus establishing extensional equivalence for these two notions of computability, at least for total functions.""
  - ""The ""diamond"" transformation that takes an RW-term T of type W into a bitlength term T of type 2, which detects whether T denotes a string built up from w or built up from nil.""
  - ""A ""length"" transformation that takes an RW-term T of type W into a bit-length term T of type C computing the length of T.""
  - ""A ""bit"" transformation b that takes an RW-term T of type W into a bit-length term T b of type 2, which has an extra variable c and computes the bit of T at c.""
  - ""The former transformation uses a well-known trick of cons-free programming, namely that we can simulate a counting module of size polynomial in the input length by a tuple of suffixes of the input.""
  - ""The approach of the present paper does not use restricted termination in any technical sense, and the characterizations we provide are not reliant on termination; there is, however, a tenuous connection in the sense that we use programs with very restricted ability to construct data structures, and this might be amenable to analysis by methods devised for ICC using restricted termination.""
  - ""Our work suggests a number of subsequent questions:
 

 1. Higher orders, non-determinism, and other data types.""",,"- The paper integrates the cons-free programming paradigm with functional complexity classes by introducing read/write-factorizable (RW-factorizable) programs. This integration is achieved through a type system that enforces data to be either destructed or constructed.
 - The interaction model between paradigms involves translating RW-factorizable programs into bit-length programs and vice versa, establishing equivalence in computational power.
 - Constraints include the non-nested stipulation to prevent exponential output lengths and the use of bit-length computability as a technical device.
 - Novel translation techniques include the dagger, diamond, length, and bit transformations, which enable the conversion between RW-factorizable and bit-length programs.
 - The paper discusses theoretical integration strategies by extending cons-free programs to capture functional complexity classes and by using bit-length computability to establish equivalence.","- ""we introduce programs with data that can either only be destructed or only be constructed, which we enforce by a type system on the program variables.""
  - ""The types in an RW-factorizable program are 2, R, and W""
  - ""A function type symbol is an expression of one of the following forms""
  - ""Definition 1. The three atomic types are 2, R, and W , denoting the type of booleans, readonly strings, and write-only strings, respectively.""
  - ""Definition 2. For each product type α, fix an infinite set Var α of variables of type α.""
  - ""Definition 3. An RW term is any expression that can be derived according to the inference rules in Figure 1""
  - ""Definition 4. We identify a few important properties of RW terms.""
  - ""Definition 6. For a program p, term T, value v of the same type as T, and environment ρ, we define the relation ρ p T → v according to the inference rules in Figure 2""
  - ""Definition 19. Let 2 † = 2 and R † = I, and extend this to product and function types coordinate-wise.""
  - ""Definition 20. For RW variables x not of type W and function symbols f not containing any type W , let x → x † and f → f † be a map from RW-factorizable variables and function symbols into bit-length variables and function symbols, so that for example, if x is of type τ , then x † is of type τ""
  - ""Definition 21. Define a map T → T † from W -free RW-factorizable terms to bit-length terms by:""
  - ""Definition 24. Let ρ be an RW environment, i.e., a partial, finite map from RW variables to RW data.""
  - ""Definition 35. A RW term term with global input is obtained by extending the formation rules of Figure 1 by the additional axiom in : R.""
  - ""Definition 36. For any RW product term α, let α R be α × R.""
  - ""Definition 37. Suppose T is a term in which only the variable x may occur.""
  - ""Definition 39. Let 2 ‡ = 2, I ‡ = R, and C ‡ = R k""
  - ""Definition 40. Fix an injection x → x ‡ from bit-length variables to RW variables such that if x has type α, x ‡ has type α""
  - ""Definition 41. Define a map T → T † from bit-length terms to cons-free terms with global input by:""
  - ""Definition 47. Given a term T of type α, we define the term T g of type α g as follows:""
  - ""Definition 48. Given a program p = (f i (x i ) = T i ) 0≤i≤k , let program p (g) be defined by combining the programs p g and q g , then adding new lines ((f i ) g ((x i ) g ) = (T i ) g ) 0≤i≤k on top.""",,"- The paper introduces a type system to enforce the separation of data into destructible and constructible types, which is a form of generic abstraction.
 - The type system includes atomic types for booleans, read-only strings, and write-only strings, which are used to define more complex types and function types.
 - The definitions of RW terms and programs provide a structured way to represent generic abstractions by specifying how terms and programs are constructed and evaluated.
 - The use of a map from RW variables and function symbols to bit-length variables and function symbols (Definitions 20 and 21) suggests a mechanism for representing generic abstractions by translating between different types.
 - The definitions related to environments and the transformation of terms and programs (Definitions 24, 35, 36, 37, 39, 40, 41) indicate strategies for static checking and optimization by ensuring consistency and correctness in the transformation process.
 - The paper does not explicitly mention minimal type requirements or specific static checking or optimization strategies beyond the type system and transformation rules.","- ""In this paper, we cleanly extend the cons-free paradigm to encompass functional complexity classes.""
  - ""we introduce programs with data that can either only be destructed or only be constructed, which we enforce by a type system on the program variables.""
  - ""We call the resulting programs read/write- (or RW-)factorizable, show that RW-factorizable string programs capture exactly the class FP of polynomial-time functions, and that tail-recursive RW-factorizable programs capture exactly the class FL of logarithmic-space functions.""
  - ""The central results of this paper are that
 

 • RW-factorizable string programs of type R → W which are non-nested capture exactly the class FP of polynomial-time functions, and • RW-factorizable strings programs of type R → W which are tail-recursive capture exactly the class FL of logarithmic-space functions.""
  - ""Our results illustrate this phenomenon in a particularly clear way.""
  - ""We now show how to compile an RW-factorizable program into a pair of bit-length programs that properly computes the same function.""
  - ""we show how to compile a pair of bit-length programs into a single RW-factorizable program, thus establishing extensional equivalence for these two notions of computability, at least for total functions.""
  - ""We have identified RW-factorizable programs as a simple extension of cons-free programs that captures functional polynomial time and logarithmic space, and we have also shown how to compose two such programs.""
  - ""Our work suggests a number of subsequent questions:
 

 1. Higher orders, non-determinism, and other data types.""",,"- The paper introduces a novel extension of the cons-free programming paradigm by incorporating read/write factorizable programs, which is a significant theoretical contribution.
 - The introduction of RW-factorizable programs allows for the capture of functional complexity classes, specifically FP and FL, which is a new insight beyond existing cons-free programs.
 - The paper provides a theoretical framework for compiling RW-factorizable programs into bit-length programs and vice versa, establishing equivalence between these models.
 - The ability to compose RW-factorizable programs is another novel contribution, as it addresses a non-trivial problem in the field.
 - The paper suggests potential implications for programming language design by exploring higher orders, non-determinism, and other data types, indicating future research directions."
Session types in concurrent calculi : higher-order processes and objects,D. Mostrous,10.25560/6132,https://doi.org/10.25560/6132,-,14,2009,"1. Primitive Name: Session Type Structure
  Definition: A process-algebraic style description of the behavior of a single program identifier serving as a communication medium, incorporating typed inputs, outputs, and choices.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Linear Treatment of Channels
  Definition: Ensuring linearity by accumulating the uses of a channel into a composite type that describes the order of actions.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Syntactic Duality
  Definition: A method to decide if the types of two connected channels are compatible.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Recursive Sessions
  Definition: Treatment of infinite interactions expressed with recursive sessions.
  Orthogonality Score: Not discussed
 

 5. Primitive Name: Encapsulation of Channels
  Definition: Encapsulating channels in higher-order structures which can be exchanged and kept suspended.
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Integration of Protocol Structure
  Definition: Integrating protocol structure directly into the description of objects.
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Asynchronous Subtyping
  Definition: Enables controlled reordering of actions on either side of a session.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Type safety, compatibility
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified",No specific integration approach described,Generic programming not extensively addressed,"- Key novel insights: Linear treatment of channels and session types, syntactic duality, treatment of infinite interactions, encapsulation of channels, integration of protocol structure into objects, introduction of asynchronous subtyping.
 - Theoretical advancements: Unification and extension of session primitives and typing systems for Lambda-calculus, Pi-calculus, Object-calculus, and multi-paradigm languages.
 - Potential implications: Provides a theoretical foundation for programming language design integrating functional, process, and object-oriented features.","- ""The structure of a session type is essentially a process-algebraic style description of the behaviour of a single program identifier serving as a communication medium (and usually referred to as a channel): the types incorporate typed inputs, outputs, and choices which can be composed to form larger protocol descriptions.""
  - ""The effectiveness of session typing can be attributed to the linear treatment of channels and session types, and to the use of tractable methods such as syntactic duality to decide if the types of two connected channels are compatible.""
  - ""Our work unifies, improves and extends, in manifold ways, the session primitives and typing systems for the Lambda-calculus, the Pi-calculus, the Object-calculus, and their combinations in multi-paradigm languages.""
  - ""Of particular interest are: the treatment of infinite interactions expressed with recursive sessions; the capacity to encapsulate channels in higher-order structures which can be exchanged and kept suspended, i.e., the use of code as data; the integration of protocol structure directly into the description of objects, providing a powerful and uniformly extensible set of implementation abstractions; finally, the introduction of asynchronous subtyping, which enables controlled reordering of actions on either side of a session.""
  - ""Linearity is ensured when accumulating the uses of a channel into a composite type that describes also the order of those actions.""
  - ""Duality provides a tractable and intuitive method for deciding when two connected channels can interact and exchange values in a statically determined type-safe way.""",,"- The abstract discusses the structure of session types as a conceptual primitive, which includes typed inputs, outputs, and choices. This is a fundamental concept in the study.
 - The linear treatment of channels and session types is another key primitive, ensuring that the uses of a channel are accumulated into a composite type that describes the order of actions.
 - Syntactic duality is a method used to decide compatibility between connected channels, which is a conceptual primitive in the context of session typing.
 - The abstract mentions the extension and improvement of session primitives and typing systems for various calculi (Lambda-calculus, Pi-calculus, Object-calculus), indicating these as conceptual primitives.
 - The study highlights specific primitives such as recursive sessions, encapsulation of channels in higher-order structures, integration of protocol structure into objects, and asynchronous subtyping as key conceptual primitives.","- ""This dissertation investigates different formalisms, in the form of programming language calculi, that are aimed at providing a theoretical foundation for structured concurrent programming based on session types.""
  - ""The structure of a session type is essentially a process-algebraic style description of the behaviour of a single program identifier serving as a communication medium (and usually referred to as a channel): the types incorporate typed inputs, outputs, and choices which can be composed to form larger protocol descriptions.""
  - ""The effectiveness of session typing can be attributed to the linear treatment of channels and session types, and to the use of tractable methods such as syntactic duality to decide if the types of two connected channels are compatible.""
  - ""Linearity is ensured when accumulating the uses of a channel into a composite type that describes also the order of those actions.""
  - ""Duality provides a tractable and intuitive method for deciding when two connected channels can interact and exchange values in a statically determined type-safe way.""
  - ""We present our contributions to the theory of sessions, distilled into two families of programming calculi, the first based on higher-order processes and the second based on objects.""
  - ""Our work unifies, improves and extends, in manifold ways, the session primitives and typing systems for the Lambda-calculus, the Pi-calculus, the Object-calculus, and their combinations in multi-paradigm languages.""",,"- The abstract discusses the use of ""programming language calculi"" as a theoretical foundation, which suggests a type theory framework.
 - The mention of ""process-algebraic style description"" and ""typed inputs, outputs, and choices"" indicates the use of type theory to formalize session types.
 - The abstract highlights ""linear treatment of channels and session types"" and ""syntactic duality"" as key methods, which are typical in type theory for ensuring compatibility and type safety.
 - The focus on ""linearity"" and ""duality"" suggests specific mathematical properties guaranteed by the framework, such as type safety and compatibility.
 - The abstract does not explicitly mention proof techniques or limitations, but the use of type theory and process algebra implies formal verification through these methods.
 - The abstract does not provide explicit details on proof techniques or limitations, so these aspects are not specified.","- ""Our work on higher-order processes and on object calculi for session-based concurrent programming provides a theoretical foundation for programming language design integrating functional, process, and object-oriented features.""
  - ""Our work unifies, improves and extends, in manifold ways, the session primitives and typing systems for the Lambda-calculus, the Pi-calculus, the Object-calculus, and their combinations in multi-paradigm languages.""",,"- The abstract mentions the integration of different programming paradigms by unifying and extending session primitives and typing systems for various calculi (Lambda-calculus, Pi-calculus, Object-calculus). This suggests a theoretical integration strategy.
 - The mention of ""combinations in multi-paradigm languages"" implies that the study addresses how these paradigms interact within a single language framework.
 - The abstract does not explicitly detail specific integration mechanisms, interaction models, constraints, or novel translation techniques. It focuses on the theoretical foundation and extension of session types rather than the specific integration approach.
 - The abstract does not provide a detailed discussion of paradigm interactions, theoretical integration strategies, or comparative analysis sections that would typically be expected in a description of a programming paradigm integration approach.","- ""The structure of a session type is essentially a process-algebraic style description of the behaviour of a single program identifier serving as a communication medium (and usually referred to as a channel): the types incorporate typed inputs, outputs, and choices which can be composed to form larger protocol descriptions.""
  - ""The effectiveness of session typing can be attributed to the linear treatment of channels and session types, and to the use of tractable methods such as syntactic duality to decide if the types of two connected channels are compatible.""
  - ""Linearity is ensured when accumulating the uses of a channel into a composite type that describes also the order of those actions.""
  - ""Duality provides a tractable and intuitive method for deciding when two connected channels can interact and exchange values in a statically determined type-safe way.""
  - ""Our work unifies, improves and extends, in manifold ways, the session primitives and typing systems for the Lambda-calculus, the Pi-calculus, the Object-calculus, and their combinations in multi-paradigm languages.""
  - ""Of particular interest are: the treatment of infinite interactions expressed with recursive sessions; the capacity to encapsulate channels in higher-order structures which can be exchanged and kept suspended, i.e., the use of code as data; the integration of protocol structure directly into the description of objects, providing a powerful and uniformly extensible set of implementation abstractions; finally, the introduction of asynchronous subtyping, which enables controlled reordering of actions on either side of a session.""",,"- The abstract discusses the use of session types as a mechanism for structured concurrent programming, which involves the composition of typed inputs, outputs, and choices to form larger protocol descriptions. This suggests a form of abstraction where complex interactions are encapsulated within session types.
 - The mention of ""linear treatment of channels and session types"" and ""syntactic duality"" implies a focus on ensuring type safety and compatibility between channels, which is a form of static checking.
 - The abstract does not explicitly mention generic programming or abstraction mechanisms in the context of genericity. Instead, it focuses on session types and their application in concurrent programming.
 - The integration of protocol structure into object descriptions and the use of higher-order structures could be seen as mechanisms for abstraction, but they are not explicitly linked to generic programming.
 - The abstract does not provide specific details on minimal type requirements or static checking strategies related to generic programming.","- ""The effectiveness of session typing can be attributed to the linear treatment of channels and session types, and to the use of tractable methods such as syntactic duality to decide if the types of two connected channels are compatible.""
  - ""Of particular interest are: the treatment of infinite interactions expressed with recursive sessions; the capacity to encapsulate channels in higher-order structures which can be exchanged and kept suspended, i.e., the use of code as data; the integration of protocol structure directly into the description of objects, providing a powerful and uniformly extensible set of implementation abstractions; finally, the introduction of asynchronous subtyping, which enables controlled reordering of actions on either side of a session.""
  - ""This dissertation investigates different formalisms, in the form of programming language calculi, that are aimed at providing a theoretical foundation for structured concurrent programming based on session types.""
  - ""Our work unifies, improves and extends, in manifold ways, the session primitives and typing systems for the Lambda-calculus, the Pi-calculus, the Object-calculus, and their combinations in multi-paradigm languages.""
  - ""We present our contributions to the theory of sessions, distilled into two families of programming calculi, the first based on higher-order processes and the second based on objects.""
  - ""Our work on higher-order processes and on object calculi for session-based concurrent programming provides a theoretical foundation for programming language design integrating functional, process, and object-oriented features.""",,"- The abstract discusses the investigation of formalisms for structured concurrent programming based on session types, indicating a focus on theoretical foundations.
 - The mention of ""linear treatment of channels and session types"" and ""syntactic duality"" suggests novel insights into how session types are managed and validated.
 - The presentation of contributions in two families of programming calculi (higher-order processes and objects) indicates a theoretical advancement by unifying and extending existing calculi.
 - The abstract highlights specific theoretical contributions such as the treatment of infinite interactions, encapsulation of channels, integration of protocol structure into objects, and the introduction of asynchronous subtyping. These are novel insights that advance existing approaches.
 - The work provides a theoretical foundation for programming language design that integrates multiple paradigms, which is a significant theoretical contribution with potential implications for future programming language design."
"A denotational model for the integration of concurrent, functional and imperative programming","D. Bolignano, M. Debbabi",10.1109/ICCI.1993.315370,https://doi.org/10.1109/ICCI.1993.315370,International Conference on Computing and Information,6,1993,"1. Primitive Name: CSP-like process algebra
  Definition: Embedding of CSP-like process algebra into a functional language to support concurrency
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Unidirectional channels
  Definition: Expressions communicate through unidirectional channels
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Concurrency combinators
  Definition: Expressions are composed through some concurrency combinators
  Orthogonality Score: Not discussed
 

 4. Primitive Name: References
  Definition: Notion of reference used to support imperative aspects
  Orthogonality Score: Not discussed
 

 5. Primitive Name: First-class citizens (references, channels, functions)
  Definition: References, channels, and functions are made first-class citizens
  Orthogonality Score: Not discussed
 

 6. Primitive Name: Effect-based semantics
  Definition: Semantics yields types, side effects, and communication effects
  Orthogonality Score: Not discussed
 

 7. Primitive Name: Denotational semantics based on acceptance trees
  Definition: Dynamic semantics is denotational and rests on an extension of the mathematical model of acceptance trees
  Orthogonality Score: Not discussed","- Type of mathematical framework: Denotational model, effect-based semantics
 - Specific mathematical properties guaranteed: Safe and efficient integration of concurrent, functional, and imperative paradigms
 - Proof techniques used: Not specified
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Embedding of CSP-like process algebra into a functional language; use of references to support imperative aspects.
 - Interaction models between paradigms: Expressions communicate through unidirectional channels; composed using concurrency combinators.
 - Constraints or challenges in paradigm integration: Technical problems related to dynamic domains; addressed by using types and effects.
 - Novel translation or embedding techniques: Embedding of CSP-like process algebra into a functional language.",Generic programming not extensively addressed,"- Key novel insights: Integration of concurrent, functional, and imperative programming paradigms; embedding of CSP-like process algebra into a functional language; making references, channels, and functions first-class citizens.
 - Theoretical advancements: Denotational model for integration; effect-based semantics for managing side effects and communication effects; extension of acceptance trees for dynamic semantics.
 - Potential implications: Provides a formal framework for integrating multiple programming paradigms, ensuring safe and efficient programming; contributes to the theoretical foundations of programming language design.","- ""The intent is to present a denotational model for a language that is aimed to integrate all the three paradigms.""
  - ""Concurrency is supported through the embedding of a CSP-like process algebra into a functional language.""
  - ""Expressions may communicate through unidirectional channels and can also be composed through some concurrency combinators.""
  - ""The notion of reference is used to support imperative aspects.""
  - ""References, channels, and functions are made first-class citizens.""
  - ""This semantics is effect-based i.e. for each expression it yields a type, the side effects and the communication effects.""
  - ""The use of types and effects allows a safe and efficient integration of the three programming paradigms and also solves some technical problems related to the foundations of the dynamic domains.""
  - ""Then the dynamic semantics is presented. It is denotational and rests on an extension of the mathematical model of acceptance trees.<<ETX>>""",,"- The abstract discusses the integration of concurrent, functional, and imperative programming paradigms, which suggests that the conceptual primitives are related to these paradigms.
 - Concurrency is supported by embedding a CSP-like process algebra into a functional language, indicating that process algebra is a conceptual primitive for concurrency.
 - Expressions communicate through unidirectional channels and are composed using concurrency combinators, which are primitives for concurrency.
 - The notion of reference is used to support imperative aspects, suggesting that references are a primitive for imperative programming.
 - References, channels, and functions are made first-class citizens, indicating these are fundamental primitives in the model.
 - The effect-based semantics yields types, side effects, and communication effects, which are likely conceptual primitives for managing the integration of paradigms.
 - The dynamic semantics is denotational and based on an extension of acceptance trees, which could be considered a conceptual primitive for dynamic semantics.","- ""Then the dynamic semantics is presented. It is denotational and rests on an extension of the mathematical model of acceptance trees.<<ETX>>""
  - ""The intent is to present a denotational model for a language that is aimed to integrate all the three paradigms.""
  - ""The use of types and effects allows a safe and efficient integration of the three programming paradigms and also solves some technical problems related to the foundations of the dynamic domains.""
  - ""We deal with the theoretical foundations of integrating the concurrent, functional and imperative programming paradigms.""
  - ""This semantics is effect-based i.e. for each expression it yields a type, the side effects and the communication effects.""",,"- The abstract mentions the use of a ""denotational model"" which is a type of mathematical framework used in programming language theory to describe the meaning of expressions.
 - The framework is described as ""effect-based,"" which suggests that it focuses on the effects of expressions, such as types, side effects, and communication effects. This is a characteristic of type theory, which is concerned with the types of expressions and their effects.
 - The abstract does not explicitly mention specific mathematical properties guaranteed by the framework, but it implies that the framework ensures ""safe and efficient integration"" of different programming paradigms.
 - The abstract does not provide details on specific proof techniques used or limitations of the framework.
 - The mention of ""acceptance trees"" suggests a connection to formal verification methods, but no further details are provided.","- ""We deal with the theoretical foundations of integrating the concurrent, functional and imperative programming paradigms.""
  - ""Concurrency is supported through the embedding of a CSP-like process algebra into a functional language.""
  - ""Expressions may communicate through unidirectional channels and can also be composed through some concurrency combinators.""
  - ""The notion of reference is used to support imperative aspects.""
  - ""References, channels, and functions are made first-class citizens.""
  - ""The use of types and effects allows a safe and efficient integration of the three programming paradigms and also solves some technical problems related to the foundations of the dynamic domains.""",,"- The abstract discusses the integration of concurrent, functional, and imperative programming paradigms, indicating a focus on theoretical foundations.
 - Concurrency is integrated by embedding a CSP-like process algebra into a functional language, which is a specific integration mechanism.
 - Expressions can communicate through unidirectional channels and are composed using concurrency combinators, which describes an interaction model between paradigms.
 - The use of references supports imperative aspects, indicating a mechanism for integrating imperative programming.
 - Making references, channels, and functions first-class citizens suggests a novel approach to integrating these elements.
 - The abstract mentions that the use of types and effects allows for safe and efficient integration, which addresses constraints or challenges in paradigm integration.
 - The abstract does not explicitly mention novel translation or embedding techniques beyond the embedding of CSP-like process algebra.","- ""The use of types and effects allows a safe and efficient integration of the three programming paradigms and also solves some technical problems related to the foundations of the dynamic domains.""
  - ""This semantics is effect-based i.e. for each expression it yields a type, the side effects and the communication effects.""
  - ""References, channels, and functions are made first-class citizens.""
  - ""Concurrency is supported through the embedding of a CSP-like process algebra into a functional language.""
  - ""The intent is to present a denotational model for a language that is aimed to integrate all the three paradigms.""",,"- The abstract discusses the integration of concurrent, functional, and imperative programming paradigms, which suggests a focus on combining different programming styles rather than generic programming.
 - The mention of ""first-class citizens"" indicates a level of abstraction where references, channels, and functions are treated equally, but this does not directly address generic programming.
 - The effect-based semantics and the use of types and effects are more related to ensuring safety and efficiency in integrating different paradigms rather than generic programming.
 - There is no explicit mention of generic programming methodology, type system discussions related to genericity, or abstraction mechanisms specifically for generic programming.","- ""We deal with the theoretical foundations of integrating the concurrent, functional and imperative programming paradigms.""
  - ""The intent is to present a denotational model for a language that is aimed to integrate all the three paradigms.""
  - ""Concurrency is supported through the embedding of a CSP-like process algebra into a functional language.""
  - ""The notion of reference is used to support imperative aspects.""
  - ""References, channels, and functions are made first-class citizens.""
  - ""This semantics is effect-based i.e. for each expression it yields a type, the side effects and the communication effects.""
  - ""The use of types and effects allows a safe and efficient integration of the three programming paradigms and also solves some technical problems related to the foundations of the dynamic domains.""
  - ""Then the dynamic semantics is presented. It is denotational and rests on an extension of the mathematical model of acceptance trees.<<ETX>>""",,"- The abstract discusses the integration of concurrent, functional, and imperative programming paradigms, which is a novel approach as it combines these three paradigms in a single language.
 - The use of a denotational model for this integration is a theoretical contribution, as it provides a formal framework for understanding how these paradigms interact.
 - The embedding of a CSP-like process algebra into a functional language is a novel insight, as it introduces concurrency in a functional context.
 - Making references, channels, and functions first-class citizens is a theoretical advancement, as it allows for more flexible and expressive programming.
 - The effect-based semantics is a key contribution, as it provides a way to manage side effects and communication effects, ensuring safe and efficient integration of the paradigms.
 - The extension of the mathematical model of acceptance trees for dynamic semantics is a theoretical innovation, as it provides a rigorous foundation for the language's behavior."
Towards ASM Engineering and Modelling,"B. Thalheim, P. Schmidt",-,-,-,0,2007,"1. Primitive Name: Abstract State Machines (ASMs)
  Definition: Foundation for all computation processes
  Orthogonality Score: Not discussed
 2. Primitive Name: Turbo ASMs
  Definition: Part of the methodology
  Orthogonality Score: Not discussed
 3. Primitive Name: Abstraction Layers
  Definition: Part of the methodology
  Orthogonality Score: Not discussed
 4. Primitive Name: Refinement
  Definition: Part of the methodology
  Orthogonality Score: Not discussed
 5. Primitive Name: Structuring
  Definition: One of the four principles of computer science
  Orthogonality Score: Not discussed
 6. Primitive Name: Evolution
  Definition: One of the four principles of computer science
  Orthogonality Score: Not discussed
 7. Primitive Name: Collaboration
  Definition: One of the four principles of computer science
  Orthogonality Score: Not discussed
 8. Primitive Name: Abstraction
  Definition: One of the four principles of computer science
  Orthogonality Score: Not discussed",Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),No specific integration approach described,"- Definition of ""concept"" used: The model relates things under consideration with concepts C.
 - Mechanisms for representing generic abstractions: Stepwise refinement, abstraction layers, hierarchical structuring, constructor composition, and generalisation.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: The ASM approach has reached maturity for use in all computation processes; development of principles for ASM specification addresses the lack of a modelling theory.
 - Theoretical advancements: ASM method supports high-level design, analysis, validation, and verification; captures four principles of computer science (structuring, evolution, collaboration, abstraction).
 - Potential implications for programming language design: Provides a scientific and formal foundation for systems engineering; improves industrial practice by orchestrating software development phases.","- ""The ASM approach has gained a maturity that permits the use of ASM as the foundation for all computation processes.""
  - ""All known models of computation can be expressed through specific abstract state machines.""
  - ""Stepwise refinement supports separation of concerns during software development and will support component-based construction of systems, thus providing a foundation of new computational paradigms such as industrial programming, programming-in-the-large, and programming-in-the-world.""
  - ""Our approach is based on the Turbo ASMs, abstraction layers, and on refinement.""
  - ""The ASM method nicely supports high-level design, analysis, validation and verification of computing systems: – ASM-based specification improves industrial practice by proper orchestration of all phases of software development, by supporting a high-level modelling at any level of abstraction, and by providing a scientific and formal foundation for systems engineering.""
  - ""Abstract state machines entirely capture the four principles [ZT04] of computer science: structuring, evolution, collaboration, and abstraction.""",,"- The abstract discusses the use of Abstract State Machines (ASMs) as a foundational element for computation processes, indicating that ASMs are a key conceptual primitive.
 - The mention of ""Turbo ASMs, abstraction layers, and refinement"" suggests these are part of the methodology, potentially serving as conceptual primitives.
 - The abstract highlights the support for high-level design and analysis, which implies that these are part of the conceptual framework.
 - The four principles of computer science captured by ASMs - structuring, evolution, collaboration, and abstraction - are explicitly mentioned as conceptual primitives.
 - The abstract does not provide explicit definitions for these primitives beyond their mention, nor does it discuss their orthogonality.","- ""The ASM approach has gained a maturity that permits the use of ASM as the foundation for all computation processes.""
  - ""All known models of computation can be expressed through specific abstract state machines.""
  - ""These models can be given in a representation independent way.""
  - ""Stepwise refinement supports separation of concerns during software development and will support component-based construction of systems,""
  - ""Our approach is based on the Turbo ASMs, abstraction layers, and on refinement.""
  - ""ASM engineering is based on a well-defined methodology that promises to be manageable.""
  - ""The ASM method nicely supports high-level design, analysis, validation and verification of computing systems:""
  - ""ASM-based specification improves industrial practice by proper orchestration of all phases of software development, by supporting a high-level modelling at any level of abstraction, and by providing a scientific and formal foundation for systems engineering.""",,"- The abstract discusses the use of Abstract State Machines (ASMs) as a foundation for computation processes, indicating a focus on ASMs as a mathematical framework.
 - The mention of ""representation independent way"" suggests a formal framework that abstracts away from specific representations, which is characteristic of mathematical frameworks like type theory or category theory.
 - The use of ""stepwise refinement"" and ""abstraction layers"" implies a structured approach to formal verification, which is typical in mathematical frameworks.
 - The abstract highlights the support for ""high-level design, analysis, validation and verification,"" which are activities often associated with formal verification techniques.
 - The mention of ""scientific and formal foundation for systems engineering"" suggests a rigorous mathematical framework, but the specific type (e.g., type theory, category theory) is not explicitly mentioned.
 - The abstract does not provide specific details about the type of mathematical framework, mathematical properties guaranteed, proof techniques used, or limitations of the framework.","- ""All known models of computation can be expressed through specific abstract state machines.""
  - ""The ASM approach has the expressivity to handle also programming in the large together with programming in the small.""
  - ""The ASM approach has gained a maturity that permits the use of ASM as the foundation for all computation processes.""
  - ""The ASM method nicely supports high-level design, analysis, validation and verification of computing systems: – ASM-based specification improves industrial practice by proper orchestration of all phases of software development, by supporting a high-level modelling at any level of abstraction, and by providing a scientific and formal foundation for systems engineering.""
  - ""Stepwise refinement supports separation of concerns during software development and will support component-based construction of systems, thus providing a foundation of new computational paradigms such as industrial programming, programming-in-the-large, and programming-in-the-world.""",,"- The abstract discusses the ASM approach as a foundation for all computation processes, indicating its potential to integrate different programming paradigms.
 - The mention of ""stepwise refinement"" and ""component-based construction"" suggests a mechanism for integrating different paradigms by allowing for modular development and separation of concerns.
 - The abstract highlights the ASM approach's ability to handle both ""programming in the large"" and ""programming in the small,"" which implies an integration of these paradigms.
 - The ASM method is described as providing a ""scientific and formal foundation for systems engineering,"" which could imply a theoretical integration strategy.
 - However, the abstract does not explicitly describe specific integration mechanisms, interaction models, constraints, or novel translation techniques beyond the general capabilities of the ASM approach.","- ""The ASM approach has gained a maturity that permits the use of ASM as the foundation for all computation processes.""
  - ""These models can be given in a representation independent way.""
  - ""Stepwise refinement supports separation of concerns during software development and will support component-based construction of systems,""
  - ""Our approach is based on the Turbo ASMs, abstraction layers, and on refinement.""
  - ""Modelling is one of the most difficult tasks in software engineering.""
  - ""The model is a result of modelling. It relates thingsD under consideration with concepts C.""
  - ""Software engineering uses a number of principles that refine different kinds of abstraction [Tha00] such as construction abstraction, context abstraction and refinement abstraction.""
  - ""Construction abstraction uses the principles of hierarchical structuring, constructor composition, and generalisation.""
  - ""Refinement abstraction uses the principle of modularisation.""
  - ""The ASM method nicely supports high-level design, analysis, validation and verification of computing systems:""",,"- The abstract discusses the use of Abstract State Machines (ASMs) as a foundation for computation processes, which implies a focus on abstraction mechanisms.
 - The mention of ""representation independent way"" suggests a level of genericity in the modeling approach.
 - The use of ""stepwise refinement"" and ""abstraction layers"" indicates mechanisms for representing generic abstractions.
 - The abstract refers to ""construction abstraction"" and ""refinement abstraction,"" which are mechanisms for abstraction.
 - The mention of ""hierarchical structuring, constructor composition, and generalisation"" provides insight into the mechanisms for representing generic abstractions.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does emphasize the use of abstraction principles.
 - The focus on ""high-level design, analysis, validation and verification"" suggests a methodology that could support generic programming.","- ""The ASM approach has gained a maturity that permits the use of ASM as the foundation for all computation processes.""
  - ""Despite the theoretical and application maturity a modelling theory for ASM specifications does not exist.""
  - ""We develop a number of principles and approaches to ASM specification that allow one to develop modular and surveyable ASMs.""
  - ""ASM engineering is based on a well-defined methodology that promises to be manageable.""
  - ""The ASM method nicely supports high-level design, analysis, validation and verification of computing systems:""
  - ""ASM-based specification improves industrial practice by proper orchestration of all phases of software development, by supporting a high-level modelling at any level of abstraction, and by providing a scientific and formal foundation for systems engineering.""",,"- The abstract mentions that the ASM approach has reached a level of maturity that allows it to be used as a foundation for all computation processes, indicating a significant theoretical contribution in terms of its applicability.
 - The development of principles and approaches for ASM specification is highlighted as a novel contribution, as it addresses the lack of a modelling theory for ASM specifications.
 - The abstract emphasizes the ASM method's support for high-level design, analysis, validation, and verification, which is a theoretical advancement over existing approaches that only provide loose coupling of notions and techniques.
 - The ASM method is noted for its ability to capture the four principles of computer science (structuring, evolution, collaboration, and abstraction), which is a unique theoretical contribution.
 - The abstract suggests that the ASM approach provides a scientific and formal foundation for systems engineering, which is a theoretical advancement beyond existing approaches."
Toward Verified Library-Level Choreographic Programming with Algebraic Effects,"Gan Shen, L. Kuper",10.48550/arXiv.2407.06509,https://doi.org/10.48550/arXiv.2407.06509,arXiv.org,2,2024,"1. Primitive Name: Algebraic Effects
  Definition: Computations with user-defined effects and EPP as location-specific effect handlers.
  Orthogonality Score: High (generalizes existing approaches)
 

 2. Primitive Name: Signature Sig
  Definition: Specifies equipped operations of an algebra, including type Op and function Arity.
  Orthogonality Score: High (fundamental abstraction)
 

 3. Primitive Name: F-Algebra
  Definition: Implements operations of a signature.
  Orthogonality Score: High (implements algebraic effects)
 

 4. Primitive Name: Terms
  Definition: Programs with uninterpreted effects.
  Orthogonality Score: High (represents computations)
 

 5. Primitive Name: Signature C
  Definition: Specifies operations for choreographies (local computation and communication).
  Orthogonality Score: High (defines choreographic operations)
 

 6. Primitive Name: Choreo
  Definition: Shorthand for terms using operations from C, abstracted over a particular At.
  Orthogonality Score: High (abstracts choreographic computations)","- Type of mathematical framework: Algebraic effects, implemented in Agda (type theory)
 - Specific mathematical properties guaranteed: Soundness and completeness of endpoint projection, deadlock freedom
 - Proof techniques used: Leveraging algebraic effects to prove correctness and properties
 - Limitations or constraints of the framework: Definitions of soundness and completeness may be too strong, limiting certain behaviors","- Specific integration mechanisms proposed: Algebraic effects are used to define choreographies as computations with user-defined effects and EPP as location-specific effect handlers.
 - Interaction models between paradigms: Algebraic effects facilitate the interaction by abstracting CP-specific effects and control flows.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned, but algebraic effects provide a flexible framework to address these.
 - Novel translation or embedding techniques: Using algebraic effects to define choreographies and EPP.",Generic programming not extensively addressed,"- Key novel insights: Introduction of algebraic effects to model library-level choreographic programming.
 - Theoretical advancements: Algebraic effects generalize existing approaches and facilitate reasoning about correctness properties like soundness and completeness.
 - Potential implications: Provides a solid theoretical foundation for library-level CP, making it less ad-hoc and more accessible.","- ""Algebraic effects let us define choreographies as computations with user-defined effects and EPP as location-specific effect handlers.""
  - ""Algebraic effects provide an abstraction that generalizes existing approaches to library-level CP.""
  - ""In programming, we can view an effectful operation as giving rise to an algebra, with the allowed effects being the signature, the result of an effect being the arity of the operation, and a carrier set of such an algebra being a functional model of the effectful computation.""
  - ""A set that implements the operations of a signature F is called an F-algebra.""
  - ""In programming, Terms correspond to programs where effects are left uninterpreted, with variables being pure computations and operations being effectful computations.""
  - ""The signature C specifies the two main operations of choreographies using one overloaded constructor:
 

 • 'comm denotes a local computation at location . • 'comm denotes location sends the result of a computation to location""
  - ""We also define Choreo as a shorthand for terms using operations from C abstracted over a particular At.""",,"- The paper introduces algebraic effects as a foundational approach for library-level choreographic programming (CP). This suggests that algebraic effects are a key conceptual primitive.
 - Algebraic effects are defined as a way to generalize existing approaches to library-level CP, indicating their role as a fundamental abstraction.
 - The paper describes the signature Sig as specifying operations and their arity, which is a conceptual primitive for defining algebraic effects.
 - The concept of an F-algebra is another primitive, as it implements the operations of a signature.
 - Terms are defined as programs with uninterpreted effects, which is a primitive for representing computations.
 - The signature C defines operations for choreographies, specifically local computations and communication, which are conceptual primitives for choreographic programming.
 - Choreo is defined as a shorthand for terms using operations from C, abstracted over a particular At, indicating another level of abstraction.","- ""In this paper, we propose modeling library-level CP using algebraic effects, an abstraction that generalizes the approach taken by existing CP libraries.""
  - ""Algebraic effects let us define choreographies as computations with user-defined effects and EPP as location-specific effect handlers.""
  - ""Algebraic effects also lend themselves to reasoning about correctness properties, such as soundness and completeness of EPP.""
  - ""We present a prototype of a library-level CP framework based on algebraic effects, implemented in the Agda proof assistant,""
  - ""In the rest of the paper, we set up a framework for programming with algebraic effects in Agda (Section 2), which we then use to implement a prototype library-level CP framework (Section 3).""
  - ""Our next step will be to leverage the algebraic-effects-based formulation of CP presented in the last two sections to prove the correctness of endpoint projection, as well as follow-on properties such as deadlock freedom.""
  - ""At a high level, given a choreographic semantics _⇒ _ and a network semantics _⇒ _, soundness of endpoint projection would say that the projected network preserves the semantics of the original choreography.""
  - ""Completeness of EPP, on the other hand, would say that the network reflects the semantics of the original choreography,""
  - ""However, the above definitions of soundness and completeness may be too strong -for instance, they prohibit EPP from doing rewritings that change the behaviors of the network but compute the same result.""",,"- The paper uses algebraic effects as the mathematical framework to formalize and guarantee properties of choreographic programming.
 - Algebraic effects are used to define choreographies and endpoint projection, which are key concepts in the paper.
 - The framework is implemented in Agda, a proof assistant, which suggests that type theory is involved.
 - The paper discusses reasoning about correctness properties such as soundness and completeness of endpoint projection, which are specific mathematical properties guaranteed by the framework.
 - The proof techniques used involve leveraging the algebraic-effects-based formulation to prove correctness and properties like deadlock freedom.
 - The limitations or constraints of the framework are noted in the discussion about the definitions of soundness and completeness being too strong, which may prohibit certain behaviors.","- ""Algebraic effects let us define choreographies as computations with user-defined effects and EPP as location-specific effect handlers.""
  - ""We can now define endpoint projection, the process of turning a choreography into a process for a target location.""
  - ""Our focus is a monad because the identity functor and units are both monads.""
  - ""In this section, we use the algebraic effects framework from the previous section to implement a CP language.""
  - ""Algebraic effects provide an abstraction that generalizes existing approaches to library-level CP.""
  - ""Choreographic programming (CP) is a paradigm for programming distributed applications as single, unified programs, called choreographies, that are then compiled to node-local programs via endpoint projection (EPP).""",,"- The paper discusses the integration of choreographic programming (CP) with existing host languages through library-level CP frameworks.
 - Algebraic effects are proposed as a foundational approach to integrate CP with host languages, providing a generalized abstraction for existing library-level CP frameworks.
 - The integration mechanism involves defining choreographies as computations with user-defined effects and endpoint projection (EPP) as location-specific effect handlers.
 - The interaction model between paradigms is facilitated by algebraic effects, which allow for the abstraction of CP-specific effects and control flows.
 - The paper does not explicitly mention constraints or challenges in paradigm integration, but it implies that algebraic effects help in addressing these by providing a flexible and generalized framework.
 - The novel translation or embedding technique involves using algebraic effects to define choreographies and EPP, which is a new approach to integrating CP with host languages.","- ""Algebraic effects provide an abstraction that generalizes existing approaches to library-level CP.""
  - ""Algebraic effects let us define choreographies as computations with user-defined effects and EPP as location-specific effect handlers.""
  - ""Algebraic effects also lend themselves to reasoning about correctness properties, such as soundness and completeness of EPP.""
  - ""In programming, Terms correspond to programs where effects are left uninterpreted, with variables being pure computations and operations being effectful computations.""
  - ""Terms also form a monad (it is actually the free monad), which allows us to chain them together:""
  - ""In programming, interp forms the foundation of effect handlers. It lets us systematically handle uninterpreted effects of a computation.""
  - ""Our focus is a monad because the identity functor and units are both monads.""
  - ""We can now define endpoint projection, the process of turning a choreography into a process for a target location.""",,"- The paper uses algebraic effects as a foundational approach for implementing and verifying library-level choreographic programming (CP). This suggests a focus on abstraction mechanisms rather than traditional generic programming.
 - Algebraic effects are used to define choreographies and endpoint projection (EPP) in a way that abstracts over specific representations, which aligns with conceptual abstraction.
 - The use of terms and monads indicates a mechanism for representing generic abstractions, as these are mathematical structures that can be applied broadly.
 - The paper does not explicitly discuss minimal type requirements or static checking strategies in the context of generic programming.
 - The focus is more on the abstraction mechanisms provided by algebraic effects rather than traditional generic programming methodologies.","- ""Algebraic effects provide an abstraction that generalizes existing approaches to library-level CP.""
  - ""In this paper, we propose modeling library-level CP using algebraic effects, an abstraction that generalizes the approach taken by existing CP libraries.""
  - ""Algebraic effects also lend themselves to reasoning about correctness properties, such as soundness and completeness of EPP.""
  - ""Our next step will be to leverage the algebraic-effects-based formulation of CP presented in the last two sections to prove the correctness of endpoint projection, as well as follow-on properties such as deadlock freedom.""
  - ""Algebraic effects let us define choreographies as computations with user-defined effects and EPP as location-specific effect handlers.""",,"- The paper introduces the use of algebraic effects as a novel approach to model library-level choreographic programming (CP). This is a theoretical contribution as it provides a new abstraction that generalizes existing methods.
 - Algebraic effects are used to define choreographies and endpoint projection (EPP) in a way that facilitates reasoning about correctness properties such as soundness and completeness. This is a theoretical advancement as it addresses a gap in existing library-level CP frameworks.
 - The paper aims to leverage this approach to prove correctness properties like deadlock freedom, which is a significant theoretical contribution towards ensuring the reliability of distributed applications.
 - The use of algebraic effects has potential implications for programming language design by providing a more solid theoretical foundation for library-level CP, making it less ad-hoc and more accessible to a broader audience."
Putting it in context: a syntactic theory of incremental program construction,Shinn-Der Lee,-,-,-,0,1996,"1. Primitive Name: Fully-evolved program contexts
  Definition: Proper parse trees perceived as compiled code
  Orthogonality Score: Not discussed
 2. Primitive Name: Partially-evolved program contexts
  Definition: Improper parse trees with holes as non-terminal leaves perceived as compilation operators
  Orthogonality Score: Not discussed
 3. Primitive Name: Context hole filling
  Definition: Means to link together compiled code
  Orthogonality Score: Not discussed
 4. Primitive Name: Construction vs. Execution
  Definition: Distinguishing between the construction and execution of programs
  Orthogonality Score: Not discussed",Not specified (the abstract does not explicitly mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Enhancing programming languages with incremental program construction capabilities based on program contexts; enriched -calculi for modular programming and interactive/object-oriented programming.
 - Interaction models between paradigms: Linking compiled code through program contexts.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Introduction of a schema for enhancing programming languages with incremental program construction capabilities based on program contexts.
 - Theoretical advancements: Extension of programming languages by treating fully-evolved program contexts as compiled code and partially-evolved contexts as compilation operators; enriched -calculi for metacircular compilation, module manipulation, and dynamic linking.
 - Potential implications: Framework for enhancing languages with incremental construction capabilities, leading to more flexible and efficient programming paradigms.","- ""By perceiving fully-evolved program contexts (proper parse trees) as compiled code, partiallyevolved program contexts (improper parse trees with holes as non-terminal leaves) as compilation operators, and context hole lling as the means to link together compiled code, the schema conservatively extends programming languages with mechanisms capable of modeling the incremental construction, linking, and loading of compiled program components.""
  - ""Incremental program development amounts to lling the holes of well-planned program contexts with new experimental components, or assembling new programs from previously developed and thoroughly tested components, or a combination of both.""
  - ""Our language design schema is unique in three aspects. First, it distinguishes the construction of programs from the execution of programs.""
  - ""The ability to construct programs in an incremental fashion is a premise of popular programming paradigms such as modular programming, object-oriented programming, and interactive programming.""",,"- The abstract discusses the concept of incremental program construction, which is a key aspect of the study.
 - It mentions ""fully-evolved program contexts (proper parse trees)"" and ""partially-evolved program contexts (improper parse trees with holes as non-terminal leaves)"" as conceptual primitives. These are defined as compiled code and compilation operators, respectively.
 - The abstract also refers to ""context hole filling"" as a means to link compiled code, which is another conceptual primitive.
 - The study distinguishes between the construction and execution of programs, which is a fundamental conceptual primitive in the language design schema.
 - The abstract does not provide explicit names for these primitives, but they are implicitly defined through their roles in the schema.","- ""The enriched pure -calculus is capable of expressing a metacircular compiler for itself.""
  - ""We use the schema to enrich three -calculi.""
  - ""We present a schema for enhancing programming languages with incremental program construction capabilities based on the notion of program contexts.""
  - ""The enriched -calculus with elaborate variable referencing devices is capable of expressing variable references whose linking relation can be altered when their context evolves.""",,"- The abstract discusses a schema for enhancing programming languages with incremental program construction capabilities, which suggests a theoretical framework.
 - The use of ""program contexts"" and ""parse trees"" implies a syntactic theory, which is a type of mathematical framework.
 - The mention of enriching ""-calculi"" suggests a connection to lambda calculus, which is a mathematical framework used in programming language theory.
 - The abstract does not explicitly mention type theory, category theory, or other specific mathematical frameworks, nor does it discuss specific mathematical properties guaranteed or proof techniques used.
 - There is no mention of limitations or constraints of the framework in the abstract.","- ""The ability to construct programs in an incremental fashion is a premise of popular programming paradigms such as modular programming, object-oriented programming, and interactive programming.""
  - ""Incremental program development amounts to lling the holes of well-planned program contexts with new experimental components, or assembling new programs from previously developed and thoroughly tested components, or a combination of both.""
  - ""We present a schema for enhancing programming languages with incremental program construction capabilities based on the notion of program contexts.""
  - ""The enriched pure -calculus is capable of expressing a metacircular compiler for itself.""
  - ""The enriched -calculus with elaborate variable de nition notations is a module manipulation language suitable for modular programming.""
  - ""The enriched -calculus with elaborate variable referencing devices is capable of expressing variable references whose linking relation can be altered when their context evolves.""
  - ""Such relinkable variable references can provide the late binding behavior required by interactive and object-oriented programming.""",,"- The abstract discusses the integration of different programming paradigms by mentioning ""modular programming, object-oriented programming, and interactive programming"" as paradigms that benefit from incremental program construction.
 - The schema proposed by the author enhances programming languages with incremental program construction capabilities, which is a mechanism for integrating these paradigms.
 - The abstract describes the use of ""program contexts"" as a way to link together compiled code, which can be seen as an interaction model between paradigms.
 - The enriched -calculi are presented as specific integration mechanisms, with each version tailored to different paradigms (e.g., modular programming and interactive/object-oriented programming).
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the use of program contexts and enriched -calculi.","- ""The ability to construct programs in an incremental fashion is a premise of popular programming paradigms such as modular programming, object-oriented programming, and interactive programming.""
  - ""Incremental program development amounts to lling the holes of well-planned program contexts with new experimental components, or assembling new programs from previously developed and thoroughly tested components, or a combination of both.""
  - ""Its popularity lies in the exibilities it provides for reusing existing program components and program structures.""
  - ""We present a schema for enhancing programming languages with incremental program construction capabilities based on the notion of program contexts.""
  - ""By perceiving fully-evolved program contexts (proper parse trees) as compiled code, partiallyevolved program contexts (improper parse trees with holes as non-terminal leaves) as compilation operators, and context hole lling as the means to link together compiled code, the schema conservatively extends programming languages with mechanisms capable of modeling the incremental construction, linking, and loading of compiled program components.""
  - ""We use the schema to enrich three -calculi.""
  - ""The enriched pure -calculus is capable of expressing a metacircular compiler for itself.""
  - ""The enriched -calculus with elaborate variable de nition notations is a module manipulation language suitable for modular programming.""
  - ""The enriched -calculus with elaborate variable referencing devices is capable of expressing variable references whose linking relation can be altered when their context evolves.""
  - ""Such relinkable variable references can provide the late binding behavior required by interactive and object-oriented programming.""",,"- The abstract discusses incremental program construction, which involves reusing existing components and structures, a concept related to generic programming.
 - The schema presented enhances programming languages with incremental construction capabilities, which could be seen as a mechanism for representing generic abstractions.
 - The use of ""program contexts"" and ""context hole filling"" suggests a form of abstraction mechanism.
 - The enrichment of lambda-calculi with features like module manipulation and relinkable variable references indicates a focus on abstraction mechanisms.
 - However, the abstract does not explicitly mention generic programming or type systems, nor does it discuss minimal type requirements or static checking strategies.
 - The focus is more on incremental construction and abstraction mechanisms rather than generic programming per se.","- ""We present a schema for enhancing programming languages with incremental program construction capabilities based on the notion of program contexts.""
  - ""The enriched pure -calculus is capable of expressing a metacircular compiler for itself.""
  - ""Our language design schema is unique in three aspects. First, it distinguishes the construction of programs from the execution of programs.""
  - ""The enriched -calculus with elaborate variable referencing devices is capable of expressing variable references whose linking relation can be altered when their context evolves.""",,"- The abstract introduces a novel schema for enhancing programming languages with incremental program construction capabilities, which is a key theoretical contribution. This schema is based on the concept of program contexts, which is a new approach to modeling incremental construction.
 - The schema extends programming languages by treating fully-evolved program contexts as compiled code and partially-evolved contexts as compilation operators. This is a theoretical advancement as it provides a new way to model the incremental construction and linking of program components.
 - The enriched -calculi (pure, with elaborate variable definition notations, and with elaborate variable referencing devices) represent theoretical advancements beyond existing approaches. They enable new functionalities such as metacircular compilation, module manipulation, and dynamic linking, which are significant theoretical contributions.
 - The distinction between program construction and execution is highlighted as a unique aspect of the schema, indicating a theoretical innovation in how programming languages are designed and understood.
 - The potential implications for programming language design are significant, as the schema provides a framework for enhancing languages with incremental construction capabilities, which can lead to more flexible and efficient programming paradigms."
Speciﬁcation and Veriﬁcation of Rust Iterators in Prusti,"Jonas Hansen, Prof Aurel Bílý, Dr. Peter Müller",-,-,-,0,2021,Not specified (the abstract does not explicitly define any conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),No specific integration approach described (the abstract mentions Rust's multi-paradigm nature and the combination of closures and iterators but does not detail specific integration mechanisms or challenges),Generic programming not extensively addressed,"The novelty and theoretical contribution of this work is the extension of Prusti's verification capabilities to support iterators, addressing a common task in programming and potentially influencing programming language design. This represents a theoretical advancement in the formal verification of Rust programs.","- ""Arguably the most unique feature of Rust is its ownership type system for memory management.""
  - ""Iterators in Rust, as in other programming languages, are used to traverse elements of a collection, such as processing each element of a vector in a for loop.""
  - ""Even though closures and iterators are orthogonal Rust features, they are often used in combination to produce concise and functional-style code.""
  - ""Rust also embraces features from functional programming by supporting first-class functions and closures, whose combination with iterators allows programming in a functional style.""
  - ""Rust is a multi-paradigm programming language with a focus on systems programming.""",,"- The abstract discusses Rust's features such as its ownership type system, first-class functions, closures, and iterators. These are not explicitly defined as conceptual primitives but are mentioned as key features of the Rust programming language.
 - The abstract does not provide explicit definitions or mention any specific conceptual primitives defined by the study.
 - The focus of the abstract is on extending Prusti's verification capabilities for iterators, but it does not specify any conceptual primitives related to this extension.
 - The abstract does not mention any specific methodology, theoretical framework, or results sections that would typically contain definitions of conceptual primitives.","- ""Arguably the most unique feature of Rust is its ownership type system for memory management.""
  - ""In their recent work [WBM21], Wolff and Bílý have leveraged Prusti’s capabilities to support the verification of closures and higher-order functions.""
  - ""This work aims to extend Prusti’s verification capabilities for iterators.""
  - ""In 2019, Astrauskas et al. [AMPS19] have introduced Prusti, a tool for formally verifying Rust programs.""
  - ""Rust is a multi-paradigm programming language with a focus on systems programming.""",,"- The abstract mentions Rust's ownership type system, which is a key feature related to memory management. This suggests a focus on type theory, as type systems are fundamental in programming languages for ensuring memory safety and other properties.
 - The mention of Prusti, a tool for formally verifying Rust programs, indicates that the work involves formal verification. Formal verification often relies on mathematical frameworks such as type theory to guarantee properties of programs.
 - The abstract does not explicitly mention the type of mathematical framework used (e.g., type theory, category theory) or specific mathematical properties guaranteed by the framework.
 - There is no mention of specific proof techniques or limitations of the framework in the abstract.
 - The abstract does not provide explicit details about the mathematical framework characteristics, such as the type of framework, specific properties guaranteed, proof techniques used, or limitations.","- ""Even though closures and iterators are orthogonal Rust features, they are often used in combination to produce concise and functional-style code.""
  - ""Rust also embraces features from functional programming by supporting first-class functions and closures, whose combination with iterators allows programming in a functional style.""
  - ""Rust is a multi-paradigm programming language with a focus on systems programming.""",,"- The abstract describes Rust as a ""multi-paradigm programming language,"" indicating that it integrates multiple programming paradigms.
 - It mentions that Rust supports ""first-class functions and closures,"" which are features typically associated with functional programming.
 - The combination of these functional programming features with iterators is highlighted as allowing for ""programming in a functional style,"" suggesting an integration of functional programming paradigms with systems programming.
 - The abstract notes that closures and iterators are ""orthogonal"" but often used together, implying a mechanism of interaction between these features.
 - However, the abstract does not provide specific details on the integration mechanisms, interaction models, constraints, or novel techniques beyond the general statement of combining closures and iterators for functional-style programming.","- ""Rust is a multi-paradigm programming language with a focus on systems programming.""
  - ""Arguably the most unique feature of Rust is its ownership type system for memory management.""
  - ""Rust also embraces features from functional programming by supporting first-class functions and closures, whose combination with iterators allows programming in a functional style.""
  - ""In 2019, Astrauskas et al. [AMPS19] have introduced Prusti, a tool for formally verifying Rust programs.""
  - ""In their recent work [WBM21], Wolff and Bílý have leveraged Prusti’s capabilities to support the verification of closures and higher-order functions.""
  - ""This work aims to extend Prusti’s verification capabilities for iterators.""
  - ""Iterators in Rust, as in other programming languages, are used to traverse elements of a collection, such as processing each element of a vector in a for loop.""",,"- The abstract discusses Rust's features, including its ownership type system and support for functional programming elements like closures and iterators. However, it does not explicitly mention generic programming or abstraction mechanisms.
 - The focus of the abstract is on the verification of Rust programs using Prusti, particularly extending its capabilities to iterators, rather than on generic programming or abstraction mechanisms.
 - There is no mention of a ""concept"" definition, mechanisms for representing generic abstractions, minimal type requirements, or static checking or optimization strategies related to generic programming.
 - The abstract does not provide any information on generic programming methodology, type system discussions, or abstraction mechanism explanations.","- ""This work aims to extend Prusti’s verification capabilities for iterators.""
  - ""Since iterating over a collection is a common task many programs, the need to formally verify iterators arises naturally.""
  - ""Iterators in Rust, as in other programming languages, are used to traverse elements of a collection, such as processing each element of a vector in a for loop.""",,"- The abstract mentions that the work aims to extend Prusti's verification capabilities for iterators. This indicates a novel contribution by enhancing the existing tool, Prusti, to support the verification of iterators, which is a common task in programming.
 - The focus on iterators suggests a theoretical advancement in the formal verification of Rust programs, as it addresses a fundamental aspect of programming—iterating over collections.
 - The extension of Prusti to support iterator verification implies a potential implication for programming language design, as it could influence how future programming languages incorporate formal verification for similar constructs.
 - The abstract does not provide specific details on the theoretical innovations or comparative analysis with existing work, but it implies that the extension of Prusti for iterators is a novel contribution."
Objects In a Functional Environment,"Juan Carlos Guzmán, Ascánder Suárez",-,-,-,0,-,Not specified (the abstract mentions the proposal of new primitives but does not provide specific names or definitions),Not specified (the abstract does not mention a specific mathematical framework or its characteristics),"- Specific integration mechanisms proposed: Proposing new primitives to incorporate objects as first-class elements in functional languages.
 - Interaction models between paradigms: Adapting objects to the pattern-matching mechanism and making them compatible with polymorphic type inference.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Incorporating objects as first-class elements in functional languages.
 - Theoretical advancements: Adapting objects to pattern-matching mechanisms and making them compatible with polymorphic type inference.
 - Potential implications: Enhancing programming language design by integrating object-oriented and functional programming paradigms.","- ""rend them compatible with the polymorphic type inference mechanism.""
  - ""adapt them to the pattern-matching mechanism""",,"- The abstract mentions the proposal of ""new primitives"" that are designed to incorporate objects into functional languages. This indicates that the study defines conceptual primitives related to object manipulation in a functional context.
 - The primitives are described as being adapted to the ""pattern-matching mechanism,"" which suggests that they are designed to work within this specific framework.
 - The primitives are also made ""compatible with the polymorphic type inference mechanism,"" indicating that they are designed to work with this type system.
 - However, the abstract does not provide specific names or detailed definitions for these primitives. It only mentions their purpose and compatibility with certain mechanisms.
 - The level of abstraction and orthogonality of the primitives are not explicitly discussed in the abstract.","- ""The Object Oriented Paradigm of Programming has a great impact in the way programs and systems are designed today.""
  - ""its infl.uence in the Functional Programming community is quite limited.""",,"- The abstract discusses the integration of object-oriented programming into functional programming, focusing on the manipulation of objects and their compatibility with functional languages.
 - It mentions the adaptation of objects to the pattern-matching mechanism and polymorphic type inference, which are concepts related to functional programming.
 - However, there is no explicit mention of a mathematical framework, such as type theory or category theory, nor are there any details about specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The abstract does not provide information on theoretical foundations, proof methodology, or formal verification discussions related to a mathematical framework.","- ""its infl.uence in the Functional Programming community is quite limited.""
  - ""The Object Oriented Paradigm of Programming has a great impact in the way programs and systems are designed today.""",,"- The abstract discusses the integration of Object-Oriented Programming (OOP) with Functional Programming (FP) by mentioning the limited influence of OOP in the FP community. This suggests an attempt to bridge these two paradigms.
 - The study proposes new primitives to incorporate objects into functional languages, which is a specific integration mechanism. This indicates an effort to integrate OOP elements into FP.
 - The adaptation of objects to the pattern-matching mechanism and making them compatible with polymorphic type inference are interaction models between the paradigms. These are specific ways in which the integration is being achieved.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the proposed primitives and adaptations.","- ""its infl.uence in the Functional Programming community is quite limited.""
  - ""The Object Oriented Paradigm of Programming has a great impact in the way programs and systems are designed today.""",,"- The abstract discusses the integration of object-oriented programming (OOP) concepts into functional programming (FP), which is a form of abstraction.
 - It mentions the proposal of new primitives to incorporate objects into functional languages, which could be related to generic programming.
 - The abstract talks about adapting these primitives to pattern-matching and polymorphic type inference, which are mechanisms related to abstraction and genericity.
 - However, the abstract does not explicitly mention generic programming or provide detailed mechanisms for representing generic abstractions, minimal type requirements, or static checking strategies.
 - The focus is more on the integration of OOP into FP rather than a detailed exploration of generic programming methodologies.","- ""its infl.uence in the Functional Programming community is quite limited.""
  - ""N o functional programming environment with objects is considered today as a standard, and new proposals continue to emerge.""
  - ""The Object Oriented Paradigm of Programming has a great impact in the way programs and systems are designed today.""",,"- The abstract highlights the limited influence of object-oriented programming in the functional programming community, indicating a gap in current research.
 - It mentions that there is no standard functional programming environment with objects, suggesting a need for innovation in this area.
 - The authors propose new primitives that incorporate objects as first-class elements in functional languages, which is a novel insight as it addresses the integration of object-oriented concepts into functional programming.
 - The adaptation of these objects to the pattern-matching mechanism and their compatibility with polymorphic type inference are theoretical advancements beyond existing approaches, as they aim to bridge the gap between object-oriented and functional programming paradigms.
 - The potential implications for programming language design are significant, as these innovations could lead to more comprehensive and flexible programming environments that combine the strengths of both paradigms."
"Linear Logic, Heap-shape Patterns and Imperative Programming","Limin Jia, D. Walker",-,-,-,2,2006,"1. Primitive Name: Linear Logical Formulas
  Definition: Used for specifying data structure shapes at a high level of abstraction.
  Orthogonality Score: Not specified
 2. Primitive Name: Pattern Matching
  Definition: A new form of pattern matching drawn from linear logic syntax for deconstructing data structures.
  Orthogonality Score: Not specified
 3. Primitive Name: Mode Analysis
  Definition: Inspired by logic programming languages to ensure safety and well-definedness of algorithms.
  Orthogonality Score: Not specified","- Type of mathematical framework: Linear logic, type theory
 - Specific mathematical properties guaranteed: Memory safety
 - Proof techniques used: Mode analysis inspired by logic programming languages
 - Limitations or constraints of the framework: Not specified","- Specific integration mechanisms proposed: Use of linear logical formulas for constructing data structures and a new form of pattern matching for deconstruction.
 - Interaction models between paradigms: Integration of linear logic with imperative programming through high-level abstraction and mode analysis inspired by logic programming languages.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.","Generic programming not extensively addressed (the abstract focuses on a new programming paradigm using linear logic and pattern matching, but does not explicitly address generic programming methodologies or mechanisms)","- Key novel insights: Use of linear logical formulas for high-level abstraction in constructing data structures; new form of pattern matching based on linear logic syntax.
 - Theoretical advancements: Introduction of a new programming paradigm; incorporation of mode analysis into a broader type system for memory safety.
 - Potential implications: Enhanced memory safety in programming language design; simplification of handling complex mutable data structures.","- ""programmers construct data structures by specifying the shapes they want at a high level of abstraction, using linear logical formulas rather than low-level pointer operations.""
  - ""analyze the programmer’s linear logical specifications using a mode analysis inspired by similar analysis used in logic programming languages.""
  - ""programmers deconstruct data structures using a new form of pattern matching, where the patterns are again drawn from the syntax of linear logic.""
  - ""This mode analysis is incorporated into a broader type system that ensures the memory safety of the overall programming language.""",,"- The abstract mentions the use of ""linear logical formulas"" for constructing data structures, which suggests that these formulas are a conceptual primitive for specifying data structure shapes.
 - The use of ""a new form of pattern matching"" drawn from linear logic syntax indicates another conceptual primitive for deconstructing data structures.
 - The ""mode analysis"" inspired by logic programming languages is a methodological primitive for ensuring safety and well-definedness of algorithms.
 - The abstract does not provide explicit names or detailed definitions for these primitives, nor does it discuss their orthogonality or level of abstraction beyond being ""at a high level of abstraction.""","- ""programmers deconstruct data structures using a new form of pattern matching, where the patterns are again drawn from the syntax of linear logic.""
  - ""programmers construct data structures by specifying the shapes they want at a high level of abstraction, using linear logical formulas rather than low-level pointer operations.""
  - ""we analyze the programmer’s linear logical specifications using a mode analysis inspired by similar analysis used in logic programming languages.""
  - ""This mode analysis is incorporated into a broader type system that ensures the memory safety of the overall programming language.""",,"- The abstract mentions the use of ""linear logical formulas"" and ""linear logic"" as part of the programming paradigm. This suggests that the mathematical framework is based on linear logic.
 - The mention of ""mode analysis inspired by similar analysis used in logic programming languages"" indicates that the framework involves some form of analysis similar to those used in logic programming, which is a characteristic of type theory.
 - The abstract does not explicitly mention specific mathematical properties guaranteed or proof techniques used, but it does mention that the framework ensures ""memory safety,"" which is a property often guaranteed by type systems.
 - There is no explicit mention of limitations or constraints of the framework in the abstract.","- ""In this paper, we propose a new programming paradigm designed to simplify the process of safely creating, manipulating and disposing of complex mutable data structures.""
  - ""In order to ensure that algorithms for construction, inspection and deconstruction of heap values are well-defined and safe, we analyze the programmer’s linear logical specifications using a mode analysis inspired by similar analysis used in logic programming languages.""
  - ""This mode analysis is incorporated into a broader type system that ensures the memory safety of the overall programming language.""
  - ""Likewise, programmers deconstruct data structures using a new form of pattern matching, where the patterns are again drawn from the syntax of linear logic.""
  - ""In our system, programmers construct data structures by specifying the shapes they want at a high level of abstraction, using linear logical formulas rather than low-level pointer operations.""",,"- The abstract discusses a new programming paradigm that integrates linear logic with imperative programming, as indicated by the use of linear logical formulas and pattern matching.
 - The integration mechanism involves using linear logical formulas for constructing data structures and a new form of pattern matching for deconstruction, which suggests a novel approach to integrating these paradigms.
 - The interaction model between paradigms is implicit in the use of linear logic for high-level abstraction and the incorporation of mode analysis from logic programming languages, which ensures memory safety.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss any novel translation or embedding techniques beyond the use of linear logic and pattern matching.
 - The focus is on ensuring memory safety through a broader type system, which is part of the integration strategy.","- ""This mode analysis is incorporated into a broader type system that ensures the memory safety of the overall programming language.""
  - ""analyze the programmer’s linear logical specifications using a mode analysis inspired by similar analysis used in logic programming languages.""
  - ""a new programming paradigm designed to simplify the process of safely creating, manipulating and disposing of complex mutable data structures.""
  - ""programmers deconstruct data structures using a new form of pattern matching, where the patterns are again drawn from the syntax of linear logic.""
  - ""programmers construct data structures by specifying the shapes they want at a high level of abstraction, using linear logical formulas rather than low-level pointer operations.""",,"- The abstract discusses a new programming paradigm that simplifies the creation and manipulation of complex data structures, which implies a focus on abstraction.
 - The use of ""linear logical formulas"" and ""pattern matching"" suggests mechanisms for representing generic abstractions, as these are high-level constructs.
 - The mention of ""mode analysis"" and its incorporation into a ""broader type system"" indicates a focus on ensuring memory safety, which could relate to minimal type requirements and static checking.
 - However, the abstract does not explicitly mention generic programming or provide detailed mechanisms for genericity and abstraction beyond the use of linear logic and pattern matching.","- ""In our system, programmers construct data structures by specifying the shapes they want at a high level of abstraction, using linear logical formulas rather than low-level pointer operations.""
  - ""Likewise, programmers deconstruct data structures using a new form of pattern matching, where the patterns are again drawn from the syntax of linear logic.""
  - ""In order to ensure that algorithms for construction, inspection and deconstruction of heap values are well-defined and safe, we analyze the programmer’s linear logical specifications using a mode analysis inspired by similar analysis used in logic programming languages.""
  - ""In this paper, we propose a new programming paradigm designed to simplify the process of safely creating, manipulating and disposing of complex mutable data structures.""
  - ""This mode analysis is incorporated into a broader type system that ensures the memory safety of the overall programming language.""",,"- The abstract introduces a ""new programming paradigm"" which suggests a significant theoretical contribution by proposing a novel approach to handling complex mutable data structures.
 - The use of ""linear logical formulas"" instead of ""low-level pointer operations"" represents a key novel insight, as it offers a high-level abstraction for constructing data structures, which is a departure from traditional methods.
 - The introduction of a ""new form of pattern matching"" based on linear logic syntax is another theoretical advancement, as it provides a new way to deconstruct data structures.
 - The incorporation of ""mode analysis"" inspired by logic programming languages into a broader type system is a theoretical contribution that ensures memory safety, which is a critical aspect of programming language design.
 - The focus on ensuring ""memory safety"" through these innovations has potential implications for programming language design, as it addresses a fundamental challenge in imperative programming."
"A Study on a Single Construct for Events, Aspects, and Behaviors","Yungyu Zhuang, Shigeru Chiba",-,-,-,0,2014,"1. Primitive Name: Method Slots
  Definition: A generic construct based on the common ground among OOP, event-driven programming, and aspect-oriented programming, which can be used as methods, events, and advices.
  Orthogonality Score: Not specified",Not specified,"- Specific integration mechanisms proposed: Method slots as a new generic construct.
 - Interaction models between paradigms: Method slots can be used as methods, events, and advices.
 - Constraints or challenges in paradigm integration: Existing generic constructs are not flexible enough; dedicated constructs complicate language design.
 - Any novel translation or embedding techniques: Not explicitly mentioned.","- Definition of ""concept"" used: Method slots as a generic construct.
 - Mechanisms for representing generic abstractions: Method slots can be used as methods, events, and advices.
 - Minimal type requirements identified: Method slots are simple and easy to extend.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: The observation of a common ground among OOP, event-driven programming, and aspect-oriented programming.
 - Theoretical advancements: The proposal of a new generic construct called ""method slots"" that can serve as methods, events, and advices, simplifying and unifying paradigm implementation.
 - Potential implications: Simplification and flexibility in programming language design, allowing for easier support of multiple paradigms without increasing language complexity.","- ""The observation on the similarities motivates us to extend the methods in JavaScript to method slots, which can be used as methods, events, and advices.""
  - ""this thesis proposes a new generic construct, method slots, based on our observation of the common ground among the implementations of three important paradigms in the real world: OOP, the event-handler paradigm (event-driven programming), the aspect paradigm (aspect-oriented programming).""
  - ""The concept ofmethod slots is very simple and easy to extend.""",,"- The abstract mentions the proposal of a new generic construct called ""method slots."" This suggests that ""method slots"" is a conceptual primitive defined in the study.
 - The definition provided is that method slots are based on the common ground among OOP, event-driven programming, and aspect-oriented programming, and they can be used as methods, events, and advices.
 - The abstract does not provide a detailed definition or explicit list of primitives beyond ""method slots,"" nor does it discuss the level of abstraction or orthogonality of these primitives.
 - The mention of method slots being ""very simple and easy to extend"" implies a certain level of abstraction and flexibility, but this is not explicitly quantified or detailed in terms of orthogonality.","- ""To overcome the problem that existing generic constructs are not flexible enough, this thesis proposes a new generic construct, method slots, based on our observation of the common ground among the implementations of three important paradigms in the real world: OOP, the event-handler paradigm (event-driven programming), the aspect paradigm (aspect-oriented programming).""
  - ""We then evaluate DominoJ by comparing with existing languages, running benchmarks for it, and rewriting programs as case studies.""
  - ""To demonstrate how method slots can be used in practice, a Java-based language named DominoJ is proposed with a compiler implementation.""
  - ""The observation on the similarities motivates us to extend the methods in JavaScript to method slots, which can be used as methods, events, and advices.""
  - ""The common ground has never been noticed before this thesis since the dedicated constructs for these paradigms were individually developed from the beginning.""",,"- The abstract discusses the development of a new generic construct called ""method slots"" and its application in a Java-based language named DominoJ.
 - It mentions the observation of common ground among different programming paradigms and the extension of methods in JavaScript to create method slots.
 - The abstract does not mention any specific mathematical framework, theoretical foundations, proof methodology, or formal verification discussions.
 - There is no mention of type theory, category theory, or any other mathematical framework used to formalize or guarantee properties of the conceptual primitives.
 - The focus is on the practical implementation and evaluation of method slots rather than on mathematical formalization or verification.","- ""How to support the implementation of paradigms can be classified into three types of approaches: by design patterns, by dedicated constructs, and by generic constructs.""
  - ""Design patterns can be used to implement most paradigms but not all.""
  - ""Dedicated constructs greatly improve the modularity of code, but also increase the number of constructs in a language supporting multiple paradigms; a large number of constructs complicates the language design.""
  - ""Generic constructs can be considered as a potentially good approach, but the number of supported paradigms in current research is quite limited; existing generic constructs are not flexible enough to support more paradigms.""
  - ""To overcome the problem that existing generic constructs are not flexible enough, this thesis proposes a new generic construct, method slots, based on our observation of the common ground among the implementations of three important paradigms in the real world: OOP, the event-handler paradigm (event-driven programming), the aspect paradigm (aspect-oriented programming).""
  - ""The common ground has never been noticed before this thesis since the dedicated constructs for these paradigms were individually developed from the beginning.""
  - ""The observation on the similarities motivates us to extend the methods in JavaScript to method slots, which can be used as methods, events, and advices.""
  - ""To demonstrate how method slots can be used in practice, a Java-based language named DominoJ is proposed with a compiler implementation.""",,"- The abstract discusses three types of approaches to support paradigm implementation: design patterns, dedicated constructs, and generic constructs. This provides a context for understanding the integration mechanisms.
 - The study identifies limitations in existing approaches: design patterns are not comprehensive, dedicated constructs complicate language design, and generic constructs are not flexible enough.
 - The proposed solution is a new generic construct called ""method slots,"" which is based on observed commonalities among OOP, event-driven programming, and aspect-oriented programming. This suggests a novel integration mechanism.
 - Method slots are designed to be flexible and can be used as methods, events, and advices, indicating a potential interaction model between paradigms.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration beyond the limitations of existing approaches.
 - The study introduces a new language, DominoJ, which demonstrates the practical application of method slots, but it does not detail specific interaction models or novel translation techniques.","- ""To overcome the problem that existing generic constructs are not flexible enough, this thesis proposes a new generic construct, method slots, based on our observation of the common ground among the implementations of three important paradigms in the real world: OOP, the event-handler paradigm (event-driven programming), the aspect paradigm (aspect-oriented programming).""
  - ""The observation on the similarities motivates us to extend the methods in JavaScript to method slots, which can be used as methods, events, and advices.""
  - ""The concept ofmethod slots is very simple and easy to extend.""",,"- The abstract discusses the introduction of a new generic construct called ""method slots,"" which is designed to address the flexibility issue in existing generic constructs. This indicates a focus on generic programming.
 - The concept of method slots is based on the observation of commonalities among different programming paradigms (OOP, event-driven, aspect-oriented), suggesting a mechanism for representing generic abstractions.
 - The abstract mentions that method slots can be used as methods, events, and advices, which implies a flexible abstraction mechanism.
 - The simplicity and ease of extension of method slots suggest a minimal type requirement, as it can be adapted to different contexts without significant complexity.
 - There is no explicit mention of static checking or optimization strategies in the abstract, but the focus on a new generic construct implies some level of abstraction and genericity.","- ""The concept ofmethod slots is very simple and easy to extend.""
  - ""The observation on the similarities motivates us to extend the methods in JavaScript to method slots, which can be used as methods, events, and advices.""
  - ""The common ground has never been noticed before this thesis since the dedicated constructs for these paradigms were individually developed from the beginning.""
  - ""To overcome the problem that existing generic constructs are not flexible enough, this thesis proposes a new generic construct, method slots, based on our observation of the common ground among the implementations of three important paradigms in the real world: OOP, the event-handler paradigm (event-driven programming), the aspect paradigm (aspect-oriented programming).""",,"- The abstract introduces a novel theoretical contribution by proposing a new generic construct called ""method slots."" This construct is designed to address the limitations of existing generic constructs, which are not flexible enough to support multiple paradigms.
 - The novelty lies in the observation of a common ground among the implementations of OOP, event-driven programming, and aspect-oriented programming. This commonality was previously unnoticed because each paradigm had its own dedicated constructs developed independently.
 - The theoretical advancement is the extension of methods in JavaScript to method slots, which can serve multiple roles (methods, events, and advices). This innovation simplifies and unifies the implementation of different programming paradigms.
 - The potential implications for programming language design are significant, as method slots offer a flexible and simple construct that can be easily extended. This could lead to more streamlined language design and support for multiple paradigms without complicating the language."
Inheritance of specifications in the calculus of functional objects (preliminary report),O. Ryšavý,-,-,-,0,2006,"1. Primitive Name: Object Type
  Definition: Consists of object's interface signature specification and accompanied specification in form of logical proposition.
  Orthogonality Score: Not discussed
 

 2. Primitive Name: Object Value
  Definition: A collection of operations working on an internal state and a proof of correctness of the implementation.
  Orthogonality Score: Not discussed
 

 3. Primitive Name: Object Type Constructor
  Definition: Combines existential and recursive types akin to Self type of Abadi and Cardelli.
  Orthogonality Score: Not discussed
 

 4. Primitive Name: Boxed Expression
  Definition: An expression annotated with a variable that allows for self-application and positive methods.
  Orthogonality Score: Not discussed","- Type of mathematical framework: Type theory
 - Specific mathematical properties guaranteed: Existential and recursive types, proof of correctness of implementation
 - Proof techniques used: Logical propositions, proof of correctness
 - Limitations or constraints of the framework: Restricted form of self application and positive methods","- Specific integration mechanisms proposed: Combining object-oriented principles with functional programming through inheritance, late binding, and encapsulation.
 - Interaction models between paradigms: Not explicitly mentioned.
 - Constraints or challenges in paradigm integration: Not explicitly mentioned.
 - Novel translation or embedding techniques: Use of object type constructor combining existential and recursive types akin to Self type of Abadi and Cardelli.","- Definition of ""concept"" used: Object type consists of interface signature specification and logical proposition.
 - Mechanisms for representing generic abstractions: Inheritance, late binding, encapsulation; existential and recursive types; boxed expressions.
 - Minimal type requirements identified: Not explicitly mentioned.
 - Static checking or optimization strategies: Not explicitly mentioned.","- Key novel insights: Integration of object-oriented principles with formal methods through object types that include interface signature specifications and logical propositions.
 - Theoretical advancements: Application of inheritance, late binding, and encapsulation to proofs; introduction of a new calculus with object notion as a primitive construction; combination of existential and recursive types in object type constructor.
 - Potential implications: Simplification of object-oriented programming language design; extension of object-oriented principles to formal methods; new ways to handle self-application and positive methods in programming languages.","- ""Object type consists of object's interface signature specification and accompanied specification in form of logical proposition.""
  - ""An object value is a collection of operations working on an internal state and a proof of correctness of the implementation.""
  - ""certain principles of object-orientation can be also applied to accompanied proofs, namely inheritance, late binding, and encapsulation.""
  - ""Paper introduces a new calculus that features object notion as a primitive con- struction allowing for quite simple presentation.""
  - ""Object type constructor combines existential and recursive types akin to Self type of Abadi and Cardelli.""
  - ""A boxed expression is an ex- pression annotated with a variable that with suitable defined substitution operation allows us to encode a restricted form of self application and positive methods.""",,"- The abstract defines several conceptual primitives related to object-oriented programming and functional programming.
 - The ""object type"" is defined as consisting of an ""interface signature specification"" and a ""specification in form of logical proposition,"" which are fundamental components of the object-oriented paradigm.
 - An ""object value"" is described as a collection of operations working on an internal state and a proof of correctness, which are key elements in functional programming.
 - The abstract mentions the application of object-oriented principles such as ""inheritance, late binding, and encapsulation"" to proofs, indicating these as conceptual primitives in the context of object-oriented programming.
 - The ""object type constructor"" is introduced as a primitive construction that combines existential and recursive types, similar to the Self type of Abadi and Cardelli.
 - ""Boxed expressions"" are defined as expressions annotated with a variable, allowing for self-application and positive methods, which is another conceptual primitive.","- ""Solid theoretical foundation of object-oriented paradigm have been developed for both functional and imperative programming languages.""
  - ""Object type consists of object's interface signature specification and accompanied specification in form of logical proposition.""
  - ""An object value is a collection of operations working on an internal state and a proof of correctness of the implementation.""
  - ""Paper introduces a new calculus that features object notion as a primitive con- struction allowing for quite simple presentation.""
  - ""Object type constructor combines existential and recursive types akin to Self type of Abadi and Cardelli.""
  - ""A boxed expression is an ex- pression annotated with a variable that with suitable defined substitution operation allows us to encode a restricted form of self application and positive methods.""",,"- The abstract mentions the use of ""type theory"" as a foundation for functional programming languages, indicating that type theory is a key component of the mathematical framework.
 - The concept of ""object type"" is defined in terms of ""interface signature specification"" and ""logical proposition,"" suggesting that the framework involves formal specifications and logical reasoning.
 - The mention of ""proof of correctness of the implementation"" implies that the framework includes proof techniques for verifying the correctness of object implementations.
 - The introduction of a ""new calculus"" with ""object notion as a primitive construction"" suggests that the framework is based on a calculus that formalizes object-oriented concepts.
 - The use of ""existential and recursive types"" and the reference to ""Self type of Abadi and Cardelli"" indicate specific mathematical properties and techniques used in the framework.
 - The concept of ""boxed expressions"" and ""restricted form of self application and positive methods"" suggests a method for encoding self-referential expressions, which is a limitation or constraint of the framework.","- ""The idea of the present work is straightforward. Object type consists of object's interface signature specification and accompanied specification in form of logical proposition.""
  - ""Object type constructor combines existential and recursive types akin to Self type of Abadi and Cardelli.""
  - ""Paper introduces a new calculus that features object notion as a primitive con- struction allowing for quite simple presentation.""
  - ""In this manner, certain principles of object-orientation can be also applied to accompanied proofs, namely inheritance, late binding, and encapsulation.""
  - ""Solid theoretical foundation of object-oriented paradigm have been developed for both functional and imperative programming languages.""",,"- The abstract discusses the integration of object-oriented principles with functional programming, as indicated by the mention of a ""solid theoretical foundation of object-oriented paradigm have been developed for both functional and imperative programming languages.""
 - The integration mechanism proposed involves combining object-oriented concepts like inheritance, late binding, and encapsulation with functional programming principles, as seen in the application of these concepts to ""accompanied proofs.""
 - The abstract introduces a new calculus that incorporates object notions as a primitive construction, which suggests a theoretical integration strategy.
 - The use of ""object type constructor combines existential and recursive types akin to Self type of Abadi and Cardelli"" indicates a novel translation or embedding technique by leveraging existing type systems to integrate paradigms.
 - There is no explicit mention of interaction models between paradigms or specific constraints or challenges in paradigm integration in the abstract.","- ""Solid theoretical foundation of object-oriented paradigm have been developed for both functional and imperative programming languages.""
  - ""Object type consists of object's interface signature specification and accompanied specification in form of logical proposition.""
  - ""An object value is a collection of operations working on an internal state and a proof of correctness of the implementation.""
  - ""certain principles of object-orientation can be also applied to accompanied proofs, namely inheritance, late binding, and encapsulation.""
  - ""Paper introduces a new calculus that features object notion as a primitive con- struction allowing for quite simple presentation.""
  - ""Object type constructor combines existential and recursive types akin to Self type of Abadi and Cardelli.""
  - ""A boxed expression is an ex- pression annotated with a variable that with suitable defined substitution operation allows us to encode a restricted form of self application and positive methods.""",,"- The abstract discusses the development of a theoretical foundation for object-oriented programming, which includes functional programming languages. This suggests a focus on abstraction mechanisms.
 - The definition of an ""object type"" includes both interface signature specification and logical propositions, indicating a structured approach to abstraction.
 - The mention of ""inheritance, late binding, and encapsulation"" as principles applied to proofs suggests mechanisms for representing generic abstractions.
 - The use of ""existential and recursive types"" and the introduction of ""boxed expressions"" for encoding self-application and positive methods indicate mechanisms for generic programming.
 - The abstract does not explicitly mention minimal type requirements or static checking strategies, but it does introduce a new calculus and type constructor, which implies some form of type system discussion.","- ""Solid theoretical foundation of object-oriented paradigm have been developed for both functional and imperative programming languages.""
  - ""The idea of the present work is straightforward. Object type consists of object's interface signature specification and accompanied specification in form of logical proposition.""
  - ""In this manner, certain principles of object-orientation can be also applied to accompanied proofs, namely inheritance, late binding, and encapsulation.""
  - ""Paper introduces a new calculus that features object notion as a primitive con- struction allowing for quite simple presentation.""
  - ""Object type constructor combines existential and recursive types akin to Self type of Abadi and Cardelli.""
  - ""A boxed expression is an ex- pression annotated with a variable that with suitable defined substitution operation allows us to encode a restricted form of self application and positive methods.""",,"- The abstract discusses the development of a solid theoretical foundation for object-oriented programming, which is a significant contribution to the field.
 - The introduction of object types that include both interface signature specifications and logical propositions is a novel insight, as it integrates object-oriented principles with formal methods.
 - The application of object-oriented principles like inheritance, late binding, and encapsulation to proofs is a theoretical advancement, as it extends these concepts beyond traditional programming contexts.
 - The introduction of a new calculus with object notion as a primitive construction is a significant theoretical contribution, as it simplifies the presentation of object-oriented concepts.
 - The combination of existential and recursive types in the object type constructor is an advancement beyond existing approaches, as it builds upon the work of Abadi and Cardelli.
 - The use of boxed expressions to encode self-application and positive methods is a theoretical innovation, as it provides a new way to handle these concepts in programming languages."
A layered object-oriented programming language,T. Clark,-,-,-,9,1994,Not specified (the abstract does not explicitly list or define conceptual primitives),"Not specified (the abstract does not provide explicit details about the mathematical framework, proof techniques, or specific properties guaranteed)",No specific integration approach described,Generic programming not extensively addressed (the abstract focuses on layering and abstraction mechanisms but does not explicitly discuss generic programming methodology or type system details),"- Key novel insights: Definition of an OOPL using a simple functional notation, layered construction of OOPLs.
 - Theoretical advancements: Systematic mapping of the OOPL design space, framework for analyzing and constructing OOPLs.
 - Potential implications: Clarification and simplification of underlying OOPL concepts, systematic approach to programming language design.","- ""The OOPL is constructed in layers, each layer contributes a new feature which is built by extending and modifying the previous layer.""
  - ""The object oriented programming paradigm has been seen as signiicant advance in software engineering quality. Its proponents cite features such as modular-ity, interfaces, polymorphism, inheritance and reuse as being characteristic of this new method for constructing software.""
  - ""The language which is the result of the nal layer contains mechanisms which are characteristic of the broad range of currently used OOPLs and the basic ideas and constructions provide a basis for a wide variety of languages and allows the OOPL design space to be mapped out in a systematic fashion.""
  - ""A layered object oriented programming language (OOPL) is deened using a simple functional notation which has been equipped with a collection of features common to many OOPLs.""",,"- The abstract mentions that the OOPL is defined using a simple functional notation equipped with common features of OOPLs, but it does not explicitly list these features as conceptual primitives.
 - The abstract discusses features like modularity, interfaces, polymorphism, inheritance, and reuse as characteristic of the object-oriented paradigm, but it does not specify these as the conceptual primitives used in the study.
 - The abstract describes the construction of the OOPL in layers, with each layer adding a new feature, but it does not provide specific names or definitions for these features as conceptual primitives.
 - The abstract does not provide explicit definitions or a list of conceptual primitives used in the study.","- ""functional languages (based upon the-calculus) are especially succinct and expressive and that they are readily extended with new and exotic features.""
  - ""functional languages promote a uniform and \least restrictive""""
  - ""a class of languages may be precisely described by a simple functional language which has been enriched with special primitive features.""
  - ""a simple functional notation which has been equipped with a collection of features common to many OOPLs.""",,"- The abstract mentions the use of a ""simple functional notation"" and ""functional languages based upon the-calculus,"" which suggests that the mathematical framework is rooted in functional programming principles and possibly lambda calculus.
 - The mention of ""enriched with special primitive features"" implies that the framework involves adding specific features to a basic functional language to create an object-oriented programming language.
 - The abstract does not explicitly mention type theory, category theory, or other specific mathematical frameworks, nor does it discuss proof techniques or formal verification methods.
 - There is no mention of specific mathematical properties guaranteed by the framework or any limitations or constraints of the framework.","- ""The OOPL is constructed in layers, each layer contributes a new feature which is built by extending and modifying the previous layer.""
  - ""The resulting language provides a framework within which existing OOPLs can be analysed and new OOPLs can be constructed.""",,"- The abstract discusses the construction of an object-oriented programming language (OOPL) using a simple functional notation, which implies an integration of object-oriented and functional programming paradigms.
 - The language is built in layers, with each layer adding new features, suggesting a structured approach to integrating different paradigm features.
 - The abstract mentions that the resulting language provides a framework for analyzing existing OOPLs and constructing new ones, indicating a focus on understanding and integrating existing paradigm features.
 - However, the abstract does not explicitly mention specific integration mechanisms, interaction models between paradigms, constraints, or novel translation techniques. It focuses more on the layered construction and the framework provided by the language.","- ""The OOPL is constructed in layers, each layer contributes a new feature which is built by extending and modifying the previous layer.""
  - ""It is well known that a class of languages may be precisely described by a simple functional language which has been enriched with special primitive features.""
  - ""The resulting language provides a framework within which existing OOPLs can be analysed and new OOPLs can be constructed.""",,"- The abstract discusses the construction of an object-oriented programming language (OOPL) using a layered approach, starting with a simple functional notation and adding features common to many OOPLs. This suggests a focus on abstraction mechanisms through layering.
 - The mention of a ""simple functional notation"" and ""special primitive features"" implies a method for representing generic abstractions, as these features are likely to include mechanisms for generic programming.
 - The abstract does not explicitly mention ""genericity"" or ""abstraction mechanisms"" in terms of type systems or static checking strategies, which are typically associated with generic programming.
 - The focus on layering and extending features suggests a conceptual abstraction mechanism, where each layer builds upon the previous one to create a more complex language.
 - The abstract does not provide specific details on minimal type requirements or static checking strategies, which are key components of generic programming.","- ""It is well known that a class of languages may be precisely described by a simple functional language which has been enriched with special primitive features.""
  - ""The contribution which this paper makes to software engineering is to strip bare the underlying concepts of OOPLs and to show them""
  - ""The OOPL is constructed in layers, each layer contributes a new feature which is built by extending and modifying the previous layer.""
  - ""The resulting language provides a framework within which existing OOPLs can be analysed and new OOPLs can be constructed.""",,"- The abstract introduces a novel approach to defining an object-oriented programming language (OOPL) by using a simple functional notation. This is a key novel insight as it provides a structured way to analyze and construct OOPLs.
 - The theoretical advancement lies in the layered construction of the OOPL, where each layer adds new features, allowing for a systematic mapping of the OOPL design space. This is a significant theoretical contribution as it provides a framework for understanding and designing OOPLs.
 - The potential implications for programming language design are significant, as the framework allows for the analysis of existing languages and the construction of new ones. This systematic approach can help in identifying and understanding the underlying concepts of OOPLs, which is a theoretical advancement beyond existing approaches.
 - The abstract mentions that the paper strips bare the underlying concepts of OOPLs, which is a theoretical contribution as it clarifies and simplifies the understanding of these concepts."
Universal Policies for Software-Defined MDPs,"Daniel Selsam, Jesse Michael Han, L. D. Moura, Patrice Godefroid",-,-,arXiv.org,2,2020,Not specified (the abstract does not explicitly define conceptual primitives),Not specified (the abstract does not provide explicit details about the mathematical framework characteristics),"- Specific integration mechanisms proposed: Use of 'choose' primitive for nondeterministic choice; meta-interpreters querying an oracle for policy and value estimates.
 - Interaction models between paradigms: Meta-interpreters interact with the oracle to perform heuristic search on the MDP.
 - Constraints or challenges in paradigm integration: Not mentioned.
 - Any novel translation or embedding techniques: Not mentioned.",Generic programming not extensively addressed,"- Key novel insights: Introduction of oracle-guided decision programming paradigm.
 - Theoretical advancements: Development of Dodona programming language with universal policy for MDPs, use of 'choose' primitive for nondeterministic choice, and integration of meta-interpreters with neural oracle.
 - Potential implications: Enables zero-shot heuristic guidance and meta-learning across various tasks, suggesting versatility in programming language design.","- ""We introduce a new programming paradigm called oracle-guided decision programming in which a program specifies a Markov Decision Process (MDP) and the language provides a universal policy.""
  - ""The Dodona interpreter returns either a value or a choicepoint that includes a lossless encoding of all information necessary in principle to make an optimal decision.""
  - ""Meta-interpreters query Dodona's (neural) oracle on these choicepoints to get policy and value estimates, which they can use to perform heuristic search on the underlying MDP.""",,"- The abstract introduces a new programming paradigm called ""oracle-guided decision programming,"" which is a conceptual framework rather than a specific primitive.
 - The term ""primitive"" typically refers to basic building blocks or elements within a programming language or paradigm. In this context, the abstract does not explicitly define any specific conceptual primitives.
 - The mention of ""a primitive 'choose' representing nondeterministic choice"" suggests that ""choose"" might be considered a conceptual primitive, but it is not explicitly defined or detailed in the abstract.
 - The abstract focuses more on the paradigm and the functionality of the Dodona interpreter rather than specifying explicit conceptual primitives.","- ""We introduce a new programming paradigm called oracle-guided decision programming in which a program specifies a Markov Decision Process (MDP) and the language provides a universal policy.""
  - ""The Dodona interpreter returns either a value or a choicepoint that includes a lossless encoding of all information necessary in principle to make an optimal decision.""
  - ""Meta-interpreters query Dodona's (neural) oracle on these choicepoints to get policy and value estimates, which they can use to perform heuristic search on the underlying MDP.""",,"- The abstract mentions the use of Markov Decision Processes (MDPs), which is a mathematical framework used to model decision-making processes in situations where outcomes are partially random and partially under the control of a decision-maker.
 - The mention of ""oracle-guided decision programming"" suggests a framework that involves decision-making processes guided by an oracle, which could imply a theoretical foundation in decision theory or game theory.
 - The abstract does not explicitly mention any specific type of mathematical framework such as type theory or category theory, nor does it discuss specific mathematical properties guaranteed, proof techniques used, or limitations of the framework.
 - The focus is on the programming paradigm and its application rather than the underlying mathematical framework characteristics.","- ""Meta-interpreters query Dodona's (neural) oracle on these choicepoints to get policy and value estimates, which they can use to perform heuristic search on the underlying MDP.""
  - ""The Dodona interpreter returns either a value or a choicepoint that includes a lossless encoding of all information necessary in principle to make an optimal decision.""
  - ""We prototype a new programming language, Dodona, that manifests this paradigm using a primitive 'choose' representing nondeterministic choice.""
  - ""We introduce a new programming paradigm called oracle-guided decision programming in which a program specifies a Markov Decision Process (MDP) and the language provides a universal policy.""",,"- The abstract introduces a new programming paradigm called ""oracle-guided decision programming,"" which suggests a novel approach to integrating different programming paradigms by leveraging a universal policy provided by the language.
 - The use of a primitive 'choose' in the Dodona language indicates a mechanism for nondeterministic choice, which could be part of an integration strategy.
 - The interaction model involves meta-interpreters querying an oracle for policy and value estimates, which implies a method for integrating different paradigms through heuristic search on the underlying MDP.
 - The abstract does not explicitly mention constraints or challenges in paradigm integration, nor does it discuss novel translation or embedding techniques beyond the use of the 'choose' primitive and the oracle-guided approach.","- ""We prototype a new programming language, Dodona, that manifests this paradigm using a primitive 'choose' representing nondeterministic choice.""
  - ""We introduce a new programming paradigm called oracle-guided decision programming in which a program specifies a Markov Decision Process (MDP) and the language provides a universal policy.""
  - ""Meta-interpreters query Dodona's (neural) oracle on these choicepoints to get policy and value estimates, which they can use to perform heuristic search on the underlying MDP.""
  - ""The Dodona interpreter returns either a value or a choicepoint that includes a lossless encoding of all information necessary in principle to make an optimal decision.""",,"- The abstract introduces a new programming paradigm called ""oracle-guided decision programming,"" which involves specifying a Markov Decision Process (MDP) and using a universal policy provided by the language. This suggests a focus on decision-making processes rather than generic programming or abstraction mechanisms.
 - The mention of the ""primitive 'choose' representing nondeterministic choice"" indicates a mechanism for handling uncertainty but does not directly relate to generic programming or abstraction.
 - The abstract discusses the use of meta-interpreters and a neural oracle for policy and value estimates, which is more related to decision-making and optimization rather than generic programming or abstraction.
 - There is no mention of generic programming methodology, type system discussions, or abstraction mechanism explanations in the abstract. The focus is on decision programming and MDPs rather than genericity or abstraction.","- ""We introduce a new programming paradigm called oracle-guided decision programming in which a program specifies a Markov Decision Process (MDP) and the language provides a universal policy.""
  - ""We prototype a new programming language, Dodona, that manifests this paradigm using a primitive 'choose' representing nondeterministic choice.""
  - ""The Dodona interpreter returns either a value or a choicepoint that includes a lossless encoding of all information necessary in principle to make an optimal decision.""
  - ""Meta-interpreters query Dodona's (neural) oracle on these choicepoints to get policy and value estimates, which they can use to perform heuristic search on the underlying MDP.""
  - ""We demonstrate Dodona's potential for zero-shot heuristic guidance by meta-learning over hundreds of synthetic tasks that simulate basic operations over lists, trees, Church datastructures, polynomials, first-order terms and higher-order terms.""",,"- The abstract introduces a ""new programming paradigm called oracle-guided decision programming,"" which is a novel insight as it combines the concept of Markov Decision Processes (MDPs) with programming languages.
 - The development of the ""Dodona"" programming language is a theoretical advancement as it provides a universal policy for MDPs, which is a unique contribution to programming language design.
 - The use of a ""primitive 'choose' representing nondeterministic choice"" and the ""Dodona interpreter"" returning ""a choicepoint that includes a lossless encoding of all information necessary in principle to make an optimal decision"" are theoretical innovations that enable efficient decision-making within the MDP framework.
 - The integration of meta-interpreters querying a neural oracle for policy and value estimates is a theoretical advancement that allows for heuristic search on MDPs, which is a new approach compared to existing methods.
 - The demonstration of ""zero-shot heuristic guidance by meta-learning over hundreds of synthetic tasks"" suggests potential implications for programming language design, as it shows the versatility and applicability of the Dodona paradigm across various tasks."