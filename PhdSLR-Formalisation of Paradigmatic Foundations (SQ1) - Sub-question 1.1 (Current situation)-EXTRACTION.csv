Sub-question 1.1 (Current situation),,,,,,,,,,,,,,,,,,,,,,,,,,
"What are the atomic concepts, defined as minimal and independent, that constitute the foundations of a programming paradigm, and how can they be formalised mathematically within a coherent framework to ensure their non-contradiction and orthogonality?",,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,,,,,,,
Title,Authors,DOI,DOI link,Venue,Citation count,Year,Type of Formalism/Taxonomy Developed,Conceptual Granularity and Analytical Approach,Limitations of Existing Classification Approaches,Validation Method for Classification System,Practical and Research Implications,Evidence for Formalism (Quotes),Evidence for Formalism (Tables),Formalism Analysis & Rationale,Evidence for Granularity (Quotes),Evidence for Granularity (Tables),Granularity Analysis & Rationale,Evidence for Limitations (Quotes),Evidence for Limitations (Tables),Limitations Analysis & Rationale,Evidence for Validation (Quotes),Evidence for Validation (Tables),Validation Analysis & Rationale,Evidence for Implications (Quotes),Evidence for Implications (Tables),Implications Analysis & Rationale
"On Functional Programming , Language Design , andPersistence",Claus Reinke,-,-,-,0,1998,No specific formalism developed (the abstract discusses principles for language design rather than a specific classification system),"Derived from theoretical derivation and literature review, using detailed feature-level analysis with concrete mappings of well-known languages, focusing on abstraction and correspondence principles.","- Inconsistent rules for name introduction and use complicate language descriptions.
 - Lack of uniform support for abstraction across all language objects.
 - Inadequate correlation between abstraction and correspondence in current taxonomies.
 - Insufficient consideration of design constraints like referential transparency and Church-Rosser property.","Validated through comparative analysis with existing languages (Pascal and S-Algol) and adherence to principles like abstraction, referential transparency, and Church-Rosser property.",Framework to guide the design of extensions to functional programming languages and facilitate high-level comparative studies of programming languages; Tool for characterizing languages that embody the virtues of functional programming; Potential impact on language design and comparative studies for researchers and educators.,"- ""The purpose of this process is to provide some number of partial problem-speci c views of a given object, each one simpler than the complete view because it temporarily disregards inessential details.""
  - ""the principle of abstraction demands language support for it.""
  - ""The principle of correspondence derives directly from Landin's work [Lan66], who pointed out that inconsistent rules for the introduction and use of names unnecessarily complicate the description of programming languages""
  - ""We do not require the problem-oriented specialities such as arithmetic operations to be de ned on all data types here4, but de ne the civil rights of data objects in programming languages as the right to participate in all services provided by the general language framework.""
  - ""The principles are strongly correlated: abstraction, which is explicitly required as a civil right for all language objects, is usually provided by giving names to details that are to be abstracted away in a partial program view.""
  - ""Therefore, we propose to take the principles as a starting point when searching for a characterization of functional programming languages.""
  - ""The principles are not restricted to languages that support only functions as basic units of programming, which is a very welcome property because it means that the principles can also guide the design of extensions to functional languages.""
  - ""Additional soundness constraints (most likely including CRP and RT) are necessary to get a complete characterization of languages that carry the virtues of functional programming beyond the domain of functions.""",,"- The abstract discusses the principles of abstraction and correspondence as key elements in the design of programming languages, particularly focusing on functional programming languages.
 - These principles are not explicitly described as a formal taxonomy or classification system but rather as guiding principles for language design.
 - The focus is on conceptual characteristics such as abstraction and correspondence, which are used to evaluate and design programming languages.
 - The scope includes functional programming languages and potentially extensions to these languages, but it does not specify a number of language categories or features covered.
 - The abstract does not mention a specific type of formalism like a feature model or taxonomy; instead, it emphasizes principles for language design.","- ""The purpose of this process is to provide some number of partial problem-speci c views of a given object, each one simpler than the complete view because it temporarily disregards inessential details.""
  - ""the principle of abstraction demands language support for it.""
  - ""The principle of correspondence derives directly from Landin's work [Lan66], who pointed out that inconsistent rules for the introduction and use of names unnecessarily complicate the description of programming languages""
  - ""We do not require the problem-oriented specialities such as arithmetic operations to be de ned on all data types here4, but de ne the civil rights of data objects in programming languages as the right to participate in all services provided by the general language framework.""
  - ""The principles are strongly correlated: abstraction, which is explicitly required as a civil right for all language objects, is usually provided by giving names to details that are to be abstracted away in a partial program view.""
  - ""The principles are not restricted to languages that support only functions as basic units of programming, which is a very welcome property because it means that the principles can also guide the design of extensions to functional languages.""
  - ""The language is basically an extended -calculus, including variables, multi-parameter abstractions and applications.""
  - ""The essential civil rights in this simple language relate to abstraction, which is allowed for all data objects.""",,"- The abstract discusses the concept of abstraction as a key principle in language design, indicating a deep level of conceptual analysis focused on how abstraction simplifies complex views by disregarding inessential details.
 - The principle of correspondence is derived from Landin's work, suggesting that the conceptual definitions are based on theoretical derivation and literature review.
 - The abstract mentions the definition of ""civil rights"" for data objects, which implies a specific conceptual dimension used for classification, focusing on the right to participate in all services provided by the general language framework.
 - The discussion of an extended lambda-calculus and the emphasis on abstraction for all data objects indicate a detailed feature-level analysis.
 - The abstract does not mention empirical analysis but relies on theoretical derivation and literature review for conceptual definitions.","- ""The principle of correspondence derives directly from Landin's work [Lan66], who pointed out that inconsistent rules for the introduction and use of names unnecessarily complicate the description of programming languages and mentioned that `any use of a user-coined name implicitly involves a functional relation'.""
  - ""To avoid irritating inconsistencies, a name introduced as a formal parameter (of a procedure or function) should correspond to a name introduced by a local declaration, meaning that the rules for using names should not depend on the way names have been introduced3.""
  - ""The principles are strongly correlated: abstraction, which is explicitly required as a civil right for all language objects, is usually provided by giving names to details that are to be abstracted away in a partial program view.""
  - ""By introducing additional design constraints such as referential transparency or Church-Rosser property, the class of admissible language designs can be further restricted to exclude designs that would invalidate these properties.""
  - ""The principle of correspondence, which explicitly deals with names, implicitly requires that every object that can be named by a declaration can also be passed as a parameter, partially overlapping with the principle of data type completeness.""",,"- The abstract discusses the principle of correspondence, which highlights inconsistencies in existing programming language classification methods. Specifically, it critiques the lack of consistency in how names are introduced and used in programming languages.
 - The principle of abstraction is also discussed as a limitation in existing approaches, as it is not always supported uniformly across all language objects.
 - The abstract suggests that current taxonomies may not adequately address the correlation between abstraction and correspondence, leading to inconsistencies in language design.
 - The mention of additional design constraints like referential transparency and Church-Rosser property implies that existing classification methods may not fully account for these important properties.
 - The abstract does not explicitly state limitations in existing classification approaches but implies them through the discussion of principles and their implications for language design.","- ""To demonstrate the application of the three language design principles in the domain of functional programming languages, we informally introduce a simple functional language and evaluate it with respect to these principles.""
  - ""The language is basically an extended -calculus, including variables, multi-parameter abstractions and applications.""
  - ""The essential civil rights in this simple language relate to abstraction, which is allowed for all data objects.""
  - ""These properties may not be surprising in themselves, but if we compare them with the inconsistencies found in the evaluation of Pascal [Ten77], or with the compromises made in the design of S-Algol [Mor79], we can conclude that the purely functional languages derived from the -calculus conform to the principles more strictly.""
  - ""It does not necessarily follow that languages designed according to the principles tend to be functional in nature6, but we conjecture that languages that are complete with respect to the principles also share many of the virtues of functional languages.""
  - ""By introducing additional design constraints such as referential transparency or Church-Rosser property, the class of admissible language designs can be further restricted to exclude designs that would invalidate these properties.""",,"- The abstract describes the validation process as involving the introduction of a simple functional language that is evaluated against the proposed principles.
 - The language is based on an extended lambda-calculus, which is a well-known formal system for functional programming.
 - The validation involves comparing the properties of this language with the inconsistencies found in other languages like Pascal and S-Algol, suggesting a form of comparative analysis.
 - The criteria for validation include the ability to support abstraction for all data objects and adherence to principles like referential transparency and the Church-Rosser property.
 - The abstract does not mention empirical testing or mapping to existing languages beyond the comparison with Pascal and S-Algol.","- ""The principles are not restricted to languages that support only functions as basic units of programming, which is a very welcome property because it means that the principles can also guide the design of extensions to functional languages.""
  - ""In the next section, we demonstrate that some starting set of language features (the changeable parts of the language design) can be embedded into a simple and general language framework by completing the language with respect to the principles.""
  - ""Additional soundness constraints (most likely including CRP and RT) are necessary to get a complete characterization of languages that carry the virtues of functional programming beyond the domain of functions.""
  - ""To demonstrate the application of the three language design principles in the domain of functional programming languages, we informally introduce a simple functional language and evaluate it with respect to these principles.""
  - ""we conjecture that languages that are complete with respect to the principles also share many of the virtues of functional languages.""
  - ""By introducing additional design constraints such as referential transparency or Church-Rosser property, the class of admissible language designs can be further restricted to exclude designs that would invalidate these properties.""",,"- The abstract discusses the application of language design principles to functional programming languages, indicating a focus on language design and comparative studies.
 - The principles are not limited to functional languages, suggesting they can be applied to extensions of these languages, which implies a practical application for language designers.
 - The mention of embedding language features into a general framework suggests a tool for facilitating high-level comparative studies of programming languages.
 - The abstract proposes using these principles to guide the design of extensions to functional languages, which could help programmers choose appropriate language concepts for problem-solving.
 - The discussion of additional soundness constraints implies a research application in characterizing languages that embody the virtues of functional programming.
 - The abstract does not explicitly mention intended user groups, but the focus on language design and comparative studies suggests it is aimed at researchers and educators in the field of programming languages."
A Semantics of Multiple Inheritance,L. Cardelli,10.1007/3-540-13346-1_2,https://doi.org/10.1007/3-540-13346-1_2,Information and Computation,1057,1984,"- Specific category of formalism: Formal semantics for multiple inheritance
 - Primary focus of the classification: Subtyping and type inclusion in object-oriented programming
 - Scope of the classification: Extends to union types and higher-order functional types","- Depth of conceptual analysis: Deep
 - Sources of conceptual definitions: Theoretical derivation, literature review (references to Simula and Smalltalk)
 - Specific conceptual dimensions or criteria used for classification: Definition of object-oriented programming, role of inheritance, distinction between single and multiple inheritance, implications on typechecking and polymorphism","- Controversy in defining object-oriented programming languages
 - Lack of clear criteria for classification due to independent features
 - Absence of subtype relation on objects
 - Limitations in inheritance typechecking due to lack of parametric polymorphism and side-effects
 - Gap in addressing parametric polymorphism
 - Confusion around polymorphism in languages like Smalltalk",Validated through theoretical proof of soundness of typechecking algorithm with respect to inference system and semantics; specific languages used include Galileo and Amber.,Framework for understanding and implementing multiple inheritance in programming languages; Tool for unifying functional and object-oriented programming; Basis for designing typechecking algorithms in strongly-typed languages; Potential application in database languages like Galileo and experimental languages like Amber; Research direction for integrating parametric polymorphism and multiple inheritance.,"- ""The aim of this paper is to present a clean semantics of multiple inheritance and to show that, in the context of strongly-typed, statically-scoped languages, a sound typechecking algorithm exists.""
  - ""Multiple inheritance is also interpreted in a broad sense: instead of being limited to objects, it is extended in a natural way to union types and to higher-order functional types.""
  - ""The definition of what makes a language object-oriented is still controversial. An examination of the differences between Simula, Smalltalk and other languages suggest that inheritance is the only notion critically associated with object-oriented programming.""
  - ""The subtype relation only holds on types, and there is no similar relation on objects.""
  - ""the subtype relation extends to higher types.""
  - ""The semantics of types is given in the weak ideal model [MacQueen 86] ℑ(V) (the set of nonempty left-closed subset of V which are closed under least upper bounds of increasing sequences and do not contain wrong).""
  - ""A subtyping relation can be defined syntactically on the structure of type expressions.""
  - ""the ordering of domains in the ℑ(V) model is set inclusion.""
  - ""The proof is by induction on the structure of τ and τ'.""
  - ""the inference system for our language. It is designed so that (1) it contains exactly one type rule for each syntactic construct; (2) it satisfies the intuitive subtyping property expressed by the syntactic subtyping theorem below; and (3) it satisfies a semantic soundness theorem, relating it to the semantics of the language.""
  - ""The basic syntactic property of this inference system is expressed in the syntactic subtyping theorem below: if an expression has a type τ, and τ is a subtype of τ', then the expression has also type τ'.""
  - ""The next theorem states the soundness of the type system with respect to the semantics: if it is possible to deduce that e has type τ, then the value denoted by e belongs to the domain denoted by τ.""","- ""(Page 7, Table 1) | type object | = | {age: int}  |
 \n|--------------|---|--------------------------------------|
 \n| type vehicle | = | {age: int, speed: int}  |""","- The paper primarily focuses on developing a formal semantics for multiple inheritance in programming languages, particularly in the context of object-oriented programming.
 - The formalism developed is centered around the concept of subtyping and type inclusion, which is a key feature of object-oriented programming.
 - The paper discusses the extension of multiple inheritance to union types and higher-order functional types, indicating a broad scope of application.
 - The use of the weak ideal model ℑ(V) and the definition of a subtyping relation on type expressions suggest a formal framework for understanding type relationships.
 - The inference system and typechecking algorithm are designed to ensure semantic soundness, indicating a focus on theoretical foundations.
 - The table on page 7 provides examples of type definitions and relationships, which are part of the formalism.","- ""The aim of this paper is to present a clean semantics of multiple inheritance and to show that, in the context of strongly-typed, statically-scoped languages, a sound typechecking algorithm exists.""
  - ""The first part of this paper is informal, and presents the basic notations and intuitions by means of examples.""
  - ""The second part is formal: it introduces a language, a semantics, a typeinference system and a typechecking algorithm.""
  - ""The algorithm is proved sound with respect to the inference system, and the inference system is proved sound with respect to the semantics""
  - ""The definition of what makes a language object-oriented is still controversial. An examination of the differences between Simula, Smalltalk and other languages suggest that inheritance is the only notion critically associated with object-oriented programming.""
  - ""The style of inheritance typechecking we have presented has a few unexpected aspects. These have to do with the lack of parametric polymorphism and with side-effects.""
  - ""The semantics of expressions is given in the recursively defined domain V of values.""
  - ""A subtyping relation can be defined syntactically on the structure of type expressions.""
  - ""The proof is by induction on the structure of τ and τ'.""
  - ""The typechecking algorithm is intentionally more restrictive than the type inference system; it is possible to deduce A.x:bool ∫ if x then {a=true} else {a=3} : {}, but in practice we want this to be a type error for the same reasons that made us rule out the anything type.""
  - ""This work originated as an attempt to justify the multiple inheritance constructs present in the Galileo data base language [Albano 85 ] and to provide a sound typechecking algorithm for that language.""
  - ""The Amber language [Cardelli 86 ] was then devised to experiment, among other things, with inheritance typechecking.""
  - ""Parametric polymorphism has not been treated in this paper. The intention was to study multiple inheritance problems in the cleanest possible framework, without interaction with other features.""","- ""(Page 7, Table 1) | type object | = | {age: int}  |
 \n|--------------|---|--------------------------------------|
 \n| type vehicle | = | {age: int, speed: int}  |""","- The paper provides a deep conceptual analysis by introducing a formal language, semantics, type inference system, and typechecking algorithm. This indicates a detailed and structured approach to understanding multiple inheritance.
 - The sources of conceptual definitions are primarily theoretical derivations, as evidenced by the formal introduction of a language and semantics. The paper also references existing languages like Simula and Smalltalk, suggesting some empirical analysis or literature review.
 - The specific conceptual dimensions or criteria used for classification include the definition of object-oriented programming, the role of inheritance, and the distinction between single and multiple inheritance. The paper also discusses the implications of these concepts on typechecking and polymorphism.
 - The methodology involves a combination of informal examples and formal proofs, indicating a comprehensive approach to conceptual analysis.
 - The paper's focus on providing a clean semantics and sound typechecking algorithm suggests a deep level of conceptual detail and analytical rigor.","- ""The definition of what makes a language object-oriented is still controversial.""
  - ""Coroutines, message-passing, static/dynamic scoping, typechecking and single/multiple superclasses are all fairly independent features which may or may not be present in languages which are commonly considered object-oriented.""
  - ""The subtype relation only holds on types, and there is no similar relation on objects.""
  - ""The style of inheritance typechecking we have presented has a few unexpected aspects. These have to do with the lack of parametric polymorphism and with side-effects.""
  - ""Inheritance typechecking has to be restricted to preserve soundness in presence of sideeffects.""
  - ""Parametric polymorphism has not been treated in this paper.""
  - ""Some confusion may arise from the fact that languages like Smalltalk are often referred to as polymorphic languages. This is correct, if by polymorphism we mean that an object or a function can have many types.""",,"- The paper discusses the controversy surrounding the definition of object-oriented programming languages, indicating a limitation in existing classification approaches.
 - It highlights that various features like coroutines, message-passing, and typechecking are independent and may or may not be present in object-oriented languages, suggesting a lack of clear criteria for classification.
 - The paper notes the absence of a subtype relation on objects, which could be seen as a limitation in current classification methods.
 - The discussion on the limitations of inheritance typechecking due to the lack of parametric polymorphism and side-effects suggests methodological limitations in handling these aspects.
 - The paper explicitly states that parametric polymorphism was not addressed, indicating a gap in existing approaches.
 - The confusion around polymorphism in languages like Smalltalk suggests a conceptual limitation in understanding and classifying polymorphic languages.","- ""The aim of this paper is to present a clean semantics of multiple inheritance and to show that, in the context of strongly-typed, statically-scoped languages, a sound typechecking algorithm exists.""
  - ""The implementation of multiple inheritance suggested by the semantics is very naïve, but does not preclude more sophisticated implementation techniques.""
  - ""The algorithm is proved sound with respect to the inference system, and the inference system is proved sound with respect to the semantics [Milner 78].""
  - ""This work originated as an attempt to justify the multiple inheritance constructs present in the Galileo data base language [Albano 85 ] and to provide a sound typechecking algorithm for that language.""
  - ""The Amber language [Cardelli 86 ] was then devised to experiment, among other things, with inheritance typechecking.""
  - ""The proof is by induction on the structure of the derivation of A ∫ e: τ, using the semantic subtyping and D D-properties theorems.""
  - ""The typechecking algorithm is intentionally more restrictive than the type inference system; it is possible to deduce A.x:bool ∫ if x then {a=true} else {a=3} : {}, but in practice we want this to be a type error for the same reasons that made us rule out the anything type.""",,"- The paper focuses on developing a formal semantics for multiple inheritance and a sound typechecking algorithm, which is a theoretical validation approach.
 - The validation is primarily theoretical, as it involves proving the soundness of the typechecking algorithm with respect to the inference system and the semantics.
 - The paper mentions the use of Galileo and Amber languages as part of the validation process, indicating that these languages were used to test or apply the proposed formalism.
 - The criteria for demonstrating validity include the soundness of the typechecking algorithm and the consistency of the inference system with the semantics.
 - The paper does not describe empirical testing or mapping to existing languages beyond the theoretical framework and the use of specific languages like Galileo and Amber.","- ""The aim of this paper is to present a clean semantics of multiple inheritance and to show that, in the context of strongly-typed, statically-scoped languages, a sound typechecking algorithm exists.""
  - ""Multiple inheritance is also interpreted in a broad sense: instead of being limited to objects, it is extended in a natural way to union types and to higher-order functional types. This constitutes a semantic basis for the unification of functional and object-oriented programming.""
  - ""The implementation of multiple inheritance suggested by the semantics is very naïve, but does not preclude more sophisticated implementation techniques.""
  - ""The style of inheritance typechecking we have presented has a few unexpected aspects. These have to do with the lack of parametric polymorphism and with side-effects.""
  - ""This work originated as an attempt to justify the multiple inheritance constructs present in the Galileo data base language [Albano 85 ] and to provide a sound typechecking algorithm for that language.""
  - ""The Amber language [Cardelli 86 ] was then devised to experiment, among other things, with inheritance typechecking.""
  - ""Parametric polymorphism has not been treated in this paper. The intention was to study multiple inheritance problems in the cleanest possible framework, without interaction with other features.""
  - ""the final goal is to achieve full integration of parametric polymorphism and multiple inheritance, merging functional programming with object-oriented programming at the semantic and typing levels; this problem is currently receiving much attention.""",,"- The paper aims to provide a clean semantics for multiple inheritance, which is a fundamental concept in object-oriented programming. This suggests a contribution to the theoretical understanding and design of programming languages.
 - The extension of multiple inheritance to union types and higher-order functional types indicates a potential application in unifying functional and object-oriented programming paradigms.
 - The paper discusses the implementation of multiple inheritance in strongly-typed, statically-scoped languages, which could influence language design and typechecking algorithms.
 - The mention of Galileo and Amber languages suggests practical applications in database languages and experimental programming languages.
 - The paper's focus on inheritance typechecking and its limitations with parametric polymorphism and side-effects implies potential research directions in these areas.
 - The ultimate goal of integrating parametric polymorphism and multiple inheritance suggests a broader impact on the development of programming languages and their theoretical foundations."
1 Kernel Andorra Prolog ( KAP ) : the language,-,-,-,-,0,2005,"Framework for nondeterministic concurrent constraint logic programming languages, combining Prolog and committed choice paradigms, with features like deep guards and three guard operators (wait, cut, and commit).","Detailed feature-level analysis with concrete mappings of well-known languages, using theoretical derivation and formal machinery to classify and analyze programming paradigms.",No limitations explicitly discussed,"Validated through mapping to existing languages such as Prolog, GtIC, Parlog, and Atomic Herbrand",Framework to facilitate high-level comparative studies of programming languages and influence language design by providing structured approaches to nondeterminism and parallelism.,"- ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""
  - ""Many languages, such as Prolog, GtIC, Parlog, and Atomic Herbrand, can be seen as instances of this framework, by adding specific constraint systems and constraint operations, and optionally by imposing further restrictions on the language and the control of the computation model.""
  - ""The semantics of Kernel Andorra Prolog is a set of or.trees which also captures infinite computations.""
  - ""Kernel Andorra Prolog is language framework that is specifically designed to combine the programming paradigms of Prolog and committed choice languages""
  - ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""Deep guards can *The visit at SICS of Catuscia Palamidessi, during which this work was carried out, has been supported by the project Andorra""",,"- The abstract describes Kernel Andorra Prolog as a ""framework for nondeterministic concurrent constraint logic programming languages,"" indicating that it is a classification system or formalism for programming languages.
 - The framework is designed to combine programming paradigms, specifically Prolog and committed choice languages, suggesting that the primary focus is on integrating different programming paradigms.
 - The framework includes specific constraint systems and operations, as well as deep guards with three guard operators, which are features of the classification.
 - The scope of the classification includes several languages such as Prolog, GtIC, Parlog, and Atomic Herbrand, which are instances of this framework.
 - The abstract does not explicitly mention a taxonomy or feature model, but it describes a framework that classifies languages based on their ability to combine programming paradigms and utilize specific features like deep guards.","- ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""In general, the machinery of deep guards is necessary in nondeterministic languages, for selecting a single solution, or collecting all solutions for a given goal.""
  - ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""
  - ""To this we add a formal description of the transformational semantics of Kernel Andorra Prolog.""
  - ""The semantics of Kernel Andorra Prolog is a set of or.trees which also captures infinite computations.""",,"- The abstract describes Kernel Andorra Prolog as a framework for nondeterministic concurrent constraint logic programming languages, indicating a deep conceptual analysis of programming paradigms.
 - The mention of revisiting and adding formal machinery suggests a theoretical derivation approach, as it involves formalizing existing descriptions and adding new formal elements.
 - The use of ""systematically revisit"" implies a structured and detailed approach to conceptual analysis, indicating a deep level of analysis.
 - The abstract references specific conceptual dimensions such as ""deep guards"" and ""three guard operators,"" which are used for classification and analysis.
 - The mention of ""transformational semantics"" and ""or.trees"" suggests a detailed feature-level analysis, as these are specific conceptual tools used to describe the language framework.","- ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""
  - ""Many languages, such as Prolog, GtIC, Parlog, and Atomic Herbrand, can be seen as instances of this framework, by adding specific constraint systems and constraint operations, and optionally by imposing further restrictions on the language and the control of the computation model.""
  - ""The semantics of Kernel Andorra Prolog is a set of or.trees which also captures infinite computations.""
  - ""Kernel Andorra Prolog is language framework that is specifically designed to combine the programming paradigms of Prolog and committed choice languages [HJ91], allowing fully general combinations.""
  - ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""In general, the machinery of deep guards is necessary in nondeterministic languages, for selecting a single solution, or collecting all solutions for a given goal.""
  - ""In particular the generalization to deep guards is essential to achieve the goal of simultaneously subsuming Prolog and exploiting independent and dependent parallelism.""",,"- The abstract discusses Kernel Andorra Prolog as a framework that encompasses various programming languages by adding specific constraint systems and operations. This suggests a focus on the framework's capabilities rather than limitations of existing classification approaches.
 - The abstract mentions revisiting and formalizing the control of the computation model, which implies an improvement or extension rather than a critique of existing methods.
 - The discussion of deep guards and their necessity in nondeterministic languages highlights a feature of the framework rather than a limitation of existing classification methods.
 - There is no explicit mention of limitations or critiques of current taxonomies or classification methods in the abstract.","- ""Many languages, such as Prolog, GtIC, Parlog, and Atomic Herbrand, can be seen as instances of this framework, by adding specific constraint systems and constraint operations, and optionally by imposing further restrictions on the language and the control of the computation model.""
  - ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""Deep guards can *The visit at SICS of Catuscia Palamidessi, during which this work was carried out, has been supported by the project Andorra""",,"- The abstract mentions that many languages can be seen as instances of the Kernel Andorra Prolog framework by adding specific constraint systems and operations. This suggests a form of validation through mapping to existing languages.
 - The abstract does not explicitly mention empirical testing or specific criteria used to demonstrate validity.
 - The focus is on formalizing the control of the computation model and describing the transformational semantics, which implies a theoretical validation approach rather than empirical testing.
 - The mention of revisiting and formalizing existing descriptions suggests a theoretical validation method rather than empirical testing.","- ""Kernel Andorra Prolog is a framework for nondeterministic concurrent constraint logic programming languages.""
  - ""The proposed family of languages are guarded definite clause languages, with deep guards, and three guard operators (wait, cut, and commit).""
  - ""Many languages, such as Prolog, GtIC, Parlog, and Atomic Herbrand, can be seen as instances of this framework, by adding specific constraint systems and constraint operations, and optionally by imposing further restrictions on the language and the control of the computation model.""
  - ""Deep guards can *The visit at SICS of Catuscia Palamidessi, during which this work was carried out, has been supported by the project Andorra""",,"- The abstract describes Kernel Andorra Prolog as a framework for nondeterministic concurrent constraint logic programming languages, which suggests it has implications for language design and comparative studies.
 - The mention of various languages (Prolog, GtIC, Parlog, Atomic Herbrand) being instances of this framework indicates potential applications in facilitating comparative studies among these languages.
 - The introduction of deep guards and guard operators (wait, cut, and commit) implies a contribution to language design by providing a structured approach to handling nondeterminism and parallelism.
 - The abstract does not explicitly mention intended user groups or specific use cases, but the framework's nature suggests it could be useful for researchers and educators in the field of programming languages.
 - The potential impact on language design is evident from the framework's ability to subsume Prolog and exploit parallelism, which could influence future language development."
Programming Paradigms and Beyond,"S. Krishnamurthi, Kathi Fisler",10.1017/9781108654555.014,https://doi.org/10.1017/9781108654555.014,The Cambridge Handbook of Computing Education Research,47,2019,No specific formalism developed (the abstract suggests the use of notional machines and operational semantics but does not specify a detailed classification system),"Derived from literature-based conceptual mapping, focusing on notional machines and operational semantics, with a deep analysis of programming language concepts like state.",Existing classification approaches are based on ill-defined and confusing concepts of 'paradigms'.,No formal validation described,"- Intended user groups: Educators and researchers in computer science
 - Specific use cases or potential applications: Tool for facilitating high-level comparative studies of programming languages; framework to improve understanding and organization of programming languages
 - Potential impact on language design or comparative studies: Improved understanding of concepts like state; identification of open problems for future research","- ""It identifies and provides context for numerous open problems worthy of research focus, some of which are new twists on long-running debates while others have not received the attention in the literature that they deserve.""
  - ""It introduces or re-examines several concepts in programming and languages, especially state, whose complexity is understood well in the programming languages literature but is routinely overlooked in computing education.""
  - ""This chapter suggests the use of notional machines, i.e., human-accessible operational semantics, as a central organizing concept for understanding languages.""",,"- The abstract mentions the use of ""notional machines"" as a central organizing concept for understanding languages. This suggests a focus on operational semantics as a way to classify or organize programming languages.
 - The mention of ""human-accessible operational semantics"" implies a formalism that is designed to be understandable by humans, which could be a type of taxonomy or classification framework.
 - The abstract does not specify a particular category of formalism like a feature model or a taxonomy with a specific number of language categories or features covered. It focuses on the concept of notional machines and operational semantics rather than a detailed classification system.
 - The abstract does not provide details on the scope of the classification or the number of language categories or features covered, which are typically expected in a formalism or taxonomy.","- ""It introduces or re-examines several concepts in programming and languages, especially state, whose complexity is understood well in the programming languages literature but is routinely overlooked in computing education.""
  - ""It identifies and provides context for numerous open problems worthy of research focus, some of which are new twists on long-running debates while others have not received the attention in the literature that they deserve.""
  - ""This chapter suggests the use of notional machines, i.e., human-accessible operational semantics, as a central organizing concept for understanding languages.""",,"- The abstract mentions the use of ""notional machines"" and ""human-accessible operational semantics"" as a central organizing concept. This suggests a deep level of conceptual analysis, as it involves operational semantics, which is a detailed and formal way of describing how programming languages work.
 - The abstract indicates that the chapter ""introduces or re-examines several concepts,"" which implies a detailed feature-level analysis. The focus on ""state"" and its complexity suggests a nuanced understanding of programming language concepts.
 - The abstract does not explicitly mention empirical analysis or theoretical derivation as sources of conceptual definitions. However, it does imply a literature-based approach by referencing the ""programming languages literature"" and ""long-running debates,"" indicating that the conceptual definitions are derived from a review of existing literature.
 - The specific conceptual dimensions or criteria used for classification are not explicitly listed in the abstract, but the focus on ""notional machines"" and ""state"" suggests that these are key dimensions in the classification system.","- ""much of the community lacks useful tools to understand and organize languages, since the standard literature is mired in the ill-defined and even confusing concept of paradigms.""",,"- The abstract mentions that the standard literature is ""mired in the ill-defined and even confusing concept of paradigms."" This suggests a limitation in existing classification approaches, as they are based on concepts that are not well-defined or are confusing.
 - The abstract does not provide specific critiques of current taxonomies or classification methods beyond the mention of the paradigm concept being ill-defined and confusing.
 - The abstract does not explicitly mention proposed improvements or alternative approaches, but it does suggest the use of ""notional machines"" as a central organizing concept, which could be seen as an alternative approach to understanding languages.","- ""It identifies and provides context for numerous open problems worthy of research focus, some of which are new twists on long-running debates while others have not received the attention in the literature that they deserve.""
  - ""It introduces or re-examines several concepts in programming and languages, especially state, whose complexity is understood well in the programming languages literature but is routinely overlooked in computing education.""
  - ""This chapter suggests the use of notional machines, i.e., human-accessible operational semantics, as a central organizing concept for understanding languages.""",,"- The abstract discusses the use of notional machines as a central organizing concept for understanding programming languages, which implies a theoretical or conceptual approach rather than an empirical validation method.
 - There is no mention of any specific validation approach, such as mapping to existing languages or empirical testing, in the abstract.
 - The abstract does not specify any particular languages or examples used in validation.
 - There are no criteria mentioned for demonstrating validity.
 - The focus of the abstract is on introducing concepts and identifying open problems rather than on validating a classification system.","- ""It introduces or re-examines several concepts in programming and languages, especially state, whose complexity is understood well in the programming languages literature but is routinely overlooked in computing education.""
  - ""It identifies and provides context for numerous open problems worthy of research focus, some of which are new twists on long-running debates while others have not received the attention in the literature that they deserve.""
  - ""Programming is a central concern of computer science, so its medium—programming languages—should be a focus of computing education.""
  - ""much of the community lacks useful tools to understand and organize languages, since the standard literature is mired in the ill-defined and even confusing concept of paradigms.""
  - ""This chapter suggests the use of notional machines, i.e., human-accessible operational semantics, as a central organizing concept for understanding languages.""",,"- The abstract suggests that the focus of the chapter is on improving the understanding and organization of programming languages, which implies a practical application for educators and researchers.
 - The use of ""notional machines"" as a central organizing concept could serve as a tool for facilitating high-level comparative studies of programming languages, which would be beneficial for researchers and educators.
 - The re-examination of concepts like state could help in language design by providing a clearer understanding of these concepts, which are often overlooked in computing education.
 - The identification of open problems suggests potential research applications, as these problems could be the focus of future studies.
 - The abstract does not explicitly mention specific user groups or use cases, but the context implies that the intended users are likely educators and researchers in the field of computer science."
PROGRAMMING PARADIGMS IN HIGHER EDUCATION,"L. Gorodnyaya, T. Andreyeva",10.31144/BNCC.CS.2542-1972.2015.N38.P67-90,https://doi.org/10.31144/BNCC.CS.2542-1972.2015.N38.P67-90,-,0,2015,"Taxonomy of programming paradigms based on implementation pragmatics, focusing on low-level coding, high-level programming, and very high-level languages, with an emphasis on memory management and semantic basis.","Derived from theoretical derivation and literature review, using detailed feature-level analysis with concrete mappings of well-known languages and paradigms, focusing on operational semantics and implementation pragmatics.","- Ambiguous classification of programming means due to multiple paradigm affiliations.
 - Difficulty in defining clear criteria and boundaries for successful application.
 - Tendency to stick with familiar programming means and methods, hindering adoption of new paradigms.",No formal validation described (the paper discusses a theoretical framework for classification but does not mention empirical testing or concrete mappings to existing languages),"- Tool for facilitating high-level comparative studies of programming languages
 - Framework to help programmers choose appropriate language concepts for problem-solving
 - Educational resource for teaching complex computational models and parallel programming
 - Research framework for developing parallel programming paradigms and tools","- ""The paper concerns a topical problem of System Informatics, namely, the study and development of the methods of analysis, comparison and formal deﬁ-nition of the programming paradigms.""
  - ""The programming styles and languages characteristic to the paradigms under consideration reflect the evolution of the programming technologies (PTs) used for solving problems in System and Applied Informatics:""
  - ""Different approaches to information processing that were formed and accumulated while creating and applying the programming languages and systems are called programming paradigms.""
  - ""To classify PPs, it is important to define the smallest educational implementation kernel. As a result, the set of all PLs can be split into the classes of implementationally similar and substantially comparable languages having the same (or, to be more exact, equivalent) semantic basis.""
  - ""The analysis of PPs is based on implementation pragmatics (IP). IP affects all levels of the PL definition, but mainly represents solutions in a certain memory management.""
  - ""The main characteristic of low-level coding is the hardware approach to computer management, aimed at the access to any hardware resources.""
  - ""High-level programming allows the definition of data structures that reflect the nature of a problem to be solved and actively uses the domain hierarchy of data structures and their processing procedures.""
  - ""Programming in very high-level languages is aimed at the representation of regular, effectively implementable data structures whose processing allows transformations of data and program representation, use of similarities and constructions that guarantee high computing productivity and reliability of the development of programs fitted for variations of architecture solutions.""
  - ""The main difficulty in shifting to new programming paradigms is the lure of an easy-way, the tendency to simulate quickly the accustomed programming means and methods.""
  - ""The main way to study PPs in practice suggests studying several PLs referring to them. These languages may be educational [50] and, at best, monoparadigmal.""",,"- The paper focuses on the study and development of methods for analyzing and comparing programming paradigms, indicating a classification system or formalism for these paradigms.
 - The classification system is based on the concept of ""implementation pragmatics,"" which involves categorizing programming languages by their memory management solutions and semantic basis.
 - The paper describes different levels of programming paradigms, such as low-level coding, high-level programming, and very high-level languages, each with distinct characteristics and focuses.
 - The classification system involves identifying the smallest educational implementation kernel to group languages into classes with equivalent semantic bases.
 - The paper does not explicitly mention a specific number of paradigms or a detailed taxonomy but emphasizes the importance of understanding and classifying these paradigms for effective programming education.","- ""The paper concerns a topical problem of System Informatics, namely, the study and development of the methods of analysis, comparison and formal deﬁ-nition of the programming paradigms.""
  - ""The programming styles and languages characteristic to the paradigms under consideration reflect the evolution of the programming technologies (PTs) used for solving problems in System and Applied Informatics:""
  - ""Programming paradigms were the central point of the 1978 ACM Turing Award Lecture by Robert Floyd, where he drew attention to the importance of this concept in the context of programmers' training""
  - ""The study and clear classification of the already existing and new PPs must help to reasonably choose and design computer languages while forming programming projects and developing IT""
  - ""The evolution of PPs reflects the usability of language concepts and implementation structures availed in creating complex programming systems.""
  - ""To classify PPs, it is important to define the smallest educational implementation kernel.""
  - ""The analysis of PPs is based on implementation pragmatics (IP).""
  - ""Implementation pragmatics is a specification of operational semantics, starting from four main semantic systems (monads): data procession, data storage, data structure, and data processing control in programming systems.""
  - ""The main characteristic of low-level coding is the hardware approach to computer management, aimed at the access to any hardware resources.""
  - ""High-level programming allows the definition of data structures that reflect the nature of a problem to be solved and actively uses the domain hierarchy of data structures and their processing procedures.""
  - ""Programming in very high-level languages is aimed at the representation of regular, effectively implementable data structures whose processing allows transformations of data and program representation, use of similarities and constructions that guarantee high computing productivity and reliability of the development of programs fitted for variations of architecture solutions.""
  - ""The main difficulty in shifting to new programming paradigms is the lure of an easy-way, the tendency to simulate quickly the accustomed programming means and methods.""
  - ""The main way to study PPs in practice suggests studying several PLs referring to them.""
  - ""The practical part of the course focuses on studying the parallel PP and the functional PP.""",,"- The paper provides a deep conceptual analysis of programming paradigms, focusing on their evolution, classification, and practical application in programming languages and systems.
 - The sources of conceptual definitions are rooted in theoretical derivation and literature review, as indicated by references to Robert Floyd's work and the evolution of programming technologies.
 - The paper uses specific conceptual dimensions for classification, such as the distinction between low-level, high-level, and very high-level programming paradigms, and the role of implementation pragmatics in defining operational semantics.
 - The analysis is detailed, with a focus on the operational semantics and implementation pragmatics, indicating a deep level of conceptual detail.
 - The paper discusses the practical application of these paradigms in educational settings, suggesting a comprehensive approach to understanding and teaching programming paradigms.","- ""The evolution of PPs reflects the usability of language concepts and implementation structures availed in creating complex programming systems. It must be said that the vogue rate of PLs differs from the rate of PLs availed in successful projects.""
  - ""Some difficulties in the research into PPs arise from the ambiguous classification of programming means. Many languages refer to several paradigms; sometimes, a language is unreasonably affiliated with a vogue paradigm.""
  - ""That is why we not only compare paradigms by DSs and admissible means of their processing but also take into consideration the criteria and boundaries of their successful application.""
  - ""The analysis of PPs is based on implementation pragmatics (IP). IP affects all levels of the PL definition, but mainly represents solutions in a certain memory management.""
  - ""PLs that share an IP are implementationally equivalent and comparable in terms of the laboriousness of PS implementation.""
  - ""The main difficulty in shifting to new programming paradigms is the lure of an easy-way, the tendency to simulate quickly the accustomed programming means and methods.""",,"- The paper discusses the challenges in classifying programming paradigms due to the ambiguous nature of how languages are associated with paradigms. This is a limitation because it makes it difficult to clearly define and categorize paradigms.
 - The paper highlights that many languages can belong to multiple paradigms, which complicates the classification process. This is a conceptual limitation as it challenges the idea of a clear taxonomy.
 - The paper suggests that current classification methods may not adequately consider the criteria and boundaries of successful application, which is a methodological limitation.
 - The focus on implementation pragmatics (IP) as a basis for comparison indicates a shift towards a more nuanced understanding of paradigms, but this also highlights the complexity and variability in how paradigms are implemented.
 - The tendency to stick with familiar programming means and methods is identified as a difficulty in adopting new paradigms, which is a limitation in terms of educational and practical implementation.","- ""To classify PPs, it is important to define the smallest educational implementation kernel. As a result, the set of all PLs can be split into the classes of implementationally similar and substantially comparable languages having the same (or, to be more exact, equivalent) semantic basis.""
  - ""The analysis of PPs is based on implementation pragmatics (IP). IP affects all levels of the PL definition, but mainly represents solutions in a certain memory management.""
  - ""PLs that share an IP are implementationally equivalent and comparable in terms of the laboriousness of PS implementation.""
  - ""The main characteristic of low-level coding is the hardware approach to computer management, aimed at the access to any hardware resources.""
  - ""High-level programming allows the definition of data structures that reflect the nature of a problem to be solved and actively uses the domain hierarchy of data structures and their processing procedures.""
  - ""Programming in very high-level languages is aimed at the representation of regular, effectively implementable data structures whose processing allows transformations of data and program representation, use of similarities and constructions that guarantee high computing productivity and reliability of the development of programs fitted for variations of architecture solutions.""
  - ""The comparative description of the exploitational and the implementational pragmatics of the main paradigms results in the following method of the definition of a PL's paradigm:""
  - ""The semantic basis definition: decomposition of the language into fragments in order to define the basic means of the language and its implementation kernel.""
  - ""The normalized definition: determination of the language's AM formally sufficient for building extensions equivalent to the initial language.""
  - ""Comparison of the obtained definition with the descriptions of the known paradigms and conceptual languages.""
  - ""Determination of the language level and its place in the life cycle of programs and programmers' activities (goals and tasks) and also of the base languages exploited for its design and implementation as recommendations for the selection and application of the PL and its PS.""",,"- The paper discusses the classification of programming paradigms (PPs) based on their implementation pragmatics (IP), which involves defining the smallest educational implementation kernel and splitting languages into classes based on their semantic basis.
 - The validation approach seems to involve a theoretical framework where languages are compared based on their implementation pragmatics and semantic basis.
 - Specific languages are not explicitly mentioned as being used in validation, but the paper discusses various paradigms such as low-level coding, high-level programming, and very high-level languages.
 - Criteria for validity include the ability to define a language's semantic basis, determine its implementation kernel, and compare it with known paradigms.
 - The paper does not mention empirical testing or mapping to existing languages as a validation method.","- ""The study and clear classification of the already existing and new PPs must help to reasonably choose and design computer languages while forming programming projects and developing IT""
  - ""The analysis of PPs is based on implementation pragmatics (IP). IP affects all levels of the PL definition, but mainly represents solutions in a certain memory management.""
  - ""The main difficulty in shifting to new programming paradigms is the lure of an easy-way, the tendency to simulate quickly the accustomed programming means and methods.""
  - ""the expansion and evolution of the system of base concepts necessary for the rational development of the process management systems on mod-ern hardware result in an urgent need to form the parallel programming paradigm (PPP)""
  - ""The aim of the design of an educational programming language intended for teaching complex computational models and parallel programming is to select mechanisms supporting experiments in designing new programs, languages and paradigms oriented towards educational research projects in the field of distributed information systems.""
  - ""Educational experiments should cultivate a habit to use program verification methods since without these program reliability and program capability are questionable.""",,"- The paper suggests that the classification system for programming paradigms (PPs) is intended to help in the design and selection of computer languages for programming projects and IT development. This implies a practical application for practitioners and researchers in choosing appropriate languages for specific tasks.
 - The focus on implementation pragmatics (IP) indicates that the classification system can be used to analyze and compare different programming languages based on their memory management solutions, which is useful for both practitioners and researchers.
 - The mention of the need to form a parallel programming paradigm (PPP) suggests a research implication in developing new concepts and tools for parallel computing, which is relevant for researchers and educators.
 - The paper discusses the design of an educational programming language for teaching parallel programming, indicating an educational application for students and educators.
 - The emphasis on cultivating habits to use program verification methods suggests a practical implication for ensuring program reliability and capability, which is relevant for practitioners and educators."
Dagstuhl Seminar Expressiveness in Concurrency,"R. Nicola, U. Goltz, F. Vaandrager",-,-,-,0,2008,No specific formalism developed (the abstract discusses the need for a systematic study and comparison but does not specify a developed formalism or taxonomy),"Detailed feature-level analysis with a focus on interconnections between programming concepts, constructs, models, and logics; theoretical derivation with a general framework for comparing formal methods across paradigms; specific dimensions include communication primitives, nondeterministic choice, causal and temporal dependencies, and semantic approaches.","- The problem of relative expressive power has rarely been addressed systematically.
 - Lack of systematic and formal comparison in existing approaches.
 - Current classification methods may not be adequate or formal enough for classifying programming languages.
 - Existing frameworks or methods are not comprehensive or generalizable enough.",No formal validation described,"- Intended user groups: Practitioners, researchers, educators
 - Specific use cases or potential applications: Tool for facilitating high-level comparative studies of programming languages; framework to help programmers choose appropriate language concepts for problem-solving
 - Potential impact on language design or comparative studies: Classification system for programming languages; general framework for comparing formal methods; focus on process algebras and other semantic models for concurrent systems design","- ""the main research objectives of computer science is the development of formal methods for the design and implementation of programming languages.""
  - ""the problem of the relative expressive power of the various programming concepts has rarely been addressed systematically.""
  - ""A systematic study and a formal comparison is even more needed in the case of formalisms for programming or specifying parallel and distributed systems.""
  - ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""
  - ""The seminar gave the possibility to compare results of the project with related approaches.""
  - ""The different talks and the lively discussion offered the occasion for comparing specification and verification methods, developed various programming paradigms, and threw light on: • the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external); • the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems), • the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""",,"- The abstract discusses the development of formal methods for programming languages, particularly focusing on the expressive power of various programming concepts.
 - It mentions the need for a systematic study and formal comparison of formalisms for parallel and distributed systems, indicating a focus on classification or taxonomy.
 - The main aim of the seminar was to understand interconnections between programming concepts, constructs, models, and logics, which suggests a framework for comparison.
 - The final objective is to define a general framework for comparing formal methods across programming paradigms, with a focus on process algebras.
 - The abstract does not explicitly mention a specific type of formalism or taxonomy developed but indicates a focus on comparing formal methods and understanding their interconnections.","- ""the problem of the relative expressive power of the various programming concepts has rarely been addressed systematically.""
  - ""A systematic study and a formal comparison is even more needed in the case of formalisms for programming or specifying parallel and distributed systems.""
  - ""The main aim of the seminar, organized within the program of the HCM-network EXPRESS, was a better understanding of the interconnections and relations between programming concepts, constructs, models and logics for concurrent specification and implementation languages.""
  - ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""
  - ""The seminar gave the possibility to compare results of the project with related approaches.""
  - ""the lively discussion offered the occasion for comparing specification and verification methods, developed various programming paradigms, and threw light on: • the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external); • the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems), • the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""",,"- The abstract indicates a systematic study and formal comparison of programming concepts, suggesting a deep level of conceptual analysis.
 - The focus on understanding interconnections and relations between programming concepts, constructs, models, and logics implies a detailed feature-level analysis.
 - The mention of a general framework for comparing formal methods across programming paradigms suggests a comprehensive approach to classification.
 - The discussion on specific dimensions such as communication primitives, nondeterministic choice, causal and temporal dependencies, and different semantic approaches indicates a nuanced analysis of conceptual dimensions.
 - The abstract does not explicitly mention sources of conceptual definitions, but the context suggests a theoretical derivation and possibly a literature review given the focus on formal methods and comparison of existing approaches.","- ""the problem of the relative expressive power of the various programming concepts has rarely been addressed systematically.""
  - ""A systematic study and a formal comparison is even more needed in the case of formalisms for programming or specifying parallel and distributed systems.""
  - ""This study is indispensable for classifying the different programming languages and for providing a formal basis for design principles and implementation techniques of concurrent and/or distributed programming languages.""
  - ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""",,"- The abstract mentions that the problem of relative expressive power has ""rarely been addressed systematically,"" which implies a limitation in existing approaches to classification.
 - It highlights the need for a ""systematic study and a formal comparison,"" suggesting that current methods lack systematic and formal approaches to comparing programming concepts.
 - The abstract states that such a study is ""indispensable for classifying the different programming languages,"" indicating that current classification methods may not be adequate or formal enough.
 - The objective of defining a ""general framework for the comparison of the formal methods"" suggests that existing frameworks or methods are not comprehensive or generalizable enough.","- ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""
  - ""The program of the seminar was intense and stimulating; it comprised 30 talks, the abstracts of which are recorded in this report in alphabetical order.""
  - ""The different talks and the lively discussion offered the occasion for comparing specification and verification methods, developed various programming paradigms, and threw light on: • the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external); • the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems), • the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""
  - ""The seminar gave the possibility to compare results of the project with related approaches.""
  - ""The main aim of the seminar, organized within the program of the HCM-network EXPRESS, was a better understanding of the interconnections and relations between programming concepts, constructs, models and logics for concurrent specification and implementation languages.""",,"- The abstract discusses the main aim of the seminar as understanding interconnections between programming concepts and developing a framework for comparing formal methods. However, it does not explicitly mention any validation method for a classification system.
 - The abstract mentions comparing results with related approaches and discussing various semantic models, but it does not specify any concrete validation approach such as mapping to existing languages or empirical testing.
 - There is no mention of specific languages or examples used in validation or criteria used to demonstrate validity.
 - The abstract focuses on the seminar's objectives and discussions rather than on a specific validation process for a classification system.","- ""The different talks and the lively discussion offered the occasion for comparing specification and verification methods, developed various programming paradigms, and threw light on: • the primitives for communication (synchronous vs asynchronous) and nondetermin-istic choice (internal vs external); • the different stress on causal and temporal dependencies offered by the various semantic models (process algebras, Petri nets, modal logics, rewrite systems), • the relative merits of the different approaches to concurrent systems semantics (algebraic , axiomatic, operational, denotational).""
  - ""The seminar gave the possibility to compare results of the project with related approaches.""
  - ""The final objective of the project is the definition of a general framework for the comparison of the formal methods for specification and verification developed within the various programming paradigms, in particular with a focus on process algebras.""
  - ""This study is indispensable for classifying the different programming languages and for providing a formal basis for design principles and implementation techniques of concurrent and/or distributed programming languages.""",,"- The abstract mentions that the study aims to classify different programming languages, which implies a practical application for practitioners and researchers in understanding and choosing appropriate languages.
 - The development of a ""general framework for the comparison of the formal methods"" suggests a tool for facilitating high-level comparative studies of programming languages, which would be useful for researchers and educators.
 - The focus on process algebras and other semantic models indicates potential applications in language design, as these models are crucial for specifying and verifying concurrent systems.
 - The discussion on communication primitives and nondeterministic choice highlights potential use cases in designing concurrent systems with specific communication needs.
 - The comparison of different approaches to concurrent systems semantics suggests a framework to help programmers choose appropriate language concepts for problem-solving."
On Systematization of Programming Paradigms by Decision-Making Priorities,L. Gorodnyaya,10.26907/1562-5419-2020-23-4-666-696,https://doi.org/10.26907/1562-5419-2020-23-4-666-696,Russian Digital Libraries Journal,2,2020,"Taxonomy of programming paradigms with relational mapping, focusing on primary, derivative, combined, auxiliary, and system-forming paradigms, covering various semantic characteristics and problem-solving approaches.","Derived from a detailed analysis of well-known programming paradigms, using literature-based conceptual mapping with specific criteria for program quality and decision-making priorities.","- Lack of detailed information on inherited paradigm properties and predecessor features in current language descriptions.
 - Current descriptions do not show what is new or inherited, lacking depth in classification.
 - Proposed improvement: Systematization based on problem statements and semantic characteristics.","Validated through analysis and comparison of a large number of programming languages across different levels, with a focus on expressing paradigmatic specificity and evaluating complexity and laboriousness of programming.",Framework for evaluating complexity and effort in programming tasks; Tool for facilitating high-level comparative studies of programming languages; Guide for language design by identifying key characteristics and priorities.,"- ""The article presents the results of the analysis of the most well-known programming paradigms and outlines an approach to navigation in the modern expanding space of programming languages, based on the classification of paradigms on the peculiarities of problem statements and semantic characteristics of programming languages and systems with an emphasis on the criteria for the quality of programs and priorities in decision-making in their implementation.""
  - ""Наиболее ясная систематизация ПП в настоящее время позволяет выделять основные и производные ПП, дополненные комбинированными, вспомогательными и системообразующими или перспективно-стратегическими.""
  - ""Предложенную систематизацию ПП можно использовать при оценке сложности и трудоёмкости программирования, особенно если дополнить более ясным разделением требований к постановкам задач по сферам применения на академические и производственные, а по уровню изученности -на точные, развиваемые и усложнённые трудно удостоверяемыми требованиями.""
  - ""Основные (базовые, расширяющие и неограниченные) ПП можно различать по упорядочению категорий семантических систем и обрабатываемых данных, производные -по отличию от исходной парадигмы, вспомогательные -по областям приложения, комбинированные -по составляющим парадигмам.""","- ""(Page 4, Table 1) | год | ЯП | Предшественники²  | Поддержанные парадигмы  |
 \n|-----|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
 \n| 2018| Dart | Java, JavaScript, CoffeeScript, Go  | объектно-ориентированный, каркас веб-приложений, сценарный язык, императивный, рефлективный, функциональный |""
  - ""<table_quotation page_num=6 table_on_page=1>```
 | Год | ЯП | Поддержанные парадигмы | Сфера влияния  |
 |------|---------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | 1954 | Fortran, Algol-60 ³ | императивный<br>параллельный<br>процедурный<br>модульный<br>структурный<br>процедурный<br>обобщённый<br>объектно-ориентированный | ИПП – императивно-процедурное<br>ALGOL 58,<br>BASIC,<br>C,<br>Chapel, CMS-2, Fortress,<br>PL/I,<br>PACT I,<br>MUMPS, IDL, Ratfor  |
 | 1958 | Lisp | экспериментальный<br>функциональный<br>объектно-ориентированный<br>процедурный<br>рефлективный<br>метапрограммирование  | ФП – функциональное<br>Clips, Common lisp, CLOS, Clu, Dylan, Forth, Scheme,<br>Erlang, Haskell, Logo, Lua, Perl, POP-2, Python, Ruby,<br>Cmucl, Scala, ML, Swift, Smalltalk, Factor, Clojure,<br>Emacs Lisp, Eulisp, ISLISP, Wolfram Language |
 | 1960 | APL  | векторный<br>функциональный<br>структурный<br>модульный  | ПВ – параллельные вычисления<br>A, A+,<br>FP, J, K, LyaPAS, Nial, S,<br>MATLAB, PPL, Wolfram Language |
 | 1962 | Simula 67  | объектно-ориентированный | ООП (1980) – объектно-ориентированное  |
 | 1968 | Forth⁴ | императивный<br>стек-ориентированный  | Factor, RPL, REBOL, PostScript, Factor<br>и другие конкатенативные языки ⁵  |
 | 1968 | Algol-68⁶  | параллельный<br>императивный | C, C++, Bome shell, KornShell, Bash,<br>Steelman, Ada, Python, Seed7, Mary, S3 |
 | 1972 | Prolog | декларативный<br>логический  | ЛП – логическое<br>Visual Prolog, Mercury, Oz,<br>Erlang, Strand, KLO, KL1, Datalog  |
 | 1970 | Pascal | императивный<br>структурный  | Структурное<br>Ada, Component Pascal, Modula-2, Java, Go, Oberon,<br>Object Pascal, Oxygenе, Seed7, VHD,<br>Structured text  |
 ```</table_quotation>""
  - ""(Page 7, Table 1) | Год | ЯП | Предшественники  | Поддержанные парадигмы | Сфера влияния  |
 \n|------|-------------|-------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
 \n| 1972 | C  | B (BCPL, CPL), Algol-68, Assembly, PL/I, FORTRAN | императивный на уровне значений процедурный скалярный структурный  | Numerous, AMPL, AWK, csh, C++, C--, C#, Objective-C, D, Go, Java, JavaScript, Julia, Limbo, LPC, Perl, PHP, Pike, Processing, Python, Ring, Rust, Seed7, Vala, Verilog (HDL), Nim, Cyclone, BitC |""
  - ""<table_quotation page_num=8 table_on_page=1>```
 | Год | ЯП  | Предшественники  | Поддержанные парадигмы  | Сфера влияния |
 |------|------------|---------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|----------------------------------------|
 | 1991 | Html  | SGML | Язык разметки и переписывания | shtml |
 | 1993 | R | Common Lisp, S, Scheme, XLispStat  | векторный<br>императивный<br>аспектно-ориентированный<br>процедурный<br>функциональный<br>рефлективный  | Julia |
 | 1995 | Java  | C++, C, C# Ada, Simula 67, Mesa, Smalltalk, Objective-C, Object Pascal, UCSD Pascal, Oberon, Eiffel, Modula-3, Simula | императивный<br>на уровне значений<br>объектно-ориентированный<br>процедурный<br>скалярный  | C#, Ceylon, D, E, ECMAScript, Groovy, Process, ing, Scala, Vala, X10 |
 | 995 | JavaScript | Lua, Self, Cw, Scheme, Perl, Python, Java, AWK, HyperTalk  | объектно-ориентированный<br>(прототипный)<br>обобщённый<br>функциональный<br>императивный<br>аспектно-ориентированный<br>событийно-ориентированный | Objective-J, Dart, TypeScript |
 | 1995 | Ruby  | Ada, Dylan, Perl, Python, Smalltalk, C++, Клу, Eiffel, Lisp, Basic, Lua  | функциональный<br>императивный<br>рефлективный  | Falcon, Groovy, Objeck  |
 | 1995 | PHP | Perl, C, C++, Java, Tcl  | сценарный, процедурный объектно-ориентированный императивный интерпретируемый свободное программное обеспечение | Falcon |
 ```</table_quotation>""
  - ""(Page 9, Table 1) | Год | ЯП | Предшественники  | Поддержанные парадигмы  | Сфера влияния  |
 \n|------|-------------|---------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
 \n| 1969 | Setl | Algol-60 | императивный процедурный, структурный, объектно-ориентированный | SETL2, ISETL, SETLX, ABC |""
  - ""(Page 10, Table 1) | Подсистема  | Примечание |
 \n|------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | Данные из множества D представляют значения из V и шкалу прерываний  |""
  - ""(Page 11, Table 1) | Подсистема | Приоритет | Примечание |
 \n|-------------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные  | 0  | Значения ограничены размерами их представлений в регистрах памяти по адресам из N. Шкала прерываний не представлена  |""
  - ""(Page 12, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Представления значений не ограничены по размеру и сложности, включая функции  |""
  - ""(Page 13, Table 1) |----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Представления фактов или правил  |
 \n| E: вычисления | 2  | Попытки вычисления, дающего или результат, или сигнал о не выполнимости, что приводит к дальнейшему перебору вариантов |""
  - ""(Page 15, Table 1) | Подсистема  | Приоритет | Примечание  |
 \n|--------------|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | В качестве значений выступают определения реализуемого ЯП и система команд целевой машины, на которой предстоит выполнять программы, подготовленные на базе данного ЯП |""
  - ""(Page 16, Table 1) | Подсистема | Приоритет | Примечание  |
 \n|---------------|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные  | 0  | Данные представляют объекты реального мира и их характеристики, а также сведения о правах доступа к данным  |""
  - ""(Page 17, Table 1) |----------------|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Данные представляют задания, процессы, файлы, каталоги, устройства, протоколы и настроечные значения, а также права доступа.  |
 \n| E: вычисления | 4  | Работу операций выполняют доступные из командной строки команды уровня ядра, дополняемые представлениями программируемых заданий уровня оболочки  |""
  - ""(Page 18, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Данные представляют процессоры и программные модули, организованные в комплекс совместно эксплуатируемого оборудования, конфигурация которого может динамически изменяться |""
  - ""(Page 19, Table 1) | Подсистема  | Приоритет | Примечание  |
 \n|----------------|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Большие объёмы данных, возможно неструктурированных, представляют на многих машинах в сети, алгоритмы анализа таких данных могут иметь высокую временную сложность и содержательное разнообразие. Используются формы представления графов с большим числом вершин.  |""
  - ""(Page 20, Table 1) |----------------|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Данные представляют заполненные в соответствии с разными форматами из тегов, наполнения и адресов, информационные ресурсы и сведения об их владельцах и заинтересованных лиц |
 \n| E: вычисления | 2  | Операции встраиваются и показываются в виде меню, состав которых может регулироваться специальными настройками  |""
  - ""(Page 20, Table 2) |----------------|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Данные представляют действия, спусковые условия их выполнения и обрабатываемые значения и результаты, включая события, происходящие при выполнении действий и в окружающем контексте  |
 \n| E: вычисления | 4  | Операции, кроме обычных арифметических над значениями и доступа к памяти соответственно дисциплине, позволяют формировать сети и комплексы и извлекать из них составляющие, а также просачивать действия относительно структур |""
  - ""(Page 21, Table 1) | Подсистема  | Приоритет | Примечание  |
 \n|----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Данные представляют готовые программы и измерительные модули, включая датчики энергопотребления, временные параметры срабатывания действий, события по срабатыванию разных действий |""","- The paper discusses the systematization of programming paradigms (ПП) based on their semantic characteristics and problem-solving approaches. This indicates a classification framework focused on programming paradigms.
 - The classification includes primary, derivative, combined, auxiliary, and system-forming or strategically-oriented paradigms. This suggests a taxonomy that categorizes paradigms based on their characteristics and applications.
 - The paper mentions the use of this systematization for evaluating the complexity and labor intensity of programming, which implies a practical application of the classification framework.
 - The tables referenced in the paper likely contain detailed categorizations and comparisons of programming paradigms, supporting the development of a comprehensive taxonomy.
 - The scope of the classification includes various categories of programming paradigms, such as basic, expanding, and unlimited paradigms, indicating a broad coverage of different programming languages and systems.","- ""The report is devoted to the analysis of the method of comparison of programming languages, convenient for assessing the expressive power of languages and the complexity of the programming systems.""
  - ""The article presents the results of the analysis of the most well-known programming paradigms and outlines an approach to navigation in the modern expanding space of programming languages, based on the classification of paradigms on the peculiarities of problem statements and semantic characteristics of programming languages and systems with an emphasis on the criteria for the quality of programs and priorities in decision-making in their implementation.""
  - ""Наиболее ясная систематизация ПП в настоящее время позволяет выделять основные и производные ПП, дополненные комбинированными, вспомогательными и системообразующими или перспективно-стратегическими.""
  - ""Методика показана на материале четырёх классических базовых парадигм программирования в рамках ЯП высокого уровня без экскурса в языки низкого и сверх высокого уровней и распространена на более широкое пространство основных парадигм, особенно новых, ещё не получивших поддержки в достаточно известных языках программирования и признания в виде примеров отлаженных программных продуктов.""
  - ""Анализ и сравнение большого числа ЯП разного уровня позволили выделить наиболее существенные характеристики для выражения парадигмальной специфики широкого класса новых ЯП (см. Таблицу 1)""
  - ""Постановки задач базовой ИПП начинаются с определённого алгоритма решения актуальной задачи.""
  - ""Производные ИПП выделяют разные методы представления данных в памяти (M) и организации порождаемых программой последовательных процессов, дополненных обработкой прерываний, поддержкой ПВ и сетевых процессов (C):""
  - ""Парадигмы программирования можно отличать по приоритетам выбора решений при определении категорий семантических систем в процессе программирования, отмечая парадигмальные различия общих понятий в каждой модели, зависящие от критериев качества программ.""
  - ""Предложенную систематизацию ПП можно использовать при оценке сложности и трудоёмкости программирования, особенно если дополнить более ясным разделением требований к постановкам задач по сферам применения на академические и производственные, а по уровню изученности -на точные, развиваемые и усложнённые трудно удостоверяемыми требованиями.""",,"- The paper provides a detailed analysis of programming paradigms, focusing on their classification based on problem statements and semantic characteristics. This suggests a deep conceptual analysis.
 - The classification system is derived from an analysis of well-known programming paradigms, indicating a literature-based approach.
 - The paper mentions the use of criteria for program quality and decision-making priorities, which are specific conceptual dimensions used for classification.
 - The paper discusses the distinction between basic and derivative paradigms, as well as the role of combined, auxiliary, and system-forming paradigms, indicating a nuanced approach to classification.
 - The mention of tables (e.g., Таблицу 1) suggests that the paper provides concrete mappings and examples to support its classification system.","- ""Описания современных языков программирования (ЯП) обычно содержат список из 5-10 языков-предшественников и ряд ПП, поддержанных языком [1, 2] . Такая характеристика как правило не показывает, какие свойства ПП и черты предшественника фактически унаследованы определяемым ЯП и какие особенности являются действительно новыми.""
  - ""Для реальной оценки уровня новизны и практичности ЯП может быть полезной коллекция постановок задач с примерами их решения на разных языках в рамках различных парадигм.""
  - ""Постановки задач базовой ИПП начинаются с определённого алгоритма решения актуальной задачи. Необходимо получить программу реализации алгоритма с практичными пространственно-временными характеристиками на конкретном доступном оборудовании.""
  - ""Постановка задач базовой ООП основана на контроле доступа к иерархии классов объектов с работоспособными методами решения задач некоторой предметной области.""
  - ""Описание производных ПП можно сделать относительным и, следовательно, более лаконичным, выражая разницу с базовой ПП.""
  - ""Предложенную систематизацию ПП можно использовать при оценке сложности и трудоёмкости программирования, особенно если дополнить более ясным разделением требований к постановкам задач по сферам применения на академические и производственные, а по уровню изученности -на точные, развиваемые и усложнённые трудно удостоверяемыми требованиями.""",,"- The paper discusses the limitations of existing classification approaches by highlighting that current descriptions of programming languages often lack detailed information on which paradigm properties and predecessor features are actually inherited or new.
 - It suggests that a collection of problem statements with examples of their solutions in different languages and paradigms could be more useful for evaluating novelty and practicality.
 - The paper critiques the current focus on listing predecessors and supported paradigms without showing what is actually inherited or new, indicating a lack of depth in current classification methods.
 - It proposes a systematization of paradigms based on problem statements and semantic characteristics, which could improve the evaluation of programming complexity and effort.
 - The paper does not explicitly mention any specific limitations or critiques of current taxonomies or classification methods beyond the lack of detailed inheritance information and the need for a more systematic approach.","- ""Предложенную систематизацию ПП можно использовать при оценке сложности и трудоёмкости программирования, особенно если дополнить более ясным разделением требований к постановкам задач по сферам применения на академические и производственные, а по уровню изученности -на точные, развиваемые и усложнённые трудно удостоверяемыми требованиями.""
  - ""Постановка задач базовой ООП основана на контроле доступа к иерархии классов объектов с работоспособными методами решения задач некоторой предметной области.""
  - ""Постановки задач базовой ИПП начинаются с определённого алгоритма решения актуальной задачи. Необходимо получить программу реализации алгоритма с практичными пространственно-временными характеристиками на конкретном доступном оборудовании.""
  - ""Анализ и сравнение большого числа ЯП разного уровня позволили выделить наиболее существенные характеристики для выражения парадигмальной специфики широкого класса новых ЯП (см. Таблицу 1)""
  - ""Методика показана на материале четырёх классических базовых парадигм программирования в рамках ЯП высокого уровня без экскурса в языки низкого и сверх высокого уровней и распространена на более широкое пространство основных парадигм, особенно новых, ещё не получивших поддержки в достаточно известных языках программирования и признания в виде примеров отлаженных программных продуктов.""",,"- The paper discusses the validation of the proposed classification system through the analysis and comparison of a large number of programming languages (ЯП) across different levels. This suggests an empirical approach to validation.
 - The methodology involves showing the method on four classic basic programming paradigms and extending it to a broader space of paradigms, indicating a mapping to existing languages.
 - The paper mentions the use of tables (e.g., Таблицу 1) to highlight significant characteristics for expressing paradigmatic specificity, which implies that these tables are part of the validation process.
 - The criteria for validation seem to involve the ability to express paradigmatic specificity and to evaluate the complexity and laboriousness of programming, which are demonstrated through the analysis of different programming paradigms.
 - The paper does not explicitly mention empirical testing or specific criteria used to demonstrate validity beyond the analysis and comparison of programming languages.","- ""The article presents the results of the analysis of the most well-known programming paradigms and outlines an approach to navigation in the modern expanding space of programming languages, based on the classification of paradigms on the peculiarities of problem statements and semantic characteristics of programming languages and systems with an emphasis on the criteria for the quality of programs and priorities in decision-making in their implementation.""
  - ""The method is adapted to substantiate practical, objective criteria of program decomposition, which can be considered as an approach to solving the problem of factorization of very complicated definitions of programming languages and their support systems.""
  - ""Любая парадигма программирования может быть обогащена дополнительными формами представления ограничительных условий на функционирование программ и вспомогательными прикладными ПП приведения к конкретной сфере приложения.""
  - ""Основные (базовые, расширяющие и неограниченные) ПП можно различать по упорядочению категорий семантических систем и обрабатываемых данных, производные -по отличию от исходной парадигмы, вспомогательные -по областям приложения, комбинированные -по составляющим парадигмам.""",,"- The paper proposes a classification system for programming paradigms based on problem statements and semantic characteristics, which can aid in navigating the expanding space of programming languages.
 - The system is intended to provide practical criteria for program decomposition and can be used to evaluate the complexity and effort required for programming tasks.
 - The classification can be applied to various user groups, including practitioners, researchers, and educators, as it helps in understanding the structure and evolution of programming paradigms.
 - Specific use cases include evaluating the complexity of programming tasks, comparing programming languages, and guiding language design by identifying key characteristics and priorities.
 - The system can impact language design by providing a framework for understanding and comparing different paradigms, which can inform the development of new languages or the adaptation of existing ones.
 - The classification can also facilitate comparative studies by providing a structured approach to analyzing and comparing different programming paradigms."
Programming Paradigms and Computational Thinking,G. Michaelson,-,-,-,0,2018,No specific formalism developed,"Derived from theoretical critique of traditional scientific paradigms, using literature-based conceptual mapping to integrate programming paradigms within a unitary paradigm of computational thinking.","- The existing notion of programming paradigms does not align with the traditional understanding of scientific paradigms.
 - Lack of clarity in characterizing and differentiating programming paradigms.
 - Proposed alternative: viewing programming paradigms as complementary approaches within a unitary paradigm of computational thinking.",No formal validation described,Framework to help programmers and educators choose appropriate language concepts for problem-solving by viewing programming paradigms as complementary approaches within a unitary paradigm of computational thinking.,"- ""Rather, we should view them as complementary approaches within a unitary paradigm of computational thinking.""",,"- The abstract discusses the concept of programming paradigms and their associated languages and methodologies, which suggests a focus on categorizing or understanding these paradigms.
 - However, it does not explicitly mention the development of a new formalism or taxonomy. Instead, it critiques the existing notion of programming paradigms and suggests viewing them as complementary approaches within a broader paradigm of computational thinking.
 - The abstract does not provide details on a specific category of formalism, primary focus, or scope of a classification system.
 - The emphasis is on reinterpreting existing paradigms rather than developing a new classification system.","- ""Rather, we should view them as complementary approaches within a unitary paradigm of computational thinking.""
  - ""Given the extraordinarily wide range of both programming languages and methodologies, it is worthwhile seeking some organising principles, both to enable understanding of how to choose amongst them for particular problems, and to teach others how to do so.""",,"- The abstract discusses the need for organizing principles to understand and choose among programming languages and methodologies, indicating a focus on conceptual analysis.
 - It references the established notion of programming paradigms in computing education, suggesting a literature-based conceptual framework.
 - The abstract critiques the traditional view of scientific paradigms, indicating a theoretical derivation of concepts rather than empirical analysis.
 - It highlights the difficulty in characterizing and differentiating programming paradigms, suggesting a lack of specific conceptual dimensions or criteria for classification.
 - The conclusion to view programming paradigms as complementary approaches within a unitary paradigm of computational thinking suggests a deep conceptual analysis that integrates various perspectives.","- ""Rather, we should view them as complementary approaches within a unitary paradigm of computational thinking.""",,"- The abstract critiques the existing notion of programming paradigms by stating that it does not align with the traditional understanding of scientific paradigms. This suggests a conceptual limitation in how programming paradigms are currently understood and taught.
 - The abstract highlights that there is a lack of clarity in how programming paradigms are characterized and differentiated. This indicates a methodological limitation in the current classification approaches.
 - The proposal to view programming paradigms as complementary approaches within a unitary paradigm of computational thinking suggests an alternative approach to the existing classification methods.","- ""Rather, we should view them as complementary approaches within a unitary paradigm of computational thinking.""
  - ""Given the extraordinarily wide range of both programming languages and methodologies, it is worthwhile seeking some organising principles, both to enable understanding of how to choose amongst them for particular problems, and to teach others how to do so.""",,"- The abstract discusses the concept of programming paradigms and their role in computing education, but it does not mention any specific validation method for a classification system.
 - There is no mention of empirical testing, mapping to existing languages, or any criteria used to demonstrate validity.
 - The focus is on the conceptual understanding and teaching of programming paradigms rather than on validating a classification system.
 - The abstract does not provide any information on how a proposed formalism or taxonomy was validated, as it does not describe any validation process.","- ""it is worthwhile seeking some organising principles, both to enable understanding of how to choose amongst them for particular problems, and to teach others how to do so.""
  - ""Rather, we should view them as complementary approaches within a unitary paradigm of computational thinking.""",,"- The abstract suggests that the work aims to provide organizing principles to help choose programming languages and methodologies for specific problems. This implies a practical application for practitioners and educators in selecting appropriate tools for problem-solving.
 - The mention of ""teach others how to do so"" indicates that educators are an intended user group, as the work aims to inform educational practices.
 - The abstract does not explicitly mention specific use cases or potential applications beyond the general idea of choosing programming languages and methodologies.
 - The concept of viewing programming paradigms as ""complementary approaches within a unitary paradigm of computational thinking"" suggests a potential impact on language design and comparative studies by promoting a unified understanding of computational thinking.
 - The abstract does not provide specific details on the practical and research implications in terms of concrete applications or impacts on language design or comparative studies."
"A survey of languages integrating functional, object-oriented and logic programming","K. Ng, C. Luk",10.1016/0165-6074(94)00017-5,https://doi.org/10.1016/0165-6074(94)00017-5,Microprocessing and Microprogramming,9,1995,"Taxonomy of multiparadigm languages using the FOOL-space (Functional, Object-Oriented, Logic) framework, focusing on programming paradigms and their combinations.","Derived from a comprehensive survey and theoretical derivation, using a structured classification system (FOOL-space) with detailed feature-level analysis and concrete mappings of well-known languages.","- Lack of surveys on the integration of functional, object-oriented, and logic programming paradigms.
 - Complexity in state representation and paradigm purity.
 - Complexity of semantics in combined paradigms.
 - Lack of large-scale applications.
 - Trade-offs between practicality and theoretical consistency.",No formal validation described,Framework for evaluating and designing multiparadigm languages; tool for facilitating high-level comparative studies of programming languages; potential applications in parallel programming and large-scale applications; framework to help programmers choose appropriate language concepts for problem-solving.,"- ""For the purpose of classification, we have proposed a design space of programming languages called the FOOL-space.""
  - ""The position of a multiparadigm language in the FOOL-space indicates the dominant paradigm of the language.""
  - ""Each one of the multiparadigm approaches can be treated as an element in a design space of programming languages, called the FOOL-space (Functional, Object-Oriented and Logic).""
  - ""Fig. 1 The FOOL-space""
  - ""Fig. 2 shows the positions of the approaches in the FOOLspace.""
  - ""The various integrated approaches we have discussed in this section have three different levels of data objects.""
  - ""The semantics of L&O programming is established by constructing a transformation from L&O programs to ordinary logic programs.""
  - ""The degree of coupling of paradigms increases from (1) to (4).Obviously,""
  - ""Actually, we have found that most of the multiparadigm languages discussed in this paper follow ways (2) or (3).""","- ""(Page 7, Table 1) |  | Logic  | Functional  | Object-oriented  |
 \n|-----------------------------|-----------------------------------------------------------------------|---------------------------------------------------------------------------|--------------------------------------------------------------------------------|
 \n| Basic representations  | Relations represented by Horn clauses  | Mathematical functions  | Objects, classes, inheritance  |""
  - ""(Page 7, Table 2) |  | Subclasses | Subtypes |
 \n|-------|------------|----------|
 \n| PROOF | √ | |""","- The paper introduces a ""design space of programming languages called the FOOL-space,"" which is a classification system for multiparadigm languages. This indicates that the primary focus is on programming paradigms.
 - The FOOL-space is used to categorize languages based on their dominant paradigm, suggesting a taxonomy of programming paradigms.
 - The paper discusses various approaches to integrating different paradigms, which are positioned within the FOOL-space, indicating a scope that covers multiple paradigms and their combinations.
 - The mention of figures and tables suggests that these visual aids are used to illustrate the classification and relationships between different paradigms and languages.
 - The paper also discusses the theoretical frameworks and problem-solving mechanisms of different paradigms, which are part of the classification.
 - The tables at the end of the paper likely provide a detailed comparison of different paradigms and languages, further supporting the classification framework.","- ""This paper is a survey of some of the existing multiparadigm languages and is organized as follows. Section 2 summarizes the elements of the three paradigms. Section 3 discusses a variety of approaches to the integration of the three paradigms through an overview of a selection of 24 representative multiparadigm languages.""
  - ""For the purpose of classification, we have proposed a design space of programming languages called the FOOL-space.""
  - ""The position of a multiparadigm language in the FOOL-space indicates the dominant paradigm of the language.""
  - ""In this section, we examine some existing ways to integrate the three paradigms. We consider the four possible combinations of them, namely logic + object-oriented, object-oriented + functional, logic + functional, and object-oriented + logic + functional, separately.""
  - ""The semantics of L&O programming is established by constructing a transformation from L&O programs to ordinary logic programs.""
  - ""The various integrated approaches we have discussed in this section have three different levels of data objects.""
  - ""The degree of coupling of paradigms increases from (1) to (4).Obviously,""
  - ""Actually, we have found that most of the multiparadigm languages discussed in this paper follow ways (2) or (3).""","- ""(Page 7, Table 1) |  | Logic  | Functional  | Object-oriented  |
 \n|-----------------------------|-----------------------------------------------------------------------|---------------------------------------------------------------------------|--------------------------------------------------------------------------------|
 \n| Basic representations  | Relations represented by Horn clauses  | Mathematical functions  | Objects, classes, inheritance  |""
  - ""(Page 7, Table 2) |  | Subclasses | Subtypes |
 \n|-------|------------|----------|
 \n| PROOF | √ | |""","- The paper provides a comprehensive survey of multiparadigm languages, indicating a deep conceptual analysis by covering various approaches to integrating different paradigms.
 - The use of the FOOL-space as a design space for classification suggests a structured and systematic approach to understanding the integration of paradigms.
 - The paper discusses different combinations of paradigms, indicating a detailed analysis of how these paradigms interact and are integrated.
 - The mention of theoretical frameworks such as ψ-calculus and lambda calculus suggests that the conceptual definitions are derived from theoretical derivations and literature review.
 - The tables at the end of the paper provide a detailed comparison of different paradigms, indicating a feature-level analysis with concrete mappings of well-known languages.
 - The discussion on the levels of data objects and the degree of coupling of paradigms suggests a nuanced understanding of the integration process.","- ""However, there is a lack of surveys of the integration of the three paradigms.""
  - ""It is possible for a language to employ more than one of the above three ways to represent states.""
  - ""The first way is simple and clear but of limited use in practice.""
  - ""the second and third ways are more convenient in accessing the state.""
  - ""The purity of the functional paradigm is preserved at the method level (this may not be true in CLOS since Lisp is not a pure functional language).""
  - ""the semantics of the combination is rather complex in these approaches.""
  - ""The degree of coupling of paradigms increases from (1) to (4).Obviously,""
  - ""Obviously, (1) is the most practical but the least theoretical one among them.In""
  - ""In contrast, (4) is consistent and elegant in theory but it requires a lot of effort to implement the system, and to attract a user community.Thus""
  - ""Thus (2) and (3) can be viewed as two balance points between theory and practicality of the design of a multiparadigm language.Actually,""
  - ""Actually, we have found that most of the multiparadigm languages discussed in this paper follow ways (2) or (3).""","- ""(Page 7, Table 1) |  | Logic  | Functional  | Object-oriented  |
 \n|-----------------------------|-----------------------------------------------------------------------|---------------------------------------------------------------------------|--------------------------------------------------------------------------------|
 \n| Basic representations  | Relations represented by Horn clauses  | Mathematical functions  | Objects, classes, inheritance  |""
  - ""(Page 7, Table 2) |  | Subclasses | Subtypes |
 \n|-------|------------|----------|
 \n| PROOF | √ | |""","- The paper discusses the lack of surveys on the integration of functional, object-oriented, and logic programming paradigms, indicating a gap in existing classification approaches.
 - The paper highlights the complexity of state representation in multiparadigm languages, suggesting limitations in how states are currently handled.
 - The purity of paradigms is compromised in some approaches, indicating a limitation in maintaining paradigmatic integrity.
 - The complexity of semantics in combined paradigms is noted, suggesting a limitation in current classification methods.
 - The lack of large-scale applications indicates a practical limitation in existing multiparadigm languages.
 - The paper discusses the trade-offs between practicality and theoretical consistency, suggesting limitations in balancing these aspects.
 - The tables at the end of the paper provide a comparison of different paradigms, which may imply limitations in how these paradigms are currently classified or integrated.","- ""Each one of the multiparadigm approaches can be treated as an element in a design space of programming languages, called the FOOL-space (Functional, Object-Oriented and Logic).""
  - ""The position of a multiparadigm language in the FOOL-space indicates the dominant paradigm of the language.""
  - ""For the purpose of classification, we have proposed a design space of programming languages called the FOOL-space.""",,"- The paper introduces a classification system called the FOOL-space, which is used to categorize multiparadigm languages based on their dominant paradigm.
 - The FOOL-space is a conceptual framework rather than an empirical or formal validation method.
 - There is no mention of specific validation methods such as mapping to existing languages, empirical testing, or case studies.
 - The paper does not provide any explicit criteria or examples used to demonstrate the validity of the FOOL-space classification system.","- ""The position of a multiparadigm language in the FOOL-space indicates the dominant paradigm of the language.""
  - ""The degree of coupling of paradigms increases from (1) to (4).Obviously, (1) is the most practical but the least theoretical one among them.In""
  - ""Thus (2) and (3) can be viewed as two balance points between theory and practicality of the design of a multiparadigm language.Actually,""
  - ""Actually, we have found that most of the multiparadigm languages discussed in this paper follow ways (2) or (3).""
  - ""Lastly, although all the three paradigms are suitable candidates for parallel programming, the possibility of parallel execution is not often discussed in literature concerning multiparadigm languages.""
  - ""We have also found that it is hard to evaluate a language based solely on its descriptions, even accompanied with detailed syntax and semantics specifications.""","- ""(Page 7, Table 1) |  | Logic  | Functional  | Object-oriented  |
 \n|-----------------------------|-----------------------------------------------------------------------|---------------------------------------------------------------------------|--------------------------------------------------------------------------------|
 \n| Basic representations  | Relations represented by Horn clauses  | Mathematical functions  | Objects, classes, inheritance  |""
  - ""(Page 7, Table 2) |  | Subclasses | Subtypes |
 \n|-------|------------|----------|
 \n| PROOF | √ | |""","- The paper discusses the FOOL-space, a design space for programming languages that integrates functional, object-oriented, and logic paradigms. This suggests a framework for understanding and comparing multiparadigm languages.
 - The paper highlights the practicality and theoretical consistency of different integration approaches, indicating a tool for language designers to balance these aspects.
 - The mention of the degree of coupling and balance points suggests a framework for evaluating and designing multiparadigm languages, which could be useful for researchers and language designers.
 - The discussion on parallel programming and the lack of large-scale applications implies potential research directions and practical applications in these areas.
 - The tables at the end of the paper provide a comparative framework for understanding the characteristics of different paradigms, which could be useful for educators and researchers in comparative studies."
The epistemology of programming language paradigms,"F. Gobbo, M. Benini",-,-,-,0,2013,"Taxonomy of four programming paradigms (procedural, functional, object-oriented, logic-based) using the method of levels of abstraction by Floridi (2008)","Derived from theoretical framework by Floridi (2008), using a deep conceptual analysis of four prototypical paradigms with a focus on epistemological commitments and levels of abstraction.",No limitations explicitly discussed,No formal validation described,Framework to help programmers choose appropriate language concepts for problem-solving; Tool for facilitating high-level comparative studies of programming languages; Potential impact on language design by clarifying epistemological commitments and levels of abstraction.,"- ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""
  - ""Furthermore, it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""",,"- The abstract mentions the use of ""the method of levels of abstraction by Floridi (2008)"" which suggests a specific approach or framework for analyzing programming paradigms.
 - The focus of this method is on ""four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based,"" indicating that the primary focus is on these programming paradigms.
 - The analysis provides a structure for simulating language constructions and clarifies epistemological commitments, suggesting a classification framework that examines how these paradigms relate to each other in terms of abstraction levels.
 - The scope of the classification is limited to these four paradigms, as they are the ones being analyzed.","- ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""
  - ""Furthermore, it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""",,"- The abstract mentions the use of ""the method of levels of abstraction by Floridi (2008),"" which suggests a theoretical derivation as the source of conceptual definitions. This indicates a deep level of conceptual analysis, as it involves understanding and applying a specific theoretical framework.
 - The analysis focuses on ""four prototypical paradigms of computer programming,"" which implies a structured approach to classification. This suggests a detailed feature-level analysis, as the authors are examining specific paradigms and their characteristics.
 - The mention of ""the structure on which each language’ constructions can be canonically simulated by another language"" indicates a focus on the theoretical underpinnings of programming languages, suggesting a deep conceptual analysis.
 - The clarification of ""epistemological commitments adopted by the programmer within each paradigm"" and ""the levels of abstraction that get hidden"" suggests a nuanced understanding of the conceptual dimensions involved in programming language paradigms.","- ""After the structured program theorem by B´’ohm & Jacopini (1966), diﬀerent computer programming languages spread out.""
  - ""some programming languages are more equal than others in accomplishing speciﬁc goals, although no particular programming language is better than the others in absolute terms.""
  - ""This paper addresses the research question of what changes in terms of the programmers’ knowledge in choosing one programming language instead of another.""
  - ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""
  - ""Furthermore, it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""",,"- The abstract discusses the spread of different programming languages after the structured program theorem, which might imply a critique of existing classification methods by highlighting the diversity and complexity of programming languages.
 - The mention that ""some programming languages are more equal than others"" suggests a critique of current taxonomies that might not adequately capture these nuances.
 - The paper's focus on the epistemological commitments and levels of abstraction within each paradigm could imply a limitation in existing approaches that do not consider these aspects.
 - However, the abstract does not explicitly mention any specific limitations or critiques of current classification methods or taxonomies.
 - The abstract focuses more on the analysis and clarification of epistemological commitments rather than explicitly discussing limitations or proposing improvements to existing classification approaches.","- ""Furthermore, it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""
  - ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""",,"- The abstract mentions the use of the ""method of levels of abstraction by Floridi (2008)"" as the approach for analyzing programming paradigms. This suggests a theoretical framework rather than an empirical validation method.
 - The analysis involves examining four prototypical paradigms, which implies a theoretical mapping or comparison rather than empirical testing.
 - The abstract does not mention any specific languages or examples used in validation or criteria for demonstrating validity.
 - There is no indication of empirical testing or case studies being conducted to validate the classification system.","- ""This paper addresses the research question of what changes in terms of the programmers’ knowledge in choosing one programming language instead of another.""
  - ""The analysis provides the structure on which each language’ constructions can be canonically simulated by another language.""
  - ""Furthermore, it clariﬁes the epistemological commitments adopted by the programmer within each paradigm, and in particular the levels of abstraction that get hidden.""
  - ""The method of levels of abstraction by Floridi (2008) is used in analysing four prototypical paradigms of computer programming: procedural, functional, object-oriented, and logic-based.""",,"- The abstract mentions that the paper addresses the research question of how programmers' knowledge changes when choosing one programming language over another. This suggests a focus on understanding the implications of language choice for programmers, which could be relevant to practitioners and educators.
 - The use of the method of levels of abstraction to analyze different programming paradigms implies a potential framework for comparative studies of programming languages. This could be useful for researchers conducting high-level comparative studies.
 - The analysis provides a structure for simulating language constructions, which could have implications for language design by highlighting how different languages can be compared and potentially improved.
 - The clarification of epistemological commitments and levels of abstraction could help programmers understand the underlying assumptions and abstractions in each paradigm, potentially aiding in choosing appropriate language concepts for problem-solving."
"An algebraic model of class, message passing and inheritance",R. J. McKenzie,-,-,-,2,1992,"Algebraic model focusing on class, objects, message passing, and inheritance in object-oriented programming","Derived from theoretical derivation, using algebraic structures and formal semantics to define object-oriented programming concepts","- Object-oriented programming is vaguely defined.
 - Programming languages describe concepts in terms of operational features rather than fundamental concepts.
 - Current understanding is superficial, incomplete, and often ambiguous.
 - Lack of a unifying model to describe interactions between features.",No formal validation described (the abstract focuses on theoretical development and consistency rather than empirical validation or mapping to existing languages),Framework for facilitating high-level comparative studies of programming languages; Tool for understanding and generalizing object-oriented programming concepts; Potential impact on language design by providing a unified model for OOP features.,"- ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""
  - ""Such features invariably have intertwined descriptions in the applicable programming languages.""
  - ""In order to be accurate, other more fundamental concepts contributing to class, objects, message passing, and inheritance are first identified and then formally defined in the form of signatures and algebras.""
  - ""Such contributing concepts are included in a single comprehensive and consistent algebraic theory.""
  - ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""",,"- The abstract mentions the development of a ""formal theory"" that characterizes key features of object-oriented programming such as class, objects, message passing, and inheritance. This suggests a formalism focused on these specific features.
 - The use of ""signatures and algebras"" indicates that the formalism is algebraic in nature, which is a specific category of formalism.
 - The primary focus of this classification is on the conceptual characteristics of object-oriented programming, specifically the interactions between class, objects, message passing, and inheritance.
 - The scope of the classification includes these four key features, which are central to object-oriented programming.
 - The abstract does not mention a taxonomy or classification framework that covers multiple programming paradigms or languages; it is focused on the formalization of specific object-oriented concepts.","- ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""
  - ""A superficial, incomplete and often ambiguous picture is formed, making it difficult, if not impossible, to clearly identify and fully exploit the inherent features of the underlying concepts.""
  - ""In order to be accurate, other more fundamental concepts contributing to class, objects, message passing, and inheritance are first identified and then formally defined in the form of signatures and algebras.""
  - ""Such contributing concepts are included in a single comprehensive and consistent algebraic theory.""
  - ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""
  - ""Once the contributing concepts are incorporated in a single theory, there is the opportunity to study and possibly generalize the individual concepts contributing to the basic phenomena.""",,"- The abstract describes a ""formal theory"" that characterizes key object-oriented programming concepts, indicating a deep level of conceptual analysis.
 - The theory is based on identifying and formally defining fundamental concepts, suggesting a theoretical derivation approach rather than empirical analysis or literature review.
 - The use of ""signatures and algebras"" and ""initial algebras"" indicates a specific conceptual dimension focused on algebraic structures.
 - The abstract mentions the integration of contributing concepts into a ""single comprehensive and consistent algebraic theory,"" which suggests a detailed and structured analytical approach.
 - The focus on formal semantics and the description of implementation inheritance as a means of defining algebras further supports the depth and specificity of the conceptual analysis.","- ""Object-oriented programming, although benefiting from a continuing surge of popularity, suffers from being vaguely defined.""
  - ""those programming languages have tended to describe the underlying concepts in terms of operational features instead of describing them as adaptations of more fundamental concepts.""
  - ""A superficial, incomplete and often ambiguous picture is formed, making it difficult, if not impossible, to clearly identify and fully exploit the inherent features of the underlying concepts.""
  - ""the lack of a unifying model, capable of describing the different interactions between these individual features, makes obtaining a complete picture impossible.""",,"- The abstract critiques the current state of object-oriented programming by noting that it is ""vaguely defined,"" which suggests a limitation in how the paradigm is conceptualized and communicated.
 - It highlights that programming languages describe concepts in terms of operational features rather than fundamental concepts, indicating a methodological limitation in how these concepts are approached.
 - The abstract describes the current understanding as ""superficial, incomplete and often ambiguous,"" which points to a conceptual limitation in the existing classification approaches.
 - The lack of a ""unifying model"" capable of describing interactions between features is explicitly mentioned as a limitation, indicating a need for a more comprehensive framework.","- ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""
  - ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""
  - ""Once the contributing concepts are incorporated in a single theory, there is the opportunity to study and possibly generalize the individual concepts contributing to the basic phenomena.""
  - ""Interactions between the concepts can also be studied.""
  - ""Furthermore, as the relevant features of each of the implementations are consistently captured, they can then be compared in formal terms.""",,"- The abstract discusses the development of a formal theory for object-oriented programming concepts, which suggests a theoretical validation approach.
 - The mention of defining formal semantics and using initial algebras indicates a focus on theoretical validation rather than empirical testing.
 - There is no mention of empirical testing or mapping to existing languages, which are common methods for validation.
 - The abstract does not specify any criteria used to demonstrate validity or any specific languages or examples used in validation.
 - The focus is on theoretical consistency and comparison rather than empirical validation.","- ""A formal theory characterizing the principal phenomena associated with this style of programming, that is class, objects, message passing, and inheritance, is presented in this thesis.""
  - ""Such features invariably have intertwined descriptions in the applicable programming languages.""
  - ""the lack of a unifying model, capable of describing the different interactions between these individual features, makes obtaining a complete picture impossible.""
  - ""Using this theory, a formal semantics of abstract data types and polymorphic operations is defined using initial algebras.""
  - ""Implementation inheritance is then described simply as one of a number of different means of defining algebras.""
  - ""Once the contributing concepts are incorporated in a single theory, there is the opportunity to study and possibly generalize the individual concepts contributing to the basic phenomena.""
  - ""Interactions between the concepts can also be studied.""
  - ""Furthermore, as the relevant features of each of the implementations are consistently captured, they can then be compared in formal terms.""
  - ""Simplifications occurring in some of the implementations can also be justified.""",,"- The abstract presents a formal theory that characterizes key features of object-oriented programming (OOP), such as class, objects, message passing, and inheritance. This theory is intended to provide a unified model that can describe the interactions between these features, which are often described ambiguously in programming languages.
 - The theory is expected to facilitate the study and generalization of these concepts, allowing for a deeper understanding of their interactions and potential simplifications in implementations.
 - The formal semantics defined using initial algebras and the description of implementation inheritance suggest a framework for understanding and comparing different programming languages and their features.
 - The abstract implies that this theory could be used for comparative studies of programming languages, as it provides a consistent way to capture and compare features across different implementations.
 - The theory could also impact language design by providing a clear and unified model for understanding OOP concepts, which could guide the development of new languages or the improvement of existing ones.
 - The abstract does not explicitly mention intended user groups, but the implications suggest that it could be useful for researchers and educators in understanding and teaching OOP concepts, as well as for practitioners in designing and comparing programming languages."
"Actors , Objects , Contextures , Morphograms Readings and Reflections about Hierarchy and Heterarchy in Programming Paradigms 1 Actors","R. Kaehr, Juli",-,-,-,0,2007,"Taxonomy of programming paradigms focusing on algebra vs. coalgebra, construction vs. observation, and interaction models (Message-passing, Client/Server, Object Models)","Derived from theoretical mathematical concepts, using literature-based conceptual mapping of algebra and coalgebra principles to classify programming paradigms","- Limitation in capturing the algebra-coalgebra dichotomy
 - Inadequate representation of construction versus observation
 - Challenge to traditional bipartite structures by object-oriented programming
 - Unnatural conceptualization of arithmetic operations in object-oriented programming",No formal validation described,Framework for understanding and designing programming languages based on algebra and coalgebra; tool for comparative studies of programming paradigms; implications for object-oriented language design.,"- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""The basic dichotomy may be described as construction versus observation''""",,"- The abstract discusses the distinction between algebra and coalgebra, which suggests a formalism related to these mathematical concepts.
 - The focus on ""construction versus observation"" indicates a classification framework that distinguishes between these two aspects in programming paradigms.
 - The mention of ""Interacting-Components MOCs"" and ""signal-response"" interaction suggests a formalism related to interaction models in programming.
 - The reference to ""Message-passing Models, Client/Server Models or Object Models"" implies a taxonomy that includes these specific models.
 - The description of object-oriented programs as having a ""homogeneous"" structure suggests a classification that includes object-oriented programming as a distinct category.","- ""A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""The basic dichotomy may be described as construction versus observation''""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""",,"- The abstract discusses the distinction between algebra and coalgebra, which suggests a deep conceptual analysis focusing on fundamental mathematical concepts in computer science.
 - The use of terms like ""construction versus observation"" indicates a theoretical derivation of conceptual definitions, as it aligns with abstract mathematical principles rather than empirical data.
 - The mention of ""interacting-components architecture"" and ""signal-response"" interaction suggests a focus on specific conceptual dimensions related to how components interact within programming paradigms.
 - The discussion of object-oriented programming and its homogeneous structure implies a detailed analysis of programming paradigms, likely derived from a literature review of existing programming languages and their characteristics.
 - The abstract does not mention empirical analysis or direct empirical data collection, suggesting that the conceptual approach is primarily theoretical and literature-based.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""The basic dichotomy may be described as construction versus observation''""
  - ""In all other languages we've considered [Fortran, Algol60, Lisp, APL, Cobol, Pascal], a program consists of passive data-objects on the one hand and the executable program that manipulates these passive objects on the other.""
  - ""For most people, it is natural to think of arithmetic in terms of expressions that state ""do something to the following numbers."" It is less natural to think of arithmetic as being performed by one number ... upon the rest.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a fundamental conceptual framework in computer science. This suggests a critique of existing approaches that may not adequately address this dichotomy.
 - The mention of ""construction versus observation"" implies a limitation in how programming paradigms are typically classified, as it highlights a basic dichotomy that may not be fully captured by current taxonomies.
 - The comparison between traditional programming languages and object-oriented programming languages suggests a limitation in how these paradigms are classified, as object-oriented programming introduces a homogeneous structure that challenges traditional bipartite structures.
 - The critique of arithmetic operations in object-oriented programming (e.g., Smalltalk) suggests a limitation in how arithmetic is conceptualized in these paradigms, which may not align with natural or intuitive ways of thinking about arithmetic.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""The basic dichotomy may be described as construction versus observation''""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Message-passing Models, Client/Server Models or Object Models [MCOM, Quib 99-104] are closely connected with the object abstraction:""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""Inappropriate for arithmetics: «For most people, it is natural to think of arithmetic in terms of expressions that state ""do something to the following numbers."" It is less natural to think of arithmetic as being performed by one number ... upon the rest.""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a theoretical framework rather than a validation method.
 - It mentions interacting-components architecture and object abstraction, which are concepts rather than validation methods.
 - The abstract references specific programming languages like Simula and Smalltalk, but these are used to illustrate concepts rather than as part of a validation process.
 - There is no mention of empirical testing, case studies, or any other form of validation in the abstract.
 - The abstract focuses on theoretical explanations and comparisons rather than on validating a classification system.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""The basic dichotomy may be described as construction versus observation''""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a fundamental concept in computer science. This suggests that the work has implications for understanding and designing programming languages.
 - The mention of ""construction versus observation"" implies a framework for analyzing programming paradigms, which could be useful for researchers and educators in comparative studies.
 - The description of interacting-components architecture and different models of computation suggests potential applications in designing and evaluating programming languages.
 - The connection to object-oriented programming and its implications for language design are highlighted, indicating potential impact on language design.
 - The abstract does not explicitly mention intended user groups or specific use cases, but the content suggests relevance to researchers and educators interested in programming paradigms and language design."
From the Definition of Aspect-oriented Programming to Aspect-oriented Programming Languages,Li Shi-xian,-,-,-,0,2011,No specific formalism developed (the abstract mentions formalization and definition but does not specify a particular type of formalism or taxonomy),"Deep conceptual analysis using theoretical derivation, focusing on formalization of quantified statements and semantics, with specific criteria of quantification and obliviousness for classification.","- Existing classification approaches view AOP too narrowly as modularizing crosscutting concerns or an extension of OOP.
 - Overlooking the true nature of AOP as quantification and obliviousness.
 - AOP is misunderstood as not being a new, independent paradigm.
 - Proposed improvement: Establishing a minimum condition set for AOPL to clarify classification criteria.",No formal validation described,Framework to help programmers and researchers understand and design Aspect-Oriented Programming Languages (AOPLs) based on a defined minimum condition set; Tool for facilitating comparative studies of AOPLs.,"- ""the quantified statement and aspect in the definition were formalized.Moreover""
  - ""And the difference between the mainstream AOPL from the view of the definition was probed into.""
  - ""Based on the definition,the minimum condition set which Aspect-Oriented Programming Languages(AOPL) need to satisfy was proposed.And""
  - ""Moreover the semantics of them were defined.And""
  - ""Based on the definition of AOP,its nature which makes it different from the other programming languages was dug out.And""",,"- The abstract mentions that the nature of Aspect-Oriented Programming (AOP) was ""dug out"" based on its definition, which suggests an exploration or identification of its unique characteristics.
 - The formalization of ""quantified statement and aspect"" and the definition of their semantics indicate a structured approach to understanding AOP, which could be part of a formalism.
 - The proposal of a ""minimum condition set"" for Aspect-Oriented Programming Languages (AOPL) implies a classification or criteria-based framework for what constitutes an AOPL.
 - The investigation into the differences between mainstream AOPLs suggests a comparative analysis, which could be part of a taxonomy or classification framework.
 - However, the abstract does not explicitly mention a specific type of formalism or taxonomy, such as a feature model or classification framework, nor does it specify the scope or number of language categories or features covered.","- ""Based on the definition of AOP,its nature which makes it different from the other programming languages was dug out.And""
  - ""the quantified statement and aspect in the definition were formalized.Moreover""
  - ""the semantics of them were defined.And""
  - ""quantification and obliviousness in the definition are the real nature of AOP.Modularizing""
  - ""Based on the definition,the minimum condition set which Aspect-Oriented Programming Languages(AOPL) need to satisfy was proposed.And""
  - ""the difference between the mainstream AOPL from the view of the definition was probed into.""",,"- The abstract indicates a deep conceptual analysis by ""dug out"" the nature of AOP, suggesting a detailed exploration of its fundamental principles.
 - The formalization of quantified statements and aspects, as well as the definition of their semantics, implies a theoretical derivation as a source of conceptual definitions.
 - The focus on quantification and obliviousness as the real nature of AOP suggests specific conceptual dimensions or criteria used for classification.
 - The proposal of a minimum condition set for AOPL based on the definition implies a systematic approach to classification.
 - The abstract does not mention empirical analysis or literature review as sources, focusing instead on theoretical derivation and formalization.","- ""Today a lot of people not only from industrial community but also from academic community simply take Aspect-Oriented Programming(AOP) as modularizing crosscutting concerns and in a narrow-mined way to believe that AOP is just an extension or an effective supplement to Object-Oriented Programming(OOP).Based""
  - ""Modularizing crosscutting concerns is just a benefit from it.And""
  - ""And then we argued quantification and obliviousness in the definition are the real nature of AOP.Modularizing""
  - ""And the difference between the mainstream AOPL from the view of the definition was probed into.""
  - ""AOP is a new programming paradigm which is independent of all the other programming languages.Based""
  - ""Based on the definition,the minimum condition set which Aspect-Oriented Programming Languages(AOPL) need to satisfy was proposed.And""",,"- The abstract critiques the common perception of AOP as merely modularizing crosscutting concerns or being an extension of OOP, indicating a limitation in how AOP is currently understood and classified.
 - It suggests that this narrow view overlooks the true nature of AOP, which is quantification and obliviousness, implying a conceptual limitation in existing classification approaches.
 - The abstract proposes that AOP is a new, independent paradigm, which challenges existing taxonomies that may not recognize AOP as distinct from other programming languages.
 - The mention of proposing a minimum condition set for AOPL suggests an attempt to address limitations by providing clearer criteria for classification.
 - The exploration of differences between mainstream AOPL from a definitional perspective implies a critique of current classification methods that may not adequately capture these differences.","- ""Based on the definition of AOP,its nature which makes it different from the other programming languages was dug out.And""
  - ""And the quantified statement and aspect in the definition were formalized.Moreover""
  - ""Moreover the semantics of them were defined.And""
  - ""And then we argued quantification and obliviousness in the definition are the real nature of AOP.Modularizing""
  - ""Based on the definition,the minimum condition set which Aspect-Oriented Programming Languages(AOPL) need to satisfy was proposed.And""
  - ""And the difference between the mainstream AOPL from the view of the definition was probed into.""",,"- The abstract discusses the formalization of aspects and quantified statements in AOP, which suggests a theoretical approach to defining AOP.
 - It mentions the definition of semantics, which is a crucial step in formalizing a programming paradigm.
 - The abstract proposes a minimum condition set for AOPL based on the definition, indicating a theoretical framework for classification.
 - However, there is no mention of any empirical testing, case studies, or mapping to existing languages, which are common methods for validation.
 - The abstract does not provide any specific languages or examples used in validation or criteria used to demonstrate validity.
 - The focus is on theoretical formalization and definition rather than empirical validation.","- ""Based on the definition of AOP,its nature which makes it different from the other programming languages was dug out.And""
  - ""And then we argued quantification and obliviousness in the definition are the real nature of AOP.Modularizing""
  - ""Modularizing crosscutting concerns is just a benefit from it.And""
  - ""AOP is a new programming paradigm which is independent of all the other programming languages.Based""
  - ""Based on the definition,the minimum condition set which Aspect-Oriented Programming Languages(AOPL) need to satisfy was proposed.And""
  - ""And the difference between the mainstream AOPL from the view of the definition was probed into.""",,"- The abstract discusses the nature of Aspect-Oriented Programming (AOP) and its distinction from other programming languages, which implies a theoretical contribution to understanding AOP.
 - The mention of ""quantification and obliviousness"" suggests a focus on formalizing aspects of AOP, which could be useful for researchers and educators in understanding and teaching AOP.
 - The proposal of a ""minimum condition set"" for Aspect-Oriented Programming Languages (AOPL) suggests a framework or set of criteria that could be used by practitioners and researchers to evaluate or design AOPLs.
 - The exploration of differences between mainstream AOPLs implies a contribution to comparative studies of programming languages, which could be useful for researchers and educators.
 - The abstract does not explicitly mention specific use cases or potential applications, but the focus on defining AOP and AOPLs suggests a contribution to language design and comparative studies."
A Meta-model for Representing Language-independent Primary Dependency Structures,Ioana Sora,10.5220/0003991400650074,https://doi.org/10.5220/0003991400650074,International Conference on Evaluation of Novel Approaches to Software Engineering,6,2012,"Meta-model for representing language-independent primary dependency structures in software systems, focusing on programming paradigms and conceptual characteristics, covering object-oriented and procedural languages with specific program parts and relationships.","Detailed feature-level analysis with concrete mappings of well-known languages, using a 4-layered architecture and literature-based conceptual mapping to identify similar constructs across languages and paradigms.","- Existing tools and approaches are difficult to reuse and integrate across different contexts.
 - Common exchange formats like GXL do not support extracting models with similar semantics from different system implementations.
 - FAMIX does not handle procedural aspects.
 - DMM lacks programming paradigm transparency and has increased complexity due to multiple ModelObject types and Relationship types.","Validated through implementation of model extraction tools for Java, C#, and ANSI C, demonstrating scalability and utility in various analysis applications.","- Intended user groups: Practitioners (software developers, maintainers), researchers (comparative studies of programming languages and paradigms)
 - Specific use cases or potential applications: Architectural reconstruction, impact analysis, modularization analysis, refactoring decisions
 - Potential impact on language design or comparative studies: Provides language and paradigm transparency, facilitating high-level comparative studies of programming languages and paradigms","- ""This article presents a meta-model that provides a unitary way of describing primary dependency structures in software systems.""
  - ""The proposed meta-model is validated by the implementation of different tools for model extraction from programs written in Java, C# (CIL) and ANSI C.""
  - ""Our general meta-modeling approach can be described as a 4-layered architecture, similar to the OMG's MOF (OMG, 2011a)""
  - ""The meta-meta-level (Layer M3) contains the following concepts: ProgramPart, AggregationRel, Depen-dencyRel.""
  - ""The goal of this meta-layer (Layer M2) in UNIQ-ART is to identify similar constructs in different languages and even different constructs that can be mapped to the same meta-representation.""
  - ""ProgramPart has following instances at the M2 level: System, UpperUnit, Unit, ADT, Variable, Function, Parameter, LocalVar, Type.""
  - ""The relationships allowed between program parts at this level are aggregation relationships (is-PartOf ) and dependency relationships(imports, extends, isOfType, calls, accesses).""
  - ""This article proposes UNIQ-ART, a meta-model that can represent primary dependency structures of programs written in object-oriented as well as procedural languages.""",,"- The paper introduces a ""meta-model"" as the primary formalism developed, which is a type of classification system for representing primary dependency structures in software systems.
 - The meta-model is designed to be language-independent and programming paradigm-independent, covering both object-oriented and procedural languages.
 - The meta-model is structured in a 4-layered architecture, with specific concepts and relationships defined at each layer, such as ProgramPart, AggregationRel, and DependencyRel.
 - The scope of the classification includes various program parts like System, UpperUnit, Unit, ADT, Variable, Function, Parameter, LocalVar, and Type, along with aggregation and dependency relationships.
 - The meta-model is validated through the implementation of model extraction tools for Java, C#, and ANSI C, indicating its applicability across different programming languages.","- ""This article presents a meta-model that provides a unitary way of describing primary dependency structures in software systems.""
  - ""The proposed meta-model is validated by the implementation of different tools for model extraction from programs written in Java, C# (CIL) and ANSI C.""
  - ""The goal of our work in ART was to capture information relevant for describing the static structure of a system and the dependency relationships between static program entities.""
  - ""The meta-meta-level (Layer M3) contains the following concepts: ProgramPart, AggregationRel, Depen-dencyRel.""
  - ""The goal of this meta-layer (Layer M2) in UNIQ-ART is to identify similar constructs in different languages and even different constructs that can be mapped to the same meta-representation.""
  - ""ProgramPart has following instances at the M2 level: System, UpperUnit, Unit, ADT, Variable, Function, Parameter, LocalVar, Type.""
  - ""The relationships allowed between program parts at this level are aggregation relationships (is-PartOf ) and dependency relationships(imports, extends, isOfType, calls, accesses).""
  - ""Our general meta-modeling approach can be described as a 4-layered architecture, similar to the OMG's MOF (OMG, 2011a)""
  - ""The utility of the proposed meta-model has been shown by a number of different reverse engineering and analysis applications that use it successfully.""",,"- The paper presents a meta-model for describing primary dependency structures in software systems, indicating a focus on conceptualizing similarities across different programming languages and paradigms.
 - The meta-model is validated through the implementation of tools for model extraction from various languages, suggesting a practical and empirical approach to its development.
 - The meta-model is structured in a 4-layered architecture, which implies a detailed and structured approach to conceptual analysis.
 - The meta-model includes specific conceptual dimensions such as ProgramPart, AggregationRel, and DependencyRel, which are further detailed into instances like System, UpperUnit, Unit, ADT, etc. This suggests a deep level of conceptual analysis.
 - The paper mentions the identification of similar constructs across languages and mapping them to a common meta-representation, indicating a literature-based and theoretical derivation approach.
 - The use of specific relationships like is-PartOf and imports, extends, isOfType, calls, accesses suggests a detailed feature-level analysis.","- ""One problem that has been noticed early in the field is that existing tools and approaches are difficult to reuse in another context and that existing tools are difficult to integrate in order to form tool-suites.""
  - ""Compared by complexity of the meta-model and level of details that it is able to capture, UNIQ-ART is most similar with FAMIX (Tichelaar et al., 2000). FAMIX is used by a wide variety of reengineering tools comprising software metrics evaluation and software visualization. FAMIX provides for a language independent representation of objectoriented source code, thus its main concepts are Class, Method, Attribute. FAMIX represent relationships between these also as entities InheritanceDefinition, Access and Invocation. It does not treat in any way procedural aspects (global variables and functions, user-defined types which are no classes) although probably it could be extended to do so.""
  - ""Another metamodel is the Dagstuhl Middle Metamodel DMM (Lethbridge et al., 2004). It can represent models of programs written in most common object-oriented and procedural languages. But DMM provides the modelling capabilities for objectoriented and non-object-oriented modelling in an explicit way. DMM generalizes several concepts to achieve multi-language transparency, but not programming paradigm transparency. For example, in DMM a Method is a concept which is different from Routine or Function, although they are very similar, except for the fact that a Method has a relationship to a Class. This leads to an increased complexity of the DMM model, which contains a big number of Mod-elObject types and Relationship types.""
  - ""Establishing only the common exchange format does not offer the needed support for extracting models of a similar semantics out of different kinds of system implementations.""",,"- The paper discusses the difficulty in reusing and integrating existing tools and approaches across different contexts, indicating a limitation in their flexibility and interoperability.
 - The paper critiques the use of common exchange formats like GXL, stating that they do not provide sufficient support for extracting models with similar semantics from different system implementations. This suggests a limitation in current data exchange formats.
 - The paper compares UNIQ-ART with FAMIX, noting that FAMIX does not handle procedural aspects, which is a limitation in its scope.
 - The paper also discusses DMM, highlighting its complexity and lack of programming paradigm transparency, which are limitations in its design.","- ""The proposed meta-model is validated by the implementation of different tools for model extraction from programs written in Java, C# (CIL) and ANSI C.""
  - ""The model extractor tools have been used on a large variety of systems, implemented in Java, C# and C, ranging from small applications developed as university projects until popular applications available as open-source or in compiled form, until, as the benchmark for the scalability of the proposed approach, the entire Java runtime (rt.jar).""
  - ""The execution times needed for the extraction of the primary model and its storage in the database are, for an averagesized system of cca 1000 classes, in the range of one minute.""
  - ""The utility of the proposed metamodel is shown by supporting a number of different analysis applications such as architectural reconstruction, impact analysis, modularization analysis, refactoring decisions.""",,"- The paper describes the validation of the proposed meta-model through the implementation of model extraction tools for Java, C#, and ANSI C. This indicates that the validation approach involves mapping the meta-model to existing languages.
 - The specific languages used in validation are Java, C#, and ANSI C, which are mentioned as part of the validation process.
 - The criteria used to demonstrate validity include the successful extraction of models from a variety of systems and the scalability of the approach, as evidenced by the execution times for model extraction and storage.
 - The paper also mentions the utility of the meta-model in supporting various analysis applications, which further validates its effectiveness.","- ""The proposed meta-model is validated by the implementation of different tools for model extraction from programs written in Java, C# (CIL) and ANSI C.""
  - ""The utility of the proposed metamodel is shown by supporting a number of different analysis applications such as architectural reconstruction, impact analysis, modularization analysis, refactoring decisions.""
  - ""The primary dependency structure models are the central element of it, and they introduce following major benefits:
 

 • A primary dependency structure model abstracts code written in different programming languages and programming paradigms for which a Model Extractor Tool exists.""
  - ""All analysis tools are applied uniformly on extracted abstract models.""
  - ""The utility of the proposed meta-model has been shown by a number of different reverse engineering and analysis applications that use it successfully.""
  - ""UNIQ-ART achieves not only programming language transparency but also programming paradigm transparency.""
  - ""All model entities introduced by UNIQ-ART abstract away differences between object oriented and procedural concepts.""
  - ""We have implemented language mappings and model extractor tools for Java, C# (MS CIL) and ANSI C.""",,"- The paper proposes a meta-model for representing primary dependency structures in software systems, which is validated by tools for model extraction from various programming languages.
 - The meta-model supports various analysis applications such as architectural reconstruction, impact analysis, and refactoring decisions, indicating its practical implications for software development and maintenance.
 - The meta-model provides language and paradigm transparency, allowing for uniform application of analysis tools across different programming languages and paradigms.
 - The implementation of language mappings and model extractor tools for Java, C#, and ANSI C suggests its practical use for practitioners working with these languages.
 - The meta-model's ability to abstract away differences between object-oriented and procedural concepts implies potential research implications for comparative studies of programming languages and paradigms."
Embedding an object calculus in the unifying theories of programming,M. Smith,-,-,-,0,2010,"Taxonomy of programming paradigms and languages within the Unifying Theories of Programming (UTP), focusing on object-based object orientation and integrating various programming formalisms such as imperative, higher-order, concurrent, and transaction processing.","Derived from theoretical literature, using detailed feature-level analysis with concrete mappings of well-known formalisms (UTP and Abadi-Cardelli object calculus)","- Lack of representation for object-based object-orientation in existing UTP framework.
 - Existing UTP models are class-based, lacking object-based models.
 - Limited handling of references and compound values in existing UTP models.",No formal validation described,"Framework for facilitating high-level comparative studies of programming languages, particularly in object-based object orientation; contributes to language design by providing a unified framework for modeling different programming paradigms.","- ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent programming (or reactive systems), class-based object-orientation, and transaction processing.""",,"- The abstract discusses the Unifying Theories of Programming (UTP) as a framework that models programs as relational predicates, indicating a broad classification system for programming paradigms and languages.
 - The UTP is described as having models for various programming formalisms, such as imperative, higher-order, concurrent, class-based object-orientation, and transaction processing, suggesting a taxonomy that covers multiple programming paradigms.
 - The primary focus of the classification is on integrating different programming paradigms and features into a unified framework, particularly focusing on object-based object orientation.
 - The scope of the classification includes extending the UTP to cover object-based object orientation, providing an alternative model for pointers, and modeling Abadi-Cardelli objects, indicating a comprehensive approach to unify different object formalisms.
 - The abstract does not explicitly mention a specific category of formalism like a feature model or taxonomy but describes the UTP as a unifying framework for various programming paradigms and languages.","- ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""",,"- The abstract discusses the integration of an object calculus into the Unifying Theories of Programming (UTP), which suggests a deep conceptual analysis of programming formalisms.
 - The mention of ""Hoare and He's Unifying Theories of Programming"" and ""Abadi and Cardelli's untyped object calculi"" indicates that the conceptual definitions are derived from theoretical literature.
 - The abstract highlights the extension of UTP with object-based object orientation and the modeling of references, which are specific conceptual dimensions used for classification.
 - The focus on embedding an object calculus and providing a fully abstract model of references suggests a detailed feature-level analysis.","- ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""",,"- The abstract mentions a ""gap"" in the UTP work, specifically the lack of representation for object-based object-orientation. This implies a limitation in the existing UTP framework.
 - The dissertation addresses this gap by embedding an object calculus, which suggests that the existing UTP did not adequately cover object-based object-orientation.
 - The abstract highlights that the existing UTP models are class-based, which is contrasted with the new contribution of object-based models. This indicates a limitation in the current classification approaches, as they do not include object-based models.
 - The mention of providing an ""alternative model of pointers"" suggests that the existing models were limited in their handling of references and compound values.
 - Overall, the abstract discusses limitations in the existing UTP framework regarding its inability to represent object-based object-orientation and its limited handling of references and compound values.","- ""More formally, the thesis that his dissertation argues is that it is possible to provide an object-based object rientation to the UTP, with value- and reference-based objects, and a fully abstract model of references.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""",,"- The abstract discusses the extension of the Unifying Theories of Programming (UTP) to include object-based object orientation, which is a significant contribution.
 - It mentions the embedding of an Abadi--Cardelli-style object calculus in the UTP, which suggests a theoretical validation by aligning with existing formalisms.
 - The abstract does not explicitly mention any empirical testing or concrete mappings to existing languages as part of the validation process.
 - There is no mention of specific criteria used to demonstrate validity or any empirical verification through case studies.
 - The focus is on theoretical contributions and extensions to the UTP framework rather than empirical validation.","- ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We have made three contributions to our area of study: first, to extend the UTP with a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""We believe that the UTP ought to be able to represent all significant computer programming language formalisms, in order for it to be considered a unifying theory.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""",,"- The abstract discusses the extension of the Unifying Theories of Programming (UTP) to include object-based object orientation, which is a significant contribution to the field of programming language formalisms.
 - The intended user groups are likely researchers and educators, as the work is focused on theoretical contributions to programming language design and comparative studies.
 - The specific use cases include providing a framework for comparative studies of programming languages, particularly in the context of object-based object orientation.
 - The potential impact is on language design, as it provides a unified framework for modeling different programming paradigms, and on comparative studies by enabling a more comprehensive comparison of object-based and class-based object orientation.
 - The abstract does not explicitly mention practitioners, but the contributions could indirectly benefit them by influencing language design and providing a more comprehensive understanding of programming paradigms."
On Traits and Types in a Java-like Setting,"V. Bono, Ferruccio Damiani, Elena Giachino",10.1007/978-0-387-09680-3_25,https://doi.org/10.1007/978-0-387-09680-3_25,IFIP TCS,34,2008,"Classification framework for object-oriented programming languages focusing on the separation of object type, behavior, and generator roles; Hybrid nominal/structural type system for type checking and structuring code","Derived from theoretical derivation, using a deep conceptual analysis with detailed feature-level mappings of programming language constructs, and supported by literature-based conceptual mapping.","- Classes play multiple roles (generator of instances and unit of reuse), complicating reuse and semantics.
 - Original trait proposal does not address typing issues.
 - Conflict between roles of unit of reuse and type.
 - Limitations in trait model as pointed out by Bergel et al.
 - Competing roles in mainstream object-oriented programming languages limit reuse potential.
 - Proposed improvement: Separate roles of object type, behavior, and generator.",Validated through theoretical proof of type soundness with respect to operational semantics using a core calculus (FRJ) and its flattening translation to FFRJ.,"Framework for improving object-oriented programming language design by separating roles of object type, behavior, and generator; intended for practitioners, researchers, and educators; potential applications in agile software development methodologies and re-engineering class-based libraries into trait-based ones.","- ""We propose a realignment of the class-based object-oriented paradigm by presenting programming language features that separate completely the declarations of object type, behavior and generator.""
  - ""We propose programming language features that separate completely the declarations of object type, behavior and generator.""
  - ""We argue that, in order to support the development of reusable program components, object oriented programming languages should be designed according to the principle that each software structuring construct must have exactly one role.""
  - ""We developed a hybrid nominal/structural type system that allows to typecheck traits in isolation and proved its soundness.""",,"- The paper discusses the development of a new programming paradigm that separates the roles of object type, behavior, and generator, which suggests a classification or formalism related to programming language features.
 - The focus is on object-oriented programming languages and the principle of assigning a single role to each software structuring construct, indicating a classification framework for programming paradigms.
 - The paper introduces a hybrid nominal/structural type system, which is a formalism for type checking and structuring code, but it is not explicitly described as a taxonomy or feature model.
 - The scope of the classification seems to be focused on the realignment of the class-based object-oriented paradigm rather than a broad taxonomy of multiple programming paradigms or languages.","- ""We argue that, in order to support the development of reusable program components, object oriented programming languages should be designed according to the principle that each software structuring construct must have exactly one role.""
  - ""We propose programming language features that separate completely the declarations of object type, behavior and generator.""
  - ""We illustrate our proposal through a core calculus and prove the soundness of the type system w.r.t. the operational semantics.""
  - ""The distinguishing features of FRJ w.r.t. the original trait proposal [10] and to other proposals of traits for Java-like setting [26,18,21] are the following:
 

 -Classes and traits are not types and class-based inheritance is not present.""
  - ""The FRJ type system combines nominal and structural typing.""
  - ""We developed a hybrid nominal/structural type system that allows to typecheck traits in isolation and proved its soundness.""
  - ""The literature related to our proposal has been partially quoted through the paper.""",,"- The paper presents a deep conceptual analysis by proposing a fundamental shift in how object-oriented programming languages are structured, focusing on the principle that each software construct should have exactly one role. This indicates a deep level of conceptual analysis.
 - The sources of conceptual definitions are primarily theoretical derivations, as evidenced by the development of a core calculus and the proof of type soundness. This suggests a strong theoretical foundation.
 - The specific conceptual dimensions used for classification include the separation of object type, behavior, and generator, which are central to the proposed programming language features. This indicates a detailed feature-level analysis.
 - The paper also references literature related to the proposal, suggesting a literature-based conceptual mapping to some extent.
 - The use of a hybrid nominal/structural type system and the focus on type soundness further indicate a detailed and theoretically grounded approach.","- ""Both single and multiple class-based inheritance are often inappropriate as a reuse mechanism, because classes play two competing roles.""
  - ""The original proposal of Schärli et al. does not address typing issues.""
  - ""the role of unit of reuse and the role of type are competing,""
  - ""The distinction between the role of type and the role of unit of reuse, described in terms of type and class, dates back at least to Snyder [27] (see also Cook et al. [9]""
  - ""Recently, Bergel et al. [4] pointed out several limitations of the trait model.""
  - ""The competing roles played by the same software structuring construct complicate the semantics and limits the reuse potential in mainstream object-oriented class-based programming languages.""
  - ""To the best of our knowledge, the conflict between the roles of unit of reuse and generator of instances was firstly described by Schärli et al. [25,10].""
  - ""We claim also that the roles of unit of reuse and type are competing""
  - ""Sophisticated hybrid nominal/structural type systems have been already proposed [11,19,24]. In particular, in [24], the combination of nominal and structural types is conceptually similar to ours, but exploited at a different level.""",,"- The paper critiques existing class-based inheritance systems for having classes play multiple roles, which complicates reuse and semantics.
 - It highlights that the original trait proposal by Schärli et al. does not address typing issues, indicating a limitation in its design.
 - The paper discusses the conflict between the roles of unit of reuse and type, suggesting that current systems do not adequately separate these roles.
 - It mentions limitations in the trait model as pointed out by Bergel et al., indicating issues with current trait-based approaches.
 - The paper suggests that mainstream object-oriented programming languages suffer from competing roles within software structuring constructs, limiting reuse potential.
 - The authors propose a new approach that separates the roles of object type, behavior, and generator to address these limitations.","- ""We illustrate our proposal through a core calculus and prove the soundness of the type system w.r.t. the operational semantics.""
  - ""We conclude by discussing some related work and outlining possible directions for further work.""
  - ""The semantics of FRJ is specified by means of a flattening translation that maps a FRJ program into a FFRJ program and of a reduction semantics for FFRJ programs.""
  - ""The flattening translation preserves the type of programs.""
  - ""The type soundness result comes in two parts: first it relates the typing of expressions with the typing of runtime expressions, then it proves the type soundness with respect to the runtime expression typing.""
  - ""Theorem 2 (Well-typed FFRJ expressions are well-typed runtime expression with a more specific type). If • e : η, then • e : η for some η such that η <: η.""
  - ""We developed a hybrid nominal/structural type system that allows to typecheck traits in isolation and proved its soundness.""",,"- The paper describes the validation of the proposed formalism through the development of a core calculus called FRJ and its type system.
 - The validation approach involves proving the soundness of the type system with respect to the operational semantics, which is a common method in programming language theory to ensure that the type system is consistent and correct.
 - The paper mentions the use of a flattening translation to map FRJ programs into FFRJ programs, which is part of the validation process to ensure that the type system is preserved.
 - The type soundness result is explicitly stated, indicating that well-typed expressions in FFRJ are also well-typed at runtime, which is a key criterion for demonstrating validity.
 - The paper does not mention empirical testing or mapping to existing languages as part of the validation process; instead, it focuses on theoretical validation through type soundness proofs.","- ""We argue that, in order to support the development of reusable program components, object oriented programming languages should be designed according to the principle that each software structuring construct must have exactly one role.""
  - ""We propose programming language features that separate completely the declarations of object type, behavior and generator.""
  - ""In further work, we would like to formulate our proposal in a Smalltalk-like setting (this would allow a careful comparison with the stateful trait proposal), to extend our type system to deal with generics, and to adapt our proposal to deal with dynamic trait substitution""
  - ""We also plan to develop prototypical implementations.""
  - ""A special form of reuse is at the base of the contemporary agile software development methodologies""
  - ""We believe that an interesting future research direction is to investigate whether the programming language features proposed in this paper may help in writing software following an agile methodology.""
  - ""we plan both to develop a trait-oriented agile methodology, suitable to be used directly within trait-based languages, and some trait-mining strategies, in order to re-engineer class-based libraries into trait-based ones.""",,"- The paper proposes a new approach to object-oriented programming by separating the roles of object type, behavior, and generator, which has implications for language design.
 - The authors suggest that this approach can improve the development of reusable program components, which is a practical application for practitioners.
 - The proposal is intended to influence language design by advocating for a separation of roles, which could impact how programming languages are structured.
 - The authors plan to extend their work to other settings, such as Smalltalk-like environments, and to explore applications in agile software development methodologies, indicating potential use cases for researchers and educators.
 - The development of prototypical implementations suggests a practical application for practitioners and researchers to test and refine the proposed features.
 - The investigation into agile methodologies and trait-mining strategies indicates potential applications in software development processes and re-engineering existing libraries."
Exception Handling: Expecting the Unexptected,"Stephen J. Drew, K. J. Gough",10.1016/0096-0551(94)90015-9,https://doi.org/10.1016/0096-0551(94)90015-9,Computer languages,16,1994,Taxonomy of exception handling models in contemporary programming languages,"- Depth of conceptual analysis: Moderate
 - Sources of conceptual definitions: Not mentioned
 - Specific conceptual dimensions or criteria used for classification: Not mentioned",No limitations explicitly discussed,No formal validation described,Framework for classifying exception handling models to improve program reliability and robustness; tool for facilitating comparative studies of programming languages,"- ""The taxonomy is applied to a number of exception handling models in some contemporary programming languages and some observations and conclusions offered.""
  - ""In an effort to provide a means of classifying exception handling models which may be encountered, a taxonomy is presented in this paper.""",,"- The abstract explicitly mentions the development of a ""taxonomy"" as a means of classifying exception handling models. This indicates that the primary type of formalism developed in the study is a taxonomy.
 - The primary focus of this taxonomy is on ""exception handling models,"" which suggests that it categorizes different approaches or models related to exception handling in programming languages.
 - The scope of the classification is not explicitly detailed in terms of the number of language categories or features covered, but it is mentioned that the taxonomy is applied to ""a number of exception handling models in some contemporary programming languages."" This implies that the taxonomy covers multiple exception handling models across different programming languages.","- ""As the taxonomy is developed some of the concepts of exception handling are introduced and discussed.""
  - ""The taxonomy is applied to a number of exception handling models in some contemporary programming languages and some observations and conclusions offered.""
  - ""a taxonomy is presented in this paper.""",,"- The abstract mentions the presentation of a taxonomy, which suggests a structured approach to classifying exception handling models. This implies a certain level of conceptual detail and analysis.
 - The development of the taxonomy involves introducing and discussing concepts of exception handling, indicating a moderate depth of conceptual analysis. It is not described as a shallow or superficial analysis.
 - The abstract does not specify the sources of conceptual definitions, such as whether they are derived from a literature review, empirical analysis, or theoretical derivation. This lack of detail makes it difficult to determine the exact sources.
 - The abstract does not provide specific conceptual dimensions or criteria used for classification. It only mentions that the taxonomy is applied to contemporary programming languages, but does not detail the criteria or dimensions used in this application.
 - Overall, the abstract suggests a structured approach to classification but lacks specific details on the depth of analysis, sources of definitions, and specific criteria used.","- ""The taxonomy is applied to a number of exception handling models in some contemporary programming languages and some observations and conclusions offered.""
  - ""In an effort to provide a means of classifying exception handling models which may be encountered, a taxonomy is presented in this paper.""",,"- The abstract mentions the presentation of a taxonomy for classifying exception handling models, which implies an attempt to address or improve upon existing classification methods.
 - However, the abstract does not explicitly mention any limitations of existing classification approaches or critiques of current taxonomies.
 - The focus is on presenting a new taxonomy and applying it to contemporary programming languages, rather than discussing the limitations of existing methods.
 - There is no mention of specific limitations, critiques, or proposed improvements to existing classification methods in the abstract.","- ""some observations and conclusions offered.""
  - ""The taxonomy is applied to a number of exception handling models in some contemporary programming languages""
  - ""a taxonomy is presented in this paper.""",,"- The abstract mentions that a taxonomy is presented, which implies some form of classification system.
 - It states that the taxonomy is applied to exception handling models in contemporary programming languages, suggesting a form of validation through application to real-world examples.
 - However, the abstract does not specify the exact validation approach, such as whether it was through mapping to existing languages or empirical testing.
 - There is no mention of specific criteria used to demonstrate validity or specific languages used in the validation process.
 - The abstract does not provide details on the methodology or results sections, which are typically where validation methods would be described.","- ""With the move towards programming for ever more complex architectures, understanding basic facilities such as exception handling as an aid to improving program reliability, robustness and comprehensibility has become much more important.""
  - ""The taxonomy is applied to a number of exception handling models in some contemporary programming languages and some observations and conclusions offered.""
  - ""In an effort to provide a means of classifying exception handling models which may be encountered, a taxonomy is presented in this paper.""",,"- The abstract mentions the importance of understanding exception handling for improving program reliability, robustness, and comprehensibility, which suggests a practical implication for programmers and developers.
 - The presentation of a taxonomy for classifying exception handling models implies a research implication, as it provides a framework for researchers to study and compare different models.
 - The application of the taxonomy to contemporary programming languages suggests a potential use case for comparative studies of programming languages.
 - The abstract does not explicitly mention specific user groups or potential applications beyond the general context of programming languages, but the taxonomy's application to contemporary languages implies a potential impact on language design and comparative studies."
Embedding an object calculus in the unifying theories of programming,J. Gibbons,-,-,-,0,2010,"Extension of the Unifying Theories of Programming (UTP) to include object-based object orientation, with a focus on integrating value- and reference-based objects and a fully abstract model of references.","Derived from theoretical derivation, using existing programming theories and models, with a focus on embedding an object calculus into the UTP framework, providing a deep conceptual analysis of object-based object orientation and reference modeling.","- Gap in UTP regarding object-based object-orientation.
 - Existing UTP models are class-based, lacking object-based orientation.
 - Existing models of pointers and references are limited to reference-based compound values.",No formal validation described (the abstract focuses on theoretical contributions and extensions to the UTP framework without mentioning empirical testing or specific language mappings),Framework for facilitating high-level comparative studies of programming languages and paradigms; extension of UTP to include object-based object orientation for enhanced language design and comparative studies.,"- ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent
 

 programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""",,"- The abstract discusses the Unifying Theories of Programming (UTP) as a framework that models programs as relational predicates, indicating a broad classification system for programming paradigms and languages.
 - The UTP is described as having models for various programming formalisms, such as imperative, higher-order, concurrent programming, class-based object-orientation, and transaction processing, suggesting a taxonomy that covers multiple programming paradigms.
 - The primary focus of the classification is on integrating object-based object orientation into the UTP, which is a specific type of programming paradigm.
 - The scope of the classification includes extending the UTP to cover object-based object orientation, providing an alternative model for pointers, and modeling Abadi-Cardelli objects, indicating an expansion of the UTP's taxonomy to include these aspects.
 - The abstract does not explicitly mention a new formalism or taxonomy being developed from scratch but rather an extension and integration of existing models into the UTP framework.","- ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""Hoare and He's Unifying Theories of Programming (UTP) provides a rich model of programs as relational predicates.""
  - ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent
 

 programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""",,"- The abstract discusses the integration of an object calculus into the Unifying Theories of Programming (UTP), which suggests a deep conceptual analysis of programming paradigms and their formalisms.
 - The mention of ""Hoare and He's Unifying Theories of Programming"" and ""Abadi and Cardelli's untyped object calculi"" indicates that the conceptual definitions are derived from theoretical derivations and existing literature in the field.
 - The abstract highlights the extension of UTP with object-based object orientation and the modeling of references, which suggests a detailed feature-level analysis of programming formalisms.
 - The focus on embedding an object calculus and providing a fully abstract model of references indicates a deep level of conceptual detail in the analysis.
 - The abstract does not explicitly mention empirical analysis or literature review as sources, but the reference to existing theories and models implies a theoretical derivation approach.","- ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models;""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""
  - ""third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values;""",,"- The abstract identifies a gap in the Unifying Theories of Programming (UTP) regarding object-based object-orientation, which is a limitation in the existing framework.
 - The dissertation addresses this gap by embedding an object calculus, indicating that the existing UTP did not adequately cover object-based object-orientation.
 - The abstract mentions extending the UTP with object-based object orientation, contrasting it with existing class-based models, which suggests a limitation in the current classification approach.
 - The alternative model of pointers and references is proposed as an improvement over existing models, indicating a limitation in how references were previously handled.
 - The abstract does not explicitly use terms like ""limitation"" or ""critique,"" but it implies that the existing UTP had gaps and needed extensions, which can be interpreted as limitations in the current classification approaches.","- ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent
 

 programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""",,"- The abstract discusses the extension of the Unifying Theories of Programming (UTP) to include object-based object orientation, which is a significant contribution.
 - It mentions the embedding of an Abadi--Cardelli-style object calculus in the UTP, which suggests a theoretical validation by aligning with existing formalisms.
 - The abstract does not explicitly mention any empirical testing or mapping to specific languages as a validation method.
 - The focus is on theoretical contributions and extensions to the UTP framework rather than empirical validation or testing.
 - The criteria for validity seem to be based on the theoretical alignment with existing formalisms and the ability to unify different programming paradigms.","- ""The UTP already has models for several programming formalisms, such as imperative programming, higher-order programming (e.g. programing with procedures), several styles of concurrent
 

 programming (or reactive systems), class-based object-orientation, and transaction processing.""
  - ""We have made three contributions to our area of study: first, to extend the UTP with
 

 a notion of object-based object orientation, in contrast with the existing class-based models; second, to provide an alternative model of pointers (references) for the UTP that supports both value-based compound values (e.g. objects) and references (pointers), in contrast to existing UTP models with pointers that have reference-based compound values; and third, to model an Abadi-Cardelli notion of an object in the UTP, and thus demonstrate that it can unify this style of object formalism.""
  - ""We believe that the UTP ought to be able to represent all significant computer programming language formalisms, in order for it to be considered a unifying theory.""
  - ""One gap in the UTP work is that of object-based object-orientation, such as that presented in Abadi and Cardelli's untyped object calculi (sigma-calculi).""
  - ""We address this gap within this dissertation by presenting an embedding of an Abadi--Cardelli-style object calculus in the UTP.""",,"- The abstract discusses the extension of the Unifying Theories of Programming (UTP) to include object-based object orientation, which is a significant contribution to the field of programming language formalisms.
 - The intended user groups are likely researchers and educators in computer science, as the work is focused on theoretical models and their integration into a unifying framework.
 - The specific use cases include providing a framework for comparative studies of programming languages and paradigms, as well as enhancing language design by incorporating object-based object orientation.
 - The potential impact on language design is significant, as it provides a more comprehensive framework for modeling different programming paradigms and features.
 - The work also has implications for comparative studies, as it allows for a unified framework to compare and contrast different programming formalisms."
IMPERATIVE/FUNCTIONAL/OBJECT-ORIENTED AN ALTERNATIVE ONTOLOGY OF PROGRAMMATIC PARADIGMS FOR DESIGN,"K. Steinfeld, C. S. Olascoaga",-,-,-,0,2014,"Taxonomy of programming paradigms (Imperative, Object-Oriented, Functional) applied to Decodes and DesignScript environments","Empirical analysis through case studies, using a programmatic paradigm taxonomy with specific conceptual dimensions (IPL, OOPL, FPL) to classify programming environments.","- Struggles to address languages that hybridize visual and textual modes.
 - Cannot account for structural features beyond user interface.
 - Proposed improvement: Alternative ontology based on programmatic paradigms.",Validated through empirical testing using case studies of Decodes and DesignScript programming environments.,Framework to help programmers choose appropriate language concepts for problem-solving; Tool for facilitating high-level comparative studies of programming languages,"- ""This study applies a programmatic paradigm taxonomy to two programming environments: Decodes and DesignScript.""
  - ""The former is a domain-specific TPL that exhibits qualities of an Imperative Programing Language (IPL) and an Object-Oriented Programming Language (OOPL).""
  - ""The latter, a VPL-TPL hybrid allows users to move between IPL, OOPL, and Functional Programming Language (FPL) modes.""
  - ""Proceeding through the analysis of case studies, this study yields a set of guidelines for the application of each of these paradigms.""
  - ""An alternative ontology, differentiated by programmatic paradigm 2 suggests an improved method of assessment.""",,"- The abstract mentions an ""alternative ontology, differentiated by programmatic paradigm,"" which suggests a classification system based on programming paradigms.
 - The term ""programmatic paradigm taxonomy"" is explicitly used, indicating that the study develops a taxonomy related to programming paradigms.
 - The taxonomy is applied to two programming environments, Decodes and DesignScript, which are described in terms of their programming paradigms (IPL, OOPL, FPL).
 - The study results in guidelines for the application of these paradigms, suggesting that the taxonomy is used to categorize and understand the applicability of different programming paradigms.
 - The scope of the classification includes at least three programming paradigms: Imperative, Object-Oriented, and Functional.","- ""This study applies a programmatic paradigm taxonomy to two programming environments: Decodes and DesignScript.""
  - ""Proceeding through the analysis of case studies, this study yields a set of guidelines for the application of each of these paradigms.""
  - ""The latter, a VPL-TPL hybrid allows users to move between IPL, OOPL, and Functional Programming Language (FPL) modes.""
  - ""The former is a domain-specific TPL that exhibits qualities of an Imperative Programing Language (IPL) and an Object-Oriented Programming Language (OOPL).""
  - ""Distinctions between approaches to programming for design applications are marked by the split between Visual Programming Languages (VPLs) and Textual Programming Languages (TPLs).""",,"- The abstract mentions the use of an ""alternative ontology"" and a ""programmatic paradigm taxonomy,"" which suggests a structured approach to classification.
 - The study applies this taxonomy to specific programming environments (Decodes and DesignScript), indicating a practical application of the conceptual framework.
 - The abstract describes the characteristics of these environments in terms of programming paradigms (IPL, OOPL, FPL), which are specific conceptual dimensions used for classification.
 - The mention of ""case studies"" implies an empirical analysis, as the study likely involved examining real-world examples to derive guidelines.
 - The abstract does not explicitly mention a literature review or theoretical derivation, but the use of established programming paradigms suggests some theoretical basis.
 - The depth of conceptual analysis appears to be moderate, as it involves applying a taxonomy to specific cases and deriving guidelines, but the abstract does not provide detailed theoretical or empirical depth.","- ""it struggles to address languages that hybridize visual and textual modes, and cannot account for other structural features beyond user interface.""
  - ""Distinctions between approaches to programming for design applications are marked by the split between Visual Programming Languages (VPLs) and Textual Programming Languages (TPLs).""",,"- The abstract discusses the existing classification approach based on the distinction between Visual Programming Languages (VPLs) and Textual Programming Languages (TPLs).
 - It highlights a limitation of this approach: it struggles to address languages that combine visual and textual modes. This indicates a limitation in handling hybrid languages.
 - Another limitation mentioned is that the current approach cannot account for structural features beyond the user interface, suggesting a lack of depth in the current classification method.
 - The abstract proposes an alternative ontology based on programmatic paradigms as an improved method of assessment, implying that the current methods are not sufficient.","- ""This study applies a programmatic paradigm taxonomy to two programming environments: Decodes and DesignScript.""
  - ""Proceeding through the analysis of case studies, this study yields a set of guidelines for the application of each of these paradigms.""
  - ""The former is a domain-specific TPL that exhibits qualities of an Imperative Programing Language (IPL) and an Object-Oriented Programming Language (OOPL).""
  - ""The latter, a VPL-TPL hybrid allows users to move between IPL, OOPL, and Functional Programming Language (FPL) modes.""",,"- The abstract mentions that the study applies a programmatic paradigm taxonomy to two programming environments: Decodes and DesignScript. This suggests that the validation method involves applying the taxonomy to these specific environments.
 - The abstract describes the characteristics of Decodes and DesignScript in terms of programming paradigms (IPL, OOPL, FPL), indicating that these languages are used as examples in the validation process.
 - The mention of ""analysis of case studies"" implies that the validation approach involves empirical testing through case studies.
 - The abstract does not explicitly mention criteria used to demonstrate validity, but the application to specific languages and the analysis of case studies suggest a practical validation approach.","- ""This study applies a programmatic paradigm taxonomy to two programming environments: Decodes and DesignScript.""
  - ""Proceeding through the analysis of case studies, this study yields a set of guidelines for the application of each of these paradigms.""",,"- The abstract mentions the application of a programmatic paradigm taxonomy to specific programming environments, which suggests a practical implication for understanding and comparing these environments.
 - The mention of ""guidelines for the application of each of these paradigms"" implies that the study provides practical advice for users, potentially including practitioners and educators, on how to apply different programming paradigms.
 - The analysis of case studies suggests a research implication, as it likely contributes to a deeper understanding of how these paradigms are used in real-world scenarios.
 - The abstract does not explicitly mention specific use cases or potential applications beyond the analysis of Decodes and DesignScript, nor does it discuss potential impacts on language design or comparative studies."
Visualization of the Results of the Analysis of Programming Languages for Their Superficial Comparison,L. Gorodnyaya,10.25205/1818-7900-2021-19-2-29-52,https://doi.org/10.25205/1818-7900-2021-19-2-29-52,Vestnik NSU. Series: Information Technologies,0,2021,"Semantic decomposition framework focusing on programming paradigms and language definitions, covering aspects like expressive power, implementation complexity, and program decomposition criteria. The scope includes studying programming methods, history, paradigms, and novelty assessment of languages.","The paper employs a deep conceptual analysis using semantic decomposition and concept matrices. The approach is theoretically derived, focusing on paradigm analysis and practical criteria for program decomposition. It uses specific conceptual dimensions like expressiveness, complexity, and novelty to classify programming languages. The methodology involves detailed feature-level analysis with mappings into abstract systems like SECD for Pure Lisp and pi-code for Pascal.","- Lack of objective criteria for program decomposition.
 - Difficulty in differentiating paradigms due to shared pragmatics.
 - Need for more nuanced classification approaches considering application spheres and levels of study.","Validated through concrete mappings of well-known languages like Pure Lisp and Pascal, using conceptual matrices to compare conceptual complexity.","- Tool for facilitating high-level comparative studies of programming languages
 - Framework to help programmers choose appropriate language concepts for problem-solving
 - Educational tool for forming teaching methodologies in information systems development
 - Research tool for assessing the novelty and complexity of programming languages","- ""The article is devoted to the choice of a clear and concise form for presenting the results of analise and comparing programming languages and systems, convenient for assessing the expressive power of languages and the complexity of implementing systems.""
  - ""The formalization is adapted to the paradigm analysis of the definitions of programming languages and the selection of practical criteria for decomposition of programs.""
  - ""The semantic decomposition of the definitions of languages and systems as part of the analysis of programming paradigms was chosen as the main ap-proach.""
  - ""Such a choice makes it possible to single out autonomously developed typical program components that can be adapted to the design of various information systems.""
  - ""The solution to this problem is useful when studying programming methods, studying the history of programming languages, for comparing programming paradigms, the potential of used circuits and models, assessing the novelty level of created programming languages, and also when choosing criteria for program decomposition.""
  - ""In addition, their existence allows us to form a teaching methodology for developing the components of information systems.""
  - ""Along the way, the distance in conceptual complexity between programming and programming system development is shown.""",,"- The paper discusses a formalism for comparing programming languages and systems, focusing on their expressive power and implementation complexity.
 - The formalism is adapted to analyze programming paradigms and select practical criteria for program decomposition.
 - The main approach involves semantic decomposition of language and system definitions, which is part of the analysis of programming paradigms.
 - The formalism aims to identify autonomously developed typical program components that can be adapted for designing various information systems.
 - The scope of the classification includes studying programming methods, the history of programming languages, comparing programming paradigms, assessing the novelty of programming languages, and choosing criteria for program decomposition.
 - The paper also mentions forming a teaching methodology for developing information system components, indicating a broad scope of application.","- ""The semantic decomposition of the definitions of languages and systems as part of the analysis of programming paradigms was chosen as the main ap-proach.""
  - ""The formalization is adapted to the paradigm analysis of the definitions of programming languages and the selection of practical criteria for decomposition of programs.""
  - ""The solution to this problem is useful when studying programming methods, studying the history of programming languages, for comparing programming paradigms, the potential of used circuits and models, assessing the novelty level of created programming languages, and also when choosing criteria for program decomposition.""
  - ""Such a choice makes it possible to single out autonomously developed typical program components that can be adapted to the design of various information systems.""",,"- The paper focuses on a detailed and structured approach to analyzing programming languages, emphasizing the need for a clear and concise presentation of results. This suggests a deep level of conceptual analysis, as it involves assessing the expressive power and implementation complexity of languages.
 - The methodology involves semantic decomposition, which is a detailed analytical approach that breaks down language definitions into components for comparison. This indicates a deep conceptual analysis rather than a shallow one.
 - The approach is adapted to paradigm analysis, suggesting that the conceptual framework is derived from theoretical derivation rather than purely empirical analysis or literature review.
 - The use of concept matrices for languages like Pure Lisp and Pascal indicates a structured, feature-level analysis. These matrices map language features into abstract systems, allowing for detailed comparisons.
 - The paper discusses the use of semantic systems and concept matrices to evaluate programming languages, which involves specific conceptual dimensions such as expressiveness, complexity, and novelty.
 - The paper's approach allows for the autonomous development of program components, indicating a focus on practical criteria for program decomposition.","- ""The solution to this problem is useful when studying programming methods, studying the history of programming languages, for comparing programming paradigms, the potential of used circuits and models, assessing the novelty level of created programming languages, and also when choosing criteria for program decomposition.""
  - ""The formalization is adapted to the paradigm analysis of the definitions of programming languages and the selection of practical criteria for decomposition of programs.""
  - ""Предложенную визуализацию при оценке сложности и трудоемкости программирования на базе ЯиСП можно дополнить разделением требований к постановкам задач по сферам применения на академические и производственные, а также по уровню изученности на четкие, развиваемые, усложненно трудоемкие и новые.""
  - ""разные парадигмы могут быть реализованы одной и той же прагматикой. Это делает нетривиальным проблему представления уловия для различия парадигм""
  - ""Различия категорий семантических систем, поддерживающих различимые парадигмы на уровне правил применения функций к значениям в наиболее известных языках высокого уровня (ЯВУ), выражены табл. 2-5.""",,"- The paper discusses the need for a clear and concise form for presenting the results of analysis and comparing programming languages, which implies a limitation in existing methods.
 - The mention of ""paradigm analysis"" and ""practical criteria for decomposition of programs"" suggests that current methods may lack objective criteria for program decomposition.
 - The paper highlights that different paradigms can be implemented with the same pragmatics, making it challenging to differentiate them, which is a limitation in current classification approaches.
 - The paper proposes a visualization method to evaluate complexity and effort, which implies that existing methods may not effectively assess these aspects.
 - The suggestion to divide requirements by application spheres and levels of study indicates a need for more nuanced classification approaches.","- ""Результаты анализа языка Pure Lisp представлены в табл. 8, а языка Pascal -в табл. 9.""
  - ""Понятийная матрица позволяет средства языка Pure Lisp характеризовать в рамках семантической системы вида <V, F, R>, отображаемой в абстрактную машину SECD, обладающую независимыми регистрами""
  - ""Понятийная матрица, характеризующая средства языка Pascal, обладает меньшей кумулятивностью.""
  - ""Такие понятийные матрицы достаточны для представления результатов сравнительного анализа ЯП и оценки сложности их применения, например, по числу различимых конструкций в каждой клетке понятийной матрицы.""
  - ""Представление результатов сравнения понятийной сложности определений языков Pure Lisp и Pascal (число пунктов в клетках табл. 7, 8)""
  - ""Понятийная матрица определения языка Си (ядро -скаляр)""
  - ""Понятийная матрица определения языка Си (расширение -процедуры)""
  - ""Понятийная матрица определения языка Си (универс -структуры)""
  - ""Таким образом, получается нечто вроде визитной карточки ЯиСП, позволяющей быстро выполнять их грубое сравнение.""",,"- The paper provides a formalism for classifying programming languages using a conceptual matrix.
 - The validation approach involves mapping this formalism to existing languages, specifically Pure Lisp and Pascal, as indicated by the results presented in tables 8 and 9.
 - The criteria used to demonstrate validity include the ability to characterize the languages within the semantic system framework and the comparison of conceptual complexity based on the number of distinguishable constructs in each cell of the conceptual matrix.
 - The paper also applies this formalism to other languages like C, further demonstrating its applicability.
 - The use of tables to present the analysis results for these languages suggests a structured approach to validation.","- ""The solution to this problem is useful when studying programming methods, studying the history of programming languages, for comparing programming paradigms, the potential of used circuits and models, assessing the novelty level of created programming languages, and also when choosing criteria for program decomposition.""
  - ""Along the way, the distance in conceptual complexity between programming and programming system development is shown.""
  - ""The formalization is adapted to the paradigm analysis of the definitions of programming languages and the selection of practical criteria for decomposition of programs.""
  - ""The semantic decomposition of the definitions of languages and systems as part of the analysis of programming paradigms was chosen as the main ap-proach.""
  - ""Such a choice makes it possible to single out autonomously developed typical program components that can be adapted to the design of various information systems.""
  - ""In addition, their existence allows us to form a teaching methodology for developing the components of information systems.""",,"- The paper discusses a method for presenting and comparing programming languages and systems, which is useful for assessing their expressive power and implementation complexity. This suggests a practical application for researchers and educators in understanding and teaching programming languages.
 - The solution is useful for studying programming methods, the history of programming languages, comparing paradigms, and assessing the novelty of languages. This indicates potential research applications in language design and comparative studies.
 - The formalization is adapted for paradigm analysis and program decomposition, which can help practitioners in selecting appropriate language concepts for problem-solving.
 - The semantic decomposition approach allows for the development of typical program components that can be adapted to various information systems, indicating practical applications in software development.
 - The existence of these methods allows for the formation of teaching methodologies, highlighting an educational application.
 - The proposed visualization aids in comparing the conceptual complexity of languages, which is beneficial for researchers and educators, suggesting its use in academic settings."
Readings and Reflections about Hierarchy and Heterarchy in Programming Paradigms,-,-,-,-,0,2007,"Taxonomy of programming paradigms based on algebra and coalgebra, focusing on construction versus observation, with scope covering interacting-components architecture and object abstraction.","Derived from theoretical derivation, using mathematical concepts like algebras and coalgebras to classify programming paradigms based on construction versus observation and object abstraction.","- Existing classification approaches may not adequately capture the algebraic and coalgebraic distinction.
 - Current taxonomies may not fully address the dichotomy of construction versus observation.
 - Limitations in handling different interaction styles and architectural models, such as interacting-components MOCs.
 - Object-oriented programming's unnatural approach to arithmetic operations.",No formal validation described,"Framework for understanding and comparing programming paradigms based on algebra and coalgebra, with implications for language design and comparative studies.","- ""A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""The basic dichotomy may be described as construction versus observation''""",,"- The abstract discusses the distinction between algebra and coalgebra, which suggests a formalism related to these mathematical concepts.
 - The focus is on the dichotomy between construction and observation, which implies a classification based on how programming paradigms are structured and interact.
 - The mention of ""Interacting-Components MOCs"" and ""signal-response"" interaction suggests a formalism related to the architecture of programming systems.
 - The abstract also references different models of computation, such as message-passing and object models, which are related to the object abstraction.
 - The scope of the classification seems to cover various programming paradigms and their interaction styles, but the abstract does not specify a clear number of categories or features.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""The basic dichotomy may be described as construction versus observation''""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""",,"- The abstract discusses the distinction between algebra and coalgebra, which suggests a deep conceptual analysis of programming paradigms.
 - The use of mathematical terms like ""algebras and coalgebras"" indicates a theoretical derivation of conceptual definitions.
 - The abstract mentions the basic dichotomy of ""construction versus observation,"" which is a specific conceptual dimension used for classification.
 - The discussion of interacting-components architecture and different models of computation suggests a detailed analysis of computational models.
 - The mention of object-oriented programming and its homogeneous structure indicates a focus on specific conceptual dimensions related to object abstraction.
 - The abstract does not explicitly mention empirical analysis or literature review as sources, but the use of theoretical terms and conceptual distinctions implies a theoretical derivation.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""The basic dichotomy may be described as construction versus observation''""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""In all other languages we've considered [Fortran, Algol60, Lisp, APL, Cobol, Pascal], a program consists of passive data-objects on the one hand and the executable program that manipulates these passive objects on the other.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""For most people, it is natural to think of arithmetic in terms of expressions that state ""do something to the following numbers."" It is less natural to think of arithmetic as being performed by one number ... upon the rest.""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a fundamental conceptual framework in computer science. This suggests a critique of existing approaches that may not adequately address this dichotomy.
 - The mention of ""construction versus observation"" implies a limitation in how programming paradigms are typically classified, as it highlights a basic dichotomy that may not be fully captured by current taxonomies.
 - The description of interacting-components MOCs and the shift from passive data-objects to active data systems in object-oriented programming suggests a limitation in how existing classification methods handle different interaction styles and architectural models.
 - The critique of arithmetic operations in object-oriented programming (e.g., Smalltalk) as unnatural or artificial suggests a limitation in how existing paradigms are applied to certain domains, such as arithmetic.
 - Overall, the abstract implies that existing classification approaches may not fully capture the nuances of programming paradigms, particularly in terms of algebraic and coalgebraic distinctions, interaction models, and the shift towards more active data systems.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""A modern, mathematical precise way to express the difference is in terms of algebras and coalgebras.""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""Message-passing Models, Client/Server Models or Object Models [MCOM, Quib 99-104] are closely connected with the object abstraction:""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""Inappropriate for arithmetics: «For most people, it is natural to think of arithmetic in terms of expressions that state ""do something to the following numbers."" It is less natural to think of arithmetic as being performed by one number ... upon the rest.""",,"- The abstract discusses the distinction between algebra and coalgebra in computer science, which is a theoretical framework rather than a validation method.
 - It mentions the characterization of interacting-components MOCs and their interaction style, which is more about describing a system rather than validating it.
 - The abstract references object-oriented programming and its structure, but this is not a validation method.
 - There is no mention of any empirical testing, mapping to existing languages, or specific criteria used to demonstrate validity.
 - The abstract does not provide any information on how the proposed formalism or taxonomy was validated.","- ""The distinction between algebra and coalgebra pervades computer science and has been recognized by many people in many situations, usually in terms of data versus machines.""
  - ""Object-oriented programs replace this bipartite structure with a homogeneous one: they consist (partially in Simula, exclusively in Smalltalk) of a set of data systems [i.e. objects, c.f. p. 43], each of which is capable of operating on itself.»""
  - ""Different styles of interaction and computing units lead to different models of the computation.""
  - ""Interacting-Components MOCs, i.e., MOCs with an interacting-components architecture[^], are characterized by a ""signal-response"" type of interaction: Computation proceeds by virtual computing units interacting with each other.""
  - ""The basic dichotomy may be described as construction versus observation''""",,"- The abstract discusses the distinction between algebra and coalgebra, which is a fundamental concept in computer science. This distinction is relevant for understanding the structure and behavior of programming languages.
 - The mention of ""construction versus observation"" suggests a framework for analyzing programming paradigms, which could be useful for researchers and educators in understanding and teaching these concepts.
 - The description of interacting-components MOCs and different interaction styles implies potential applications in designing and comparing programming languages, which could be of interest to practitioners and researchers.
 - The connection to object-oriented programming and the homogeneous structure of object-oriented programs suggests implications for language design and comparative studies.
 - The abstract does not explicitly mention intended user groups or specific use cases, but the concepts discussed are likely to be relevant to researchers, educators, and practitioners interested in programming language design and comparative studies."
Towards a semiotic framework for programming languages,"Valle Andrea, Mazzei Alessandro",-,-,-,0,2013,No specific formalism developed (the abstract discusses a semiotic framework but does not specify a detailed classification system or formalism),"Derived from theoretical frameworks, using conceptual mapping of programming paradigms (imperative, functional, object-oriented) with focus on semiotics and Von Neumann machine framework.",No limitations explicitly discussed,No formal validation described,Framework to help researchers and educators understand the semiotic structure of programming languages and its implications on language design and comparative studies,"- ""A programming language is ”an artiﬁcial formalism in which algorithms can be expressed.""
  - ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""
  - ""All programming languages are Turing-complete.""
  - ""In high-level languages, in which the abstraction allows for the introduction of a ”structured” form of linguistic representation based on the notion of ”control ﬂow” by means of conditionals and loop, there is an osmosis between human and machine semiotics,""",,"- The abstract mentions a ""semiotic framework"" which suggests a type of formalism or classification system related to the semiotics of programming languages.
 - The focus is on the ""general semiotic framework of the Von Neumann machine,"" indicating that the primary focus is on the conceptual characteristics of programming languages in relation to the Von Neumann architecture.
 - The abstract also mentions the analysis of ""persona, time, and space in the imperative, functional and object-oriented paradigms,"" which suggests that the scope includes these three programming paradigms.
 - There is no mention of a specific taxonomy or feature model, nor is there a detailed description of a classification framework with specific categories or features.","- ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""
  - ""All programming languages are Turing-complete.""
  - ""A programming language is ”an artiﬁcial formalism in which algorithms can be expressed.""
  - ""In high-level languages, in which the abstraction allows for the introduction of a ”structured” form of linguistic representation based on the notion of ”control ﬂow” by means of conditionals and loop, there is an osmosis between human and machine semiotics,""",,"- The abstract discusses the conceptual framework of programming languages, focusing on their semiotic aspects and the balance between human and machine semiotics. This suggests a deep conceptual analysis, as it involves understanding the fundamental nature of programming languages as a form of communication.
 - The mention of the ""general semiotic framework of the Von Neumann machine"" indicates a theoretical derivation of conceptual definitions, as it references a foundational model in computer science.
 - The analysis of ""persona, time, and space"" in different programming paradigms (imperative, functional, object-oriented) suggests specific conceptual dimensions or criteria used for classification. This implies a detailed feature-level analysis, as it involves examining specific aspects of programming languages.
 - The abstract does not explicitly mention empirical analysis or literature review as sources of conceptual definitions, but the discussion of theoretical frameworks and paradigms suggests a theoretical derivation.","- ""In other words, there is obviously a connection to the Sapir-Whorf hypothesis in the relationship between programming language and what it can express.""",,"- The abstract discusses the Turing-completeness of all programming languages, which implies that they can express the same concepts. However, it highlights the need for better expression of these concepts in terms of ease and efficiency, suggesting a limitation in how existing languages are classified or evaluated.
 - The mention of the Sapir-Whorf hypothesis suggests a critique of current classification methods, as it implies that the language itself influences what can be expressed, which may not be fully captured by existing taxonomies.
 - The abstract does not explicitly mention any specific limitations or critiques of current classification methods, nor does it propose improvements or alternative approaches. It focuses more on the theoretical framework and the relationship between language and expression rather than discussing specific limitations.","- ""A programming language is ”an artiﬁcial formalism in which algorithms can be expressed.""
  - ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""
  - ""All programming languages are Turing-complete.""
  - ""In high-level languages, in which the abstraction allows for the introduction of a ”structured” form of linguistic representation based on the notion of ”control ﬂow” by means of conditionals and loop, there is an osmosis between human and machine semiotics,""",,"- The abstract discusses the semiotic framework for programming languages and the analysis of different paradigms (imperative, functional, object-oriented), but it does not mention any specific validation method or criteria for the classification system.
 - There is no mention of empirical testing, mapping to existing languages, or any other form of validation in the abstract.
 - The focus is on the theoretical framework and analysis rather than on validation or empirical verification.","- ""there is obviously a connection to the Sapir-Whorf hypothesis in the relationship between programming language and what it can express.""
  - ""All programming languages are Turing-complete.""
  - ""there is an osmosis between human and machine semiotics, where the strict formal correctness of the machine side is balanced by the variety typical of natural languages.""
  - ""First we discuss the general semiotic framework of the Von Neumann machine; then, following the theory of enunciation, we analyze the concepts of persona, time, and space in the imperative, functional and object-oriented paradigms.""
  - ""A programming language is ”an artiﬁcial formalism in which algorithms can be expressed.""",,"- The abstract discusses the semiotic framework for programming languages, which implies a theoretical contribution to understanding how programming languages are structured and how they relate to human and machine semiotics.
 - The mention of the Sapir-Whorf hypothesis suggests a research implication related to how programming languages influence thought and expression, which could be relevant for comparative studies.
 - The analysis of concepts in different paradigms (imperative, functional, object-oriented) suggests a potential application in understanding and comparing these paradigms, which could be useful for educators and researchers.
 - The abstract does not explicitly mention specific practical applications or intended user groups, but the theoretical framework could potentially inform language design by highlighting the balance between formal correctness and natural language variety."
Operational versus definitional: a perspective on programming paradigms,"A. Ambler, M. Burnett, B. A. Zimmerman",10.1109/2.156380,https://doi.org/10.1109/2.156380,Computer,70,1992,"Taxonomy of programming paradigms with a continuum from operational to definitional, covering operational (side-effecting and non-side-effecting), demonstrational, definitional, pseudodefinitional (functional, transformational, logic), form-based, dataflow, and constraint-programming paradigms.","Derived from theoretical derivation, using hypothetical languages to illustrate paradigms, with a focus on control sequencing as a conceptual dimension for classification.",No limitations explicitly discussed,"Validated through concrete mappings of well-known languages in object-oriented, functional, and procedural categories","Framework to help programmers and educators understand and choose appropriate language concepts for problem-solving, facilitating high-level comparative studies of programming languages and potentially influencing language design.","- ""Various paradigms that support high-level programming are discussed independently of supporting languages.""
  - ""The paradigms are grouped according to their approach to problem solving.""
  - ""The operational approach describes step-by-step how to construct a solution.""
  - ""The demonstrational approach is a variation on it that illustrates the solution operationally for specific examples and lets the system generalize these example solutions for other cases.""
  - ""The definitional approach is different. It states properties about the solution to constrain it without describing how to compute it.""
  - ""These three approaches are viewed on a continuum from operational to definitional.""
  - ""we group them according to their approach to problem solving.""
  - ""These three approaches can be viewed on a continuum from operational to definitional.""
  - ""We start our discussionwith the operational approaches, describing each paradigm in a separate section.""
  - ""In choosing an algorithm for illustrating a particular paradigm, our objective is to best illustrate the natural style of the paradigm, not to find the most efficient solution.""
  - ""We have written the solutions in hypothetical languages.""
  - ""We do, however, briefly describe real languages that typify support for the paradigm.""
  - ""Step-by-step computational sequences characterize operational paradigms.""
  - ""Operational paradigms are of two basic types: those that proceed by repeatedly modifying their data representation (side-effecting) and those that proceed by continuously creating new data (non-side-effecting).""
  - ""Non-side-effecting paradigms include those that were traditionally calledfunctional paradigms.""
  - ""Operational paradigms define sequencing explicitly.""
  - ""In principle, definitional paradigms are not inherently serial or parallel because they do not address control sequencing and thus do not alter the natural parallelism of algorithms.""
  - ""The pseudodefinitional approaches discussed in this section arefunctional, transformational, and logic.""
  - ""Some paradigms do not have the difficulties that require reintroducing control sequencing. These areform-based, dataflow, and constraint-programming.""
  - ""The techniques associated with these parallel approaches and their impact on the corresponding paradigms are similar to those already discussed for operational paradigms.""
  - ""The functional paradigm attempts to match the mathematicalmodel byexpressingfunctions as mathematicians do.""
  - ""The logic paradigm assumes that we begin with a set of known facts, such as ""Tom is a father,"" and a set of rules that allow deduction of other facts.""
  - ""The central idea of the constraint-programming paradigm is to sufficiently constrain the solution value set such that only the desired solution or solutions are possible.""
  - ""When programming under the demonstrational paradigm (also called byexample or by-demonstration programming), programmers neither specify operationally how to compute a value set nor constrain the solution value set.""
  - ""We can view the programming paradigms discussed here on a continuum based on the relative degree to which control sequencing is expressed.""
  - ""Figure 2 shows the continuum.""",,"- The paper discusses various programming paradigms, focusing on their approaches to problem-solving.
 - The paradigms are categorized into operational, demonstrational, and definitional approaches.
 - The operational approach is further divided into side-effecting and non-side-effecting paradigms.
 - The paper also discusses pseudodefinitional paradigms such as functional, transformational, and logic.
 - Other paradigms like form-based, dataflow, and constraint-programming are mentioned.
 - The paper presents a continuum of these paradigms based on control sequencing.
 - The primary focus is on programming paradigms and their conceptual characteristics.
 - The scope includes multiple paradigms and their variations.","- ""Various paradigms that support high-level programming are discussed independently of supporting languages.""
  - ""The paradigms are grouped according to their approach to problem solving.""
  - ""The operational approach describes step-by-step how to construct a solution.""
  - ""The demonstrational approach is a variation on it that illustrates the solution operationally for specific examples and lets the system generalize these example solutions for other cases.""
  - ""The definitional approach is different. It states properties about the solution to constrain it without describing how to compute it.""
  - ""These three approaches are viewed on a continuum from operational to definitional.""
  - ""In choosing an algorithm for illustrating a particular paradigm, our objective is to best illustrate the natural style of the paradigm, not to find the most efficient solution.""
  - ""We have written the solutions in hypothetical languages. In this way we avoid communicating solutions that depend on a particular language.""
  - ""We do, however, briefly describe real languages that typify support for the paradigm.""
  - ""We can view the programming paradigms discussed here on a continuum based on the relative degree to which control sequencing is expressed.""",,"- The paper discusses various programming paradigms based on their approach to problem-solving, indicating a conceptual analysis of how different paradigms address computational tasks.
 - The classification system is based on the operational, demonstrational, and definitional approaches, which are described in detail, suggesting a deep conceptual analysis.
 - The paper uses hypothetical languages to illustrate paradigms, indicating a theoretical derivation of conceptual definitions rather than empirical analysis or literature review.
 - The classification criteria include the degree of control sequencing expressed, which is a specific conceptual dimension used for classification.
 - The paper provides a continuum view of paradigms based on control sequencing, suggesting a nuanced analytical approach to understanding the relationships between different paradigms.","- ""Various paradigms that support high-level programming are discussed independently of supporting languages.""
  - ""The operational approach describes step-by-step how to construct a solution.""
  - ""The demonstrational approach is a variation on it that illustrates the solution operationally for specific examples and lets the system generalize these example solutions for other cases.""
  - ""The definitional approach is different. It states properties about the solution to constrain it without describing how to compute it.""
  - ""These three approaches are viewed on a continuum from operational to definitional.""
  - ""Most attempts at general definitional approaches to programming are eventually tainted by operational necessities that work their way back into the supported paradigm.""
  - ""The resulting paradigms and supporting languages are not truly definitional. We refer to these tainted approaches as pseudodefinitional.""
  - ""The pseudodefinitional approaches discussed in this section arefunctional, transformational, and logic.""
  - ""In principle, definitional paradigms are not inherently serial or parallel because they do not address control sequencing and thus do not alter the natural parallelism of algorithms.""
  - ""The techniques associated with these parallel approaches and their impact on the corresponding paradigms are similar to those already discussed for operational paradigms.""
  - ""The logic paradigm is intended for general-purpose programming. Indeed, pseudodefinitional logic is used for production programming in industry, where it is very well-suited to certain types of problems.""
  - ""There are other nondefinitional features found in most implementations of logic-programming variants, most notably cuts.""
  - ""The cut is an extra-logical device that creates a barrier inhibiting the backtracking mechanism of the theorem prover.""",,"- The paper discusses various programming paradigms and their characteristics, but it does not explicitly critique existing classification methods or taxonomies.
 - The paper focuses on describing different paradigms (operational, demonstrational, definitional) and their variations, rather than discussing limitations of existing classification approaches.
 - The mention of ""pseudodefinitional"" approaches suggests a critique of how some paradigms are not purely definitional due to operational necessities, but this is more about the nature of the paradigms themselves rather than a critique of classification methods.
 - The paper does not explicitly mention any limitations or critiques of current taxonomies or classification methods in programming languages.","- ""We have written the solutions in hypothetical languages. In this way we avoid communicating solutions that depend on a particular language. Some of these ""pure"" languages may resemble real languages.""
  - ""We do, however, briefly describe real languages that typify support for the paradigm.""
  - ""Many programming languages support this model; most also include extensions that support other paradigms to varying degrees.""
  - ""Smalltalk' is the preeminent object-oriented language, both historically and in the extent of its compatibility with the paradigm.""
  - ""Pure"" Lisp' represents this paradigm best.""
  - ""Examples of form-based languages include Farms/31,2 and Plane Lucid.""
  - ""A good example of a modern functional language is Haskell,' which represents an effort by the functional programming language community to reach a consensus and thereby encourage wider use of functional languages.""",,"- The paper discusses the use of hypothetical languages to illustrate paradigms, which suggests a theoretical approach to validation rather than empirical testing.
 - The authors mention real languages that typify support for each paradigm, indicating a mapping to existing languages as a form of validation.
 - Specific languages like Smalltalk and Lisp are highlighted as examples that align with certain paradigms, which serves as a form of validation by mapping the proposed formalism to well-known languages.
 - The mention of other languages like Haskell and form-based languages like Farms and Plane Lucid further supports the validation through mapping to existing languages.
 - There is no mention of empirical testing or specific criteria used to demonstrate validity beyond the mapping to existing languages.","- ""We feel that stepping back from these languages to understand the underlying programming paradigms independent-ly can broaden our programming skills, develop new perspectives on how to use particular programming languages and styles, and perhaps stimulate curiosity about alternatives to our favorite programming paradigms.""
  - ""P rogramming paradigms affect our thought processes for solving problems. They provide a framework and determine the form in which we express solutions.""
  - ""A number of programming languages have evolved based on particular programming paradigms.""",,"- The paper discusses how understanding programming paradigms can influence problem-solving approaches and language usage, suggesting a practical application for programmers and educators.
 - The mention of broadening programming skills and developing new perspectives implies that the classification system could be used as a tool for educational purposes, helping students and practitioners understand different paradigms.
 - The potential impact on language design is suggested by the idea that understanding paradigms can stimulate curiosity about alternative paradigms, which could lead to the development of new languages or improvements in existing ones.
 - The paper does not explicitly mention specific use cases or applications, but the implications for comparative studies are clear, as understanding paradigms can facilitate comparisons between languages."
Towards a Taxonomy for Reversible Computation Approaches,"R. Glück, Ivan Lanese, C. A. Mezzina, Jaroslaw Adam Miszczak, I. Phillips, I. Ulidowski, G. Vidal",10.1007/978-3-031-38100-3_3,https://doi.org/10.1007/978-3-031-38100-3_3,International Workshop on Reversible Computation,1,2023,"Taxonomy of reversible computation approaches with six dimensions: Reversibility focus (FOC), Resources for reversibility (RES), When reversibility is enabled (WHE), Order of undoing (ORD), State reachability (STR), and Precision (PRE).","Derived from theoretical derivation, using expertise in formal methods and programming languages, with a detailed feature-level analysis and concrete mappings of well-known languages and models.","- Existing notions of reversible computation have not been compared or categorized in detail.
 - Defining a taxonomy for reversible computation is challenging due to its heterogeneity.
 - Current taxonomy proposals are not exhaustive or definitive.
 - There is a lack of comprehensive classification approaches.
 - Gaps in literature coverage exist.
 - Focus is mainly on precise reversibility and action undoing, with less emphasis on imperfect reversibility and other aspects.",No formal validation described,Framework for facilitating comparative studies of reversible computation models and languages; Tool for researchers and educators to understand relationships among different approaches; Potential applications in theoretical computer science for investigating computational power and complexity; Future research directions include exploring non-perfect reversibility in robotics and neural networks.,"- ""This work aims at being a first stepping stone towards a taxonomy of the approaches that co-exist under the term reversible computation.""
  - ""we present our taxonomy for approaches in the area of reversible computation. The taxonomy includes six dimensions, and for each dimension we describe different positions that a given approach may fit.""
  - ""The taxonomy includes six dimensions, and for each dimension we describe different positions that a given approach may fit.""
  - ""We have presented a first proposal of taxonomy for reversible computation approaches, and discussed how various models fit in it.""
  - ""We are not aware of other works putting forward proposals of taxonomies for reversible computing.""","- ""(Page 10, Table 1) | Formalism | Approach  | FOCus  | RESource | WHEn | ORDer | STate R. | PREcis. |
 \n|----------------------------------|----------------|---------|----------|------|-------|----------|---------|
 \n| Reversible Turing machines  | [8, 67] | FUN UND | NON | ALW | REV  | PAS | PRC  |""","- The paper explicitly states that it aims to develop a ""taxonomy of the approaches that co-exist under the term reversible computation."" This indicates that the primary focus is on creating a classification system for reversible computation approaches.
 - The taxonomy is described as including six dimensions, which suggests a structured classification framework.
 - The paper discusses how various models fit into this taxonomy, indicating that the scope includes multiple approaches within reversible computation.
 - The table at the end of the paper provides a detailed application of the taxonomy to various formalisms, further supporting the idea that a taxonomy is the primary formalism developed.","- ""This work aims at being a first stepping stone towards a taxonomy of the approaches that co-exist under the term reversible computation.""
  - ""we provide a possible classification, with the aim to start the discussion.""
  - ""The taxonomy includes six dimensions, and for each dimension we describe different positions that a given approach may fit.""
  - ""We note that the same approach may fit different positions, depending on the level of abstraction.""
  - ""We describe below each dimension, by explaining the different positions, with examples of approaches that fit each of them.""
  - ""We remark that defining a taxonomy for a field as heterogeneous as reversible computation is a very difficult task, and as far as we are aware this is the first effort in this direction.""
  - ""our examples are concentrated in the area of formal methods and programming languages, which are the main expertise of most of the authors, and we may have missed very significant examples from other areas.""
  - ""We are not aware of other works putting forward proposals of taxonomies for reversible computing.""
  - ""Table 1 , while not covering all the literature, highlights some holes which are interesting targets for future work.""",,"- The paper aims to create a taxonomy for reversible computation approaches, indicating a deep conceptual analysis to categorize various models and languages.
 - The taxonomy is based on six dimensions, which suggests a structured and detailed approach to classification.
 - The authors mention that the same approach can fit different positions depending on the level of abstraction, indicating a nuanced understanding of the complexity of reversible computation.
 - The paper is based on the authors' expertise in formal methods and programming languages, suggesting a theoretical derivation of the conceptual dimensions.
 - The authors acknowledge the difficulty of defining a taxonomy for such a heterogeneous field, indicating a deep understanding of the challenges involved.
 - The paper does not mention empirical analysis or literature review as primary sources for conceptual definitions, suggesting a theoretical approach.
 - The table included at the end of the paper provides a detailed mapping of various approaches to the taxonomy, indicating a concrete and detailed analysis.","- ""The existing notions of reversible computation however have never been compared and categorized in detail.""
  - ""We remark that defining a taxonomy for a field as heterogeneous as reversible computation is a very difficult task, and as far as we are aware this is the first effort in this direction.""
  - ""We do not claim that our taxonomy is the final word on the subject, and indeed other dimensions may be worth considering, in addition to or instead of some of the ones that we propose (cf. Section 2), and of course we do not claim to be complete on our coverage of models 9 and languages (cf. Section 3).""
  - ""We are not aware of other works putting forward proposals of taxonomies for reversible computing.""
  - ""Table 1 , while not covering all the literature, highlights some holes which are interesting targets for future work.""
  - ""For instance, a large part of the approaches concern precise reversibility, and indeed this is the main focus of the reversible computing community. Approaches where reversibility is not perfect are however of interest as well, motivated, e.g., by applications in robotics and neural networks, and are an interesting research direction for the reversible computation community.""
  - ""Another interesting point is that most of the approaches focus on undoing actions, while a focus on functional behavior and on states has been adopted only in a few cases.""",,"- The paper explicitly states that existing notions of reversible computation have not been compared or categorized in detail, indicating a lack of comprehensive classification approaches.
 - The authors acknowledge the difficulty in defining a taxonomy for reversible computation due to its heterogeneity, suggesting that current methods may not adequately address this complexity.
 - The paper does not claim to be exhaustive or definitive, implying that there are limitations in the current taxonomy proposed by the authors themselves.
 - The absence of other taxonomy proposals suggests a gap in existing classification methods.
 - The table highlights gaps in literature coverage, indicating limitations in the current classification approach.
 - The focus on precise reversibility and action undoing suggests a limitation in addressing imperfect reversibility and other aspects like functional behavior and state reachability.","- ""Table 1 , while not covering all the literature, highlights some holes which are interesting targets for future work.""
  - ""We are not aware of other works putting forward proposals of taxonomies for reversible computing.""
  - ""We have presented a first proposal of taxonomy for reversible computation approaches, and discussed how various models fit in it.""
  - ""We do not claim that our taxonomy is the final word on the subject, and indeed other dimensions may be worth considering, in addition to or instead of some of the ones that we propose (cf. Section 2), and of course we do not claim to be complete on our coverage of models 9 and languages (cf. Section 3).""","- ""(Page 10, Table 1) | Formalism | Approach  | FOCus  | RESource | WHEn | ORDer | STate R. | PREcis. |
 \n|----------------------------------|----------------|---------|----------|------|-------|----------|---------|
 \n| Reversible Turing machines  | [8, 67] | FUN UND | NON | ALW | REV  | PAS | PRC  |""","- The paper explicitly states that the authors do not claim their taxonomy to be complete or final, indicating a lack of formal validation.
 - The authors mention that they have discussed how various models fit into their taxonomy, but this does not imply a formal validation process.
 - The paper does not mention any specific validation approach, such as empirical testing or mapping to existing languages.
 - The table included at the end of the paper provides examples of how different models fit into the taxonomy, but this is not described as a validation method.
 - The authors note that their work is a first proposal and that other dimensions may be worth considering, suggesting that the taxonomy is not yet validated against existing standards or criteria.","- ""This work aims at being a first stepping stone towards a taxonomy of the approaches that co-exist under the term reversible computation.""
  - ""We hope that such a work will shed light on the relation among the various approaches.""
  - ""We do not claim that our taxonomy is the final word on the subject, and indeed other dimensions may be worth considering, in addition to or instead of some of the ones that we propose""
  - ""We focused on approaches from programming languages and concurrency theory, hence in future work it would be good to put our taxonomy at work also on other kinds of models.""
  - ""Table 1 , while not covering all the literature, highlights some holes which are interesting targets for future work.""
  - ""For instance, a large part of the approaches concern precise reversibility, and indeed this is the main focus of the reversible computing community.""
  - ""Approaches where reversibility is not perfect are however of interest as well, motivated, e.g., by applications in robotics and neural networks, and are an interesting research direction for the reversible computation community.""
  - ""From a theoretical perspective, it would also be interesting to investigate the computational power and inherent complexity of reversible computing models.""",,"- The paper proposes a taxonomy for reversible computation approaches, which is intended to help understand the relationships among different models and languages.
 - The taxonomy is designed to be a starting point for further research and discussion, indicating its potential use for researchers and educators in the field.
 - The authors suggest that the taxonomy could be applied to other models beyond programming languages and concurrency theory, indicating potential use cases in broader areas of computer science.
 - The paper highlights areas for future research, such as investigating the computational power and complexity of reversible models, which suggests potential applications in theoretical computer science.
 - The taxonomy could facilitate comparative studies of different reversible computation models and languages, helping practitioners choose appropriate concepts for problem-solving."
Types for Multi-Paradigm Modelling,"J. Lara, H. Vangheluwe",-,-,-,0,-,No specific formalism developed (the abstract discusses limitations and proposes improvements but does not specify a clear formalism or taxonomy),"Derived from theoretical derivation, using detailed feature-level analysis with concrete mappings of multi-paradigm modeling concepts","- Limitations in handling multiparadigm modelling (combination of meta-modelling, multi-formalism modelling, and multiple abstraction levels)
 - Lack of temporal representation and simulation information in current types",No formal validation described,"Framework for improving multi-paradigm modeling by enhancing type systems with time representation and simulation, facilitating flexible modeling and automatic tool generation for practitioners and researchers.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""
  - ""AToM3 allows one to model different parts of a system using different formalisms.""
  - ""The formalisms themselves are modelled at a metalevel within an appropriate formalism.""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the limitations of regular programming language types in multi-paradigm modeling, indicating a focus on improving or developing a new formalism for handling multiple programming paradigms.
 - The term ""multi-paradigm"" suggests a classification system that encompasses multiple programming paradigms, such as meta-modelling, multi-formalism modeling, and multiple abstraction levels.
 - The inclusion of information about time representation and simulation in types suggests a focus on conceptual characteristics related to time and simulation.
 - The mention of AToM3 and its ability to model different parts of a system using different formalisms implies a tool-based implementation of the formalism.
 - The use of graph grammars to manipulate types indicates a specific method for handling and relating different types within the formalism.
 - The abstract does not specify a particular category of formalism like a feature model or taxonomy, nor does it provide details on the scope or number of language categories or features covered.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""
  - ""AToM3 allows one to model different parts of a system using different formalisms.""
  - ""The formalisms themselves are modelled at a metalevel within an appropriate formalism.""
  - ""AToM3 uses the information found in the meta-models to automatically generate tools to process (create, edit, check, and generate simulators for) the models in the described formalism.""
  - ""Models can be automatically converted between formalisms thanks to information found in a Formalism Transformation Graph (FTG).""
  - ""The transformations are described at a meta-level by means of models in the graph-grammar formalism.""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the limitations of regular programming language types in multi-paradigm modeling, indicating a deep conceptual analysis of these limitations.
 - The authors propose including information about time representation and simulation in types, suggesting a detailed feature-level analysis.
 - The use of meta-modelling, multi-formalism modeling, and multiple abstraction levels indicates a comprehensive approach to conceptual granularity.
 - The mention of AToM3 and its capabilities suggests a theoretical derivation of the conceptual approach, as it involves designing and implementing multi-paradigm concepts.
 - The abstract does not explicitly mention a literature review or empirical analysis, but the detailed description of AToM3 and its functionalities implies a theoretical derivation.
 - The specific conceptual dimensions include the representation of time, formalisms, and types, as well as the use of graph grammars for type manipulation.","- ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""In particular, we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""",,"- The abstract explicitly mentions ""the limitations found in regular programming language types when used in the context of multiparadigm modelling."" This indicates that the authors are discussing limitations in existing classification approaches related to types in programming languages.
 - The context of ""multiparadigm modelling"" suggests that current types do not adequately handle the complexity of combining different modelling paradigms, formalisms, and abstraction levels.
 - The proposal to include ""information about how time is represented and ultimately simulated"" implies a limitation in current types regarding temporal representation and simulation.
 - The discussion of the relationship between formalisms and types suggests a limitation in how current classification methods handle the integration of different formalisms.
 - The abstract does not provide specific critiques of current taxonomies or classification methods but focuses on the limitations related to handling multiparadigm modelling and temporal representation.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""
  - ""AToM3 allows one to model different parts of a system using different formalisms.""
  - ""The formalisms themselves are modelled at a metalevel within an appropriate formalism.""
  - ""AToM3 uses the information found in the meta-models to automatically generate tools to process (create, edit, check, and generate simulators for) the models in the described formalism.""
  - ""Models can be automatically converted between formalisms thanks to information found in a Formalism Transformation Graph (FTG).""
  - ""The transformations are described at a meta-level by means of models in the graph-grammar formalism.""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the design and implementation of multi-paradigm concepts in AToM3, which involves modeling different parts of a system using different formalisms.
 - It mentions the use of meta-models to generate tools for processing models, which implies a structured approach to handling different formalisms.
 - The abstract describes the use of a Formalism Transformation Graph (FTG) for converting models between formalisms, which suggests a systematic method for handling different formalisms.
 - However, there is no explicit mention of a validation method for the classification system or taxonomy proposed in the article.
 - The abstract does not provide details on empirical testing, mapping to existing languages, or specific criteria used to demonstrate validity.","- ""In this article we discuss the limitations found in regular programming language types when used in the context of multiparadigm modelling.""
  - ""By multi-paradigm, we mean the combination of meta-modelling (i.e., modelling models), multi-formalism modelling, and multiple abstraction levels.""
  - ""we propose the inclusion, in types, of information about how time is represented and ultimately simulated in each component of a system model.""
  - ""We also discuss the relationship between formalisms and types, and give an overview of the design and implementation of the multi-paradigm concepts in a tool called AToM3.""
  - ""AToM3 allows one to model different parts of a system using different formalisms.""
  - ""The formalisms themselves are modelled at a metalevel within an appropriate formalism.""
  - ""AToM3 uses the information found in the meta-models to automatically generate tools to process (create, edit, check, and generate simulators for) the models in the described formalism.""
  - ""Models can be automatically converted between formalisms thanks to information found in a Formalism Transformation Graph (FTG).""
  - ""The transformations are described at a meta-level by means of models in the graph-grammar formalism.""
  - ""Composite types are described by constructing models in the “types” formalism which has also been modelled at a meta-level within AToM3.""
  - ""Graph grammars are used to manipulate types.""",,"- The abstract discusses the limitations of regular programming language types in multi-paradigm modeling, indicating a research implication in addressing these limitations.
 - The proposal to include time representation and simulation in types suggests a practical application in improving system modeling.
 - The development of AToM3 as a tool for multi-paradigm modeling implies a practical application for practitioners and researchers in modeling complex systems.
 - The ability to model different parts of a system using different formalisms and automatically generate tools suggests a potential impact on language design by facilitating more flexible and adaptable modeling.
 - The use of Formalism Transformation Graphs (FTGs) and graph grammars indicates a research implication in developing new methods for model transformation and type manipulation.
 - The abstract does not explicitly mention intended user groups or specific use cases, but the focus on tool development and formalism transformation suggests applications for both practitioners and researchers."
A Design Space for Integrating Declarative Languages,"J. Darlington, Yike Guo, Helen Pull",10.1007/978-1-4471-3794-8_1,https://doi.org/10.1007/978-1-4471-3794-8_1,Declarative Programming,1,1991,"Classification framework for integrating functional and logic programming languages within the Phoenix Design Space (PDS), focusing on declarative programming languages and inducing a new paradigm, constraint functional logic programming.","Theoretical derivation with a shallow depth of conceptual analysis, using a simple classification system based on assertional programming and constraint abstract machine concepts.",No limitations explicitly discussed,No formal validation described,"- Intended user groups: Researchers, educators, practitioners
 - Specific use cases or potential applications: Integration of functional and logic programming languages, insights into concurrency and program transformation
 - Potential impact on language design or comparative studies: Provides a methodology for systematic integration and classification, induces a new programming paradigm","- ""The PDS provides a methodology for systematically integrating functional and logic programming languages.""
  - ""We present a simple classification of existing integrated functional and logic programming systems and show how the design space induces a powerful new programming paradigm, constraint functional logic programming, and provides insights into other aspects of declarative programming such as concurrency and program transformation.""
  - ""We present a survey of the Phoenix Design Space (PDS) and its applications.""
  - ""The PDS is a conceptual framework for studying declarative programming languages based on assertional programming as a uniform presentation of declarative language semantics, and a constraint abstract machine as a general computational model for declarative programming.""",,"- The abstract mentions the ""Phoenix Design Space (PDS)"" as a ""conceptual framework"" for studying declarative programming languages. This suggests that the PDS is a type of formalism or taxonomy.
 - The PDS is described as providing a ""methodology for systematically integrating functional and logic programming languages,"" indicating its primary focus is on integrating these programming paradigms.
 - The abstract also mentions a ""simple classification of existing integrated functional and logic programming systems,"" which implies that the PDS includes a classification framework for these systems.
 - The scope of the classification seems to be focused on declarative programming languages, specifically functional and logic programming languages, and their integration.
 - The abstract does not specify the number of language categories or features covered, but it does mention the induction of a new programming paradigm, ""constraint functional logic programming,"" which suggests a broad scope.","- ""We present a survey of the Phoenix Design Space (PDS) and its applications.""
  - ""The PDS is a conceptual framework for studying declarative programming languages based on assertional programming as a uniform presentation of declarative language semantics, and a constraint abstract machine as a general computational model for declarative programming.""
  - ""We present a simple classification of existing integrated functional and logic programming systems and show how the design space induces a powerful new programming paradigm, constraint functional logic programming, and provides insights into other aspects of declarative programming such as concurrency and program transformation.""
  - ""The PDS provides a methodology for systematically integrating functional and logic programming languages.""",,"- The abstract mentions a ""survey of the Phoenix Design Space (PDS) and its applications,"" which suggests a broad overview rather than a deep, detailed analysis. This implies a shallow depth of conceptual analysis.
 - The PDS is described as a ""conceptual framework,"" which indicates that it is based on theoretical derivation rather than empirical analysis or literature review. This suggests that the sources of conceptual definitions are likely theoretical.
 - The abstract mentions a ""simple classification of existing integrated functional and logic programming systems,"" which implies that the classification system is not overly complex or detailed. This suggests that the specific conceptual dimensions or criteria used for classification are not deeply nuanced.
 - The abstract does not mention any specific empirical analysis or literature review as sources for the conceptual definitions, reinforcing the idea that the approach is theoretically derived.","- ""We present a simple classification of existing integrated functional and logic programming systems and show how the design space induces a powerful new programming paradigm, constraint functional logic programming, and provides insights into other aspects of declarative programming such as concurrency and program transformation.""
  - ""The PDS provides a methodology for systematically integrating functional and logic programming languages.""
  - ""The PDS is a conceptual framework for studying declarative programming languages based on assertional programming as a uniform presentation of declarative language semantics, and a constraint abstract machine as a general computational model for declarative programming.""
  - ""We present a survey of the Phoenix Design Space (PDS) and its applications.""",,"- The abstract discusses the Phoenix Design Space (PDS) as a conceptual framework for studying declarative programming languages, which implies a focus on integrating functional and logic programming languages.
 - It mentions a ""simple classification of existing integrated functional and logic programming systems,"" which suggests that there is some form of classification or taxonomy being discussed.
 - However, the abstract does not explicitly mention any limitations of existing classification approaches or critiques of current taxonomies.
 - The focus is on the PDS as a methodology for integration and its applications, rather than on the limitations of existing methods.
 - There is no mention of specific limitations, critiques, or proposed improvements regarding existing classification methods.","- ""We present a simple classification of existing integrated functional and logic programming systems and show how the design space induces a powerful new programming paradigm, constraint functional logic programming, and provides insights into other aspects of declarative programming such as concurrency and program transformation.""
  - ""The PDS provides a methodology for systematically integrating functional and logic programming languages.""
  - ""The PDS is a conceptual framework for studying declarative programming languages based on assertional programming as a uniform presentation of declarative language semantics, and a constraint abstract machine as a general computational model for declarative programming.""
  - ""We present a survey of the Phoenix Design Space (PDS) and its applications.""",,"- The abstract discusses the Phoenix Design Space (PDS) as a conceptual framework for studying declarative programming languages, which implies a theoretical approach rather than an empirical validation.
 - It mentions a ""simple classification of existing integrated functional and logic programming systems,"" which suggests some form of mapping or categorization, but it does not specify whether this classification was validated through empirical testing or other means.
 - The abstract does not provide details on specific languages or examples used in validation or criteria used to demonstrate validity.
 - The focus is on presenting the PDS and its applications rather than on validating a classification system.","- ""We present a simple classification of existing integrated functional and logic programming systems and show how the design space induces a powerful new programming paradigm, constraint functional logic programming, and provides insights into other aspects of declarative programming such as concurrency and program transformation.""
  - ""The PDS provides a methodology for systematically integrating functional and logic programming languages.""
  - ""The PDS is a conceptual framework for studying declarative programming languages based on assertional programming as a uniform presentation of declarative language semantics, and a constraint abstract machine as a general computational model for declarative programming.""
  - ""We present a survey of the Phoenix Design Space (PDS) and its applications.""",,"- The abstract mentions that the Phoenix Design Space (PDS) is a conceptual framework for studying declarative programming languages, which implies it is a tool for researchers and educators interested in understanding and comparing these languages.
 - The PDS provides a methodology for integrating functional and logic programming languages, suggesting it is useful for practitioners who need to combine these programming paradigms.
 - The classification of existing integrated systems and the induction of a new programming paradigm indicate potential applications in language design and comparative studies.
 - The mention of insights into concurrency and program transformation suggests potential use cases in these areas."
Formalising sharing mechanisms in object-oriented paradigm,"Verónica Argarañaz, G. Baum, C. Pons, María José Presso, M. Prieto, Natalia Romero",-,-,-,0,1997,Formal calculus of objects (impς-calculus) for representing delegation between concrete objects in prototype environments,"Derived from theoretical derivation, using Abadi and Cardelli's formal calculus of objects to express delegation between concrete objects and represent sharing schemes in a prototype environment.","- Most existing models focus on class-based inheritance, neglecting prototype-based languages.
 - Less effort has been made to develop foundations for prototype-based languages.
 - Abadi & Cardelli's formalism lacks representation of delegation among concrete objects in prototype-based languages.",No formal validation described (the abstract discusses theoretical mapping and representation but lacks explicit validation methods or criteria),Framework for facilitating high-level comparative studies of programming languages; Tool for programmers to choose appropriate language concepts for problem-solving; Potential impact on language design by providing a formal calculus for per object delegation in prototype environments.,"- ""Sharing of behavior is one of the most important features in the Object-Oriented paradigm.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""Abadi and Cardelli have defined a calculus of objects which represents the basic elements.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment,""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""Martin Abadi & Luca Cardelli have defined a formal calculus of objects, the impς-calculus, which consists just of objects, object communication and object update""
  - ""We have built per object delegation using the calculus.""",,"- The abstract discusses the development of a formalism related to the Object-Oriented paradigm, specifically focusing on sharing mechanisms.
 - The authors mention the use of a ""calculus of objects"" defined by Abadi and Cardelli, which is a formal system for representing object-oriented concepts.
 - The primary focus of this formalism is on expressing delegation between concrete objects, which is a key aspect of prototype-based languages.
 - The scope of this classification includes the representation of sharing schemes in prototype environments, indicating a focus on object-oriented programming paradigms.
 - The abstract does not explicitly mention a taxonomy or classification framework but describes a formal calculus for representing object-oriented concepts, particularly delegation.","- ""Sharing of behavior is one of the most important features in the Object-Oriented paradigm.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""Abadi and Cardelli have defined a calculus of objects which represents the basic elements.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""This shows how constructs similar to those appearing in usual programming languages can be written in the formal calculus, and allows writing programs in the formalism without requiring understanding details about it.""
  - ""There are primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object.""
  - ""Martin Abadi & Luca Cardelli have defined a formal calculus of objects, the impς-calculus, which consists just of objects, object communication and object update""
  - ""We have built per object delegation using the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment,""",,"- The abstract discusses the conceptual granularity by focusing on the sharing mechanisms in object-oriented programming, specifically how these can be represented using a basic model of objects and messages. This suggests a deep level of conceptual analysis, as it involves breaking down complex sharing schemes into fundamental components.
 - The sources of conceptual definitions appear to be theoretical derivation, as indicated by the use of Abadi and Cardelli's formal calculus of objects. This calculus is used to derive and express delegation between concrete objects, which is a key conceptual dimension in the classification system.
 - The specific conceptual dimensions or criteria used for classification include the ability to express delegation between concrete objects and the representation of sharing schemes in a prototype environment. This is evident from the mention of building per object delegation using the calculus and representing every sharing scheme possible in a prototype environment.
 - The abstract does not mention empirical analysis or literature review as sources of conceptual definitions, suggesting that the approach is primarily theoretical and based on formal derivation.","- ""Most of these models define the concept of class as a basic construction of object-oriented languages and make emphasis on the semantics of class-based inheritance.""
  - ""Abadi & Cardelli describe how to build the concepts of class based languages in their formalism, but they don't represent the ability to share behavior by delegation among concrete objects present in prototype based languages.""
  - ""Most existing models of Object-Oriented languages fall into one of three categories: Models in the first category, such as the ones defined in [Breu89, Ehrich90, Goguen94, Lu93 ], rest on the appealing simile between the programming concept of object and the mathematical notion of algebra. Models of the second kind [Abadi96, America90, Bruce91, Castagna92, Cook90, Steyaert95 ] describe object-oriented languages using some formal notation, such as lambda calculus. Models in the third category [Bahsoun93, Fiadeiro96, Meseguer91, Wieringa94] give formal semantics of an object as a logic theory.""",,"- The abstract discusses the limitations of existing models by categorizing them into three types and highlighting their focus areas. It notes that most models emphasize class-based inheritance, which suggests a limitation in their ability to represent prototype-based languages.
 - The abstract explicitly states that there has been less effort to develop foundations for prototype-based languages, indicating a gap in the current classification approaches.
 - The mention that Abadi & Cardelli's formalism does not represent delegation among concrete objects in prototype-based languages highlights a specific limitation in their approach.
 - The abstract does not provide a detailed critique of current taxonomies or classification methods but focuses on the methodological limitations related to the representation of prototype-based languages.","- ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""This shows how constructs similar to those appearing in usual programming languages can be written in the formal calculus, and allows writing programs in the formalism without requiring understanding details about it.""
  - ""We conclude by stating some final remarks and future work.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in Object-Oriented languages can be built using only objects and messages.""",,"- The abstract discusses the development of a formal calculus that can represent sharing schemes in object-oriented programming, specifically focusing on prototype-based languages.
 - It mentions the definition of sharing constructs for an object-based high-level language and their translation into the formal calculus, which suggests a mapping or translation approach to validation.
 - The abstract indicates that the formalism can represent constructs similar to those in usual programming languages, implying a form of validation through mapping to existing languages.
 - However, there is no explicit mention of empirical testing or specific criteria used to demonstrate validity beyond the theoretical mapping and representation.
 - The abstract does not provide specific examples or languages used in validation, nor does it detail any empirical verification or testing.
 - The conclusion section mentions future work, which might imply that further validation or testing is planned but not yet conducted.","- ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in Object-Oriented languages can be built using only objects and messages.""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""This shows how constructs similar to those appearing in usual programming languages can be written in the formal calculus, and allows writing programs in the formalism without requiring understanding details about it.""
  - ""There are primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object.""
  - ""Section 6 exemplifies the use of the proposed language, giving solutions to known problems.""
  - ""We conclude by stating some final remarks and future work.""",,"- The abstract discusses the development of a formal calculus that allows for per object delegation, which is a significant contribution to the field of object-oriented programming.
 - The work provides a framework for representing sharing schemes in prototype environments, which can be used to build constructs similar to those in usual programming languages.
 - The abstract mentions that the proposed language can be used to write programs without requiring detailed understanding of the formalism, which suggests practical applications for programmers.
 - The mention of ""Section 6 exemplifies the use of the proposed language, giving solutions to known problems"" indicates that the work has potential use cases for solving specific problems in programming.
 - The conclusion about future work suggests that the authors see potential for further research and development based on their contributions."
Programming paradigms for dummies: what every programmer should know,P. V. Roy,-,-,-,69,2009,Taxonomy of 30 programming paradigms with relational mapping,"Derived from a comprehensive taxonomy of programming paradigms, using a detailed feature-level analysis with concrete mappings of paradigm relationships and influences on language design.",No limitations explicitly discussed,No formal validation described,Framework to help programmers choose appropriate language concepts for problem-solving; Tool for facilitating high-level comparative studies of programming languages; Potential impact on language design and comparative studies; Specific use cases in multi-core processor environments and computer music.,"- ""This chapter gives an introduction to all the main programming paradigms, their underlying concepts, and the relationships between them.""
  - ""We give a taxonomy of almost 30 useful programming paradigms and how they are related.""
  - ""We explain briefly how programming paradigms influence language design, and we show two sweet spots: dual-paradigm languages and a definitive language.""
  - ""We introduce the main concepts of programming languages: records, closures, independence (concurrency), and named state.""
  - ""We explain the main principles of data abstraction and how it lets us organize large programs.""
  - ""We present four little-known but important paradigms that greatly simplify concurrent programming with respect to mainstream languages: declarative concurrency (both eager and lazy), functional reactive programming, discrete synchronous programming, and constraint programming.""",,"- The abstract mentions a ""taxonomy of almost 30 useful programming paradigms,"" which indicates that the primary focus of the classification is on programming paradigms.
 - The scope of the classification is specified as covering ""almost 30 useful programming paradigms,"" which provides a clear number of language categories covered.
 - The abstract also discusses the relationships between these paradigms, suggesting a relational mapping within the taxonomy.
 - The focus on programming paradigms and their relationships suggests that the formalism developed is a taxonomy, specifically a taxonomy of programming paradigms.","- ""We give a taxonomy of almost 30 useful programming paradigms and how they are related.""
  - ""Most of them differ only in one or a few concepts, but this can make a world of difference in programming.""
  - ""We introduce the main concepts of programming languages: records, closures, independence (concurrency), and named state.""
  - ""We explain briefly how programming paradigms influence language design, and we show two sweet spots: dual-paradigm languages and a definitive language.""
  - ""This chapter gives an introduction to all the main programming paradigms, their underlying concepts, and the relationships between them.""
  - ""We present four little-known but important paradigms that greatly simplify concurrent programming with respect to mainstream languages: declarative concurrency (both eager and lazy), functional reactive programming, discrete synchronous programming, and constraint programming.""
  - ""We explain the main principles of data abstraction and how it lets us organize large programs.""",,"- The abstract provides a broad introduction to programming paradigms, indicating a comprehensive approach to conceptual analysis.
 - The mention of a taxonomy of almost 30 paradigms suggests a detailed classification system, which implies a deep level of conceptual analysis.
 - The abstract does not explicitly mention sources such as literature review, empirical analysis, or theoretical derivation, but the detailed taxonomy and explanation of relationships suggest a literature-based approach.
 - Specific conceptual dimensions or criteria used for classification are not explicitly mentioned, but the focus on relationships between paradigms and their influence on language design implies a structured analytical approach.
 - The introduction of main concepts and principles of data abstraction suggests a detailed feature-level analysis.","- ""This chapter gives an introduction to all the main programming paradigms, their underlying concepts, and the relationships between them.""
  - ""We give a taxonomy of almost 30 useful programming paradigms and how they are related.""
  - ""Most of them differ only in one or a few concepts, but this can make a world of difference in programming.""
  - ""We explain briefly how programming paradigms influence language design, and we show two sweet spots: dual-paradigm languages and a definitive language.""
  - ""We introduce the main concepts of programming languages: records, closures, independence (concurrency), and named state.""
  - ""We explain the main principles of data abstraction and how it lets us organize large programs.""
  - ""Finally, we conclude by focusing on concurrency, which is widely considered the hardest concept to program with.""
  - ""We present four little-known but important paradigms that greatly simplify concurrent programming with respect to mainstream languages: declarative concurrency (both eager and lazy), functional reactive programming, discrete synchronous programming, and constraint programming.""
  - ""These paradigms have no race conditions and can be used in cases where no other paradigm works.""",,"- The abstract provides an overview of the chapter's content, focusing on introducing programming paradigms and their relationships.
 - It mentions the presentation of a taxonomy of almost 30 programming paradigms, which suggests an attempt to organize and classify these paradigms.
 - The abstract does not explicitly mention any limitations of existing classification approaches or taxonomies.
 - There is no critique of current taxonomies or classification methods in the abstract.
 - The focus is on introducing and explaining various paradigms and their applications, particularly in concurrent programming.
 - The abstract does not propose improvements or alternative approaches to existing classification methods.","- ""We explain why for multi-core processors and we give several examples from computer music, which often uses these paradigms.""
  - ""We present four little-known but important paradigms that greatly simplify concurrent programming with respect to mainstream languages: declarative concurrency (both eager and lazy), functional reactive programming, discrete synchronous programming, and constraint programming.""
  - ""We explain briefly how programming paradigms influence language design, and we show two sweet spots: dual-paradigm languages and a definitive language.""
  - ""We give a taxonomy of almost 30 useful programming paradigms and how they are related.""
  - ""This chapter gives an introduction to all the main programming paradigms, their underlying concepts, and the relationships between them.""",,"- The abstract discusses the introduction of programming paradigms and their relationships, as well as a taxonomy of these paradigms.
 - It mentions the influence of paradigms on language design and highlights specific paradigms related to concurrency.
 - The abstract provides examples from computer music, which suggests a practical application of these paradigms.
 - However, there is no explicit mention of a validation method for the classification system or taxonomy proposed in the chapter.
 - The abstract does not specify any validation approach, such as mapping to existing languages or empirical testing, nor does it mention specific criteria used to demonstrate validity.","- ""This chapter gives an introduction to all the main programming paradigms, their underlying concepts, and the relationships between them.""
  - ""We give a broad view to help programmers choose the right concepts they need to solve the problems at hand.""
  - ""We give a taxonomy of almost 30 useful programming paradigms and how they are related.""
  - ""We explain briefly how programming paradigms influence language design, and we show two sweet spots: dual-paradigm languages and a definitive language.""
  - ""We introduce the main concepts of programming languages: records, closures, independence (concurrency), and named state.""
  - ""We explain the main principles of data abstraction and how it lets us organize large programs.""
  - ""Finally, we conclude by focusing on concurrency, which is widely considered the hardest concept to program with.""
  - ""We present four little-known but important paradigms that greatly simplify concurrent programming with respect to mainstream languages: declarative concurrency (both eager and lazy), functional reactive programming, discrete synchronous programming, and constraint programming.""
  - ""These paradigms have no race conditions and can be used in cases where no other paradigm works.""
  - ""We explain why for multi-core processors and we give several examples from computer music, which often uses these paradigms.""",,"- The abstract provides a broad introduction to programming paradigms, which suggests that the intended user groups include practitioners (programmers) who need to choose the right concepts for problem-solving.
 - The taxonomy of programming paradigms and the explanation of their relationships imply a framework for comparative studies of programming languages, which could be useful for researchers and educators.
 - The mention of how programming paradigms influence language design suggests potential implications for language design and comparative studies.
 - The focus on concurrency and the introduction of specific paradigms that simplify concurrent programming indicate potential applications in multi-core processor environments and areas like computer music.
 - The abstract does not explicitly mention specific use cases or potential applications beyond the general context of programming and language design, but it implies that these paradigms could be used in various contexts where concurrency is a challenge."
Attribute grammar paradigms—a high-level methodology in language implementation,J. Paakki,10.1145/210376.197409,https://doi.org/10.1145/210376.197409,CSUR,395,1995,"Taxonomy of attribute grammar paradigms into structured, modular, object-oriented, logic, and functional attribute grammars, with additional approaches based on implicit parallel or incremental attribute evaluation paradigms","Derived from a literature-based survey, using a structured classification system that maps attribute grammars to programming paradigms, with specific dimensions including application support, linguistic characteristics, and degree of automation.",No limitations explicitly discussed,No formal validation described,Framework for evaluating and classifying programming language specifications; Tool for facilitating high-level comparative studies of programming languages; Potential impact on language design through structured specification approaches,"- ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""Attribute grammars are a formalism for specifying programming languages.""
  - ""The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.""
  - ""The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.""",,"- The abstract mentions that attribute grammars are a formalism for specifying programming languages, indicating that the study involves a formalism related to attribute grammars.
 - The classification system is described as evaluating systems and specification languages based on application support, linguistic characteristics, and degree of automation, suggesting a broad scope for the classification.
 - The study discusses attribute grammar paradigms and presents a classification into structured, modular, object-oriented, logic, and functional attribute grammars, which are specific categories within the formalism.
 - The mention of a taxonomy complemented by approaches based on implicit parallel or incremental attribute evaluation paradigms suggests that the formalism includes multiple approaches or sub-classifications.
 - The primary focus of the classification appears to be on programming paradigms, as indicated by the categories listed (structured, modular, object-oriented, logic, and functional).
 - The scope of the classification includes at least five categories of attribute grammars, as explicitly mentioned in the abstract.","- ""Attribute grammars are a formalism for specifying programming languages.""
  - ""The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.""
  - ""A survey of attribute grammar-based specification languages is given.""
  - ""The modern advanced specification languages extend the core attribute grammar model with concepts and primitives from established programming paradigms.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""The presentation is founded on mapping elements of attribute grammars to their counterparts in programming languages.""
  - ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.""",,"- The abstract mentions that the systems and their specification languages are evaluated and classified based on ""level of application support, linguistic characteristics, and degree of automation."" This suggests a structured approach to classification, indicating a moderate to deep level of conceptual analysis.
 - The abstract refers to a ""survey of attribute grammar-based specification languages,"" which implies that the conceptual definitions are derived from a literature review rather than empirical analysis or theoretical derivation.
 - The classification system is based on mapping elements of attribute grammars to their counterparts in programming languages, which indicates a detailed feature-level analysis.
 - The abstract discusses the integration of attribute grammars with established programming paradigms, suggesting a conceptual approach that is grounded in existing programming paradigms.
 - The classification into structured, modular, object-oriented, logic, and functional attribute grammars provides specific conceptual dimensions or criteria used for classification.","- ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.""
  - ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.""",,"- The abstract discusses the evaluation and classification of systems and specification languages based on certain criteria, but it does not explicitly mention any limitations of existing classification approaches.
 - The abstract focuses on presenting a methodology for integrating attribute grammars with programming paradigms and classifying them, but it does not critique or discuss limitations of current taxonomies or classification methods.
 - There is no mention of specific limitations, critiques of current taxonomies, or proposed improvements or alternative approaches in the abstract.","- ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The presentation is founded on mapping elements of attribute grammars to their counterparts in programming languages.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""A survey of attribute grammar-based specification languages is given.""",,"- The abstract mentions a ""survey of attribute grammar-based specification languages,"" which suggests a review or examination of existing languages but does not explicitly state a validation method.
 - The presentation of ""representative specification languages"" with a ""common example grammar"" implies some form of demonstration or illustration, but this does not necessarily constitute a formal validation.
 - The abstract discusses the ""mapping elements of attribute grammars to their counterparts in programming languages,"" which could be interpreted as a form of validation by mapping to existing languages. However, this is not explicitly described as a validation method.
 - The classification into different paradigms is mentioned, but there is no explicit mention of how this classification was validated.","- ""Attribute grammars are a formalism for specifying programming languages.""
  - ""The systems and their specification languages can be evaluated and classified according to their level of application support, linguistic characteristics, and degree of automation.""
  - ""A survey of attribute grammar-based specification languages is given.""
  - ""The main ideas behind the developed attribute grammar paradigms are discussed, and representative specification languages are presented with a common example grammar.""
  - ""The presentation is founded on mapping elements of attribute grammars to their counterparts in programming languages.""
  - ""This methodology of integrating two problem-solving disciplines together is explored with a classification of the paradigms into structured, modular, object-oriented, logic, and functional attribute grammars.""
  - ""The taxonomy is complemented by introducing approaches based on an implicit parallel or incremental attribute evaluation paradigm.""",,"- The abstract discusses the use of attribute grammars for specifying programming languages, which implies a practical application in language implementation.
 - The classification system is designed to evaluate and classify systems based on application support, linguistic characteristics, and automation, which could be useful for practitioners in choosing appropriate language concepts.
 - The survey and discussion of attribute grammar paradigms suggest a research implication in understanding and comparing different programming language specifications.
 - The integration of attribute grammars with programming paradigms could impact language design by providing a structured approach to language specification.
 - The abstract does not explicitly mention specific user groups or use cases, but the classification system could be useful for researchers and educators in comparative studies of programming languages."
Logical foundations of object-oriented and frame-based languages,"M. Kifer, G. Lausen, James Wu",10.1145/210332.210335,https://doi.org/10.1145/210332.210335,JACM,1866,1995,"F-logic: A formalism for object-oriented and frame-based languages with model-theoretic semantics and sound and complete resolution-based proof theory, covering features such as object identity, complex objects, inheritance, polymorphic types, methods, and encapsulation.","Derived from theoretical derivation, using model-theoretic semantics and sound and complete resolution-based proof theory, with a focus on higher-order syntax for data and schema exploration.","- Existing approaches restrict object structure and queries or sacrifice declarativeness.
 - Lack of logical foundations for object-oriented databases comparable to relational databases.
 - Proposed improvement: F-logic provides a declarative formalism for object-oriented concepts.","Validated through mapping to predicate calculus, establishing equivalence in logical entailment.","- Tool for facilitating high-level comparative studies of programming languages
 - Framework to help language designers create custom-tailored declarative languages
 - Basis for developing a theory of object-oriented logic programming
 - Application in frame-based languages in AI
 - Contribution to ongoing research in object-oriented logic programming","- ""We propose a novel formalism, called Frame Logic (abbr., F-logic), that accounts in a clean and declarative fashion for most of the structural aspects of object-oriented and frame-based languages.""
  - ""F-logic stands in the same relationship to the object-oriented paradigm as classical predicate calculus stands to relational programming.""
  - ""F-logic has a model-theoretic semantics and a sound and complete resolution-based proof theory.""
  - ""The paper also discusses semantic issues pertaining to programming with a deductive object-oriented language based on a subset of F-logic.""
  - ""F-logic is a full-edged logic; it has a model-theoretic semantics and a sound and complete proof theory.""
  - ""In a sense, F-logic stands in the same relationship to the object-oriented paradigm as classical predicate calculus stands to relational programming.""",,"- The paper introduces a formalism called Frame Logic (F-logic), which is a novel formalism designed to account for structural aspects of object-oriented and frame-based languages.
 - F-logic is described as having a model-theoretic semantics and a sound and complete resolution-based proof theory, indicating it is a comprehensive logical framework.
 - The primary focus of F-logic is on object-oriented and frame-based languages, suggesting it is a classification system for these programming paradigms.
 - The scope of F-logic includes various features such as object identity, complex objects, inheritance, polymorphic types, methods, and encapsulation, indicating a broad coverage of conceptual characteristics.
 - The paper does not explicitly mention a taxonomy or feature model, but F-logic itself can be considered a formalism that classifies and organizes these programming paradigms and their features.","- ""We propose a novel formalism, called Frame Logic (abbr., F-logic), that accounts in a clean and declarative fashion for most of the structural aspects of object-oriented and frame-based languages.""
  - ""F-logic has a model-theoretic semantics and a sound and complete resolution-based proof theory.""
  - ""The paper also discusses semantic issues pertaining to programming with a deductive object-oriented language based on a subset of F-logic.""
  - ""In this paper we propose a formalism, called Frame Logic abbr., F-logic, that achieves all of the goals listed above and, in addition, is suitable for de ning and manipulating database schema and types.""
  - ""F-logic is a full-edged logic; it has a model-theoretic semantics and a sound and complete proof theory.""
  - ""The syntax of F-logic is higher-order, which, among other things, allows the user to explore data and schema using the same declarative language.""
  - ""This paper also discusses various aspects of programming in declarative object-oriented languages based on F-logic.""",,"- The paper introduces F-logic as a formalism that accounts for structural aspects of object-oriented and frame-based languages, indicating a deep conceptual analysis.
 - The mention of model-theoretic semantics and sound and complete resolution-based proof theory suggests a theoretical derivation of conceptual definitions.
 - The paper discusses semantic issues and programming aspects, indicating a comprehensive approach that likely involves both theoretical and empirical analysis.
 - The syntax of F-logic is described as higher-order, which allows for exploration of data and schema, suggesting a detailed feature-level analysis.
 - The paper's focus on achieving specific goals and its suitability for database schema and types manipulation implies a structured approach to conceptual dimensions.","- ""These approaches would seriously restrict object structure and queries; or they may sacri ce declarativeness by adding extra-logical concepts; or they would not address certain important aspects of object-oriented systems, such a s t yping or inheritance.""
  - ""Our contention is that the problem lies much deeper: when Codd made his in uential proposal, he was relying on a large body of knowledge in Mathematical Logic concerning predicate calculus. He had an insight t o s e e a v ery practical twist to a rather theoretical body of knowledge about mathematical logic, which has led him to develop a theory that revolutionized the entire database eld. Until now, logical foundations for object-oriented databases that are parallel to those underlying the relational theory were lacking and this was a major factor for the uneasy feeling.""
  - ""In this paper we propose a formalism, called Frame Logic abbr., F-logic, that achieves all of the goals listed above and, in addition, is suitable for de ning and manipulating database schema and types.""
  - ""A great number of attempts to combine the two approaches has been reported in the literature see, e.g., 1, 2, 3, 13, 16, 1 7 , 31, 50, 60, 5 8 , 65, 85, 10 but, in our opinion, none was entirely successfully.""",,"- The paper discusses the limitations of existing approaches to combining object-oriented and deductive paradigms. It mentions that previous attempts have either restricted object structure and queries, sacrificed declarativeness, or failed to address important aspects like typing and inheritance.
 - The authors critique the lack of logical foundations for object-oriented databases that are comparable to those for relational databases, which they believe has been a significant limitation.
 - The paper proposes F-logic as an improvement, suggesting it addresses the limitations by providing a formalism that is both declarative and capable of handling object-oriented concepts.","- ""Theorem 17.1 There a r e mappings , : fF-formulasg 7 ,! fwell-formed formulas of predicate calculusg : fF-structuresg 7 ,! fsemantic structures of predicate calculusg such that M j = F if and only if M j = P C ,
 

 for any F-structure M and any F-formula ; here j = F "" and j = P C "" denote logical entailment in F-logic and predicate calculus, respectively.""
  - ""Theorem 17.1 relates only the monotonic part of F-logic to classical logic.""
  - ""The paper also discusses semantic issues pertaining to programming with a deductive object-oriented language based on a subset of F-logic.""
  - ""The syntax of a programming language is of paramount importance, as it shapes the way programmers approach and solve problems.""",,"- The paper discusses the validation of F-logic through its relationship with predicate calculus, as indicated by Theorem 17.1. This theorem establishes a mapping between F-logic and predicate calculus, which is a well-established and validated formalism.
 - The validation approach involves demonstrating the equivalence between F-logic and predicate calculus, which is a widely accepted and validated logic system. This equivalence serves as a form of validation for F-logic.
 - The specific language used in validation is predicate calculus, which is a well-known and established formal system.
 - The criteria used to demonstrate validity include the establishment of logical entailment equivalence between F-logic and predicate calculus, as stated in Theorem 17.1.","- ""Because of the independence of its various components, F-logic can be viewed as a tool-kit for designing custom-tailored declarative languages.""
  - ""Besides object-oriented databases, another important application for F-logic is in the area of framebased languages in AI""
  - ""F-logic has a sound and complete resolution-based proof procedure, which makes it also computationally attractive and renders it a suitable basis for developing a theory of object-oriented logic programming.""
  - ""F-logic is capable of representing almost all aspects of what is known as the object-oriented paradigm.""
  - ""F-logic is a full-edged logic; it has a model-theoretic semantics and a sound and complete proof theory.""
  - ""The last issue we w ould like to discuss is the relationship between predicate calculus and F-logic.""",,"- The paper proposes F-logic as a comprehensive framework for object-oriented programming, which suggests its potential use by practitioners and researchers in the field.
 - The mention of a ""sound and complete resolution-based proof procedure"" indicates that F-logic is designed to be computationally efficient, making it suitable for practical applications in programming.
 - The description of F-logic as a ""tool-kit for designing custom-tailored declarative languages"" implies that it can be used by language designers to create new languages or modify existing ones.
 - The comparison with predicate calculus suggests that F-logic could be used for theoretical studies and comparative analyses of programming languages.
 - The application in ""frame-based languages in AI"" indicates potential use in artificial intelligence research.
 - The paper's focus on rectifying earlier flaws and continuing research suggests that it is intended to contribute to ongoing research in object-oriented logic programming."
"Reflection in logic, functional and object-oriented programming: a Short Comparative Study",J. Malenfant,-,-,-,155,1995,No specific formalism developed,"Derived from a synthesis of different programming paradigms, using a literature-based approach to identify similar concepts and different emphases across logic, functional, and object-oriented programming languages.",No limitations explicitly discussed (the abstract mentions separate evolution of concepts but does not explicitly critique existing classification methods),No formal validation described,Framework to facilitate high-level comparative studies of programming languages and build bridges between programming language communities,"- ""Reflection is a wide-ranging concept that has been studied independently in many different areas of science in general, and computer science in particular.""
  - ""Even in the sub-area of programming languages, it has been applied to different paradigms, especially the logic, functional and objectoriented ones.""
  - ""In this paper, we propose a synthesis covering mainly the application of computation reflection to programming languages.""
  - ""We compare the different approaches and try to identify similar concepts hidden behind different names or constructs.""
  - ""We also point out the different emphasis that has been given to different concepts in each of them.""
  - ""We do not claim neither completeness nor closeness in our treatment.""
  - ""We rather aim at building bridges between programming languages communities, and address other aspects when they appear relevant.""",,"- The abstract mentions that the paper proposes a ""synthesis"" covering the application of computation reflection to programming languages, which suggests a comparative analysis rather than a new formalism or taxonomy.
 - The focus is on comparing different approaches and identifying similar concepts across logic, functional, and object-oriented programming paradigms.
 - The abstract does not specify the development of a specific type of formalism or taxonomy, such as a feature model or classification framework.
 - The scope of the classification is not explicitly mentioned in terms of the number of language categories or features covered.
 - The abstract emphasizes building bridges between communities rather than developing a new formalism or taxonomy.","- ""Reflection is a wide-ranging concept that has been studied independently in many different areas of science in general, and computer science in particular.""
  - ""Even in the sub-area of programming languages, it has been applied to different paradigms, especially the logic, functional and objectoriented ones.""
  - ""Partly because of different past influences, but also because researchers in these communities scarcely talk to each others, concepts have evolved separately, sometimes to the point where it is hard for people in one community to recognize similarities in the work of others, not to speak about cross-fertilization among them.""
  - ""In this paper, we propose a synthesis covering mainly the application of computation reflection to programming languages.""
  - ""We compare the different approaches and try to identify similar concepts hidden behind different names or constructs.""
  - ""We also point out the different emphasis that has been given to different concepts in each of them.""
  - ""We do not claim neither completeness nor closeness in our treatment.""
  - ""We rather aim at building bridges between programming languages communities, and address other aspects when they appear relevant.""",,"- The abstract indicates that the paper aims to synthesize and compare different approaches to reflection in programming languages, specifically in logic, functional, and object-oriented paradigms. This suggests a broad conceptual analysis rather than a deep dive into specific details.
 - The mention of ""concepts have evolved separately"" and ""hard for people in one community to recognize similarities"" implies that the paper is more focused on identifying commonalities and differences across different communities rather than conducting a detailed feature-level analysis.
 - The abstract does not specify the sources of conceptual definitions, such as whether they are derived from literature review, empirical analysis, or theoretical derivation. However, the aim to ""build bridges between programming languages communities"" suggests a literature-based approach to identify similarities and differences.
 - The paper does not claim completeness or closeness, indicating that the analysis might not be exhaustive or deeply detailed.
 - The focus on identifying similar concepts and different emphases suggests a conceptual mapping approach, but the abstract does not provide specific details on the criteria or dimensions used for classification.","- ""We do not claim neither completeness nor closeness in our treatment.""
  - ""concepts have evolved separately, sometimes to the point where it is hard for people in one community to recognize similarities in the work of others, not to speak about cross-fertilization among them.""",,"- The abstract mentions that concepts have evolved separately in different programming language paradigms, which implies a limitation in existing classification approaches. This separation makes it difficult for researchers to recognize similarities across different communities, suggesting a lack of cross-fertilization and understanding.
 - The statement ""We do not claim neither completeness nor closeness in our treatment"" indicates that the authors are aware of limitations in their own synthesis, which might reflect broader limitations in existing classification methods. However, this is more about their own work rather than a direct critique of existing approaches.
 - The abstract does not explicitly discuss specific limitations or critiques of current taxonomies or classification methods. It focuses more on the need for synthesis and building bridges between communities rather than detailing specific limitations.","- ""We rather aim at building bridges between programming languages communities, and address other aspects when they appear relevant.""
  - ""We do not claim neither completeness nor closeness in our treatment.""
  - ""We compare the different approaches and try to identify similar concepts hidden behind different names or constructs.""
  - ""In this paper, we propose a synthesis covering mainly the application of computation reflection to programming languages.""",,"- The abstract mentions a ""synthesis"" and ""comparing different approaches,"" which suggests a comparative analysis rather than a formal validation process.
 - The statement ""We do not claim neither completeness nor closeness in our treatment"" implies that the paper does not aim to provide a comprehensive or definitive validation of a classification system.
 - The focus is on ""building bridges between programming languages communities,"" which indicates a more theoretical or conceptual approach rather than empirical validation.
 - There is no mention of specific validation methods, languages, or criteria used to demonstrate validity, which suggests that no formal validation was described.","- ""In this paper, we propose a synthesis covering mainly the application of computation reflection to programming languages.""
  - ""We rather aim at building bridges between programming languages communities, and address other aspects when they appear relevant.""
  - ""We also point out the different emphasis that has been given to different concepts in each of them.""
  - ""We compare the different approaches and try to identify similar concepts hidden behind different names or constructs.""",,"- The abstract mentions a ""synthesis covering mainly the application of computation reflection to programming languages,"" which suggests a practical implication of providing a comprehensive overview of reflection in different programming paradigms.
 - The comparison of different approaches and identification of similar concepts indicate a research implication of facilitating cross-paradigm understanding and potential cross-fertilization.
 - The aim to ""build bridges between programming languages communities"" implies a practical implication of enhancing communication and collaboration among practitioners and researchers from different programming language backgrounds.
 - The abstract does not explicitly mention specific use cases or potential applications, nor does it detail potential impacts on language design or comparative studies. However, the synthesis and comparison suggest a framework for facilitating high-level comparative studies of programming languages."
Expressive Power of Query Languages,"S. Abiteboul, V. Vianu",10.1016/b978-0-12-708240-0.50013-7,https://doi.org/10.1016/b978-0-12-708240-0.50013-7,Theoretical Studies in Computer Science,22,1991,"Classification framework for query languages based on expressive power and complexity, focusing on logic, algebraic, and logic programming paradigms, with central classes of fixpoint and while queries.","Derived from a literature review, using theoretical derivation and detailed feature-level analysis with concrete mappings of well-known languages and paradigms (logic, algebraic, logic programming), focusing on expressive power and complexity classes.","- Inability of languages to express low complexity classes of queries (PTIME and below)
 - Limitation related to the data independence principle when computing without order
 - Introduction of non-deterministic constructs as an alternative to address these limitations",No formal validation described,Framework for comparative studies of query languages; Tool for language design to balance complexity and data independence; Research implications for exploring expressiveness above NP,"- ""Recent research on query languages and their expressive power is discussed.""
  - ""Several query languages are described, emphasizing recursive extensions of the first-order queries based on three paradigms: logic, algebraic, and logic programming.""
  - ""Many of these languages converge around two central classes of queries, the fixpoint queries and the while queries.""
  - ""The relative expressive power of these languages is examined, as well as their connection to complexity classes of queries.""
  - ""The focus is on the inability of languages to express low complexity classes of queries, PTIME and below.""
  - ""The cost of computing without order is formalized by defining non-standard complexity classes based on a model of database computation called Generic Machine.""
  - ""As an alternative to order, it is shown that the difficulty of expressing low complexity classes can be circumvented by introducing non-deterministic constructs in query languages.""",,"- The abstract discusses the expressive power of query languages, focusing on recursive extensions based on logic, algebraic, and logic programming paradigms. This suggests a classification or taxonomy related to these paradigms.
 - The mention of ""two central classes of queries, the fixpoint queries and the while queries"" indicates a categorization of query types.
 - The examination of the relative expressive power and connection to complexity classes implies a framework for comparing these languages based on their ability to express different complexity classes.
 - The introduction of non-standard complexity classes and the Generic Machine model suggests a formalism for understanding computational complexity in query languages.
 - The abstract does not explicitly mention a specific type of formalism like a feature model or taxonomy, but it implies a classification framework for query languages based on their expressive power and complexity.","- ""Recent research on query languages and their expressive power is discussed.""
  - ""Several query languages are described, emphasizing recursive extensions of the first-order queries based on three paradigms: logic, algebraic, and logic programming.""
  - ""Many of these languages converge around two central classes of queries, the fixpoint queries and the while queries.""
  - ""The relative expressive power of these languages is examined, as well as their connection to complexity classes of queries.""
  - ""The focus is on the inability of languages to express low complexity classes of queries, PTIME and below.""
  - ""The cost of computing without order is formalized by defining non-standard complexity classes based on a model of database computation called Generic Machine.""
  - ""As an alternative to order, it is shown that the difficulty of expressing low complexity classes can be circumvented by introducing non-deterministic constructs in query languages.""",,"- The abstract discusses recent research on query languages, indicating a literature-based approach to conceptual analysis.
 - The mention of ""recursive extensions of the first-order queries based on three paradigms"" suggests a deep conceptual analysis, as it involves detailed examination of different paradigms.
 - The focus on ""the relative expressive power of these languages"" and their connection to ""complexity classes of queries"" indicates a theoretical derivation of conceptual definitions.
 - The abstract mentions specific conceptual dimensions such as ""fixpoint queries and the while queries,"" which are used for classification.
 - The introduction of ""non-standard complexity classes based on a model of database computation called Generic Machine"" suggests a detailed feature-level analysis.
 - The discussion of ""non-deterministic constructs in query languages"" as an alternative to order implies a nuanced analytical approach to addressing specific challenges in query languages.","- ""The focus is on the inability of languages to express low complexity classes of queries, PTIME and below.""
  - ""As an alternative to order, it is shown that the difficulty of expressing low complexity classes can be circumvented by introducing non-deterministic constructs in query languages.""
  - ""The cost of computing without order is formalized by defining non-standard complexity classes based on a model of database computation called Generic Machine.""",,"- The abstract discusses the limitations of existing query languages in terms of their inability to express low complexity classes of queries, specifically PTIME and below. This indicates a limitation in the expressive power of current languages.
 - The mention of the ""cost of computing without order"" suggests a limitation related to the data independence principle when trying to achieve low complexity.
 - The introduction of non-deterministic constructs as an alternative to order implies a critique of current deterministic methods and suggests an improvement by incorporating non-determinism.
 - The abstract does not explicitly mention limitations in classification methods or taxonomies but focuses on the limitations in expressive power and complexity.","- ""Recent research on query languages and their expressive power is discussed.""
  - ""Several query languages are described, emphasizing recursive extensions of the first-order queries based on three paradigms: logic, algebraic, and logic programming.""
  - ""Many of these languages converge around two central classes of queries, the fixpoint queries and the while queries.""
  - ""The relative expressive power of these languages is examined, as well as their connection to complexity classes of queries.""
  - ""The focus is on the inability of languages to express low complexity classes of queries, PTIME and below.""
  - ""We consider several ways to circumvent this difficulty.""
  - ""The cost of computing without order is formalized by defining non-standard complexity classes based on a model of database computation called Generic Machine.""
  - ""As an alternative to order, it is shown that the difficulty of expressing low complexity classes can be circumvented by introducing non-deterministic constructs in query languages.""
  - ""Expressiveness above NP is also discussed.""",,"- The abstract discusses the expressive power of query languages and their connection to complexity classes, but it does not mention any specific validation method for a classification system.
 - The focus is on the theoretical examination of query languages and their limitations in expressing certain complexity classes, rather than on validating a classification system.
 - There is no mention of empirical testing, mapping to existing languages, or specific criteria used to demonstrate validity.
 - The abstract does not provide any information on how a proposed formalism or taxonomy was validated.","- ""Recent research on query languages and their expressive power is discussed.""
  - ""Several query languages are described, emphasizing recursive extensions of the first-order queries based on three paradigms: logic, algebraic, and logic programming.""
  - ""The relative expressive power of these languages is examined, as well as their connection to complexity classes of queries.""
  - ""The focus is on the inability of languages to express low complexity classes of queries, PTIME and below.""
  - ""We consider several ways to circumvent this difficulty.""
  - ""The first is to introduce an ordering of the domain which leads to a trade-off between complexity and the data independence principle.""
  - ""The cost of computing without order is formalized by defining non-standard complexity classes based on a model of database computation called Generic Machine.""
  - ""As an alternative to order, it is shown that the difficulty of expressing low complexity classes can be circumvented by introducing non-deterministic constructs in query languages.""
  - ""Expressiveness above NP is also discussed.""",,"- The abstract discusses the expressive power of query languages, which is a fundamental aspect of both practical and research implications. This suggests that the work is intended for researchers and potentially practitioners in the field of database systems and query languages.
 - The description of various query languages and their paradigms indicates a potential use case for comparative studies among these languages, which could be useful for both researchers and educators.
 - The focus on the inability to express low complexity classes and the proposed solutions (introducing ordering or non-deterministic constructs) implies a practical application in language design. This could help in developing more efficient query languages.
 - The mention of a trade-off between complexity and data independence principle suggests a potential impact on language design, as it highlights considerations for balancing these factors.
 - The discussion of expressiveness above NP indicates a research implication, as it explores the boundaries of what can be achieved with these query languages."
Method of Paradigmatic Analysis of Programming Languages and Systems,L. Gorodnyaya,10.20948/abrau-2019-03,https://doi.org/10.20948/abrau-2019-03,Conference on Scientific Services & Internet,4,2019,"Taxonomy of programming paradigms with a focus on semantic characteristics and complexity, covering four classical paradigms and their derivatives.","Detailed feature-level analysis with concrete mappings of well-known languages, using theoretical derivation and literature-based conceptual mapping to classify programming paradigms based on problem statements and semantic characteristics.","- Existing descriptions of programming languages often lack clarity on inherited and new paradigmatic properties and language features.
 - Current examples used to characterize languages are too simplistic and do not adequately represent language capabilities.
 - Current methods may not adequately address problem statements and semantic characteristics.
 - Current methods may not fully capture complexity and effort required for programming.","Validated through concrete mappings of well-known languages in imperative, object-oriented, functional, and logical categories",Framework for facilitating high-level comparative studies of programming languages; Tool for evaluating complexity and laboriousness in programming; Methodology for navigating programming paradigms to choose appropriate language concepts for problem-solving.,"- ""The purpose of the article is to describe the method of comparison of programming languages, convenient for assessing the expressive power of languages and the complexity of the programming systems.""
  - ""The method is adapted to substantiate practical, objective criteria of program decomposition, which can be considered as an approach to solving the problem of factorization of very complicated definitions of programming languages and their support systems.""
  - ""the article presents the results of the analysis of the most well-known programming paradigms and outlines an approach to navigation in the modern expanding space of programming languages, based on the classification of paradigms on the peculiarities of problem statements and semantic characteristics of programming languages and systems with an emphasis on the criteria for the quality of programs and priorities in decision-making in their implementation.""
  - ""The concept of ""programming paradigm"" is manifested as the way of thinking in the programming process.""","- ""(Page 4, Table 1) | Год | ЯП | Предшественники²  | Поддержанные парадигмы  |
 \n|------|-------|--------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
 \n| 2018 | Dart | Java, JavaScript, CoffeeScript, Go  | объектно-ориентированный каркас веб-приложений сценарный язык императивный рефлективный функциональный  |""
  - ""<table_quotation page_num=5 table_on_page=1>```markdown
 | Год | ЯП  | Поддержанные парадигмы  | Сфера влияния  |
 |------|------------------|----------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | 1954 | Fortran,  | императивный | ИПП — императивно-процедурное  |
 | 1958 | Algol-60 ³ | параллельный<br>процедурный<br>модульный<br>структурный<br>процедурный<br>обобщённое объектно-ориентированный | ALGOL 58,<br>BASIC,<br>C,<br>Chapel, CMS-2, Fortress,<br>PL/I, PACT I,<br>MUMPS, IDL, Ratfor |
 | 1958 | Lisp  | экспериментальный<br>функциональный<br>объектно-ориентированный<br>процедурный<br>рефлексивный<br>метапрограммирование | ФП — функциональное<br>CLIPS, Common lisp, CLOS, Clu, Dylan, Forth,<br>Scheme, Erlang, Haskell, Logo, Lua, Perl,<br>POP-2, Python, Ruby, Cmucl, Scala, ML, Swift,<br>Smalltalk, Factor, Clojure, Emacs Lisp, Eulisp,<br>ISLISP, Wolfram Language |
 | 1960 | APL | векторный<br>функциональный<br>структурный<br>модульный  | ПВ — параллельные вычисления<br>A, A+,<br>FP, J, K, LyaPAS, Nial, S,<br>MATLAB, PPL, Wolfram Language  |
 | 1962 | Simula 67 | объектно-ориентированный | ООП (1980) — объектно-ориентированное |
 | 1968 | Forth⁴  | императивный<br>стек-ориентированный | Factor, RPL, REBOL, PostScript, Factor<br>и другие конкатенативные языки⁵  |
 | 1968 | Algol-68⁶ | параллельный<br>императивный | C, C++, Bourne shell, KornShell, Bash,<br>Steelman, Ada, Python, Seed7, Mary, S3  |
 | 1972 | Prolog  | декларативный<br>логический  | ЛП — логическое<br>Visual Prolog, Mercury, Oz,<br>Erlang, Strand, KL0, KL1, Datalog |
 | 1970 | Pascal  | императивный | СП — структурное  |
 ```</table_quotation>""
  - ""(Page 6, Table 1) | Подсистема | Примечание |
 \n|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | Данные из множества D представляют значения из V и шкалу прерываний |""
  - ""(Page 7, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|--------------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Значения ограничены размерами их представлений в регистрах памяти по адресам из N. Шкала прерываний не представлена  |""
  - ""(Page 8, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Представления значений не ограничены по размеру и сложности, включая функции  |""
  - ""(Page 9, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|----------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Представления фактов или правил  |""
  - ""(Page 9, Table 2) | Подсистема | Приоритет | Примечание |
 \n|-------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные  | 0  | Данные представляют не только значения, но и методы их обработки |""","- The paper describes a method for comparing programming languages based on their expressive power and complexity, which suggests a classification framework.
 - The focus is on programming paradigms and their semantic characteristics, indicating a taxonomy of paradigms.
 - The scope includes four classical programming paradigms and their derivatives, suggesting a structured approach to categorizing these paradigms.
 - The paper mentions the use of tables to illustrate the methodology, which likely contain detailed classifications or mappings of paradigms.
 - The methodology is designed to evaluate complexity and laboriousness, suggesting a feature model or classification framework that assesses these aspects.","- ""The purpose of the article is to describe the method of comparison of programming languages, convenient for assessing the expressive power of languages and the complexity of the programming systems.""
  - ""The method is adapted to substantiate practical, objective criteria of program decomposition, which can be considered as an approach to solving the problem of factorization of very complicated definitions of programming languages and their support systems.""
  - ""the article presents the results of the analysis of the most well-known programming paradigms and outlines an approach to navigation in the modern expanding space of programming languages, based on the classification of paradigms on the peculiarities of problem statements and semantic characteristics of programming languages and systems with an emphasis on the criteria for the quality of programs and priorities in decision-making in their implementation.""
  - ""The concept of ""programming paradigm"" is manifested as the way of thinking in the programming process.""","- ""(Page 4, Table 1) | Год | ЯП | Предшественники²  | Поддержанные парадигмы  |
 \n|------|-------|--------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
 \n| 2018 | Dart | Java, JavaScript, CoffeeScript, Go  | объектно-ориентированный каркас веб-приложений сценарный язык императивный рефлективный функциональный  |""
  - ""<table_quotation page_num=5 table_on_page=1>```markdown
 | Год | ЯП  | Поддержанные парадигмы  | Сфера влияния  |
 |------|------------------|----------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | 1954 | Fortran,  | императивный | ИПП — императивно-процедурное  |
 | 1958 | Algol-60 ³ | параллельный<br>процедурный<br>модульный<br>структурный<br>процедурный<br>обобщённое объектно-ориентированный | ALGOL 58,<br>BASIC,<br>C,<br>Chapel, CMS-2, Fortress,<br>PL/I, PACT I,<br>MUMPS, IDL, Ratfor |
 | 1958 | Lisp  | экспериментальный<br>функциональный<br>объектно-ориентированный<br>процедурный<br>рефлексивный<br>метапрограммирование | ФП — функциональное<br>CLIPS, Common lisp, CLOS, Clu, Dylan, Forth,<br>Scheme, Erlang, Haskell, Logo, Lua, Perl,<br>POP-2, Python, Ruby, Cmucl, Scala, ML, Swift,<br>Smalltalk, Factor, Clojure, Emacs Lisp, Eulisp,<br>ISLISP, Wolfram Language |
 | 1960 | APL | векторный<br>функциональный<br>структурный<br>модульный  | ПВ — параллельные вычисления<br>A, A+,<br>FP, J, K, LyaPAS, Nial, S,<br>MATLAB, PPL, Wolfram Language  |
 | 1962 | Simula 67 | объектно-ориентированный | ООП (1980) — объектно-ориентированное |
 | 1968 | Forth⁴  | императивный<br>стек-ориентированный | Factor, RPL, REBOL, PostScript, Factor<br>и другие конкатенативные языки⁵  |
 | 1968 | Algol-68⁶ | параллельный<br>императивный | C, C++, Bourne shell, KornShell, Bash,<br>Steelman, Ada, Python, Seed7, Mary, S3  |
 | 1972 | Prolog  | декларативный<br>логический  | ЛП — логическое<br>Visual Prolog, Mercury, Oz,<br>Erlang, Strand, KL0, KL1, Datalog |
 | 1970 | Pascal  | императивный | СП — структурное  |
 ```</table_quotation>""
  - ""(Page 6, Table 1) | Подсистема | Примечание |
 \n|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | Данные из множества D представляют значения из V и шкалу прерываний |""
  - ""(Page 7, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|--------------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Значения ограничены размерами их представлений в регистрах памяти по адресам из N. Шкала прерываний не представлена  |""
  - ""(Page 8, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Представления значений не ограничены по размеру и сложности, включая функции  |""
  - ""(Page 9, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|----------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Представления фактов или правил  |""
  - ""(Page 9, Table 2) | Подсистема | Приоритет | Примечание |
 \n|-------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные  | 0  | Данные представляют не только значения, но и методы их обработки |""","- The paper describes a method for comparing programming languages based on their expressive power and complexity, indicating a deep conceptual analysis.
 - The method involves practical, objective criteria for program decomposition, suggesting a detailed feature-level analysis.
 - The classification system is based on the peculiarities of problem statements and semantic characteristics, which are specific conceptual dimensions used for classification.
 - The paper discusses the concept of programming paradigms as a way of thinking, indicating a theoretical derivation of conceptual definitions.
 - The methodology is applied to four classical programming paradigms, suggesting a detailed analysis of well-known languages.
 - The use of tables to organize and compare different paradigms and languages indicates a structured approach to classification.
 - The paper mentions the use of additional paradigms to impose restrictive conditions, indicating a nuanced approach to classification.","- ""Описания современных языков программирования (ЯП) обычно содержат список из 5-10 предшественников и ряд парадигм программирования (ПП), поддержанных языком [1,2]. Такая характеристика как правило не показывает, какие свойства ПП и черты ЯП фактически унаследованы определяемым языком и какие особенности являются действительно новыми""
  - ""Для реальной оценки уровня новизны и практичности ЯП может быть полезной коллекция постановок задач с примерами их решения на разных языках в рамках разных парадигм.""
  - ""Чаще всего это программа печати приветствия, что позволяет быстро начать эксперименты с системой программирования (СП), но, учитывая, что большинство современных ЯП поддерживают механизмы ввода-вывода на уровне библиотечных вызовов, такие примеры слабо характеризуют язык.""
  - ""Постановки задач ИПП начинаются с определённого алгоритма решения актуальной задачи.""
  - ""Постановка задач ООП основана на контроле доступа к иерархии классов объектов с работоспособными методами решения задач некоторой предметной области.""
  - ""Предложенную методику парадигмального анализа языков и систем программирования можно использовать при оценке сложности и трудоёмкости программирования, особенно если дополнить более ясным разделением требований к постановкам задач по сферам применения на академические и производственные, а по уровню изученности на точные, развиваемые и усложнённые трудно удостоверяемыми требованиями.""",,"- The paper critiques existing approaches by noting that current descriptions of programming languages often lack clarity on which paradigmatic properties and language features are inherited or new. This suggests a limitation in the current classification methods, as they do not provide a clear understanding of the novelty and practicality of languages.
 - The paper suggests that existing examples used to characterize languages are often too simplistic (e.g., printing a greeting) and do not adequately represent the language's capabilities, indicating a limitation in the depth of current classification methods.
 - The paper proposes a new method of paradigmatic analysis that focuses on problem statements and semantic characteristics, which implies that current methods may not adequately address these aspects.
 - The paper discusses the need for a more nuanced approach to evaluating programming languages, especially in terms of complexity and effort required for programming, suggesting that current methods may not fully capture these dimensions.","- ""Методика показана на материале четырёх классических парадигм программирования в рамках ЯП высокого уровня без экскурса в языки низкого и сверх высокого уровней или более широкое пространство парадигм, особенно новых, ещё не получивших поддержки в достаточно известных языках программирования и признания в виде примеров отлаженных программ.""
  - ""Предложенную методику парадигмального анализа языков и систем программирования можно использовать при оценке сложности и трудоёмкости программирования, особенно если дополнить более ясным разделением требований к постановкам задач по сферам применения на академические и производственные, а по уровню изученности на точные, развиваемые и усложнённые трудно удостоверяемыми требованиями.""
  - ""методика представления парадигмальных особенностей определения ЯП на уровне семантических систем [3], классифицированных по постановкам задач и языковым средствам, используемым при их решении.""
  - ""Полученное пространство может быть исходной структурой при выборе критериев декомпозиции программ с учётом особенностей развития постановок задач в процессе программирования их решений [4], расширения семантических систем ЯП и их уточнения при реализации СП [5].""
  - ""Постановки задач ИПП начинаются с определённого алгоритма решения актуальной задачи.""
  - ""Постановка задач ООП основана на контроле доступа к иерархии классов объектов с работоспособными методами решения задач некоторой предметной области.""
  - ""Задачи ФП обычно ориентированы на известную предметную область, в рамках которой следует выбрать символьное представление данных и отладить систему универсальных функций, пригодных для не чрезмерно трудоёмкого создания прототипов решения новых задач из этой области.""","- ""(Page 4, Table 1) | Год | ЯП | Предшественники²  | Поддержанные парадигмы  |
 \n|------|-------|--------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
 \n| 2018 | Dart | Java, JavaScript, CoffeeScript, Go  | объектно-ориентированный каркас веб-приложений сценарный язык императивный рефлективный функциональный  |""
  - ""<table_quotation page_num=5 table_on_page=1>```markdown
 | Год | ЯП  | Поддержанные парадигмы  | Сфера влияния  |
 |------|------------------|----------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 | 1954 | Fortran,  | императивный | ИПП — императивно-процедурное  |
 | 1958 | Algol-60 ³ | параллельный<br>процедурный<br>модульный<br>структурный<br>процедурный<br>обобщённое объектно-ориентированный | ALGOL 58,<br>BASIC,<br>C,<br>Chapel, CMS-2, Fortress,<br>PL/I, PACT I,<br>MUMPS, IDL, Ratfor |
 | 1958 | Lisp  | экспериментальный<br>функциональный<br>объектно-ориентированный<br>процедурный<br>рефлексивный<br>метапрограммирование | ФП — функциональное<br>CLIPS, Common lisp, CLOS, Clu, Dylan, Forth,<br>Scheme, Erlang, Haskell, Logo, Lua, Perl,<br>POP-2, Python, Ruby, Cmucl, Scala, ML, Swift,<br>Smalltalk, Factor, Clojure, Emacs Lisp, Eulisp,<br>ISLISP, Wolfram Language |
 | 1960 | APL | векторный<br>функциональный<br>структурный<br>модульный  | ПВ — параллельные вычисления<br>A, A+,<br>FP, J, K, LyaPAS, Nial, S,<br>MATLAB, PPL, Wolfram Language  |
 | 1962 | Simula 67 | объектно-ориентированный | ООП (1980) — объектно-ориентированное |
 | 1968 | Forth⁴  | императивный<br>стек-ориентированный | Factor, RPL, REBOL, PostScript, Factor<br>и другие конкатенативные языки⁵  |
 | 1968 | Algol-68⁶ | параллельный<br>императивный | C, C++, Bourne shell, KornShell, Bash,<br>Steelman, Ada, Python, Seed7, Mary, S3  |
 | 1972 | Prolog  | декларативный<br>логический  | ЛП — логическое<br>Visual Prolog, Mercury, Oz,<br>Erlang, Strand, KL0, KL1, Datalog |
 | 1970 | Pascal  | императивный | СП — структурное  |
 ```</table_quotation>""
  - ""(Page 6, Table 1) | Подсистема | Примечание |
 \n|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | Данные из множества D представляют значения из V и шкалу прерываний |""
  - ""(Page 7, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|--------------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Значения ограничены размерами их представлений в регистрах памяти по адресам из N. Шкала прерываний не представлена  |""
  - ""(Page 8, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Представления значений не ограничены по размеру и сложности, включая функции  |""
  - ""(Page 9, Table 1) | Подсистема  | Приоритет | Примечание |
 \n|----------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные | 0  | Представления фактов или правил  |""
  - ""(Page 9, Table 2) | Подсистема | Приоритет | Примечание |
 \n|-------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------|
 \n| D: данные  | 0  | Данные представляют не только значения, но и методы их обработки |""","- The paper describes a method for paradigmatic analysis of programming languages and systems, focusing on the classification of paradigms based on problem statements and language tools.
 - The methodology is demonstrated using four classic programming paradigms: imperative, object-oriented, functional, and logical programming.
 - The validation approach involves mapping these paradigms to existing languages and discussing their characteristics and differences.
 - Specific languages mentioned in the context of these paradigms include Dart, Swift, Rust, F#, Scala, and others, as seen in the tables.
 - The criteria used to demonstrate validity include the ability to classify languages into these paradigms and to evaluate the complexity and practicality of programming based on these classifications.
 - The paper does not mention empirical testing or case studies as part of the validation process.","- ""The purpose of the article is to describe the method of comparison of programming languages, convenient for assessing the expressive power of languages and the complexity of the programming systems.""
  - ""The method is adapted to substantiate practical, objective criteria of program decomposition, which can be considered as an approach to solving the problem of factorization of very complicated definitions of programming languages and their support systems.""
  - ""the article presents the results of the analysis of the most well-known programming paradigms and outlines an approach to navigation in the modern expanding space of programming languages, based on the classification of paradigms on the peculiarities of problem statements and semantic characteristics of programming languages and systems with an emphasis on the criteria for the quality of programs and priorities in decision-making in their implementation.""
  - ""The concept of ""programming paradigm"" is manifested as the way of thinking in the programming process.""",,"- The paper proposes a method for comparing programming languages, which is useful for assessing their expressive power and complexity. This suggests a practical application for researchers and educators in comparative studies.
 - The method is designed to provide practical criteria for program decomposition, which is relevant for practitioners in software development.
 - The paper outlines an approach to navigating the space of programming languages based on paradigm classification, which could help programmers choose appropriate language concepts for problem-solving.
 - The methodology is intended to evaluate complexity and laboriousness in programming, which could impact language design by providing insights into how different paradigms affect these aspects.
 - The paper does not explicitly mention specific user groups, but the applications suggest relevance for practitioners, researchers, and educators."
Teaching Programming with the Kernel Language Approach,"P. V. Roy, Seif Haridi",-,-,-,4,-,"Taxonomy of programming paradigms (imperative, object-oriented, concurrent, logic, functional) translated into kernel languages with simple formal semantics","Derived from programmer's perspective, using theoretical derivation and empirical analysis, with detailed feature-level analysis and concrete mappings of well-known languages",No limitations explicitly discussed (the abstract critiques teaching methods rather than classification approaches),No formal validation described,"- Intended user groups: Educators, students
 - Specific use cases: Facilitating high-level comparative studies of programming languages, complementing courses on algorithms, data structures, program design, and software engineering
 - Potential impact: Uniform setting for understanding programming paradigms, simplifying language design and comparative studies","- ""We present the kernel language approach, a new way to teach programming that situates most of the widely-known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) in a uniform setting that shows their deep relationships and how to use them together.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""
  - ""Widely-different practical languages (exemplified by Java, Haskell, Prolog, and Erlang) with their rich panoplies of abstractions and syntax are explained by straightforward translations into closely-related kernel languages, simple languages that consist of small numbers of programmer-significant concepts.""",,"- The abstract introduces the ""kernel language approach,"" which is a method for teaching programming by situating various programming paradigms in a uniform setting. This suggests a classification or taxonomy of programming paradigms.
 - The approach involves translating practical languages into ""kernel languages,"" which are simple and have a straightforward formal semantics. This indicates a focus on simplifying complex programming concepts into more manageable, fundamental elements.
 - The primary focus of this classification appears to be on programming paradigms, as it includes imperative, object-oriented, concurrent, logic, and functional paradigms.
 - The scope of the classification is broad, as it covers multiple widely-known programming paradigms and translates them into simpler kernel languages.","- ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""
  - ""Widely-different practical languages (exemplified by Java, Haskell, Prolog, and Erlang) with their rich panoplies of abstractions and syntax are explained by straightforward translations into closely-related kernel languages, simple languages that consist of small numbers of programmer-significant concepts.""
  - ""We present the kernel language approach, a new way to teach programming that situates most of the widely-known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) in a uniform setting that shows their deep relationships and how to use them together.""
  - ""The approach is the fruit of ten years of research by an international team, the Mozart Consortium.""",,"- The abstract describes the kernel language approach as a method to teach programming by situating various paradigms in a uniform setting, indicating a deep conceptual analysis that integrates different programming paradigms.
 - The approach involves translating practical languages into kernel languages, which are simple and consist of small numbers of programmer-significant concepts. This suggests a detailed feature-level analysis with concrete mappings of well-known languages.
 - The mention of ""simple formal semantics"" implies that the approach is grounded in theoretical derivation, providing a structured framework for understanding programming concepts.
 - The fact that the approach is the result of ""ten years of research by an international team"" suggests that it is derived from a combination of empirical analysis and theoretical derivation, as it likely involved extensive study and collaboration.","- ""Surveying existing textbooks, we find that programming is taught in three different ways.""
  - ""Surprisingly, we find that programming is almost never taught in this way.""",,"- The abstract mentions that programming is ""almost never taught"" in a way that integrates both the science and technology of programming, suggesting a limitation in how programming is currently taught.
 - The mention of existing textbooks teaching programming in ""three different ways"" implies a lack of uniformity or consistency in teaching methods, which could be seen as a limitation in existing approaches.
 - However, the abstract does not explicitly discuss limitations in existing programming language classification methods or taxonomies. It focuses more on the teaching approach rather than classification methods.","- ""The approach is the fruit of ten years of research by an international team, the Mozart Consortium.""
  - ""As part of a curriculum, the approach naturally complements courses on algorithms & data structures and program design & software engineering.""
  - ""We have taught the approach at three universities in courses ranging from second-year undergraduate courses to graduate courses.""
  - ""Widely-different practical languages (exemplified by Java, Haskell, Prolog, and Erlang) with their rich panoplies of abstractions and syntax are explained by straightforward translations into closely-related kernel languages, simple languages that consist of small numbers of programmer-significant concepts.""
  - ""We present the kernel language approach, a new way to teach programming that situates most of the widely-known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) in a uniform setting that shows their deep relationships and how to use them together.""",,"- The abstract describes the kernel language approach as a method to teach programming by situating various paradigms in a uniform setting. This suggests a theoretical framework rather than an empirical validation process.
 - The mention of translating practical languages into kernel languages implies a mapping process, but this is more about explaining the approach rather than validating it.
 - The teaching of the approach at universities and its integration into curricula indicate practical application but not formal validation.
 - The abstract does not mention any specific criteria or empirical testing used to validate the classification system.
 - The reference to ten years of research by the Mozart Consortium suggests a long-term development process, but again, no explicit validation method is described.","- ""We present the kernel language approach, a new way to teach programming that situates most of the widely-known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) in a uniform setting that shows their deep relationships and how to use them together.""
  - ""Widely-different practical languages (exemplified by Java, Haskell, Prolog, and Erlang) with their rich panoplies of abstractions and syntax are explained by straightforward translations into closely-related kernel languages, simple languages that consist of small numbers of programmer-significant concepts.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""
  - ""We have taught the approach at three universities in courses ranging from second-year undergraduate courses to graduate courses.""
  - ""As part of a curriculum, the approach naturally complements courses on algorithms & data structures and program design & software engineering.""
  - ""The approach is the fruit of ten years of research by an international team, the Mozart Consortium.""
  - ""Teaching programming means to teach both the science and the technology.""",,"- The kernel language approach is designed to teach programming by showing the deep relationships between different programming paradigms, which implies a practical application for educators and students.
 - The approach simplifies complex languages into kernel languages, which are easy to understand and have a simple formal semantics, suggesting a tool for facilitating high-level comparative studies of programming languages.
 - The mention of teaching at universities indicates that the intended user group includes educators and students.
 - The approach complements courses on algorithms, data structures, program design, and software engineering, suggesting specific use cases in these areas.
 - The research implications include the development of a uniform setting for understanding programming paradigms, which could impact language design and comparative studies."
"Design, implementation and evaluation of a declarative object-oriented programming language",Adolfo J. Socorro Ramos,-,-,-,5,1993,"- Classification framework: Type system distinguishing between sorts (immutable entities), classes (mutable entities), and modules.
 - Primary focus: Object-oriented programming paradigms, hierarchical classification of values and objects, code reuse through module inheritance.
 - Scope: Focuses on object-oriented features such as classes, overloading, polymorphism, and multiple class inheritance; includes theories and views for module classification.","Derived from theoretical derivation, using axioms and formal semantics, with detailed feature-level analysis and literature-based comparisons",No limitations explicitly discussed,No formal validation described (the abstract mentions evaluation and comparison with other languages but does not specify a validation method or criteria),"- Intended user groups: Practitioners, researchers, educators
 - Specific use cases or potential applications: Tool for facilitating high-level comparative studies of programming languages; framework to help programmers choose appropriate language concepts for problem-solving
 - Potential impact on language design or comparative studies: Contributions to the design of declarative object-oriented programming languages; framework for comparative studies of programming languages","- ""This thesis is a detailed study of FOOPS, a ""wide spectrum"" object-oriented program­ ming language.""
  - ""FOOPS supports all ofthe classical features of the object paradigm, includ­ ing classes, overloading. polymorphism, and multiple class inheritance with overriding and dynamic binding.""
  - ""Moreover, both of these are different from modules, which may declare together several re­ lated sorts and classes.""
  - ""Theories are special kinds of modules that serve to classify other theories and modules by the syntactic and semantic properties that they satisfy; they are mostly used to constrain the actual arguments to parameterised modules.""
  - ""FOOPS is declarative in that it uses axioms to define the properties of functions, attributes and methods.""
  - ""Also, there is a formal semantics given by a deduction system, which can be used to prove properties of FOOPS programs.""
  - ""This thesis considers the design of FOOPS, explaining all its features and examining their application to the design and development of object.-oriented systems,""",,"- The abstract describes FOOPS as a ""wide spectrum"" object-oriented programming language, indicating a focus on object-oriented programming paradigms.
 - The type system of FOOPS is highlighted, which distinguishes between sorts (immutable entities) and classes (mutable entities), and modules. This suggests a classification framework within the language itself.
 - Inheritance mechanisms are detailed for sorts, classes, and modules, indicating a hierarchical classification system within the language.
 - Theories and views are described as mechanisms for classifying and relating modules and theories, suggesting a formalism for organizing and structuring programming concepts.
 - The abstract mentions a formal semantics given by a deduction system, which implies a mathematical formalism for proving properties of FOOPS programs.
 - The thesis evaluates large-grain issues such as the distinction between classes and modules, and presents work towards a mathematical semantics, indicating a focus on conceptual characteristics and language features.","- ""This thesis is a detailed study of FOOPS, a ""wide spectrum"" object-oriented program­ ming language.""
  - ""FOOPS supports all ofthe classical features of the object paradigm, includ­ ing classes, overloading. polymorphism, and multiple class inheritance with overriding and dynamic binding.""
  - ""Theories are special kinds of modules that serve to classify other theories and modules by the syntactic and semantic properties that they satisfy; they are mostly used to constrain the actual arguments to parameterised modules.""
  - ""FOOPS is declarative in that it uses axioms to define the properties of functions, attributes and methods.""
  - ""Also, there is a formal semantics given by a deduction system, which can be used to prove properties of FOOPS programs.""
  - ""This thesis considers the design of FOOPS, explaining all its features and examining their application to the design and development of object.-oriented systems,""",,"- The abstract indicates a ""detailed study"" of FOOPS, suggesting a deep level of conceptual analysis.
 - The conceptual definitions are derived from theoretical derivation, as evidenced by the use of axioms and formal semantics to define properties.
 - The abstract mentions specific conceptual dimensions such as the distinction between sorts and classes, inheritance mechanisms, and the use of theories and modules for classification.
 - The evaluation of FOOPS includes comparisons with other languages, indicating a literature-based approach to conceptual mapping.
 - The mention of a ""detailed summary of current work towards a mathematical semantics"" suggests a theoretical derivation of conceptual definitions.","- ""This thesis considers the design of FOOPS, explaining all its features and examining their application to the design and development of object.-oriented systems,""
  - ""Theories are special kinds of modules that serve to classify other theories and modules by the syntactic and semantic properties that they satisfy; they are mostly used to constrain the actual arguments to parameterised modules.""
  - ""Moreover, both of these are different from modules, which may declare together several re­ lated sorts and classes.""
  - ""However, it goes beyond other object-oriented. languages in its facilities for the specification. composition and reuse of modules.""
  - ""FOOPS supports all ofthe classical features of the object paradigm, includ­ ing classes, overloading. polymorphism, and multiple class inheritance with overriding and dynamic binding.""",,"- The abstract discusses the features and design of FOOPS, a declarative object-oriented programming language, highlighting its advancements over other object-oriented languages.
 - It mentions that FOOPS goes beyond other languages in its facilities for module specification, composition, and reuse, which could imply limitations in existing classification approaches that do not account for these advanced features.
 - The abstract does not explicitly mention limitations in existing classification approaches or critiques of current taxonomies. Instead, it focuses on the design and evaluation of FOOPS.
 - The abstract does not provide specific limitations identified or proposed improvements to existing classification methods.","- ""This thesis considers the design of FOOPS, explaining all its features and examining their application to the design and development of object.-oriented systems,""",,"- The abstract mentions that the thesis evaluates FOOPS by focusing on large-grain issues and comparing it with other languages. This suggests a form of validation through comparison with existing languages.
 - The mention of a prototype implementation and its support for most features implies some form of empirical testing or verification.
 - The abstract does not explicitly mention a specific validation method or criteria used to demonstrate validity, but it does indicate that comparisons with other languages are part of the evaluation process.
 - The abstract does not provide specific details on the criteria used for validation or specific languages used in the validation process.","- ""This thesis is a detailed study of FOOPS, a ""wide spectrum"" object-oriented program­ ming language.""
  - ""FOOPS supports all ofthe classical features of the object paradigm, includ­ ing classes, overloading. polymorphism, and multiple class inheritance with overriding and dynamic binding.""
  - ""FOOPS is declarative in that it uses axioms to define the properties of functions, attributes and methods.""
  - ""FOOPS supports design in the same framework as specification and coding.""
  - ""This thesis considers the design of FOOPS, explaining all its features and examining their application to the design and development of object.-oriented systems,""
  - ""comparisons with many other languages are given.""",,"- The abstract discusses the design and implementation of FOOPS, a declarative object-oriented programming language, which suggests its practical application in programming and software development.
 - The mention of FOOPS supporting classical object-oriented features and its declarative nature implies its potential use by practitioners and researchers in software development.
 - The thesis's focus on the design and development of object-oriented systems suggests its relevance to educators teaching object-oriented programming.
 - The evaluation of FOOPS and comparisons with other languages indicate potential applications in comparative studies of programming languages.
 - The discussion of mathematical semantics for FOOPS suggests research implications in the field of programming language design and theoretical computer science.
 - The abstract does not explicitly mention specific user groups or use cases, but the context implies applications in programming, software development, and comparative studies."
Explorer Naturally Embedded Query Languages,"V. Tannen, P. Buneman, L. Wong",-,-,-,0,2014,"No specific formalism developed (the abstract implies a classification framework for programming languages and query languages based on expressive power and conceptual restrictions, but does not specify a particular type of formalism)","Derived from theoretical derivation, using structural recursion, category theory, and algebraic perspectives to classify sublanguages based on expressive power and conceptual restrictions.",No limitations explicitly discussed (the abstract presents advantages of the proposed approach rather than explicit limitations of existing methods),No formal validation described,Framework for facilitating high-level comparative studies of programming languages; potential applications in database query systems and data manipulation; theoretical contributions to language design and comparative studies using category theory and algebraic perspectives.,"- ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""
  - ""we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""",,"- The abstract discusses the investigation of a programming language with structural recursion on sets, which suggests a focus on the formalism related to programming paradigms.
 - The mention of a ""progression of sublanguages"" indicates a classification or taxonomy of these sublanguages based on their expressive power and conceptual restrictions.
 - The abstract highlights the characterization of nested relational and complex-object algebras, suggesting a taxonomy or classification framework for these types of algebras.
 - The use of equational theories and categorical ideas implies an algebraic perspective, which could be part of the formalism or taxonomy developed.
 - The abstract does not explicitly mention a specific category of formalism like a feature model or taxonomy, but it implies a classification framework for programming languages and query languages based on their properties and expressive power.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""",,"- The abstract indicates a deep conceptual analysis by describing a progression of sublanguages with increasing expressive power and robust conceptual restrictions. This suggests a detailed examination of the languages' properties.
 - The sources of conceptual definitions appear to be theoretical derivations, as indicated by the use of structural recursion, category theory, and algebraic perspectives. There is no mention of empirical analysis or literature review as sources.
 - Specific conceptual dimensions or criteria used for classification include the expressive power of sublanguages and the use of category theory to organize semantics and syntax. The mention of ""surprisingly simple operators"" and ""equational theories"" suggests a focus on theoretical derivation and algebraic perspectives.
 - The abstract does not mention any empirical analysis or literature review, suggesting that the conceptual approach is primarily theoretical.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""First, there is no ""impedance mismatch problem; the query languages are already there, so they share common semantic foundation with the general language.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Third, we exhibit differences in expressive power that are not always based on complexity arguments, but use the idea that a query in one language may not be polymorphically expressible in another.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""",,"- The abstract discusses the advantages of viewing query languages as restrictions of a more general programming language, which implies a critique of existing approaches that might not share this perspective.
 - The mention of ""no 'impedance mismatch problem'"" suggests a limitation in existing approaches where such a mismatch might occur, indicating a conceptual limitation in how query languages are typically integrated with general programming languages.
 - The abstract highlights the ability to make comparisons of expressiveness in a general framework, which could imply a limitation in existing classification methods that might not allow for such comparisons.
 - The use of category theory to organize semantics and syntax suggests a methodological limitation in existing approaches that might not utilize such theoretical frameworks effectively.
 - However, the abstract does not explicitly state these as limitations of existing classification approaches but rather presents them as advantages of the proposed approach.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""",,"- The abstract discusses the investigation of a programming language and its sublanguages, focusing on their properties and expressive power.
 - It mentions the use of category theory to organize semantics and syntax, which could be part of a validation process.
 - The abstract suggests a uniform characterization of certain algebras, which might imply a form of validation through theoretical comparison.
 - However, there is no explicit mention of a validation method such as mapping to existing languages or empirical testing.
 - The abstract does not specify any criteria used to demonstrate validity or any specific languages or examples used in validation.
 - The focus is more on theoretical properties and advantages rather than empirical validation.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""These properties suggest that we consider our sublanguages as candidates for ""query languages"".""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""First, there is no ""impedance mismatch problem; the query languages are already there, so they share common semantic foundation with the general language.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators; and we can make comparisons of expressiveness in a general framework.""
  - ""Third, we exhibit differences in expressive power that are not always based on complexity arguments, but use the idea that a query in one language may not be polymorphically expressible in another.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""",,"- The abstract discusses the investigation of a programming language with structural recursion on sets, which suggests a focus on theoretical and research implications.
 - The mention of sublanguages as candidates for ""query languages"" implies potential applications in database query systems or data manipulation.
 - The advantages listed, such as no impedance mismatch and uniform characterization of algebras, suggest practical implications for language design and comparative studies.
 - The use of category theory and algebraic perspectives indicates potential research applications in theoretical computer science and programming language design.
 - The abstract does not explicitly mention intended user groups or specific use cases, but the focus on language design and theoretical foundations suggests applications for researchers and educators in computer science."
FROM DIFFICULT PROBLEMS TO PROGRAMMING PARADIGMS,Л.В. Городняя,10.38028/ESI.2021.21.1.008,https://doi.org/10.38028/ESI.2021.21.1.008,-,0,2021,"Taxonomy of programming languages based on their similarities and differences, with a focus on programming paradigms and stratification of semantic features","Derived from historical and scientific literature, using a detailed feature-level analysis with stratification of semantic features into autonomously developed components and ranking of problem statements by knowledge degree",No limitations explicitly discussed,No formal validation described,"- Intended user groups: Practitioners, researchers, educators
 - Specific use cases or potential applications: Tool for facilitating high-level comparative studies of programming languages; framework to help programmers choose appropriate language concepts for problem-solving; aid in developing experimental programming systems and educational schemes
 - Potential impact on language design or comparative studies: Systematization of programming languages for comparative studies; stratification of language semantics for language design","- ""Попутно формируется ранжирование постановок задач по степени их изученности,""
  - ""Это даёт возможность стратификации особенностей семантики языков программирования с разделением на автономно развиваемые компоненты""
  - ""Результаты анализа позволили выполнить систематизацию языков программирования, представляя оценку их сходства и различия,""
  - ""Статья посвящена описанию и анализу взаимосвязи между трудно решаемыми проблемами и процессом формирования парадигм программирования,""",,"- The abstract mentions the analysis of the relationship between hard-to-solve problems and the formation of programming paradigms, indicating a focus on programming paradigms.
 - The results of the analysis allowed for the systematization of programming languages, which suggests a classification or taxonomy of these languages based on their similarities and differences.
 - The stratification of the peculiarities of the semantics of programming languages into autonomously developed components implies a structured approach to categorizing language features.
 - The ranking of problem statements by their degree of knowledge suggests a classification framework for problem complexity or knowledge level.","- ""Попутно формируется ранжирование постановок задач по степени их изученности,""
  - ""Это даёт возможность стратификации особенностей семантики языков программирования с разделением на автономно развиваемые компоненты""
  - ""Результаты анализа позволили выполнить систематизацию языков программирования, представляя оценку их сходства и различия,""
  - ""Материал для анализа даёт история вычислительной техники, а также малозаметная линия научной деятельности лидера программирования А.П. Ершова""
  - ""Статья посвящена описанию и анализу взаимосвязи между трудно решаемыми проблемами и процессом формирования парадигм программирования,""",,"- The abstract mentions an analysis of the relationship between hard-to-solve problems and the formation of programming paradigms, indicating a deep conceptual analysis.
 - The material for analysis is drawn from the history of computer technology and the scientific activity of A.P. Ershov, suggesting a literature-based approach.
 - The results include the systematization of programming languages and an assessment of their similarities and differences, which implies a detailed feature-level analysis.
 - The stratification of semantic features into autonomously developed components suggests a structured and detailed approach to classification.
 - The ranking of problem statements by their degree of knowledge indicates a criterion-based approach to classification.","- ""Это даёт возможность стратификации особенностей семантики языков программирования с разделением на автономно развиваемые компоненты в процессе пошаговой разработки экспериментальных систем программирования и формирования схем изучения и преподавания системного программирования,""
  - ""Результаты анализа позволили выполнить систематизацию языков программирования, представляя оценку их сходства и различия, что позволяет строить лаконичные определения относительно парадигмальных моделей.""
  - ""Статья посвящена описанию и анализу взаимосвязи между трудно решаемыми проблемами и процессом формирования парадигм программирования, которые могут быть полезны при решении таких проблем.""",,"- The abstract discusses the relationship between hard-to-solve problems and the formation of programming paradigms, which suggests a focus on improving or developing new classification approaches rather than critiquing existing ones.
 - The mention of systematizing programming languages and evaluating their similarities and differences implies a methodological contribution, but it does not explicitly mention limitations of existing classification approaches.
 - The abstract does not contain any explicit discussion of limitations in existing programming language classification methods or critiques of current taxonomies.
 - There is no mention of proposed improvements or alternative approaches to existing classification methods.","- ""Это даёт возможность стратификации особенностей семантики языков программирования с разделением на автономно развиваемые компоненты в процессе пошаговой разработки экспериментальных систем программирования и формирования схем изучения и преподавания системного программирования,""
  - ""Результаты анализа позволили выполнить систематизацию языков программирования, представляя оценку их сходства и различия, что позволяет строить лаконичные определения относительно парадигмальных моделей.""",,"- The abstract mentions the systematization of programming languages and the assessment of their similarities and differences, which suggests a classification system.
 - It also talks about stratifying the presentation of the peculiarities of the semantics of programming languages into autonomously developed components, which implies a structured approach to classification.
 - However, there is no explicit mention of a validation method for this classification system in the abstract. The abstract does not specify how the proposed formalism or taxonomy was validated, such as through mapping to existing languages or empirical testing.
 - The abstract does not provide specific languages or examples used in validation or criteria used to demonstrate validity.","- ""Попутно формируется ранжирование постановок задач по степени их изученности, что влияет на оценку трудоёмкости программирования.""
  - ""Это даёт возможность стратификации особенностей семантики языков программирования с разделением на автономно развиваемые компоненты в процессе пошаговой разработки экспериментальных систем программирования и формирования схем изучения и преподавания системного программирования, что может быть полезным для повышения производительности программного обеспечения.""
  - ""Результаты анализа позволили выполнить систематизацию языков программирования, представляя оценку их сходства и различия, что позволяет строить лаконичные определения относительно парадигмальных моделей.""
  - ""Статья посвящена описанию и анализу взаимосвязи между трудно решаемыми проблемами и процессом формирования парадигм программирования, которые могут быть полезны при решении таких проблем.""",,"- The abstract discusses the relationship between hard-to-solve problems and the formation of programming paradigms, which suggests a practical application in solving complex problems.
 - The systematization of programming languages and their similarities and differences could be useful for comparative studies and language design.
 - The stratification of language semantics into autonomously developed components could aid in the development of experimental programming systems and educational schemes, indicating a potential application for educators and researchers.
 - The ranking of problem statements by their degree of knowledge could help in assessing labor intensity, which is relevant for practitioners and researchers in planning and executing projects."
Logical reconstruction of programming language paradigms,D. Lauc,-,-,-,0,2013,"Taxonomy of programming paradigms visualized as a prism with imperative, function, and logical paradigms, considering modularity as a depth axis","Deep conceptual analysis using theoretical derivation; multi-dimensional classification with imperative, function, and logical paradigms, and degree of modularity as criteria; detailed feature-level analysis with mapping of languages onto paradigmatic space.",The present usage of the term 'programming language paradigms' is quite chaotic.,Validated through mapping of existing programming languages onto the model; specific languages not mentioned; criteria for validity include completeness with regard to existing programming languages.,Framework for comparative studies of programming languages; Tool for evaluating completeness of programming language paradigms; Potential impact on language design and comparative studies,"- ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""
  - ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""
  - ""Actual programming languages are represented as occupying some space in such a model.""
  - ""Finally, the model is evaluated for completeness with regard to existing programming languages.""",,"- The abstract mentions the use of ""logical reconstruction"" to model programming paradigms, indicating a formal approach to categorizing these paradigms.
 - The visualization of programming languages as a ""prism"" with specific edges for imperative, function, and logical paradigms suggests a structured framework or taxonomy.
 - The mention of a ""depth axis as degree of modularity of languages"" implies that the classification also considers the modularity aspect of programming languages.
 - The abstract does not specify the exact number of language categories or features covered, but it does indicate that actual programming languages are represented within this model.
 - The focus is on programming paradigms and their logical models, which are considered fundamental to computing.","- ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""
  - ""Finally, the model is evaluated for completeness with regard to existing programming languages.""
  - ""Actual programming languages are represented as occupying some space in such a model.""
  - ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""",,"- The abstract mentions the use of ""logical reconstruction"" as a method, which suggests a deep conceptual analysis. This method involves creating logical models to represent programming paradigms, indicating a structured and systematic approach.
 - The abstract does not explicitly mention sources such as literature review or empirical analysis, but the use of ""logical reconstruction"" implies a theoretical derivation of conceptual definitions.
 - The conceptual dimensions used for classification include the edges of the prism representing imperative, function, and logical paradigms, and the depth axis representing the degree of modularity. This suggests a multi-dimensional approach to classification.
 - The visualization of programming languages as occupying space within this model indicates a detailed feature-level analysis, as it involves mapping languages onto specific points within the paradigmatic space.","- ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""",,"- The abstract mentions that the ""present usage of the term"" (referring to programming language paradigms) is ""quite chaotic."" This suggests a limitation in the existing classification approaches, as it implies a lack of clarity or consistency in how these paradigms are currently understood or categorized.
 - The abstract does not provide specific details about the nature of this chaos or how it affects classification, but it implies that there is a need for a more structured approach, which is what the author's method of logical reconstruction aims to address.
 - The abstract does not explicitly mention any specific critiques of current taxonomies or classification methods beyond the general statement about chaos, nor does it outline proposed improvements or alternative approaches in detail.","- ""Finally, the model is evaluated for completeness with regard to existing programming languages.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""
  - ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""
  - ""Actual programming languages are represented as occupying some space in such a model.""
  - ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""",,"- The abstract mentions that the model is ""evaluated for completeness with regard to existing programming languages,"" which suggests some form of validation.
 - The validation approach seems to involve mapping existing programming languages onto the proposed model, as indicated by ""Actual programming languages are represented as occupying some space in such a model.""
 - The criteria used to demonstrate validity appear to be related to the completeness of the model in representing existing programming languages.
 - However, the abstract does not specify which particular languages were used in the validation or provide detailed criteria for demonstrating validity.","- ""Using method of logical reconstruction programming paradigms are modeled by original logical models of computation that are considered paradigms of programming language paradigms.""
  - ""The concept of programming language paradigms is a one of fundamental concepts of computing, but the present usage of the term is quite chaotic.""
  - ""Finally, the model is evaluated for completeness with regard to existing programming languages.""
  - ""The space of the programming languages is visualized as a prism, with edges of imperative, function and logical paradigms corresponding to basic models of computation, and depth axis as degree of modularity of languages.""
  - ""Actual programming languages are represented as occupying some space in such a model.""",,"- The abstract discusses the chaotic current state of programming language paradigms, suggesting a need for a more structured approach.
 - The use of logical reconstruction to model programming paradigms implies a theoretical framework that could be used by researchers to better understand and classify programming languages.
 - The visualization of programming languages as a prism suggests a tool for comparative studies, which could be useful for researchers and educators in understanding the relationships between different programming paradigms.
 - The evaluation of the model for completeness regarding existing programming languages suggests potential applications in language design, as it could help identify gaps or areas for improvement in current languages.
 - The abstract does not explicitly mention intended user groups or specific use cases, but the implications for comparative studies and language design suggest potential applications for researchers and educators."
On the problem of computer language classification,"I. Anureev, E. V. Bodin, L. Gorodnyaya, A. Marchuk, F. Murzin, N. Shilov",-,-,-,3,2009,"Taxonomy of computer language paradigms based on unified formal semantics (Abstract State Machines) and open ontology for pragmatists, focusing on semantics and pragmatics of programming languages","Derived from a unified formal semantics and open ontology, using literature-based conceptual mapping and detailed feature-level analysis of syntax, semantics, and pragmatics.","- Existing classification approaches from natural sciences are not applicable to computer languages due to their dynamic nature.
 - Chronological classification methods are no longer effective due to rapid growth and diversification.
 - Current methods struggle to categorize certain languages into specific paradigms.
 - Need for a modern classification that considers pragmatics and is adaptable to changes.",No formal validation described,"- Intended user groups: Practitioners, researchers, educators
 - Specific use cases or potential applications: Framework to help programmers choose appropriate language concepts for problem-solving; tool for facilitating high-level comparative studies of programming languages
 - Potential impact on language design or comparative studies: Provides a sound framework for choosing computer languages; facilitates comparison and estimation of system potential and usability","- ""The paper presents a so-called “semantics and pragmatics view” – an approach to computer languages paradigms and classification, that is based on a unified formal semantics (Abstract State Machines) and an open ontology for pragmatists.""
  - ""Computer paradigms are the basis for classification of the computer languages.""
  - ""Classification problem A computer language is any language designed or used for automatic “information processing”, i.e. data and process handling and management.""
  - ""The process of rapid generation of new computer languages will continue till new spheres of human activities will be computerized.""
  - ""Also, a modern classification should be (whenever possible) steady and opened for changes, when new branches, approaches, or models of computer languages appear.""
  - ""We call the alternative approaches to information processing, accumulated and fixed in the form of computer languages, the paradigms of computer languages.""
  - ""Characteristics of paradigms at the level of their basic means for information processing could provide designers, developers and users of software and information systems with a sound basis for comparison of systems, estimation of their potential, usability, etc.""
  - ""the approach based on “specific features” of syntax, semantics and pragmatics could be natural for specifications of paradigmization and classification of computer languages.""",,"- The abstract mentions a ""semantics and pragmatics view"" as an approach to classifying computer languages, which suggests a focus on both the meaning and usage of languages.
 - The classification is based on ""unified formal semantics (Abstract State Machines) and an open ontology for pragmatists,"" indicating a formalism that integrates semantic and pragmatic aspects.
 - The primary focus is on ""computer paradigms,"" which are described as the basis for classification, suggesting a taxonomy or framework centered around these paradigms.
 - The scope includes a wide range of language categories and features, as it aims to cover the rapidly evolving field of computer languages and their applications.
 - The abstract does not specify a particular number of language categories or features covered, but it emphasizes the need for a classification system that is adaptable to new developments.","- ""The paper presents a so-called “semantics and pragmatics view” – an approach to computer languages paradigms and classification, that is based on a unified formal semantics (Abstract State Machines) and an open ontology for pragmatists.""
  - ""the approach based on “specific features” of syntax, semantics and pragmatics could be natural for specifications of paradigmization and classification of computer languages.""
  - ""Pragmatics or programmer’s practice was chosen by R. Floyd as a basis for development of the existing programming languages and design of new ones.""
  - ""Characteristics of paradigms at the level of their basic means for information processing could provide designers, developers and users of software and information systems with a sound basis for comparison of systems, estimation of their potential, usability, etc.""
  - ""The importance of study of computer languages and their paradigmization is widely recognized in Computer Science and Information Technology.""",,"- The abstract mentions a ""semantics and pragmatics view"" which suggests a deep conceptual analysis focusing on the meaning and usage of computer languages.
 - The use of ""unified formal semantics (Abstract State Machines)"" indicates a theoretical derivation of conceptual definitions, suggesting a deep level of analysis.
 - The mention of ""open ontology for pragmatists"" implies a broad and flexible framework for understanding the pragmatics of computer languages, which is a deep conceptual approach.
 - The abstract references the work of prominent scientists like Robert Floyd, indicating a literature-based conceptual mapping.
 - The focus on ""characteristics of paradigms"" and ""basic means for information processing"" suggests a detailed feature-level analysis.
 - The abstract discusses the influence of computer languages on software and information technologies, indicating a comprehensive analytical approach.","- ""Due to this argument, classification approaches adopted in Natural Science cannot be adequately applied to computer languages.""
  - ""At the initial stage of programming and information technology history (years 1950-65), it was possible to classify computer languages chronologically with annotations a-là Herodotus “The Histories”, i.e. including lists of authors, their purposes, personal related stories, etc.""
  - ""But since the late 1960-s, the approach in the style of “Father of History” becomes unacceptable.""
  - ""However, the 1990-s and the beginning of a new millennium became the time of rapid growth of existing and new branches of computer languages.""
  - ""At the same time, classification of already developed and new computer languages is a very important problem for computer science, since it could benefit software engineering and information technology by a sound framework for computer language choice for components of new program and information systems.""
  - ""Also, a modern classification should be (whenever possible) steady and opened for changes, when new branches, approaches, or models of computer languages appear.""
  - ""In spite of active research on systematization and classification of computer languages, experts have difficulties in putting some languages into one particular paradigm (e.g., Eiffel [23], Erlang [2], Python [36], etc.).""
  - ""There is a demand for paradigms for Language Of Temporal Ordering Specification LOTOS [39], Business Process Modeling Notation BPMN [34], Unified Medical Language System UMLS, [38] and many others.""",,"- The abstract discusses the limitations of existing classification approaches by highlighting that methods used in natural sciences are not applicable to computer languages due to the dynamic nature of computer language development.
 - The chronological approach used in the early stages of computer science is noted as becoming unacceptable due to the rapid growth and diversification of computer languages.
 - The abstract emphasizes the need for a modern classification system that considers not only technical aspects but also the pragmatics (application sphere) of languages.
 - It is mentioned that current classification methods struggle to categorize certain languages into specific paradigms, indicating a limitation in the current taxonomic approaches.
 - The abstract suggests that a modern classification should be adaptable to changes and new developments, implying that current methods are not flexible enough.","- ""The paper presents a so-called “semantics and pragmatics view” – an approach to computer languages paradigms and classification, that is based on a unified formal semantics (Abstract State Machines) and an open ontology for pragmatists.""
  - ""Characteristics of paradigms at the level of their basic means for information processing could provide designers, developers and users of software and information systems with a sound basis for comparison of systems, estimation of their potential, usability, etc.""
  - ""The importance of study of computer languages and their paradigmization is widely recognized in Computer Science and Information Technology.""
  - ""Currently, the number of essentially different paradigms only in programming languages is already close to several dozens""
  - ""Many new parallel programming languages, languages of specification and modeling of multiagent systems, languages for object-oriented modeling and design, languages of knowledge representation, etc., appearing over the past 10-15 years, do not fit in the current classification and require its essential revision.""
  - ""There is a demand for paradigms for Language Of Temporal Ordering Specification LOTOS [39], Business Process Modeling Notation BPMN [34], Unified Medical Language System UMLS, [38] and many others.""",,"- The abstract discusses the ""semantics and pragmatics view"" as an approach to classification, which suggests a theoretical framework rather than an empirical validation method.
 - The mention of ""unified formal semantics (Abstract State Machines) and an open ontology for pragmatists"" indicates a theoretical basis for the classification system but does not specify any empirical validation.
 - The abstract highlights the recognition of paradigmization in computer science and the need for revision due to new languages, but it does not describe any specific validation process or criteria.
 - The abstract does not mention any specific languages or examples used in validation or criteria to demonstrate validity.
 - The focus is on the theoretical framework and the need for classification rather than on empirical validation or testing.","- ""Study and precise specification of computer paradigms (including new ones) are called to improve the choice of appropriate computer languages for new software projects and information technologies.""
  - ""The paper presents a so-called “semantics and pragmatics view” – an approach to computer languages paradigms and classification, that is based on a unified formal semantics (Abstract State Machines) and an open ontology for pragmatists.""
  - ""classification of already developed and new computer languages is a very important problem for computer science, since it could benefit software engineering and information technology by a sound framework for computer language choice for components of new program and information systems.""
  - ""Also, a modern classification should be (whenever possible) steady and opened for changes, when new branches, approaches, or models of computer languages appear.""
  - ""Characteristics of paradigms at the level of their basic means for information processing could provide designers, developers and users of software and information systems with a sound basis for comparison of systems, estimation of their potential, usability, etc.""
  - ""Many new parallel programming languages, languages of specification and modeling of multiagent systems, languages for object-oriented modeling and design, languages of knowledge representation, etc., appearing over the past 10-15 years, do not fit in the current classification and require its essential revision.""",,"- The abstract suggests that the classification system is intended to improve the choice of appropriate computer languages for new software projects and information technologies, which implies a practical application for practitioners and researchers.
 - The ""semantics and pragmatics view"" approach is proposed as a framework to help in the classification and understanding of computer languages, which could be useful for educators in teaching about language paradigms.
 - The classification system is expected to benefit software engineering and information technology by providing a sound framework for choosing computer languages, indicating a potential impact on language design and comparative studies.
 - The abstract mentions that the classification should be based on the sphere of application of languages, which suggests a focus on pragmatics and practical use cases.
 - The system is designed to be adaptable to new branches and models of computer languages, indicating a potential for ongoing research and development.
 - The abstract highlights the importance of understanding paradigms for comparison and estimation of system potential, usability, etc., which suggests a tool for facilitating high-level comparative studies."
The paradigm of open C++,B. Sunik,10.1145/885638.885648,https://doi.org/10.1145/885638.885648,SIGP,3,2003,No specific formalism developed (the abstract introduces a new class of languages but does not specify a formalism or taxonomy),"Derived from theoretical derivation, combining object-oriented programming language grammar with natural language universality, with a focus on syntax and conceptual system of C++",No limitations explicitly discussed,No formal validation described,"Framework for facilitating high-level comparative studies of programming languages and language design, potentially impacting how programming languages are structured or compared.","- ""Open languages are a new class of formal languages initially defined in [Sunik].""
  - ""This work details Open C++ based on the syntax and the conceptual system of C++.""
  - ""A language of this class combines the grammar of an object-oriented programming language with the universality of a natural language.""",,"- The abstract mentions ""Open languages"" as a ""new class of formal languages,"" which suggests a classification or categorization of programming languages.
 - The focus of this classification is on combining object-oriented programming language grammar with the universality of natural languages, indicating a focus on conceptual characteristics and language features.
 - The abstract does not specify the scope of the classification in terms of the number of language categories or features covered, nor does it explicitly mention a specific type of formalism like a feature model or taxonomy.
 - The mention of ""Open C++"" suggests that the work is detailing a specific instance of this new class of languages, but it does not provide enough information to determine if a broader formalism or taxonomy is developed beyond this specific example.","- ""A language of this class combines the grammar of an object-oriented programming language with the universality of a natural language.""
  - ""Open languages are a new class of formal languages initially defined in [Sunik].""
  - ""This work details Open C++ based on the syntax and the conceptual system of C++.""",,"- The abstract mentions that open languages are a new class of formal languages, which suggests a theoretical derivation of the conceptual system.
 - The combination of object-oriented programming language grammar with natural language universality implies a deep conceptual analysis, as it involves integrating two distinct linguistic paradigms.
 - The abstract does not explicitly mention sources of conceptual definitions such as literature review or empirical analysis, but the mention of ""initially defined in [Sunik]"" suggests that the conceptual framework may be derived from theoretical work or previous research by the author.
 - The specific conceptual dimensions or criteria used for classification are not detailed in the abstract, but the focus on syntax and conceptual system suggests a detailed analysis of these aspects.","- ""This work details Open C++ based on the syntax and the conceptual system of C++.""
  - ""A language of this class combines the grammar of an object-oriented programming language with the universality of a natural language.""
  - ""Open languages are a new class of formal languages initially defined in [Sunik].""",,"- The abstract introduces the concept of ""open languages"" and specifically discusses ""Open C++,"" which suggests a new approach or paradigm in programming languages.
 - The mention of combining the grammar of an object-oriented programming language with the universality of a natural language implies a critique of existing classification methods that may not account for such integration.
 - However, the abstract does not explicitly mention any limitations of existing classification approaches or critiques of current taxonomies.
 - The focus is on introducing a new concept rather than discussing the limitations of existing methods.","- ""Open languages are a new class of formal languages initially defined in [Sunik].""
  - ""This work details Open C++ based on the syntax and the conceptual system of C++.""
  - ""A language of this class combines the grammar of an object-oriented programming language with the universality of a natural language.""",,"- The abstract introduces the concept of ""open languages"" and specifically discusses ""Open C++,"" which is based on the syntax and conceptual system of C++.
 - There is no mention of any validation method or approach in the abstract. The focus is on the definition and detailing of Open C++, not on how it was validated.
 - The abstract does not provide any information on empirical testing, mapping to existing languages, or criteria used to demonstrate validity.
 - Since the abstract does not mention any validation process, it is reasonable to conclude that no formal validation is described.","- ""A language of this class combines the grammar of an object-oriented programming language with the universality of a natural language.""
  - ""Open languages are a new class of formal languages initially defined in [Sunik].""
  - ""This work details Open C++ based on the syntax and the conceptual system of C++.""",,"- The abstract introduces ""open languages"" as a new class of formal languages, which suggests a potential framework for comparative studies or language design.
 - The combination of object-oriented programming language grammar with natural language universality implies a potential application in facilitating high-level comparative studies or in designing new languages that integrate these features.
 - The focus on Open C++ based on C++ syntax and conceptual system suggests a practical application in language design or modification, potentially impacting how programming languages are structured or compared.
 - The abstract does not explicitly mention intended user groups, specific use cases, or potential impact, but the introduction of a new class of languages implies potential applications in research and education."
Teaching Programming Broadly and Deeply: The Kernel Language Approach,"P. V. Roy, Seif Haridi",10.1007/978-0-387-35619-8_6,https://doi.org/10.1007/978-0-387-35619-8_6,Informatics Curricula and Teaching Methods,17,2002,"Taxonomy of programming paradigms (imperative, object-oriented, concurrent, logic, functional) with a kernel language approach, covering over 20 paradigms with simple formal semantics.","Derived from a decade of research and implementation by the Mozart Consortium, using a theoretically grounded approach that focuses on underlying concepts and simple formal semantics to provide a deep analysis of programming paradigms.","- Existing teaching methods are either too paradigm-specific or too theoretical.
 - Lack of a unified framework for understanding different programming paradigms.
 - Limited formal semantics in textbooks for most paradigms.
 - Specialized books on language semantics are too formal or restricted.
 - Teaching multiple languages without showing connections is inefficient.
 - Proposed improvement: The kernel language approach focuses on underlying concepts rather than specific languages or paradigms.","Validated through concrete mappings of well-known languages (Erlang, Haskell, Java, and Prolog) into kernel languages, supported by the Mozart Programming System.","- Intended user groups: Practitioners, researchers, educators
 - Specific use cases or potential applications: Educational curriculum design, language design and implementation, comparative studies of programming languages
 - Potential impact on language design or comparative studies: Provides a framework for understanding and comparing different programming paradigms, facilitates high-level comparative studies, and aids in language design by focusing on underlying concepts rather than specific languages.","- ""We present the kernel language approach; a new way to teach programming that situates most of the widely known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) into a uniform setting that shows their deep relationships and how to use them together.""
  - ""The kernel language approach is an outgrowth of ten years of programming language research and implementation by an international team, the Mozart Consortium,""
  - ""The kernel languages are easy to understand and have a simple formal semantics that allows practicing programmers to reason about correctness and complexity at a high level of abstraction.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""
  - ""The textbook mentions many languages and gives an in-depth treatment of four languages that are representative of widely different paradigms, namely Erlang, Haskell, Java, and Prolog.""",,"- The paper introduces the ""kernel language approach"" as a new method for teaching programming that integrates various programming paradigms into a uniform framework. This suggests a classification system or formalism that organizes these paradigms.
 - The focus of this classification is on programming paradigms, as it aims to show their deep relationships and how they can be used together.
 - The scope of the classification includes several widely known programming paradigms such as imperative, object-oriented, concurrent, logic, and functional programming.
 - The kernel languages are described as having a simple formal semantics, which implies a structured approach to understanding and comparing these paradigms.
 - The paper mentions that the textbook covers more than 20 paradigms, each with its kernel language, indicating a broad scope of the classification.","- ""The kernel language approach is an outgrowth of ten years of programming language research and implementation by an international team, the Mozart Consortium,""
  - ""We present the kernel language approach; a new way to teach programming that situates most of the widely known programming paradigms (including imperative, object-oriented, concurrent, logic, and functional) into a uniform setting that shows their deep relationships and how to use them together.""
  - ""The kernel languages are easy to understand and have a simple formal semantics that allows practicing programmers to reason about correctness and complexity at a high level of abstraction.""
  - ""Kernel languages are easy to understand and have a simple formal semantics that can be used by practicing programmers to reason about correctness and complexity.""
  - ""The approach is not based on a single language (or a few languages), but on the underlying concepts. The concepts are carefully chosen to be meaningful for practical programming.""",,"- The paper introduces the ""kernel language approach"" as a method to teach programming by situating various paradigms in a uniform setting, indicating a deep analysis of conceptual relationships.
 - The approach is based on ""underlying concepts"" rather than specific languages, suggesting a focus on fundamental principles rather than surface-level features.
 - The mention of ""simple formal semantics"" implies a structured and systematic methodology for analyzing and classifying programming concepts.
 - The approach is the result of ""ten years of programming language research and implementation,"" indicating a thorough and empirically grounded development process.
 - The emphasis on ""practical programming"" and the ability to reason about ""correctness and complexity"" suggests a focus on practical applicability and analytical depth.","- ""Surprisingly, we find that programming is not taught in this way. Rather, it is taught in two different ways: either as a craft in the context of a single programming paradigm and its tools, or as a branch of mathematics.""
  - ""The science is either limited to the chosen paradigm or too fundamental to be of practical use.""
  - ""Almost no attempt is made to put the paradigms in a uniform framework.""
  - ""None of these textbooks give a formal semantics except for those on functional programming and concurrent imperative programming.""
  - ""Specialized books on language semantics are either too formal or too restricted for the wider concerns of practical programming""
  - ""Taken together, these textbooks show programming as a discipline lacking unity.""
  - ""Teaching a few carefully selected languages, say one per paradigm (for example Java, Prolog, and Haskell), is a stopgap solution. It multiplies the intellectual effort of the student (since each language has its own syntax and semantics) and does not show the deep connections between the paradigms.""
  - ""The kernel language approach we propose solves these problems.""",,"- The paper critiques the current teaching methods of programming, which are either too focused on a single paradigm or too theoretical, lacking practical application.
 - It highlights that existing textbooks fail to provide a unified framework for understanding different programming paradigms, leading to a lack of unity in the discipline.
 - The paper notes that most textbooks do not provide formal semantics for all paradigms, except for functional and concurrent imperative programming, indicating a limitation in the current educational materials.
 - Specialized books on language semantics are criticized for being either too formal or too restricted, suggesting a need for more accessible and comprehensive resources.
 - The paper argues that teaching multiple languages without showing their connections is inefficient and does not provide a deep understanding of programming concepts.
 - The kernel language approach is proposed as a solution to these limitations, suggesting an alternative method that focuses on underlying concepts rather than specific languages or paradigms.","- ""The kernel language approach we propose solves these problems.""
  - ""The approach is not based on a single language (or a few languages), but on the underlying concepts.""
  - ""Practical languages in all their richness are translated into the kernel languages in a straightforward manner.""
  - ""The kernel languages are easy to understand and have a simple formal semantics that allows practicing programmers to reason about correctness and complexity at a high level of abstraction.""
  - ""The textbook mentions many languages and gives an in-depth treatment of four languages that are representative of widely different paradigms, namely Erlang, Haskell, Java, and Prolog.""
  - ""The textbook is supported by the Mozart Programming System, a fullfeatured open-source development platform that can run all program fragments in the book""
  - ""The kernel language approach is an outgrowth of ten years of programming language research and implementation by an international team, the Mozart Consortium,""",,"- The paper describes the kernel language approach as a method to teach programming by translating practical languages into simpler kernel languages, which are easy to understand and have a simple formal semantics.
 - The approach is validated through the translation of practical languages into kernel languages, which is a form of mapping to existing languages.
 - The paper mentions that the textbook provides an in-depth treatment of four languages (Erlang, Haskell, Java, and Prolog), which are used as examples to demonstrate the validity of the kernel language approach.
 - The use of the Mozart Programming System as a development platform to run program fragments from the book suggests a practical validation of the approach.
 - The paper does not explicitly mention empirical testing or specific criteria used to demonstrate validity, but the mapping of practical languages to kernel languages and the use of the Mozart system imply a form of validation.","- ""The kernel language approach we propose solves these problems.""
  - ""The kernel languages are easy to understand and have a simple formal semantics that allows practicing programmers to reason about correctness and complexity at a high level of abstraction.""
  - ""The kernel language approach is an outgrowth of ten years of programming language research and implementation by an international team, the Mozart Consortium,""
  - ""We are writing a textbook Concepts, Techniques, and Models of Computer Programming.""
  - ""The textbook is supported by the Mozart Programming System, a fullfeatured open-source development platform that can run all program fragments in the book""
  - ""The textbook mentions many languages and gives an in-depth treatment of four languages that are representative of widely different paradigms, namely Erlang, Haskell, Java, and Prolog.""
  - ""We have discussed the effects of the kernel language approach on the informatics curriculum with our colleagues at UCL, at workshops and conferences where we presented the approach,""
  - ""Based on these discussions, we propose the following natural division of the discipline of programming into three core topics:
 

 1. Concepts and techniques. 2. Algorithms and data structures.
 

 3. Program design and software engineering.""
  - ""The approach focuses on programming concepts and the techniques to use them (""concepts first""), not on programming languages or paradigms.""",,"- The kernel language approach is proposed as a solution to the problems of teaching programming, indicating its practical application in education.
 - The approach is designed to be easy to understand and provides a simple formal semantics, which is beneficial for practicing programmers, suggesting its use for practitioners.
 - The involvement of the Mozart Consortium and the development of a textbook and programming system indicate research implications and applications in language design and implementation.
 - The discussion of the approach's impact on the informatics curriculum suggests its potential use in educational settings and curriculum design.
 - The division of programming into core topics indicates a framework for organizing programming education and research."
A layered object-oriented programming language,T. Clark,-,-,-,9,1994,"Layered classification framework for object-oriented programming languages, focusing on characteristic features and mechanisms, allowing for systematic mapping of the OOPL design space.","Detailed feature-level analysis with concrete mappings of well-known languages, using theoretical derivation to construct a layered framework for understanding OOPLs.","- Difficulty in defining what an object-oriented programming language (OOPL) is.
 - Lack of formal description for current OOPLs.
 - Lack of precise understanding of object-oriented primitives leading to unpredictable language design.","Validated through mapping to existing languages, as it provides a framework for analyzing and constructing new OOPLs characteristic of a broad range of currently used languages.",Framework for analyzing existing OOPLs and constructing new ones; facilitates systematic mapping of the OOPL design space for comparative studies; provides a basis for designing new languages or modifying existing ones.,"- ""The OOPL is constructed in layers, each layer contributes a new feature which is built by extending and modifying the previous layer.""
  - ""The resulting language provides a framework within which existing OOPLs can be analysed and new OOPLs can be constructed.""
  - ""This paper shows how an OOPL can be constructed using a simple functional language which has been enriched with a small collection of characteristic primitives.""",,"- The abstract describes the development of a ""layered object-oriented programming language"" using a ""simple functional notation"" enriched with common features of OOPLs. This suggests a structured approach to defining OOPLs.
 - The language is constructed in layers, with each layer adding new features, indicating a hierarchical or layered formalism.
 - The focus is on object-oriented programming languages, specifically on analyzing existing ones and constructing new ones, which implies a classification or framework for understanding OOPLs.
 - The scope includes a broad range of currently used OOPLs, suggesting a comprehensive classification system.
 - The abstract does not explicitly mention a specific type of formalism like a feature model or taxonomy, but the layered construction and focus on characteristic features imply a structured classification framework.","- ""The resulting language provides a framework within which existing OOPLs can be analysed and new OOPLs can be constructed.""
  - ""The contribution which this paper makes to software engineering is to strip bare the underlying concepts of OOPLs and to show them""
  - ""The OOPL is constructed in layers, each layer contributes a new feature which is built by extending and modifying the previous layer.""",,"- The abstract describes the use of a ""simple functional notation"" to define a layered object-oriented programming language, indicating a structured and systematic approach to conceptual analysis.
 - The language is constructed in layers, with each layer adding new features, suggesting a deep and incremental analysis of conceptual dimensions.
 - The abstract mentions that the language provides a framework for analyzing existing OOPLs and constructing new ones, implying a comprehensive and detailed feature-level analysis.
 - The paper aims to ""strip bare the underlying concepts of OOPLs,"" indicating a focus on theoretical derivation and understanding of fundamental principles rather than empirical analysis or literature review.
 - The abstract does not explicitly mention sources like literature review or empirical analysis, suggesting that the conceptual definitions are derived from theoretical considerations.
 - The use of a layered approach and the focus on characteristic primitives suggest a detailed and systematic classification system.","- ""It is, however, notoriously dii-cult to deene exactly what is meant by the term \object oriented programming language""(OOPL);""
  - ""This fact and the lack of any formal description for the current object oriented programming languages, has meant that it is diicult to say exactly what, if any, the advances for software engineering are.""
  - ""Furthermore, if a precise understanding of the underlying object oriented primitives is lacking, then the design of new languages becomes a rather \hit and miss""""",,"- The abstract discusses the difficulty in defining what an object-oriented programming language (OOPL) is, indicating a limitation in the conceptual clarity of existing classification approaches.
 - The lack of a formal description for current OOPLs is highlighted as a limitation, suggesting that current classification methods may not be based on clear, objective criteria.
 - The abstract mentions that without a precise understanding of object-oriented primitives, language design becomes unpredictable, implying a methodological limitation in current approaches to designing new languages.","- ""The language which is the result of the nal layer contains mechanisms which are characteristic of the broad range of currently used OOPLs and the basic ideas and constructions provide a basis for a wide variety of languages and allows the OOPL design space to be mapped out in a systematic fashion.""
  - ""The resulting language provides a framework within which existing OOPLs can be analysed and new OOPLs can be constructed.""
  - ""The contribution which this paper makes to software engineering is to strip bare the underlying concepts of OOPLs and to show them""",,"- The abstract mentions that the proposed language provides a framework for analyzing existing OOPLs and constructing new ones, which suggests a form of validation through mapping to existing languages.
 - The language is described as containing mechanisms characteristic of a broad range of currently used OOPLs, indicating that it is validated by being applicable to multiple existing languages.
 - The abstract does not explicitly mention empirical testing or specific criteria used to demonstrate validity, but it implies a form of validation through its applicability to existing languages.","- ""The resulting language provides a framework within which existing OOPLs can be analysed and new OOPLs can be constructed.""
  - ""The language which is the result of the nal layer contains mechanisms which are characteristic of the broad range of currently used OOPLs and the basic ideas and constructions provide a basis for a wide variety of languages and allows the OOPL design space to be mapped out in a systematic fashion.""
  - ""The contribution which this paper makes to software engineering is to strip bare the underlying concepts of OOPLs and to show them""",,"- The abstract suggests that the proposed language framework can be used to analyze existing object-oriented programming languages (OOPLs) and construct new ones. This implies a practical application for practitioners and researchers in software engineering.
 - The framework allows for the systematic mapping of the OOPL design space, which could facilitate comparative studies of programming languages. This is a potential use case for researchers and educators interested in language design and comparison.
 - By providing a basis for a wide variety of languages, the framework could help in designing new languages or modifying existing ones, which is a potential impact on language design.
 - The abstract does not explicitly mention specific user groups or detailed use cases, but the implications for software engineering and language design are clear."
Type Models: Toward U nifying Concepts for Language Interoperability*,Arturo J. Sánchez Ruíz,-,-,-,1,-,Taxonomy of type models for programming languages with different paradigms,"- Depth of conceptual analysis: Deep (involves understanding and categorizing type systems across languages)
 - Sources of conceptual definitions: Not mentioned
 - Specific conceptual dimensions or criteria used for classification: Not mentioned (but involves mapping type models to specific languages and paradigms)",No limitations explicitly discussed (the abstract implies a need for a new approach due to different type systems but does not explicitly state limitations),No formal validation described,"Framework to facilitate language interoperability by providing a common platform for different type systems to coexist, applicable in distributed object interoperability, multi-language programming, and legacy code re-engineering.","- ""This paper presents the concept of type models with the goal of providing a common platform on which apparently different type systems can coexist in harmony.""",,"- The abstract mentions the presentation of ""type models"" as a concept, which suggests a formalism or framework for understanding and categorizing type systems across different programming languages.
 - The term ""taxonomy of type models"" explicitly indicates that a classification system or formalism is being developed. This taxonomy is focused on categorizing type models associated with various programming languages.
 - The primary focus of this classification is on type systems and how they relate to different programming paradigms, as indicated by ""examples of type models associated with various programming languages which implement different paradigms.""
 - The scope of the classification is not explicitly detailed in terms of the number of language categories or features covered, but it is implied to be broad enough to include multiple programming paradigms.","- ""The term language interoperability refers to the ability of one language to use software resources (perhaps previously) written in another language.""
  - ""This paper presents the concept of type models with the goal of providing a common platform on which apparently different type systems can coexist in harmony.""
  - ""It is therefore important to deal with the issues introduced by the fact that the languages in question have, in general, type systems of different nature.""",,"- The abstract discusses the concept of type models as a means to unify different type systems, which suggests a focus on conceptual analysis at a level that involves understanding and categorizing type systems across languages.
 - The mention of a ""taxonomy of type models"" indicates a structured approach to classification, which implies a certain depth of conceptual analysis.
 - The abstract does not specify the sources of conceptual definitions, such as whether they are derived from literature review, empirical analysis, or theoretical derivation.
 - The abstract does not provide specific conceptual dimensions or criteria used for classification, but the mention of ""examples of type models associated with various programming languages"" suggests that the classification may involve mapping type models to specific languages and paradigms.","- ""We also present a taxonomy of type models, and examples of type models associated with various programming languages which implement different paradigma.""
  - ""This paper presents the concept of type models with the goal of providing a common platform on which apparently different type systems can coexist in harmony.""
  - ""It is therefore important to deal with the issues introduced by the fact that the languages in question have, in general, type systems of different nature.""
  - ""The term language interoperability refers to the ability of one language to use software resources (perhaps previously) written in another language.""",,"- The abstract discusses the importance of dealing with issues related to different type systems in languages, which implies a limitation in existing approaches to language interoperability.
 - The mention of ""type systems of different nature"" suggests a limitation in current classification methods, as they may not adequately address these differences.
 - The introduction of ""type models"" as a common platform indicates a proposed improvement or alternative approach to existing classification methods.
 - The abstract does not explicitly state specific limitations or critiques of current taxonomies but implies a need for a new approach to handle different type systems.","- ""We also present a taxonomy of type models, and examples of type models associated with various programming languages which implement different paradigma.""
  - ""This paper presents the concept of type models with the goal of providing a common platform on which apparently different type systems can coexist in harmony.""",,"- The abstract mentions the presentation of a taxonomy of type models and examples associated with various programming languages, which suggests some form of validation or demonstration of the taxonomy's applicability.
 - However, the abstract does not explicitly mention any validation method, such as mapping to existing languages or empirical testing.
 - There is no mention of specific languages or examples used in validation, nor are there criteria mentioned to demonstrate validity.
 - The abstract focuses on the presentation of the concept and taxonomy but does not provide details on how these were validated.","- ""This paper presents the concept of type models with the goal of providing a common platform on which apparently different type systems can coexist in harmony.""
  - ""The term language interoperability refers to the ability of one language to use software resources (perhaps previously) written in another language.""
  - ""We also present a taxonomy of type models, and examples of type models associated with various programming languages which implement different paradigma.""
  - ""This problem arises in applications such as distributed object interoperability, multi language/multi-paradigm programming and the re-engineering of legacy code for ulterior reuse.""",,"- The abstract discusses the concept of language interoperability, which is crucial for applications like distributed object interoperability and multi-language programming. This suggests that the intended user groups are likely practitioners and researchers working in these areas.
 - The mention of ""distributed object interoperability, multi language/multi-paradigm programming and the re-engineering of legacy code for ulterior reuse"" indicates specific use cases where the type models could be applied.
 - The presentation of a taxonomy of type models and examples associated with various programming languages implies a potential impact on language design and comparative studies, as it provides a framework for understanding and comparing different type systems.
 - The goal of providing a ""common platform on which apparently different type systems can coexist in harmony"" suggests a practical application in facilitating interoperability among different programming languages."
Productivity of High-Level Languages on Reconfigurable Computers: An HPC Perspective,"E. El-Araby, Preetham Nosum, T. El-Ghazawi",10.1109/FPT.2007.4439260,https://doi.org/10.1109/FPT.2007.4439260,International Conference on Field-Programmable Technology,19,2007,"Classification framework for high-level languages covering imperative, functional, and graphical programming paradigms","Derived from a general HPC perspective, using a classification system that assesses performance and ease-of-use trade-offs among different programming paradigms (imperative, functional, graphical).","- Lack of standards in classification methods
 - Uncertainty generated by sales literature
 - Difficulty in understanding performance and ease-of-use trade-offs
 - Complexity due to plethora of development environment options",No formal validation described,Framework to help programmers choose appropriate language concepts for problem-solving; Tool for facilitating high-level comparative studies of programming languages; Potential impact on language design by assessing trade-offs between performance and ease-of-use.,"- ""In this work, we consider a number of representative high-level tools that were selected to represent imperative programming, functional programming and graphical programming, and thereby demonstrate the applicability of our methodology.""
  - ""In order to do so, one needs a classification of HLLs programming models from a general high-performance computing (HPC) perspective.""
  - ""It will be shown that in spite of the disparity in concepts behind those tools, our methodology will be able to uncover the basic differences among them and assess their comparative productivity in terms of performance, and ease-of-use.""",,"- The abstract mentions the need for a ""classification of HLLs programming models from a general high-performance computing (HPC) perspective,"" indicating that a classification system or taxonomy is developed.
 - The focus of this classification is on ""programming models"" and specifically covers ""imperative programming, functional programming and graphical programming,"" which are different programming paradigms.
 - The scope of the classification includes these three programming paradigms, as they are explicitly mentioned as being part of the study.
 - The abstract does not specify the exact type of formalism (e.g., feature model, taxonomy, classification framework), but it clearly states that a classification is developed to assess productivity in terms of performance and ease-of-use.","- ""Productivity on high-performance reconfigurable computers (HPRCs) is becoming a concern given the complexity of today's applications and development flows.""
  - ""High-level languages (HLLs) for developing reconfigurable computing applications trade performance with ease-of-use.""
  - ""it is hard to know in a general sense how much performance one is giving up and how much ease-of-use he/she is gaining.""
  - ""given the lack of standards and the uncertainty generated by sales literature, it is very hard to know the real differences that exist among different high-level programming paradigms.""
  - ""In order to do so, one needs a classification of HLLs programming models from a general high-performance computing (HPC) perspective.""
  - ""we consider a number of representative high-level tools that were selected to represent imperative programming, functional programming and graphical programming, and thereby demonstrate the applicability of our methodology.""
  - ""our methodology will be able to uncover the basic differences among them and assess their comparative productivity in terms of performance, and ease-of-use.""",,"- The abstract discusses the complexity and lack of standards in high-level languages for reconfigurable computing, indicating a need for a detailed conceptual analysis to understand these differences.
 - The mention of ""a classification of HLLs programming models from a general high-performance computing (HPC) perspective"" suggests a deep conceptual analysis, as it involves categorizing different programming paradigms.
 - The abstract does not specify the sources of conceptual definitions, but the context implies a literature-based approach, as it discusses the lack of standards and the need for a general perspective.
 - The specific conceptual dimensions used for classification are performance and ease-of-use, as indicated by the trade-off between these two factors.
 - The abstract does not provide explicit details on the methodology or results sections, but it implies a detailed analysis by mentioning the selection of representative tools and the assessment of comparative productivity.","- ""More importantly, given the lack of standards and the uncertainty generated by sales literature, it is very hard to know the real differences that exist among different high-level programming paradigms.""
  - ""In order to do so, one needs a classification of HLLs programming models from a general high-performance computing (HPC) perspective.""
  - ""However, it is hard to know in a general sense how much performance one is giving up and how much ease-of-use he/she is gaining.""
  - ""Furthermore, the plethora of options from which application developers need to select their development environments has recently become another productivity obstacle.""",,"- The abstract mentions that the ""plethora of options"" for development environments is a productivity obstacle, which implies a limitation in existing classification approaches due to the complexity and variety of options.
 - It highlights the difficulty in understanding the trade-offs between performance and ease-of-use, suggesting a limitation in current methods for evaluating these aspects.
 - The ""lack of standards"" and ""uncertainty generated by sales literature"" are explicitly mentioned as limitations, indicating that current classification methods are not standardized and are influenced by biased sales information.
 - The need for a classification from an HPC perspective suggests that existing methods may not adequately address high-performance computing needs.","- ""It will be shown that in spite of the disparity in concepts behind those tools, our methodology will be able to uncover the basic differences among them and assess their comparative productivity in terms of performance, and ease-of-use.""
  - ""In this work, we consider a number of representative high-level tools that were selected to represent imperative programming, functional programming and graphical programming, and thereby demonstrate the applicability of our methodology.""",,"- The abstract mentions that the methodology is demonstrated through the use of ""representative high-level tools"" that represent different programming paradigms (imperative, functional, graphical). This suggests that the validation approach involves using these tools to show the applicability of the methodology.
 - The abstract does not explicitly mention any specific languages or examples used in the validation process, nor does it detail the criteria used to demonstrate validity.
 - The focus is on demonstrating the methodology's ability to uncover differences and assess productivity, but there is no explicit mention of a formal validation process or criteria.","- ""High-level languages (HLLs) for developing reconfigurable computing applications trade performance with ease-of-use.""
  - ""it is very hard to know the real differences that exist among different high-level programming paradigms.""
  - ""It will be shown that in spite of the disparity in concepts behind those tools, our methodology will be able to uncover the basic differences among them and assess their comparative productivity in terms of performance, and ease-of-use.""
  - ""In order to do so, one needs a classification of HLLs programming models from a general high-performance computing (HPC) perspective.""
  - ""Productivity on high-performance reconfigurable computers (HPRCs) is becoming a concern given the complexity of today's applications and development flows.""",,"- The abstract discusses the concern of productivity on high-performance reconfigurable computers, which implies a practical implication for developers and researchers working with these systems.
 - The mention of high-level languages trading performance with ease-of-use suggests a research implication in understanding these trade-offs.
 - The need for a classification of HLLs programming models from an HPC perspective indicates a potential framework for comparative studies.
 - The methodology aims to uncover differences and assess productivity, which could be useful for both practitioners (in choosing appropriate languages) and researchers (in designing new languages or improving existing ones).
 - The abstract does not explicitly mention specific user groups or use cases, but the context suggests applications in high-performance computing and reconfigurable computing."
Multi-paradigm Declarative Languages,M. Hanus,10.1007/978-3-540-74610-2_5,https://doi.org/10.1007/978-3-540-74610-2_5,International Conference on Logic Programming,106,2007,"Taxonomy of declarative programming paradigms: functional, logic, and constraint languages, with a focus on their integration into multi-paradigm languages.","Derived from a literature review, using a broad survey approach with a focus on functional programming as a starting point for extending with logic programming features.",No limitations explicitly discussed (the paper implies complexities in integrating paradigms but does not explicitly critique existing classification methods),No formal validation described,"- Intended user groups: Researchers, educators, practitioners
 - Specific use cases or potential applications: High-level programming of GUIs, web applications, distributed programming, embedded systems, object-oriented programming, declarative APIs to databases
 - Potential impact on language design or comparative studies: Promoting more efficient evaluation strategies through needed narrowing; combining flexibility of logic programming with efficiency of functional programming","- ""The different declarative programming paradigms offer a variety of programming concepts to the programmer.""
  - ""Since all these features have been shown to be useful in application programming and declarative languages are based on common grounds, it is a natural idea to combine these worlds of programming into a single multi-paradigm declarative language.""
  - ""This paper surveys approaches to combine these different classes into a single programming language.""
  - ""In the following, we survey some of these proposals.""",,"- The paper discusses the combination of different declarative programming paradigms into a single language, indicating a focus on integrating various programming paradigms.
 - The paper distinguishes between functional, logic, and constraint languages, suggesting a classification based on these paradigms.
 - The primary focus of the classification is on programming paradigms, specifically how they can be combined into a multi-paradigm language.
 - The scope of the classification includes at least three main categories: functional, logic, and constraint languages, with a focus on their integration.","- ""This paper surveys approaches to combine these different classes into a single programming language.""
  - ""In the following, we survey some of these proposals.""
  - ""In the following, we use functional programming as our starting point, i.e., we develop functional logic languages by extending functional languages with features for logic programming.""
  - ""The rest of this paper is structured as follows. The next main section introduces and reviews the foundations of functional logic programming that are relevant in current languages.""
  - ""Section 3 discusses practical aspects of multi-paradigm languages.""
  - ""Section 4 contains references to applications of such languages.""
  - ""Finally, Section 5 contains our conclusions.""
  - ""Since this paper is a survey of limited size, not all of the numerous papers in this area can be mentioned and relevant topics are only sketched.""",,"- The paper is described as a survey, which indicates that it is based on a literature review rather than empirical analysis or theoretical derivation.
 - The paper's structure suggests a broad overview of existing approaches rather than a deep, detailed analysis of specific conceptual dimensions.
 - The focus on surveying proposals and discussing practical aspects implies a shallow depth of conceptual analysis, as it does not delve into detailed theoretical derivations or empirical studies.
 - The paper uses functional programming as a starting point and extends it with logic programming features, indicating a conceptual mapping based on existing literature rather than new empirical or theoretical insights.
 - The paper does not specify particular conceptual dimensions or criteria for classification beyond the general approach of combining functional and logic programming paradigms.","- ""The different declarative programming paradigms offer a variety of programming concepts to the programmer. For instance, functional programming emphasizes generic programming using higher-order functions and polymorphic typing, and efficient and (under particular conditions) optimal evaluation strategies using demand-driven evaluation, which contributes to modularity in programming [59].""
  - ""Logic programming supports the computation with partial information (logic variables) and nondeterministic search for solutions, where constraint programming adds efficient constraint solving capabilities for particular domains.""
  - ""Since all these features have been shown to be useful in application programming and declarative languages are based on common grounds, it is a natural idea to combine these worlds of programming into a single multi-paradigm declarative language.""
  - ""However, the interactions between the different features are complex in detail so that the concrete design of a multi-paradigm declarative language is non-trivial.""
  - ""This is demonstrated by many different proposals and a lot of research work on the semantics, operational principles, and implementation of multi-paradigm declarative languages since more than two decades.""
  - ""The rest of this paper is structured as follows. The next main section introduces and reviews the foundations of functional logic programming that are relevant in current languages.""
  - ""The important question to be answered when designing a functional logic language is: How are conditions solved and are there constructive methods to avoid a blind guessing of values for unknowns?""
  - ""Although narrowing extends soundness and completeness results of logic programming to the general framework of functional logic programming, it is not the only method that has been proposed to integrate functions into logic programs.""
  - ""Narrowing and residuation are quite different approaches to integrate functional and logic programming. Narrowing is sound and complete but requires the nondeterministic evaluation of function calls if some arguments are unknown. Residuation might not compute some result due to the potential suspension of evaluation but avoids guessing on functions.""
  - ""From an operational point of view, there is no clear advantage of one of the strategies.""",,"- The paper discusses the complexity of integrating different declarative programming paradigms into a single language, indicating a limitation in current classification approaches that may not fully capture these complexities.
 - The paper highlights the challenges in designing a multi-paradigm declarative language due to the interactions between different features, suggesting a limitation in existing classification methods that may not adequately address these interactions.
 - The paper critiques the lack of a unified approach to integrating functional and logic programming, with narrowing and residuation being different methods, each with its own limitations.
 - The paper does not explicitly mention limitations in existing classification approaches but implies that current methods may not fully account for the complexities and nuances of multi-paradigm languages.","- ""This paper surveys approaches to combine these different classes into a single programming language.""
  - ""In the following, we survey some of these proposals.""
  - ""In the following, we use functional programming as our starting point, i.e., we develop functional logic languages by extending functional languages with features for logic programming.""
  - ""As a concrete example, we consider the language Curry that is based on these principles and intended to provide a common platform for research, teaching, and application of integrated functional logic languages.""
  - ""The operational semantics is based on weakly needed narrowing with sharing and residuation.""
  - ""The use of higher-order operations, i.e., operations that take other operations as arguments or yields them as results, is an important programming technique in functional languages so that it should be also covered by multi-paradigm declarative languages.""
  - ""We conclude with a summary of the advantages of combining different declarative paradigms in a single language.""",,"- The paper primarily focuses on surveying approaches to combine different declarative programming paradigms into a single language, rather than validating a specific classification system.
 - The paper discusses the development of functional logic languages by extending functional languages with logic programming features, but it does not mention any validation method for a classification system.
 - The paper uses Curry as a concrete example of a multi-paradigm declarative language, but this is more about illustrating the integration of paradigms rather than validating a classification system.
 - The operational semantics and higher-order operations are discussed in terms of their implementation and use in multi-paradigm languages, but again, there is no mention of validating a classification system.
 - The conclusion summarizes the advantages of combining paradigms but does not address validation of a classification system.","- ""As a concrete example, we consider the language Curry that is based on these principles and intended to provide a common platform for research, teaching, and application of integrated functional logic languages.""
  - ""The combination of functional and logic language features are exploited in [43] for the high-level programming of GUIs.""
  - ""Similar ideas are applied in [44] to provide a high-level programming interface for web applications (dynamic web pages).""
  - ""Furthermore, there are proposals to use multi-paradigm languages for high-level distributed programming [42,85], programming of embedded systems [50,51], object-oriented programming [53,82], or declarative APIs to databases [32,47].""
  - ""We conclude with a summary of the advantages of combining different declarative paradigms in a single language.""
  - ""Although functions can be considered as predicates (thus, logic programming is sometimes considered as more general than functional programming), functional notation should not be used only as syntactic sugar: we have seen that the properties of functions (i.e., functional dependencies between input and output arguments) can be exploited to construct more efficient evaluation strategies without loosing generality.""
  - ""For instance, needed narrowing ensures soundness and completeness in the sense of logic programming and it is also optimal, whereas similar results are not available for pure logic programs.""
  - ""As a consequence, functional logic languages combine the flexibility of logic programming with the efficiency of functional programming.""",,"- The paper discusses the use of the language Curry as a platform for research, teaching, and application, indicating its intended use by researchers, educators, and practitioners.
 - The paper highlights specific use cases such as high-level programming of GUIs and web applications, suggesting practical applications in these areas.
 - It also mentions proposals for using multi-paradigm languages in distributed programming, embedded systems, object-oriented programming, and declarative APIs to databases, indicating potential applications in these fields.
 - The paper emphasizes the advantages of combining different declarative paradigms, suggesting an impact on language design by promoting more efficient evaluation strategies.
 - The discussion on needed narrowing and its optimality suggests a potential impact on comparative studies by providing a sound and complete method that is not available in pure logic programs."
"Confluence: The Unifying, Expressive Power of Locality","Jiaxiang Liu, J. Jouannaud",10.1007/978-3-642-54624-2_17,https://doi.org/10.1007/978-3-642-54624-2_17,"Specification, Algebra, and Software",6,2014,"Taxonomy of programming paradigms including imperative, functional, logic, object-oriented, concurrent, and distributed programming, with subcategories within functional and logic programming","Derived from theoretical derivation, using formalization and induction, with a focus on programming paradigms and their specializations.",No limitations explicitly discussed,"No formal validation described (the paper focuses on theoretical formalization and proof, but does not explicitly describe a validation method for the classification system)",Framework for facilitating high-level comparative studies of programming languages; Tool for researchers in programming language design and theory; Potential impact on language design through the Parallel Closure Theorem,"- ""The field of programming languages is in a phase of specialization. Among the main programming paradigms are imperative programming, functional programming, logic programming, object oriented programming, concurrent programming and distributed programming.""
  - ""Each of these fields is further specialized. For example, there are many different paradigms for functional programming: LISP, Mac Carthy’s original functional programming paradigm based on pure lambda-calculus for lists enriched with recursion; ML, Milner’s paradigm based on a typed lambda-calculus enriched with data types, a let construct and recursion which has become a standard; O’Donnel’s paradigm based on orthogonal rewriting; and OBJ, Goguen’s paradigm based on terminating rewriting in first-order algebra to cite a few.""
  - ""Similarly, logic programming has given rise to constraint logic programming, as well as query languages for data bases.""
  - ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""van Oostrom (June 16, 2020, private communication) liu's proof may look quite different to your proof, but it seems based on a similar main idea""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper discusses various programming paradigms such as imperative, functional, logic, object-oriented, concurrent, and distributed programming, indicating a broad categorization of programming languages.
 - It further specializes these paradigms, for example, within functional programming, it mentions LISP, ML, O’Donnel’s paradigm, and OBJ, suggesting a taxonomy of programming paradigms.
 - The mention of logic programming giving rise to constraint logic programming and query languages for databases suggests a classification framework that includes subcategories within paradigms.
 - The tables referenced at the end of the paper likely contain data related to these paradigms or their characteristics, but without specific content, it's difficult to determine their exact role in the formalism.
 - The paper does not explicitly mention a specific type of formalism like a feature model or classification framework, but it implies a taxonomy through its discussion of various programming paradigms and their subcategories.","- ""The field of programming languages is in a phase of specialization.""
  - ""Among the main programming paradigms are imperative programming, functional programming, logic programming, object oriented programming, concurrent programming and distributed programming.""
  - ""Each of these fields is further specialized.""
  - ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""Consequently, when starting the present formalization, we also adopted this definition.""
  - ""van Oostrom (June 16, 2020, private communication) liu's proof may look quite different to your proof, but it seems based on a similar main idea""","- ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""","- The paper discusses the specialization phase in the field of programming languages, indicating a broad conceptual framework that categorizes programming paradigms.
 - The mention of various programming paradigms (imperative, functional, logic, object-oriented, concurrent, distributed) suggests a classification system based on these categories.
 - The reference to the Parallel Closure Theorem and its reliance on induction indicates a theoretical derivation of conceptual definitions.
 - The tables included in the paper (pages 44 and 45) likely provide specific data or examples related to these paradigms, although their content is not directly quoted here.
 - The paper's focus on formalization and theoretical derivation suggests a deep conceptual analysis rather than a shallow one.
 - The mention of van Oostrom's private communication implies that the conceptual approach may involve comparisons or discussions with other researchers, potentially indicating a literature-based or empirical analysis component.","- ""The field of programming languages is in a phase of specialization.""
  - ""Among the main programming paradigms are imperative programming, functional programming, logic programming, object oriented programming, concurrent programming and distributed programming.""
  - ""Each of these fields is further specialized.""
  - ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""Consequently, when starting the present formalization, we also adopted this definition. However, the book keeping required by working with sets of positions as well as formally reasoning about this measure in Isabelle became so convoluted that it very much obscured the ingenuity and elegance of Huet's original idea while at the same time defeating our formalization efforts.""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper discusses the specialization phase in the field of programming languages, indicating a focus on the diversity and complexity of programming paradigms.
 - The mention of various programming paradigms suggests a critique of existing classification methods, as it highlights the complexity and specialization within each paradigm.
 - The discussion of the Parallel Closure Theorem and its formalization issues implies a limitation in current methods, as it notes the complexity and obscurity introduced by certain formalization approaches.
 - The tables referenced at the end of the paper are likely related to specific data or results, but without explicit content, they do not provide direct evidence of limitations in classification approaches.
 - The paper does not explicitly discuss limitations in existing classification methods or propose improvements, focusing instead on the complexity and specialization of programming paradigms.","- ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""Consequently, when starting the present formalization, we also adopted this definition. However, the book keeping required by working with sets of positions as well as formally reasoning about this measure in Isabelle became so convoluted that it very much obscured the ingenuity and elegance of Huet's original idea while at the same time defeating our formalization efforts.""
  - ""van Oostrom (June 16, 2020, private communication) liu's proof may look quite different to your proof, but it seems based on a similar main idea""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper discusses the Parallel Closure Theorem and its formalization, which suggests a focus on theoretical validation rather than empirical testing.
 - The mention of ""ingenious induction"" and ""formally reasoning about this measure in Isabelle"" indicates a formal validation approach, likely involving proof assistants like Isabelle.
 - The tables referenced at the end of the paper may contain data or results related to the validation, but without specific content, it's unclear how they contribute to the validation method.
 - The private communication from van Oostrom suggests a comparison of proofs, which might imply a theoretical validation through comparison with existing work.
 - There is no explicit mention of empirical testing or mapping to existing languages, which are common methods for validation in classification systems.","- ""The field of programming languages is in a phase of specialization.""
  - ""Among the main programming paradigms are imperative programming, functional programming, logic programming, object oriented programming, concurrent programming and distributed programming.""
  - ""The Parallel Closure Theorem relies on an ingenious induction to reduce multiple overlaps to critical pairs""
  - ""Consequently, when starting the present formalization, we also adopted this definition.""
  - ""van Oostrom (June 16, 2020, private communication) liu's proof may look quite different to your proof, but it seems based on a similar main idea""","- ""(Page 34, Table 1) ""
  - ""(Page 44, Table 1) |  | H80 | T88 | G96 |
 \n|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 |""
  - ""(Page 45, Table 1) |  | H80 | T88 | G96 | T81 |
 \n|-----|-----|-----|-----|-----|
 \n| YES | 36 | 49 | 56 | 78 |""
  - ""(Page 60, Table 1) ""","- The paper discusses the specialization phase in the field of programming languages, indicating a focus on understanding and categorizing different programming paradigms.
 - The mention of various programming paradigms suggests that the paper may be relevant for researchers and educators interested in comparative studies of these paradigms.
 - The Parallel Closure Theorem and its formalization imply a theoretical contribution that could be useful for researchers in programming language design and theory.
 - The tables included at the end of the paper likely contain data or results related to the theorem or its applications, but without specific content, it's difficult to determine their exact implications.
 - The private communication from van Oostrom suggests that the work may have implications for theoretical proofs and ideas in programming language theory."
Classless Object Semantics,T. Jones,10.26686/wgtn.17064350.v1,https://doi.org/10.26686/wgtn.17064350.v1,-,5,2017,"Taxonomy of object-oriented language formalisms focusing on classless object semantics and object inheritance models (forwarding, delegation, concatenation, merged identity, uniform identity, multiple uniform inheritance) using PLT Redex for semantic modeling.","Detailed feature-level analysis with concrete mappings of well-known languages, derived from theoretical derivation and empirical analysis using PLT Redex for mechanical verification.","- Difficulty in encoding behaviors from class-based languages in classless languages.
 - Challenges in fully formalizing widely used languages due to complexity and need for continuous extension and proof.
 - Limitations in using core calculi to abstract away complexities.
 - Critique of soundness in formal models like Featherweight Java.
 - Gaps in design space for object inheritance models, particularly in combining features.
 - Challenges in typing object inheritance due to need for exact type information and structural subtyping complexities.","Validated through mechanical verification using PLT Redex and comparison with existing languages like Java, focusing on simulating class behavior and inheritance interactions.","- Tool for facilitating high-level comparative studies of programming languages
 - Framework to help language designers explore alternative inheritance mechanisms
 - Research direction for extending type systems with gradual typing
 - Practical application for researchers and educators in understanding language semantics through PLT Redex implementation","- ""A formal model for a programming language has a number of benefits. A language formalism subsumes the task of defining a language specification while also providing formal constructs to reason about the design of the language.""
  - ""The formalisation of Cook and Palsberg (1989) for object inheritance with denotational semantics subsequently revealed a number of flaws in the type conformance algorithm of Eiffel (Cook 1989).""
  - ""Few widely used languages are completely formally specified because of the difficulty in encoding the detailed nuances of large programming languages, which in many cases are specified mostly by their implementation (Owens 2008).""
  - ""Within the object-oriented paradigm, perhaps the most influential formalism derived from an actual programming language has been Featherweight Java (FJ), a formalised subset of the Java programming language (Igarashi, Pierce, and Wadler 2001).""
  - ""The result is a significantly simpler (though less practical) object-oriented language that submits to formalisation more easily, and is more readily extended.""
  - ""The PLT group have also developed the Racket language Redex for the semantic modelling of software (Felleisen, Findler, and Flatt 2009).""
  - ""We have also implemented most of our formal models using PLT Redex (Felleisen, Findler, and Flatt 2009).""
  - ""The key insight of this investigation is that there are gaps in the design space presented by Table 11 .1: no model permits inheriting from preëxisting objects while also permitting down-calls during initialisation, for instance.""","- ""(Page 268, Table 1) | | Reg. | Down. | Dist. | Stable | Exist. | Mult. | Mult. | Overl. | Par. |
 \n|----------------------|------|-------|-------|--------|--------|-------|-------|--------|------|
 \n| Forwarding  | no  | no | yes  | yes | yes | no | no | yes | no  |""","- The paper discusses the development of formal models for programming languages, particularly focusing on object-oriented languages and the concept of classless object semantics.
 - The primary focus of the classification is on the formalism of object-oriented languages, specifically how objects can be used to emulate the functionality of classes.
 - The scope of the classification includes various models of object inheritance, such as forwarding, delegation, concatenation, merged identity, uniform identity, and multiple uniform inheritance.
 - The paper uses PLT Redex for semantic modeling, indicating a focus on formalizing language semantics.
 - The table on page 268 provides a comparison of different models of object-first inheritance, suggesting a taxonomy or classification framework for these models.","- ""This dissertation investigates the foundational nature of the class in the object-oriented paradigm from the perspective of an ‘objects-first’, classless language.""
  - ""We present Graceless, our theory of objects without classes, and use this language to explore what class functionality is difficult to encode using only objects.""
  - ""We consider the role of classes in the types and static analysis of object-oriented languages, and present both a practical design of brand objects and a corresponding extension of our theory that simulates the discipline of nominal typing.""
  - ""We also modify our theory to investigate the semantics of many different kinds of implementation reuse in the form of inheritance between both objects and classes, and compare the consequences of these different approaches.""
  - ""The result of our investigations is a family of formal languages that can help us to better understand the role that classes have to play in object-oriented programs, systems, languages, and applications.""
  - ""We have also implemented most of our formal models using PLT Redex (Felleisen, Findler, and Flatt 2009). Encoding the models into a mechanical form helps to clarify any assumptions made in the text, permits counterexample checking, and makes it easy and automatic to examine the exact semantics of each language.""
  - ""The key insight of this investigation is that there are gaps in the design space presented by Table 11 .1: no model permits inheriting from preëxisting objects while also permitting down-calls during initialisation, for instance.""
  - ""We have presented several models of object inheritance, including the wellknown approaches of delegation, forwarding, and concatenation.""
  - ""We have illustrated that object-based inheritance has the full range of possibilities of classical inheritance, and showed that many of these models can be used as effectively as purely declarative classes, but particular combinations -especially class initialisation semantics combined with inheritance from preëxisting objects -require a specific set of features usually reserved for very dynamic and reflective languages.""","- ""(Page 268, Table 1) | | Reg. | Down. | Dist. | Stable | Exist. | Mult. | Mult. | Overl. | Par. |
 \n|----------------------|------|-------|-------|--------|--------|-------|-------|--------|------|
 \n| Forwarding  | no  | no | yes  | yes | yes | no | no | yes | no  |""","- The paper provides a deep conceptual analysis by exploring the foundational nature of classes in object-oriented programming from an ""objects-first"" perspective. This indicates a detailed examination of how objects can replace or complement classes.
 - The sources of conceptual definitions include theoretical derivation, as evidenced by the development of Graceless and its extensions to simulate nominal typing and explore inheritance semantics.
 - The paper uses specific conceptual dimensions such as the role of classes in types and static analysis, the design of brand objects, and the semantics of implementation reuse through inheritance. These dimensions are used to classify and compare different models of object inheritance.
 - The use of PLT Redex for implementing formal models suggests a rigorous analytical methodology that allows for mechanical verification and counterexample checking, indicating a deep level of analysis.
 - The comparison of various inheritance models (delegation, forwarding, concatenation) and their implications for object-oriented programming suggests a detailed feature-level analysis.
 - The table at the end of the paper likely provides a structured comparison of these models based on specific criteria, further indicating a detailed classification system.","- ""Much of the formal theory of objects that eschews classes as a fundamental construct has difficulty encoding the variety of behaviours possible in programs from class-based languages.""
  - ""Few widely used languages are completely formally specified because of the difficulty in encoding the detailed nuances of large programming languages, which in many cases are specified mostly by their implementation""
  - ""Maintaining a language in strict adherence to a formalism will often stymie extensions to the language, as it requires first extending and proving the correctness of the model""
  - ""The approach of using a core calculus that abstracts away complications means that any properties proven for the calculus do not necessarily translate into properties on the larger language.""
  - ""The unsoundness of Java is the outcome of an interaction between wildcards and null pointers: modelling null pointers is not a particularly difficult challenge, but it was still elided from FJ and from other calculi used to reason about wildcards such as Tame FJ""
  - ""The key insight of this investigation is that there are gaps in the design space presented by Table 11 .1: no model permits inheriting from preëxisting objects while also permitting down-calls during initialisation, for instance.""
  - ""The primary difficulty is that we must know the exact type of an object in order to safely inherit from it, both in terms of width and depth: to add new methods, the type system must know that there is not a corresponding method in the super-object that is being overridden; to override existing methods, the type system must know exactly the type annotations on the parameters and return of the overridden method to ensure that the override does not generalise the signature type.""
  - ""The primary challenge here is collecting exact information about the type of the inherited object, since both width and depth subtyping of the structural types of Graceless are at odds with the needs of typing inheritance.""",,"- The paper discusses limitations in formalizing object-oriented languages without classes, highlighting difficulties in encoding behaviors from class-based languages (Quote 1).
 - It notes that fully formalizing widely used languages is challenging due to their complexity and the need for continuous extension and proof of correctness (Quotes 2 and 3).
 - The use of core calculi to abstract away complexities can lead to limitations in translating properties from the calculus to the larger language (Quote 4).
 - The paper critiques the soundness of formal models like Featherweight Java, which may not capture all aspects of the language, such as null pointers (Quote 5).
 - It identifies gaps in the design space for object inheritance models, particularly in combining features like inheriting from pre-existing objects and down-calls during initialization (Quote 6).
 - The paper highlights challenges in typing object inheritance due to the need for exact type information and the complexities of structural subtyping (Quotes 7 and 8).","- ""We have also implemented most of our formal models using PLT Redex (Felleisen, Findler, and Flatt 2009). Encoding the models into a mechanical form helps to clarify any assumptions made in the text, permits counterexample checking, and makes it easy and automatic to examine the exact semantics of each language.""
  - ""The implementation of the inheritance semantics in Redex has allowed us to run automatic tests of particular properties and immediately visualise the reduction of any program, as well as demonstrate the many combinations of our semantics with multiple inheritance without having to put every different combination to paper.""
  - ""The result of our investigations is a family of formal languages that can help us to better understand the role that classes have to play in object-oriented programs, systems, languages, and applications.""
  - ""We have extended Graceless to model a number of different semantic models of object inheritance, in order to better understand the differences between the models.""
  - ""Our comparison of these models illustrate our conclusion that the interaction of inheritance with object initialisation and self references means that standard object inheritance mechanisms such as delegation are not sufficient to simulate the behaviour of classes from popular languages such as Java.""
  - ""We have augmented our investigation by considering a number of different designs for supporting multiple inheritance as extensions to all of the models that are capable of it.""",,"- The paper describes the use of PLT Redex to implement and test the formal models, which suggests a form of validation through mechanical verification.
 - The implementation in Redex allows for automatic testing and visualization of the language semantics, which is a method of validation.
 - The paper discusses the extension of Graceless to model different semantic models of object inheritance, which implies a validation approach by comparing these models.
 - The comparison of these models with popular languages like Java suggests a validation approach by mapping to existing languages.
 - The criteria used to demonstrate validity include the ability to simulate class behavior and the interaction of inheritance with object initialization and self-references.","- ""The result of our investigations is a family of formal languages that can help us to better understand the role that classes have to play in object-oriented programs, systems, languages, and applications.""
  - ""We have also implemented most of our formal models using PLT Redex (Felleisen, Findler, and Flatt 2009). Encoding the models into a mechanical form helps to clarify any assumptions made in the text, permits counterexample checking, and makes it easy and automatic to examine the exact semantics of each language.""
  - ""The implementation of the inheritance semantics in Redex has allowed us to run automatic tests of particular properties and immediately visualise the reduction of any program, as well as demonstrate the many combinations of our semantics with multiple inheritance without having to put every different combination to paper.""
  - ""Extending the type system of Graceless to embrace the discipline of gradual typing is an obvious first step to more fully encoding the realities of the full Grace language.""
  - ""The outstanding question for a language like Branded Graceless extended with type members is how this affects the run-time match construct -which cannot match directly on a type, only perform a shallow structural test -so it is likely the case that a class would need to include a third component to act as a pattern for the purposes of determining if an object was constructed by a particular class at runtime.""
  - ""The primary challenge here is collecting exact information about the type of the inherited object, since both width and depth subtyping of the structural types of Graceless are at odds with the needs of typing inheritance.""
  - ""Object-based inheritance is unexpectedly complicated, especially when commonplace desires for functionality available in classical models are involved, and programmers have resorted to increasingly complex workarounds in existing objectbased languages.""
  - ""We have demonstrated that object inheritance without classes is both viable and desirable, avoiding the conceptual complexity of an additional conceptual entity (the class) in an object-oriented language without losing functionality through careful feature selection, and set out a range of options with their various trade-offs made explicit.""
  - ""We have presented several models of object inheritance, including the wellknown approaches of delegation, forwarding, and concatenation.""
  - ""Our comparison of these models illustrate our conclusion that the interaction of inheritance with object initialisation and self references means that standard object inheritance mechanisms such as delegation are not sufficient to simulate the behaviour of classes from popular languages such as Java.""
  - ""The key insight of this investigation is that there are gaps in the design space presented by Table 11 .1: no model permits inheriting from preëxisting objects while also permitting down-calls during initialisation, for instance.""
  - ""The primary difficulty is that we must know the exact type of an object in order to safely inherit from it, both in terms of width and depth: to add new methods, the type system must know that there is not a corresponding method in the super-object that is being overridden; to override existing methods, the type system must know exactly the type annotations on the parameters and return of the overridden method to ensure that the override does not generalise the signature type.""
  - ""Extending the static semantics of Graceless to type the inheritance systems that we have defined produces some interesting challenges.""
  - ""we have not presented accompanying type systems for any of the object inheritance systems that we modelled.""
  - ""There has been some work in typing first-class classes with row typing and the ability to express in a type what methods do not appear in any inhabiting object (Takikawa et al. 2012), but Grace opts for the simpler mechanism that the relevant object constructor must be statically resolved.""",,"- The paper discusses the development of a family of formal languages to better understand the role of classes in object-oriented programming, which implies a tool for comparative studies of programming languages.
 - The implementation of formal models using PLT Redex allows for automatic testing and visualization, suggesting a practical application for researchers and educators in understanding language semantics.
 - The paper highlights the potential for extending the type system of Graceless to embrace gradual typing, indicating a research direction for further exploration in type systems.
 - The discussion on object-based inheritance without classes and the presentation of various models (delegation, forwarding, concatenation) suggest a framework for language designers to consider alternative inheritance mechanisms.
 - The paper identifies gaps in the design space, such as the inability to inherit from preëxisting objects while permitting down-calls during initialization, which could guide future research and language design improvements."
Классификация парадигм программирования в контексте теоретического программирования,Ирина Андреевна Кудрявцева,-,-,-,0,2015,"Classification framework of programming paradigms based on mathematical subjects (algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory), focusing on mathematical bases and programming languages, with an emphasis on functional programming","Theoretical derivation based on mathematical subjects (algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory) with a focus on mathematical bases and programming languages, indicating a deep conceptual analysis.",No limitations explicitly discussed,No formal validation described,"Framework to help researchers and educators in comparative studies of programming paradigms and inform language design decisions, with potential impact on shifting towards functional programming paradigm.","- ""based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""
  - ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""The author presents a classification of programming paradigms in the context of theoretical programming,""
  - ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""",,"- The abstract mentions a ""classification of programming paradigms,"" which indicates that the study involves a taxonomy or classification framework.
 - The classification is based on mathematical subjects such as algebra, mathematical logic, and theory of algorithms, suggesting a focus on theoretical foundations.
 - The scope of the classification includes programming paradigms and is based on mathematical bases and programming languages, excluding technologies.
 - The emphasis on a shift towards functional programming suggests that this paradigm is a significant focus within the classification.","- ""The author presents a classification of programming paradigms in the context of theoretical programming, based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""
  - ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""",,"- The abstract mentions that the classification is based on mathematical subjects such as algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, and automata theory. This suggests a deep conceptual analysis rooted in theoretical foundations.
 - The classification is based on the level of mathematical bases and programming languages, indicating a focus on theoretical derivation rather than empirical analysis or literature review.
 - The abstract does not mention any specific conceptual dimensions or criteria used for classification beyond the mathematical subjects and programming languages, which implies a broad theoretical approach rather than detailed feature-level analysis.
 - The emphasis on theoretical programming and the shift towards functional programming suggests a conceptual approach that is theoretically derived and focused on mathematical foundations.","- ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""
  - ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""The author presents a classification of programming paradigms in the context of theoretical programming, based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""",,"- The abstract discusses the author's classification approach based on mathematical subjects, which suggests a focus on theoretical foundations rather than critiquing existing approaches.
 - There is no mention of specific limitations or critiques of current taxonomies or classification methods in the abstract.
 - The abstract does not provide any information on proposed improvements or alternative approaches beyond the author's own classification method.
 - The emphasis on shifting towards a functional programming paradigm is noted, but this does not explicitly address limitations of existing classification approaches.","- ""The author presents a classification of programming paradigms in the context of theoretical programming, based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""
  - ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""
  - ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""",,"- The abstract mentions that the classification is based on mathematical subjects such as algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, and automata theory. This suggests a theoretical foundation for the classification.
 - The classification is structured around the level of mathematical bases and programming languages, which implies a systematic approach to categorizing programming paradigms.
 - However, there is no mention of any specific validation method, such as mapping to existing languages or empirical testing, in the abstract.
 - The abstract does not provide any specific languages or examples used in validation or criteria used to demonstrate validity.
 - The focus on theoretical programming and the shift towards a functional programming paradigm does not imply a validation method.","- ""In accordance with the structure of the selected programming paradigms classification is based on the level of mathematical bases and programming languages, not including technologies of programming.""
  - ""As a result, it is noted that in the context of theoretical programming emphasis is shifting towards a functional programming paradigm.""
  - ""The author presents a classification of programming paradigms in the context of theoretical programming, based on a number of the following math subjects: algebra, mathematical logic, theory of algorithms, theory of formal languages and grammars, automata theory.""",,"- The abstract discusses a classification system for programming paradigms based on mathematical subjects, which suggests a theoretical framework that could be useful for researchers and educators in understanding and comparing different programming paradigms.
 - The focus on mathematical bases and programming languages indicates potential applications in language design and comparative studies, as it provides a structured approach to analyzing programming paradigms.
 - The shift towards a functional programming paradigm suggests that the classification system could be used to inform language design and programming practices, potentially impacting how programmers choose language concepts for problem-solving.
 - The abstract does not explicitly mention specific user groups or use cases, but the context implies that researchers and educators could use this classification system to facilitate comparative studies and inform language design decisions."
What is Generic Programming ?,"G. D. Reis, Jaakko Järvi",-,-,-,4,2005,No specific formalism developed (the abstract focuses on analyzing and relating methodologies rather than creating a new classification system),"Derived from a literature-based review of multiple programming paradigms, focusing on core mathematical notions and theoretical underpinnings of generic programming concepts.",No limitations explicitly discussed,No formal validation described,"Framework to provide a base for common understanding of techniques underpinning generic software components and libraries, facilitating comparative studies and potentially impacting language design.","- ""The last two decades have seen an ever-growing interest in generic programming.""
  - ""As for most programming paradigms, there are several definitions of generic programming in use.""
  - ""In the simplest view generic programming is equated to a set of language mechanisms for implementing type-safe polymorphic containers, such as List<T> in Java.""
  - ""The notion of generic programming that motivated the design of the Standard Template Library (STL) advocates a broader definition: a programming paradigm for designing and developing reusable and efficient collections of algorithms.""
  - ""The functional programming community uses the term as a synonym for polytypic and type-indexed programming, which involves designing functions that operate on data-types having certain algebraic structures.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""",,"- The abstract discusses various definitions and perspectives on generic programming, indicating a focus on understanding and categorizing different approaches to generic programming.
 - It mentions different views from the imperative and functional programming communities, suggesting a comparison or classification of these methodologies.
 - The paper aims to analyze core mathematical notions and provide a base for common understanding, which implies a systematic approach to categorizing or formalizing these concepts.
 - However, the abstract does not explicitly mention the development of a specific formalism or taxonomy. It focuses more on analyzing and relating methodologies rather than creating a new classification system.","- ""The last two decades have seen an ever-growing interest in generic programming.""
  - ""As for most programming paradigms, there are several definitions of generic programming in use.""
  - ""In the simplest view generic programming is equated to a set of language mechanisms for implementing type-safe polymorphic containers, such as List<T> in Java.""
  - ""The notion of generic programming that motivated the design of the Standard Template Library (STL) advocates a broader definition: a programming paradigm for designing and developing reusable and efficient collections of algorithms.""
  - ""The functional programming community uses the term as a synonym for polytypic and type-indexed programming, which involves designing functions that operate on data-types having certain algebraic structures.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""",,"- The abstract indicates a deep conceptual analysis by mentioning multiple definitions and perspectives on generic programming, suggesting a comprehensive review of existing concepts.
 - The sources of conceptual definitions appear to be based on a literature review, as the abstract references various programming paradigms and communities, such as the STL and functional programming.
 - The abstract does not explicitly mention empirical analysis or theoretical derivation as sources, but the focus on ""core mathematical notions"" suggests a theoretical underpinning.
 - Specific conceptual dimensions or criteria used for classification include the distinction between language mechanisms for type-safe polymorphic containers and broader definitions involving reusable algorithms and polytypic programming.
 - The abstract aims to provide a ""base for common understanding,"" indicating an effort to synthesize and clarify existing concepts rather than introduce new empirical findings.","- ""As for most programming paradigms, there are several definitions of generic programming in use.""
  - ""The notion of generic programming that motivated the design of the Standard Template Library (STL) advocates a broader definition: a programming paradigm for designing and developing reusable and efficient collections of algorithms.""
  - ""The functional programming community uses the term as a synonym for polytypic and type-indexed programming, which involves designing functions that operate on data-types having certain algebraic structures.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""",,"- The abstract mentions that there are ""several definitions of generic programming in use,"" which implies a lack of consensus or clarity in how generic programming is defined. This could be seen as a limitation in existing classification approaches, as it suggests a lack of standardization or agreement on what constitutes generic programming.
 - The abstract does not explicitly discuss limitations or critiques of current taxonomies or classification methods. Instead, it focuses on the variety of definitions and approaches to generic programming.
 - The paper aims to analyze core mathematical notions and provide a base for common understanding, which could be interpreted as an attempt to address the lack of clarity or standardization in definitions. However, this is not explicitly framed as a limitation or critique of existing approaches.
 - The abstract does not mention specific limitations, critiques, or proposed improvements to existing classification methods.","- ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""",,"- The abstract discusses the analysis of core mathematical notions and the relation of methodologies in different programming communities, which suggests a theoretical approach rather than empirical validation.
 - There is no mention of any specific validation method, such as mapping to existing languages or empirical testing, in the abstract.
 - The focus is on providing a base for common understanding and relating methodologies, which does not imply a formal validation process.
 - The abstract does not specify any criteria used to demonstrate validity or mention any specific languages or examples used in validation.","- ""As a necessary step, we provide a base for common understanding of techniques underpinning generic software components and libraries, and their construction, not limited to a particular linguistic support.""
  - ""This paper aims at analyzing core mathematical notions at the foundations of rational approaches to generic programming and library design as reasoned and principled activity.""
  - ""The notion of generic programming that motivated the design of the Standard Template Library (STL) advocates a broader definition: a programming paradigm for designing and developing reusable and efficient collections of algorithms.""
  - ""The last two decades have seen an ever-growing interest in generic programming.""
  - ""We relate several methodologies used and studied in the imperative and functional programming communities.""",,"- The abstract discusses the growing interest in generic programming, indicating its relevance to both practitioners and researchers.
 - The mention of the Standard Template Library (STL) suggests a practical application in designing reusable and efficient algorithms, which could be useful for programmers.
 - The analysis of core mathematical notions and methodologies implies a contribution to the theoretical understanding of generic programming, which could be beneficial for educators and researchers.
 - The aim to provide a base for common understanding of techniques suggests a framework that could facilitate comparative studies of programming languages and libraries.
 - The abstract does not explicitly mention specific use cases or potential applications, but the focus on library design and generic software components implies potential impact on language design and comparative studies."
"A feature model of actor, agent, functional, object, and procedural programming languages","Howell R. Jordan, Goetz Botterweck, J. Noll, A. Butterfield, Rem W. Collier",10.1016/j.scico.2014.02.009,https://doi.org/10.1016/j.scico.2014.02.009,Science of Computer Programming,13,2015,"Feature model comparing actor, agent, functional, object-oriented, and procedural programming languages","Derived from programmer's perspective, using literature-based conceptual mapping with detailed feature-level analysis and concrete mappings of well-known languages","- Existing advice based on ill-defined notions of 'paradigms' and 'orientation'
 - Lack of high-level, objective programming language feature assessment criteria
 - Researchers lack a shared common basis for generalisation and synthesis of empirical results","Validated through concrete mappings of well-known languages in actor, agent, functional, object-oriented, and procedural categories","- Intended user groups: Practitioners, Researchers
 - Specific use cases or potential applications: Tool for facilitating high-level comparative studies of programming languages; detailed investigations of feature usage and efficacy in specific development contexts
 - Potential impact on language design or comparative studies: Facilitates comparative studies and evaluations of feature usage","- ""This paper presents a feature model constructed from the programmer's perspective, which can be used to precisely compare general-purpose programming languages in the actor-oriented, agent-oriented, functional, object-oriented, and procedural categories.""
  - ""The feature model is derived from the existing literature on general concepts of programming, and validated with concrete mappings of well-known languages in each of these categories.""
  - ""The model is intended to act as a tool for both practitioners and researchers, to facilitate both further high-level comparative studies of programming languages, and detailed investigations of feature usage and efficacy in specific development contexts.""",,"- The abstract explicitly mentions the development of a ""feature model,"" which is a specific type of formalism.
 - The primary focus of this classification is on comparing programming languages based on their features, as indicated by the term ""feature model.""
 - The scope of the classification includes five categories of programming languages: actor-oriented, agent-oriented, functional, object-oriented, and procedural.
 - The feature model is designed to facilitate comparative studies and investigations of feature usage, indicating its application in assessing language suitability and understanding feature efficacy.","- ""The feature model is derived from the existing literature on general concepts of programming, and validated with concrete mappings of well-known languages in each of these categories.""
  - ""This paper presents a feature model constructed from the programmer's perspective, which can be used to precisely compare general-purpose programming languages in the actor-oriented, agent-oriented, functional, object-oriented, and procedural categories.""
  - ""We argue that these shortages are partly due to a lack of high-level, objective programming language feature assessment criteria: existing advice to practitioners is often based on ill-defined notions of 'paradigms' [3, p. xiii] and 'orientation', while researchers lack a shared common basis for generalisation and synthesis of empirical results.""",,"- The abstract mentions that the feature model is ""constructed from the programmer's perspective,"" indicating that the conceptual analysis is derived from a practical, user-centric viewpoint rather than a purely theoretical or abstract one.
 - The model is ""derived from the existing literature on general concepts of programming,"" suggesting that the sources of conceptual definitions are based on a literature review rather than empirical analysis or theoretical derivation.
 - The abstract does not specify the depth of conceptual analysis, but the mention of ""precisely compare general-purpose programming languages"" implies a detailed level of analysis.
 - The model is validated with ""concrete mappings of well-known languages,"" which suggests a detailed feature-level analysis.
 - The abstract does not explicitly mention specific conceptual dimensions or criteria used for classification, but it implies a focus on programming paradigms and orientations.","- ""researchers lack a shared common basis for generalisation and synthesis of empirical results.""
  - ""little structured information and empirical evidence is available to help software engineers assess the suitability of a language for a particular development project or software architecture.""",,"- The abstract mentions that there is a lack of structured information and empirical evidence, which suggests a limitation in the current state of programming language classification.
 - It explicitly states that existing advice is based on ""ill-defined notions of 'paradigms' and 'orientation',"" indicating a conceptual limitation in how programming languages are currently classified.
 - The abstract also notes that researchers lack a shared common basis for generalization and synthesis, which implies a methodological limitation in terms of consistency and comparability across studies.","- ""The feature model is derived from the existing literature on general concepts of programming, and validated with concrete mappings of well-known languages in each of these categories.""",,"- The abstract mentions that the feature model was ""validated with concrete mappings of well-known languages in each of these categories."" This indicates that the validation approach involved mapping the feature model to existing languages.
 - The categories mentioned include actor-oriented, agent-oriented, functional, object-oriented, and procedural programming languages, suggesting that these were the specific areas where validation was performed.
 - The abstract does not specify the criteria used to demonstrate validity, nor does it mention any empirical testing or case studies. The focus is on the mapping to well-known languages as the validation method.","- ""The model is intended to act as a tool for both practitioners and researchers, to facilitate both further high-level comparative studies of programming languages, and detailed investigations of feature usage and efficacy in specific development contexts.""
  - ""The feature model is derived from the existing literature on general concepts of programming, and validated with concrete mappings of well-known languages in each of these categories.""",,"- The abstract mentions that the feature model is intended for both practitioners and researchers, indicating that these are the intended user groups.
 - The model is described as a tool for facilitating ""high-level comparative studies of programming languages,"" which suggests a specific use case for researchers.
 - It also aims to facilitate ""detailed investigations of feature usage and efficacy in specific development contexts,"" which implies a potential application for practitioners in evaluating language suitability for projects.
 - The abstract does not explicitly mention educators or specific impacts on language design, but the focus on comparative studies and feature usage suggests potential implications for language design and comparative studies."
New Developments of the Computer Language Classification Knowledge Portal,"A. Akinin, A. V. Zubkov, N. Shilov",10.15514/SYRCOSE-2012-6-6,https://doi.org/10.15514/SYRCOSE-2012-6-6,-,0,2012,"Classification framework focusing on programming paradigms (imperative, declarative, object-oriented, etc.) with a model checking engine for paraconsistent description logic; scope not explicitly detailed.","Deep conceptual analysis using theoretical derivation and computational tools, with specific criteria based on joint attributes and paradigms, employing a model checking engine for paraconsistent description logic.",No limitations explicitly discussed,No formal validation described,"- Intended user groups: Practitioners, researchers, educators
 - Specific use cases or potential applications: Tool for facilitating high-level comparative studies of programming languages; framework to help programmers choose appropriate language concepts for problem-solving
 - Potential impact on language design or comparative studies: Advanced research applications in analyzing inconsistencies in language design; facilitating comparative studies of programming languages","- ""In each of these branches of computer languages it is possible to track several approaches (imperative, declarative, object-oriented, etc.), disciplines of processing (sequential, non-deterministic, distributed, etc.), and formalized models, such as Turing machines or logic inference machines.""
  - ""The computer language universe includes languages for different purposes (programming, specification, modeling, etc.).""
  - ""We have presented our computer-aided approach to the problem of computer language classification and paradigm identification in a recent paper Development of the Computer Language Classification Portal (Proc. of Ershov Informatics Conference PSI-2011, Lect. Not. in Comp. Sci., v.7162).""
  - ""Computer language paradigms are the basis for classification of the computer languages.""
  - ""In the present paper we discuss new developments of our project: (1) the pre-alpha version of the Portal is online, and (2) the reasoner is a model checking engine for a paraconsistent (inconsistencytolerant) description logic.""",,"- The abstract mentions that the classification is based on ""computer language paradigms,"" which suggests a focus on programming paradigms.
 - The classification includes various approaches such as ""imperative, declarative, object-oriented, etc.,"" indicating a broad scope covering multiple programming paradigms.
 - The mention of ""disciplines of processing"" and ""formalized models"" suggests that the classification may also cover aspects related to language features and conceptual characteristics.
 - The abstract does not specify the exact number of language categories or features covered, nor does it explicitly state the type of formalism (e.g., feature model, taxonomy).
 - The mention of a ""model checking engine for a paraconsistent (inconsistencytolerant) description logic"" suggests a formalism involving description logic, but it is not clear if this is the primary focus of the classification system.","- ""The computer language universe includes languages for different purposes (programming, specification, modeling, etc.).""
  - ""In each of these branches of computer languages it is possible to track several approaches (imperative, declarative, object-oriented, etc.), disciplines of processing (sequential, non-deterministic, distributed, etc.), and formalized models, such as Turing machines or logic inference machines.""
  - ""Computer language paradigms are the basis for classification of the computer languages.""
  - ""They are based on joint attributes which allow us to differentiate branches in the computer language universe.""
  - ""We have presented our computer-aided approach to the problem of computer language classification and paradigm identification in a recent paper Development of the Computer Language Classification Portal (Proc. of Ershov Informatics Conference PSI-2011, Lect. Not. in Comp. Sci., v.7162).""
  - ""In the present paper we discuss new developments of our project: (1) the pre-alpha version of the Portal is online, and (2) the reasoner is a model checking engine for a paraconsistent (inconsistencytolerant) description logic.""",,"- The abstract mentions that the classification system is based on ""computer language paradigms,"" which suggests a deep conceptual analysis as it involves understanding and categorizing languages based on their fundamental approaches and models.
 - The mention of ""joint attributes"" indicates that the classification system uses specific criteria to differentiate between branches of computer languages, suggesting a detailed feature-level analysis.
 - The abstract references a previous paper where the authors presented their ""computer-aided approach,"" implying that the methodology involves empirical or theoretical derivation from existing literature or computational methods.
 - The use of a ""model checking engine for a paraconsistent description logic"" suggests a sophisticated analytical approach that can handle inconsistencies, indicating a deep level of conceptual analysis.
 - The abstract does not explicitly mention a literature review or empirical analysis as sources of conceptual definitions, but the reference to a previous paper and the use of computational tools imply a theoretical derivation and possibly empirical validation.","- ""In the present paper we discuss new developments of our project: (1) the pre-alpha version of the Portal is online, and (2) the reasoner is a model checking engine for a paraconsistent (inconsistencytolerant) description logic.""
  - ""We have presented our computer-aided approach to the problem of computer language classification and paradigm identification in a recent paper Development of the Computer Language Classification Portal (Proc. of Ershov Informatics Conference PSI-2011, Lect. Not. in Comp. Sci., v.7162).""
  - ""Computer language paradigms are the basis for classification of the computer languages.""
  - ""In each of these branches of computer languages it is possible to track several approaches (imperative, declarative, object-oriented, etc.), disciplines of processing (sequential, non-deterministic, distributed, etc.), and formalized models, such as Turing machines or logic inference machines.""
  - ""The computer language universe includes languages for different purposes (programming, specification, modeling, etc.).""",,"- The abstract discusses the complexity and diversity of the computer language universe, highlighting various purposes, approaches, and models. However, it does not explicitly mention any limitations of existing classification approaches.
 - The abstract focuses on the authors' own approach to classification and the development of their portal, rather than critiquing existing methods.
 - There is no mention of specific limitations, critiques of current taxonomies, or proposed improvements to existing classification methods in the abstract.
 - The abstract is more about presenting new developments in the authors' project rather than discussing limitations of existing approaches.","- ""In the present paper we discuss new developments of our project: (1) the pre-alpha version of the Portal is online, and (2) the reasoner is a model checking engine for a paraconsistent (inconsistencytolerant) description logic.""
  - ""We have presented our computer-aided approach to the problem of computer language classification and paradigm identification in a recent paper Development of the Computer Language Classification Portal (Proc. of Ershov Informatics Conference PSI-2011, Lect. Not. in Comp. Sci., v.7162).""",,"- The abstract mentions that the authors have presented their approach to computer language classification and paradigm identification in a previous paper, but it does not provide details on how this approach was validated.
 - The current paper discusses new developments, such as the pre-alpha version of the portal and the use of a model checking engine for paraconsistent description logic, but again, there is no mention of validation methods or criteria.
 - The abstract does not specify any validation approach, such as mapping to existing languages or empirical testing, nor does it mention specific languages or examples used in validation.
 - There is no mention of criteria used to demonstrate validity, which is a crucial aspect of validation.","- ""In the present paper we discuss new developments of our project: (1) the pre-alpha version of the Portal is online, and (2) the reasoner is a model checking engine for a paraconsistent (inconsistencytolerant) description logic.""
  - ""We have presented our computer-aided approach to the problem of computer language classification and paradigm identification in a recent paper Development of the Computer Language Classification Portal""
  - ""Computer language paradigms are the basis for classification of the computer languages.""
  - ""The computer language universe includes languages for different purposes (programming, specification, modeling, etc.).""",,"- The abstract discusses the classification of computer languages based on paradigms, which suggests a framework for organizing and understanding different languages.
 - The mention of a ""computer-aided approach"" and a ""Portal"" implies a tool or system that could be used by practitioners, researchers, or educators to facilitate comparative studies or language selection.
 - The pre-alpha version of the Portal being online suggests a practical application for users to access and utilize the classification system.
 - The use of a ""model checking engine for a paraconsistent description logic"" indicates a potential for advanced research applications, such as analyzing inconsistencies in language design.
 - The abstract does not explicitly mention specific user groups or use cases, but the context suggests potential applications in comparative studies and language design."
"effort to develop foundations for prototype-based languages or to define a more general model , which at the same time represents both class-based and prototype-based languages","Verónica Argañaraz, G. Baum, C. Pons, María José Presso, M. Prieto, Natalia Romero",-,-,-,0,2012,"Formal calculus of objects (impς-calculus) for representing sharing schemes and delegation in object-oriented programming, covering both class-based and prototype-based languages.","Detailed feature-level analysis with concrete mappings of well-known languages, using theoretical derivation from Abadi and Cardelli's formal calculus of objects.","- Lack of effort in developing foundations for prototype-based languages.
 - Emphasis on class-based inheritance, potentially neglecting prototype-based languages.
 - Inability to represent delegation among concrete objects in prototype-based languages.",No formal validation described (the abstract focuses on theoretical representation and translation rather than empirical validation or testing),Framework for unifying class-based and prototype-based languages; Tool for facilitating high-level comparative studies of programming languages; Practical application for educators and practitioners in problem-solving and language design,"- ""Sharing of behavior is one of the most important features in the Object-Oriented paradigm.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""Abadi and Cardelli have defined a calculus of objects which represents the basic elements.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment,""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""Martin Abadi & Luca Cardelli have defined a formal calculus of objects, the impς-calculus, which consists just of objects, object communication and object update""
  - ""We have built per object delegation using the calculus.""",,"- The abstract discusses the development of a formalism related to object-oriented programming, specifically focusing on the sharing of behavior between objects.
 - The authors mention the use of a ""calculus of objects"" defined by Abadi and Cardelli, which is a formal system for representing object-oriented concepts.
 - The primary focus of this formalism is on representing sharing schemes and delegation between objects, which are key features of object-oriented programming.
 - The scope of this classification includes the representation of both class-based and prototype-based languages within a single formal framework.
 - The abstract does not explicitly mention a taxonomy or feature model, but it describes a formal calculus that serves as a foundational model for object-oriented programming.","- ""Sharing of behavior is one of the most important features in the Object-Oriented paradigm.""
  - ""We claim that sharing schemes can be constructed in a more basic model with just objects and messages.""
  - ""Abadi and Cardelli have defined a calculus of objects which represents the basic elements.""
  - ""In this work we show how to express delegation between concrete objects in the calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment,""
  - ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""This shows how constructs similar to those appearing in usual programming languages can be written in the formal calculus, and allows writing programs in the formalism without requiring understanding details about it.""
  - ""There are primitives to express the sharing relationship in object creation, to change that relationship and to reference the donor of an object.""
  - ""Martin Abadi & Luca Cardelli have defined a formal calculus of objects, the impς-calculus, which consists just of objects, object communication and object update""
  - ""Abadi & Cardelli describe how to build the concepts of class based languages in their formalism, but they don't represent the ability to share behavior by delegation among concrete objects present in prototype based languages.""
  - ""We have built per object delegation using the calculus.""
  - ""The structure of the paper is as follows. Section 1 describes the Object-Oriented paradigm essentials. Section 2 discusses the notion of sharing, the different aspects it involves and the usual sharing mechanisms.""",,"- The abstract discusses the conceptual granularity by focusing on the sharing of behavior as a fundamental feature of the Object-Oriented paradigm. This indicates a deep analysis of the conceptual underpinnings of object-oriented programming.
 - The authors use a theoretical derivation approach by building upon the formal calculus of objects defined by Abadi and Cardelli. This suggests a deep theoretical foundation for their analysis.
 - The abstract mentions the use of a formal calculus to represent object-oriented constructs, which implies a detailed feature-level analysis.
 - The authors provide specific conceptual dimensions such as the ability to express delegation between concrete objects and the translation of sharing constructs into a formal calculus. This indicates a nuanced understanding of the conceptual dimensions involved.
 - The abstract does not mention empirical analysis or literature review as sources of conceptual definitions, suggesting that the approach is primarily theoretical.","- ""Abadi & Cardelli describe how to build the concepts of class based languages in their formalism, but they don't represent the ability to share behavior by delegation among concrete objects present in prototype based languages.""
  - ""Most of these models define the concept of class as a basic construction of object-oriented languages and make emphasis on the semantics of class-based inheritance.""",,"- The abstract discusses the limitations of existing classification approaches by highlighting the lack of effort in developing foundations for prototype-based languages. This suggests a limitation in the current classification methods, as they do not adequately address prototype-based languages.
 - The emphasis on class-based inheritance in most models indicates a bias towards class-based languages, which could be seen as a limitation in terms of representing prototype-based languages.
 - The abstract critiques the work of Abadi & Cardelli by noting that their formalism does not represent delegation among concrete objects in prototype-based languages, indicating a limitation in their approach.","- ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""This shows how constructs similar to those appearing in usual programming languages can be written in the formal calculus, and allows writing programs in the formalism without requiring understanding details about it.""
  - ""We conclude by stating some final remarks and future work.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in Object-Oriented languages can be built using only objects and messages.""",,"- The abstract discusses the development of a formal calculus that represents both class-based and prototype-based languages, focusing on the ability to share behavior through delegation.
 - It mentions the definition of sharing constructs for an object-based language and their translation into the formal calculus, which suggests a theoretical validation by demonstrating how these constructs can be represented within the calculus.
 - The abstract does not explicitly mention any empirical testing or mapping to existing languages as a validation method.
 - The focus is on theoretical representation and translation rather than empirical validation or testing against specific languages or criteria.
 - The conclusion section mentions future work, which implies that further validation or testing might be planned but is not described in the abstract.","- ""We have defined sharing constructs for an object based (prototypes) high level language, and their translation into the formal calculus.""
  - ""The key advantage of our contribution is that by providing per object delegation we can represent every sharing scheme possible in a prototype environment, thus completing the conviction that all the usual constructs found in Object-Oriented languages can be built using only objects and messages.""
  - ""We conclude by stating some final remarks and future work.""
  - ""This shows how constructs similar to those appearing in usual programming languages can be written in the formal calculus, and allows writing programs in the formalism without requiring understanding details about it.""",,"- The abstract discusses the development of a model that can represent both class-based and prototype-based languages using only objects and messages. This suggests a practical implication for language design, as it provides a unified framework for understanding and implementing different object-oriented programming paradigms.
 - The mention of ""per object delegation"" and its representation in the formal calculus implies a potential application in comparative studies of programming languages, as it allows for a more nuanced understanding of how different languages implement object-oriented concepts.
 - The abstract mentions that the proposed constructs can be used to write programs in the formalism without requiring detailed understanding, which suggests a practical application for educators and practitioners who teach or use object-oriented programming languages.
 - The exemplification of solutions to known problems in Section 6 indicates that the work has practical implications for problem-solving in programming.
 - The conclusion about future work suggests ongoing research implications, potentially leading to further developments in language design and comparative studies."
Parallelism in declarative languages,C. Chronaki,-,-,-,1,1990,"Classification framework comparing functional, logic, and constraint languages under the declarative paradigm","Derived from a comparative analysis of language families under the declarative paradigm, using a detailed feature-level comparison to identify advantages and deficiencies, likely based on literature review and theoretical derivation.",No limitations explicitly discussed (the abstract critiques the Von Neumann model but does not explicitly discuss limitations in existing classification approaches),No formal validation described,Framework for facilitating high-level comparative studies of declarative programming languages for parallel computation; Tool for improving language design for multiprocessor programming,"- ""In the first part of this thesis we examine different language families under the declarative paradigm: functional, logic, and constraint languages.""
  - ""Here we will compare and con trast the language classes above, locate advantages and deficiencies, and explain different choices made by language implementors.""
  - ""In the second part of thesis we describe a front end for the CONSUL, a prototype constraint language for programming multiprocessors.""",,"- The abstract mentions the examination of different language families under the declarative paradigm, which includes functional, logic, and constraint languages. This suggests a classification or comparison framework for these language families.
 - The focus is on comparing and contrasting these language classes, which implies a taxonomy or classification framework that highlights their advantages and deficiencies.
 - The scope of the classification includes at least three language categories: functional, logic, and constraint languages.
 - The abstract does not explicitly mention a specific type of formalism like a feature model or a detailed taxonomy with a specific number of paradigms or features. However, it implies a comparative framework for these language families.","- ""In the first part of this thesis we examine different language families under the declarative paradigm: functional, logic, and constraint languages.""
  - ""In the second part of thesis we describe a front end for the CONSUL, a prototype constraint language for programming multiprocessors.""
  - ""Here we will compare and con trast the language classes above, locate advantages and deficiencies, and explain different choices made by language implementors.""",,"- The abstract mentions an examination of different language families under the declarative paradigm, which suggests a comparative analysis of these languages. This implies a certain level of conceptual detail in understanding the differences and similarities among these language families.
 - The abstract states that the thesis will compare and contrast these language classes, which indicates a deep analysis of their advantages and deficiencies. This suggests a detailed conceptual analysis rather than a shallow one.
 - The mention of explaining different choices made by language implementors suggests that the thesis may involve a theoretical derivation or analysis of design decisions, which could be based on literature review or empirical analysis.
 - The abstract does not explicitly mention the sources of conceptual definitions, such as literature review or empirical analysis, but the nature of the comparison and contrast implies a literature-based approach.
 - The specific conceptual dimensions or criteria used for classification are not explicitly mentioned in the abstract, but the focus on advantages and deficiencies suggests that these might be key criteria.","- ""Here we will compare and con trast the language classes above, locate advantages and deficiencies, and explain different choices made by language implementors.""
  - ""In the first part of this thesis we examine different language families under the declarative paradigm: functional, logic, and constraint languages.""
  - ""Declarative languages based on mathemat ical models of computation, seem more suitable for the development of parallel programs.""
  - ""This model of stor age oriented computation blocks parallelism and increases the cost of parallel program development and porting.""
  - ""Imperative programming languages were initially built for uniprocessor sys tems that evolved out of the Von Neumann machine model.""",,"- The abstract discusses the limitations of imperative programming languages, which are based on the Von Neumann machine model. This model is criticized for blocking parallelism and increasing the cost of parallel program development and porting.
 - The abstract suggests that declarative languages are more suitable for parallel programs, implying a limitation in the existing classification approaches that favor imperative languages.
 - The thesis aims to compare and contrast different language families under the declarative paradigm, which may imply a critique of current taxonomies or classification methods that do not adequately address these differences.
 - However, the abstract does not explicitly discuss limitations in existing classification approaches or taxonomies. It focuses more on the suitability of declarative languages for parallelism rather than critiquing existing classification methods.","- ""In the second part of thesis we describe a front end for the CONSUL, a prototype constraint language for programming multiprocessors.""
  - ""Here we will compare and con trast the language classes above, locate advantages and deficiencies, and explain different choices made by language implementors.""
  - ""In the first part of this thesis we examine different language families under the declarative paradigm: functional, logic, and constraint languages.""",,"- The abstract discusses the examination of different language families under the declarative paradigm, which suggests a comparison or analysis of these languages.
 - It mentions comparing and contrasting language classes, which could imply some form of validation through analysis or mapping.
 - However, there is no explicit mention of a validation method, such as empirical testing or mapping to existing languages, in the abstract.
 - The abstract does not specify any criteria used to demonstrate validity or any specific languages or examples used in validation.
 - The focus on describing a front end for a prototype constraint language does not directly relate to validation of a classification system.","- ""Declarative languages based on mathemat ical models of computation, seem more suitable for the development of parallel programs.""
  - ""In the second part of thesis we describe a front end for the CONSUL, a prototype constraint language for programming multiprocessors.""
  - ""In the first part of this thesis we examine different language families under the declarative paradigm: functional, logic, and constraint languages.""
  - ""Here we will compare and con trast the language classes above, locate advantages and deficiencies, and explain different choices made by language implementors.""
  - ""The most im portant features of the front end are compact representation of constraints, type definitions, functional use of relations, and the ability to split programs into multiple files.""",,"- The abstract discusses the suitability of declarative languages for parallel programming, which implies a practical application in developing parallel programs.
 - The comparison and contrast of different language families suggest a research implication in understanding the advantages and deficiencies of each, which could inform language design.
 - The description of a front end for a prototype constraint language indicates a practical application in programming multiprocessors.
 - The features of the front end, such as compact representation and functional use of relations, suggest potential improvements in language design for parallel computation.
 - The abstract does not explicitly mention intended user groups or specific use cases beyond parallel programming, but it implies a focus on researchers and language implementors."
Naturally Embedded Query Languages,"V. Tannen, P. Buneman, L. Wong",10.1007/3-540-56039-4_38,https://doi.org/10.1007/3-540-56039-4_38,International Conference on Database Theory,211,1992,"Taxonomy of programming languages based on structural recursion on sets, focusing on expressive power and conceptual characteristics, using category theory for semantic and syntactic organization.","Derived from theoretical derivation using category theory, with a focus on expressiveness and algebraic perspectives, and detailed feature-level analysis with concrete mappings of well-known languages.","- Impedance mismatch problem in existing integration of query languages with general programming languages.
 - Lack of uniform characterization of nested relational and complex-object algebras.
 - Overreliance on complexity arguments for expressive power comparisons.
 - Proposed improvement: Viewing query languages as restrictions of a more general programming language, using category theory for semantics and syntax.","No formal validation described (the abstract focuses on theoretical advantages and uses of category theory, but does not mention empirical testing or concrete mappings as validation methods)","- Intended user groups: Researchers and educators in theoretical computer science, practitioners in database query systems.
 - Specific use cases or potential applications: Simplification of interactions between query languages and general programming languages, comparative studies of nested relational and complex-object algebras, optimization techniques.
 - Potential impact on language design or comparative studies: Uniform characterization of algebras, use of category theory for semantics and syntax organization, derivation of equational theories for optimizations.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators;and we can make comparisons of expressiveness in a general framework.""
  - ""ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""",,"- The abstract discusses the development of a formalism related to programming languages, specifically focusing on structural recursion on sets and the progression of sublanguages with increasing expressive power.
 - The primary focus of the classification appears to be on the conceptual characteristics and expressive power of these sublanguages, as they are described as having ""robust conceptual restrictions"" and ""interesting additional properties.""
 - The scope of the classification includes a progression of sublanguages, suggesting a hierarchical or layered approach to categorizing these languages based on their expressive power.
 - The use of category theory to organize semantics and syntax indicates a formal framework for understanding the relationships between these languages.
 - The mention of equational theories and categorical ideas suggests a formalism that involves mathematical structures to derive identities and optimizations.","- ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators;and we can make comparisons of expressiveness in a general framework.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""",,"- The abstract indicates a deep conceptual analysis by describing a progression of sublanguages with increasing expressive power and robust conceptual restrictions. This suggests a detailed examination of the languages' properties.
 - The use of category theory to organize semantics and syntax implies a theoretical derivation of conceptual definitions, as category theory is a theoretical framework.
 - The mention of a ""uniform characterization of nested relational and complex-object algebras"" suggests a specific conceptual dimension or criterion used for classification, focusing on expressiveness and algebraic perspectives.
 - The abstract does not mention empirical analysis or literature review as sources of conceptual definitions, indicating that the approach is more theoretically derived.
 - The use of equational theories and categorical ideas to derive identities for optimizations suggests a detailed feature-level analysis with concrete mappings of well-known languages.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""First, there is no “impedance mismatch” problem; the query languages are already there, so they share common semantic foundation with the general language.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators;and we can make comparisons of expressiveness in a general framework.""
  - ""Third, we exhibit differences in expressive power that are not always based on complexity arguments, but use the idea that a query in one language may not be polymorphically expressible in another.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""",,"- The abstract discusses the advantages of viewing query languages as restrictions of a more general programming language, which implies a critique of existing approaches that might not share this perspective.
 - The mention of ""no 'impedance mismatch' problem"" suggests a limitation in existing approaches where such mismatches are common, indicating a conceptual limitation in how query languages are typically integrated with general programming languages.
 - The abstract suggests a uniform characterization of algebras, which could imply a critique of current taxonomies or classification methods that lack such uniformity.
 - The discussion of differences in expressive power not based on complexity arguments suggests a methodological limitation in existing approaches that might rely too heavily on complexity as a criterion.
 - The use of category theory to organize semantics and syntax implies an alternative approach to existing methods, suggesting a proposed improvement.","- ""We describe a progression of sublanguages in this paradigm that (1) have increasing expressive power, and (2) illustrate robust conceptual restrictions thus exhibiting interesting additional properties.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators;and we can make comparisons of expressiveness in a general framework.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""",,"- The abstract discusses the development of a programming language paradigm based on structural recursion on sets and its sublanguages, which are considered as candidates for query languages.
 - It mentions the advantages of viewing query languages as restrictions of a more general programming language, including no ""impedance mismatch"" and a uniform characterization of nested relational and complex-object algebras.
 - The abstract highlights the use of category theory to organize semantics and syntax, indicating a theoretical validation approach.
 - It also mentions the derivation of general identities using categorical ideas, which could serve as optimizations, suggesting a theoretical validation method.
 - However, there is no mention of empirical testing or concrete mappings to existing languages as a validation method.
 - The abstract does not explicitly describe any empirical verification or case studies as part of the validation process.","- ""We investigate the properties of a simple programming language whose main computational engine is structural recursion on sets.""
  - ""These properties suggest that we consider our sublanguages as candidates for “query languages”.""
  - ""Viewing query languages as restrictions of our more general programming language has several advantages.""
  - ""First, there is no “impedance mismatch” problem; the query languages are already there, so they share common semantic foundation with the general language.""
  - ""Second, we suggest a uniform characterization of nested relational and complex-object algebras in terms of some surprisingly simple operators;and we can make comparisons of expressiveness in a general framework.""
  - ""Third, we exhibit differences in expressive power that are not always based on complexity arguments, but use the idea that a query in one language may not be polymorphically expressible in another.""
  - ""Fourth, ideas of category theory can be profitably used to organize semantics and syntax, in particular our minimal (core) language is a well-understood categorical construction: a cartesian category with a strong monad on it.""
  - ""Finally, we bring out an algebraic perspective, that is, our languages come with equational theories, and categorical ideas can be used to derive a number of rather general identities that may serve as optimizations or as techniques for discovering optimizations.""",,"- The abstract discusses the development of a programming language paradigm based on structural recursion on sets, which is proposed as a candidate for query languages. This suggests a practical application in database query systems.
 - The mention of ""no 'impedance mismatch' problem"" implies that the proposed system could simplify interactions between different query languages and the general programming language, which is a practical implication for language design.
 - The uniform characterization of nested relational and complex-object algebras suggests a potential application in comparative studies of these algebras, which could be useful for researchers and educators.
 - The use of category theory to organize semantics and syntax indicates a research implication in theoretical computer science, particularly in language design and comparative studies.
 - The derivation of equational theories and identities suggests potential applications in optimization techniques, which could be useful for practitioners and researchers."
A Theory of Tagged Objects,"Joseph Lee, Jonathan Aldrich, Troy Shaw, A. Potanin",10.4230/LIPIcs.ECOOP.2015.174,https://doi.org/10.4230/LIPIcs.ECOOP.2015.174,European Conference on Object-Oriented Programming,11,2015,No specific formalism developed (the paper focuses on developing a theoretical model for object-oriented languages using type theory constructs),"Derived from theoretical derivation, using detailed feature-level analysis with concrete mappings of foundational constructs in type theory to model object-oriented programming languages.","- The fixed nature of the class table, which assumes the entire class table can be computed at compile time, limiting dynamic class loading or creation.
 - The lack of foundational nature in existing models, which do not explain classes and instance checking in terms of fundamental type theory constructs.
 - Proposed improvement: A more flexible and foundational model of class-based object-oriented programming languages.","Validated through implementation and empirical testing in the Wyvern programming language, using examples such as the bordered window example to demonstrate successful typechecking and execution.","- Intended user groups: Language designers, researchers in programming languages
 - Specific use cases or potential applications: Enhancing Wyvern language, exploring dynamic class loading, improving functional programming languages like Standard ML
 - Potential impact on language design or comparative studies: More expressive statically typed object-oriented languages, enhanced support for multiple tags in Wyvern, potential for functional languages to adopt enhanced tag constructs","- ""In this paper, we explore how to model statically-typed object-oriented languages that support dynamic class creation using foundational constructs of type theory.""
  - ""The primary contribution of this paper is exploring a more flexible and foundational model of class-based object-oriented programming languages.""
  - ""We start with an extensible tag construct motivated by type theory, and adapt it to support static reasoning about class hierarchy and the tags supported by each object.""
  - ""The result is a model that better explains the relationship between objectoriented and functional programming paradigms, suggests a useful enhancement to functional programming languages, and paves the way for more expressive statically typed object-oriented languages.""
  - ""we describe the design and implementation of the Wyvern language, which leverages our theory.""
  - ""Section 2 defines a source-level statically-typed object-oriented language that supports dynamic creation of class hierarchies, including mixin composition, along with a match construct that generalizes instanceof checks and casts.""
  - ""Section 3 defines a foundational calculus, consisting of a standard core type theory with the addition of constructs to support hierarchical tag creation, tag matching, and the extraction of tagged content.""
  - ""Section 4, the semantics of the source-level language is defined by a translation into the target language, thus explaining how dynamic, class-based OO languages can be modeled in terms of type theory.""
  - ""Section 5, we present the publicly available implementation of our language.""
  - ""Section 8 concludes with a discussion of the potential applications of the model.""",,"- The paper primarily focuses on developing a foundational model for class-based object-oriented programming languages that support dynamic class creation and composition.
 - The model is based on an extensible tag construct inspired by type theory, which is used to support static reasoning about class hierarchies and tags.
 - The paper describes a source-level language and a foundational calculus that includes constructs for hierarchical tag creation, tag matching, and extraction of tagged content.
 - The scope of the classification includes the modeling of dynamic class creation, mixin composition, and the relationship between object-oriented and functional programming paradigms.
 - The paper does not explicitly mention a taxonomy or feature model but rather focuses on developing a theoretical model for object-oriented languages.","- ""In this paper, we explore how to model statically-typed object-oriented languages that support dynamic class creation using foundational constructs of type theory.""
  - ""The primary contribution of this paper is exploring a more flexible and foundational model of class-based object-oriented programming languages.""
  - ""We start with an extensible tag construct motivated by type theory, and adapt it to support static reasoning about class hierarchy and the tags supported by each object.""
  - ""The result is a model that better explains the relationship between objectoriented and functional programming paradigms, suggests a useful enhancement to functional programming languages, and paves the way for more expressive statically typed object-oriented languages.""
  - ""Section 2 defines a source-level statically-typed object-oriented language that supports dynamic creation of class hierarchies, including mixin composition, along with a match construct that generalizes instanceof checks and casts.""
  - ""Section 3 defines a foundational calculus, consisting of a standard core type theory with the addition of constructs to support hierarchical tag creation, tag matching, and the extraction of tagged content.""
  - ""Section 4, the semantics of the source-level language is defined by a translation into the target language, thus explaining how dynamic, class-based OO languages can be modeled in terms of type theory.""
  - ""Section 5, we present the publicly available implementation of our language.""
  - ""Section 8 concludes with a discussion of the potential applications of the model.""",,"- The paper provides a deep conceptual analysis by exploring foundational models of object-oriented constructs and their relationship with type theory. This is evident from the focus on developing a ""foundational model"" and ""foundational calculus"" that integrates type theory with object-oriented programming.
 - The conceptual definitions are derived from theoretical derivation, as indicated by the development of a ""foundational calculus"" and the adaptation of type theory constructs to support class hierarchy and tags.
 - The paper uses specific conceptual dimensions such as ""hierarchical tag creation,"" ""tag matching,"" and ""extraction of tagged content"" to classify and analyze object-oriented languages.
 - The methodology involves defining a source-level language and translating it into a core language to model dynamic class creation and composition, indicating a detailed feature-level analysis.
 - The paper discusses potential applications and extensions, suggesting a comprehensive approach to understanding the conceptual granularity of object-oriented programming languages.","- ""The class-based models of object-oriented programming with which we are familiar have two limitations. The first limitation is the fixed nature of the class table: the models assume that the entire class table can be computed at compile time, meaning that run-time loading, generation, or composition of classes is not modeled.""
  - ""The second limitation is that these class-based models are not foundational in nature, in that they do not explain classes and instance checking in terms of the fundamental constructs of type theory.""
  - ""Typical models of these languages, such as Featherweight Java [18], assume that each object is a member of a class, and that a fixed class table exists mapping classes to their definitions (and thus defining a subclassing relation).""
  - ""The primary contribution of this paper is exploring a more flexible and foundational model of class-based object-oriented programming languages.""",,"- The paper discusses two main limitations of existing class-based models of object-oriented programming. The first limitation is the assumption of a fixed class table that can be computed at compile time, which does not allow for dynamic class loading or creation. This is a conceptual limitation as it restricts the flexibility of class-based models.
 - The second limitation is that these models are not foundational in nature, meaning they do not explain classes and instance checking in terms of fundamental type theory constructs. This is a methodological limitation as it lacks a deep theoretical basis.
 - The paper proposes a more flexible and foundational model as an improvement, indicating a critique of current taxonomies or classification methods that do not account for dynamic class creation and foundational type theory.","- ""We implemented the core functionality of tags as a contribution to the open source Wyvern programming language""
  - ""we describe the design and implementation of the Wyvern language, which leverages our theory.""
  - ""The syntax of Wyvern's tag support differs slightly from the source-level language presented in Section 2 to better harmonize with the other features of Wyvern, but the underlying concepts remain the same and the implementation is informed by the theory presented here.""",,"- The paper describes the implementation of the Wyvern language as a validation method for the proposed formalism. This suggests that the validation approach involves mapping the formalism to an existing language, in this case, Wyvern.
 - The paper mentions that the Wyvern interpreter's implementation is available and accompanied by an artifact, indicating that the validation involves empirical testing through the implementation and execution of the language.
 - The use of the bordered window example as a unit test in Wyvern suggests that specific examples were used to validate the formalism.
 - The criteria for demonstrating validity include the successful typechecking and execution of the example in Wyvern, indicating that the formalism was validated through practical implementation and testing.","- ""The result is a model that better explains the relationship between objectoriented and functional programming paradigms, suggests a useful enhancement to functional programming languages, and paves the way for more expressive statically typed object-oriented languages.""
  - ""we describe the design and implementation of the Wyvern language, which leverages our theory.""
  - ""We believe that our theory might also be useful for exploring the semantics of dynamic class loading, for similar reasons, but we have not yet investigated this connection.""
  - ""The flexibility of the theory suggests that it may enable statically
 

 typed, nominal OO languages to express many useful design idioms that, at present, are limited to dynamically-typed or structurally-typed languages.""
  - ""We expect the theory presented here to contribute to the design of Wyvern [24], a language that already supports dynamic class creation and composition, but may benefit from support for multiple tags as well.""
  - ""These results suggest that functional programming languages, such as Standard ML, that already provide an extensible tag mechanism [16] could gain expressiveness by adopting the enhanced constructs in our theory, perhaps in conjunction with mechanisms such as refinement types [11].""",,"- The paper proposes a theoretical model that enhances the understanding of object-oriented programming paradigms and their relationship with functional programming. This has implications for language design, particularly in making statically typed object-oriented languages more expressive.
 - The theory is applied in the design and implementation of the Wyvern language, indicating a practical application for language developers.
 - The paper suggests potential applications in exploring dynamic class loading, which could impact how languages handle class creation and composition.
 - The theory is expected to contribute to the development of Wyvern, specifically in enhancing its support for multiple tags, which could benefit language designers and users.
 - The paper suggests that functional programming languages like Standard ML could benefit from adopting the enhanced tag constructs, indicating a potential impact on language design and comparative studies."
Development of the Computer Language Classification Knowledge Portal,"N. Shilov, A. A. Akinin, A. V. Zubkov, R. Idrisov",10.1007/978-3-642-29709-0_29,https://doi.org/10.1007/978-3-642-29709-0_29,Ershov Memorial Conference,2,2011,Classification framework for programming paradigms based on unified formal semantics and open wiki-like ontology,"Derived from theoretical frameworks, using a unified approach to formal semantics and an open wiki-like ontology for pragmatics, formal syntax, and informal style.",No limitations explicitly discussed,No formal validation described,"- Intended user groups: Practitioners, researchers, educators
 - Specific use cases or potential applications: Improving the choice of appropriate computer languages for new software projects and information technologies; facilitating high-level comparative studies of programming languages
 - Potential impact on language design or comparative studies: Unified approach to formal semantics and open wiki-like ontology could influence language design and comparative studies","- ""This position paper presents an approach to computer languages paradigmatization (i. e. paradigm specification) and classification that is based on a unified approach to formal semantics, and an open wiki-like ontology for pragmatics, formal syntax and informal “style”.""
  - ""The computer language universe includes languages for different purposes: programming languages, specification languages, modeling languages, languages for knowledge representation, etc.""
  - ""The study and precise specification of computer language paradigms (including new ones) are called to improve the choice of appropriate computer languages for new Software projects and information technologies.""
  - ""Computer language paradigms are the basis for classification of the computer languages.""",,"- The abstract mentions that computer language paradigms are the basis for classification, indicating a focus on programming paradigms.
 - The study involves the specification and classification of these paradigms, suggesting a classification framework.
 - The approach is based on a unified formal semantics and an open wiki-like ontology, which implies a structured and systematic classification system.
 - The scope of the classification is not explicitly mentioned in terms of the number of language categories or features covered, but it is clear that the focus is on paradigms.","- ""This position paper presents an approach to computer languages paradigmatization (i. e. paradigm specification) and classification that is based on a unified approach to formal semantics, and an open wiki-like ontology for pragmatics, formal syntax and informal “style”.""
  - ""In each of these branches of computer languages it is possible to track several approaches (imperative, declarative, object-oriented, etc.), disciplines of processing (sequential, non-deterministic, parallel, distributed, etc.), and formalized models, such as Turing machines or logic inference machines.""
  - ""Computer language paradigms are the basis for classification of the computer languages.""
  - ""They are based on joint attributes which allow us to differentiate branches in the computer language universe.""
  - ""The computer language universe includes languages for different purposes: programming languages, specification languages, modeling languages, languages for knowledge representation, etc.""",,"- The abstract mentions various branches of computer languages and approaches, indicating a broad conceptual scope.
 - It highlights the use of ""joint attributes"" to differentiate branches, suggesting a structured approach to classification.
 - The mention of ""computer language paradigms"" as the basis for classification implies a focus on theoretical frameworks.
 - The use of a ""unified approach to formal semantics"" and an ""open wiki-like ontology"" suggests a deep conceptual analysis, as it involves integrating multiple aspects of language design.
 - The abstract does not explicitly mention sources like literature review or empirical analysis, but the focus on formal semantics and ontology suggests a theoretical derivation.
 - The specific conceptual dimensions include formal semantics, pragmatics, formal syntax, and informal style, indicating a detailed feature-level analysis.","- ""The computer language universe includes languages for different purposes: programming languages, specification languages, modeling languages, languages for knowledge representation, etc.""
  - ""In each of these branches of computer languages it is possible to track several approaches (imperative, declarative, object-oriented, etc.), disciplines of processing (sequential, non-deterministic, parallel, distributed, etc.), and formalized models, such as Turing machines or logic inference machines.""
  - ""Computer language paradigms are the basis for classification of the computer languages.""
  - ""Currently the number of essentially different paradigms is close to several dozens.""
  - ""The study and precise specification of computer language paradigms (including new ones) are called to improve the choice of appropriate computer languages for new Software projects and information technologies.""
  - ""This position paper presents an approach to computer languages paradigmatization (i. e. paradigm specification) and classification that is based on a unified approach to formal semantics, and an open wiki-like ontology for pragmatics, formal syntax and informal “style”.""",,"- The abstract discusses the complexity and diversity of computer languages, indicating a need for better classification methods.
 - It mentions the existence of multiple paradigms and approaches, which suggests a potential limitation in current classification methods: they might not adequately capture or organize these diverse paradigms.
 - The abstract implies that current methods might not be precise or unified, as it suggests a need for ""precise specification of computer language paradigms"" to improve the choice of languages for projects.
 - The introduction of a new approach based on a unified formal semantics and an open wiki-like ontology suggests that current methods might lack these features, which could be seen as limitations.
 - However, the abstract does not explicitly state specific limitations or critiques of current taxonomies or classification methods. It focuses more on the introduction of a new approach rather than detailing the shortcomings of existing ones.","- ""This position paper presents an approach to computer languages paradigmatization (i. e. paradigm specification) and classification that is based on a unified approach to formal semantics, and an open wiki-like ontology for pragmatics, formal syntax and informal “style”.""",,"- The abstract discusses the development of a classification system for computer languages based on a unified approach to formal semantics and an open wiki-like ontology.
 - It does not mention any specific validation method or criteria used to validate the classification system.
 - There is no mention of empirical testing, mapping to existing languages, or specific languages used in validation.
 - The abstract focuses on the presentation of the approach rather than its validation.","- ""This position paper presents an approach to computer languages paradigmatization (i. e. paradigm specification) and classification that is based on a unified approach to formal semantics, and an open wiki-like ontology for pragmatics, formal syntax and informal “style”.""
  - ""The study and precise specification of computer language paradigms (including new ones) are called to improve the choice of appropriate computer languages for new Software projects and information technologies.""",,"- The abstract mentions that the study and specification of computer language paradigms are intended to ""improve the choice of appropriate computer languages for new Software projects and information technologies."" This suggests a practical implication for practitioners and researchers in software development, as it could help them select the most suitable languages for their projects.
 - The proposed approach to paradigmatization and classification is based on a unified approach to formal semantics and an open wiki-like ontology. This could serve as a tool for facilitating high-level comparative studies of programming languages, as it provides a structured framework for understanding and comparing different language paradigms.
 - The abstract does not explicitly mention specific use cases or potential applications beyond improving language choice for software projects. However, the implication is that this framework could be useful for educators in teaching about different programming paradigms and for researchers in conducting comparative studies.
 - The potential impact on language design could be significant, as a unified approach to formal semantics and an open ontology could influence how new languages are designed and how existing languages are evaluated."
Object-oriented systems: a cross-discipline overview,O. Díaz,10.1016/0950-5849(95)01044-0,https://doi.org/10.1016/0950-5849(95)01044-0,Information and Software Technology,5,1996,"Taxonomy of object-oriented systems with four categories: class-based, frame-based, terminological, and actor-based models","Derived from theoretical understanding, using detailed feature-level analysis with concrete mappings of different models (class-based, frame-based, terminological, actor-based)",No limitations explicitly discussed (the abstract implies issues with diverse terminology and perspectives but does not explicitly state limitations or critiques of existing classification approaches),No formal validation described,Framework for facilitating comparative studies and educational purposes; potential use for researchers and educators in understanding object-oriented systems,"- ""This paper proposes a classification of object-oriented systems based upon the conceptualization underlying an object and how such a conceptualization is described.""
  - ""The classification serves both as a framework for comparison and as a context within which individual concepts can be described.""",,"- The abstract mentions that the paper proposes a ""classification of object-oriented systems,"" which indicates the development of a taxonomy or classification framework.
 - The primary focus of this classification is on the ""conceptualization underlying an object,"" suggesting that it is centered on conceptual characteristics rather than specific programming language features.
 - The scope of the classification includes four broad categories: class-based, frame-based, terminological, and actor-based models. This indicates that the classification framework covers these four distinct conceptualizations.
 - The classification is described as serving both as a framework for comparison and as a context for describing individual concepts, which aligns with the characteristics of a taxonomy or classification framework.","- ""This paper proposes a classification of object-oriented systems based upon the conceptualization underlying an object and how such a conceptualization is described.""
  - ""In the paper, for each category, a definition of the conceptualization is first presented, followed by a description of its characteristics together with some examples of its intended use.""
  - ""The object-oriented paradigm is characterized in a general sense by a grouping of information with the concept or entity to which it relates.""
  - ""The classification serves both as a framework for comparison and as a context within which individual concepts can be described.""",,"- The abstract suggests a focus on conceptualization and description, indicating a deep level of conceptual analysis as it involves understanding and categorizing different models (class-based, frame-based, terminological, actor-based).
 - The classification is based on the conceptualization underlying an object, which implies a theoretical derivation of these concepts rather than empirical analysis or literature review.
 - The abstract mentions that for each category, a definition and description of characteristics are provided, which suggests a detailed feature-level analysis.
 - The classification serves as a framework for comparison and context for individual concepts, indicating a structured analytical approach.
 - The abstract does not explicitly mention sources like literature review or empirical analysis, suggesting that the conceptual definitions are derived from theoretical understanding.","- ""The object-oriented paradigm is characterized in a general sense by a grouping of information with the concept or entity to which it relates.""
  - ""However, such systems may provide significantly different perspectives on the structure and manipulation of objects.""
  - ""This stems principally from the different motivations underlying the distinct fields from which object-oriented systems have emerged, such as Data Bases, Artificial Intelligence and Programming Languages.""
  - ""As a result, a myriad of systems have appeared in which diverse terminology is used.""
  - ""For example, are terms such as class, frame, term, actor and entity synonyms, related notions, or descriptions of distinct concepts?""
  - ""This paper proposes a classification of object-oriented systems based upon the conceptualization underlying an object and how such a conceptualization is described.""",,"- The abstract discusses the diversity in perspectives and terminology within object-oriented systems due to their emergence from different fields. This suggests a limitation in existing classification approaches, as they may not adequately account for these differences.
 - The mention of ""diverse terminology"" and the confusion over whether certain terms are synonyms or distinct concepts indicates a lack of clarity and consistency in current classification methods.
 - The abstract does not explicitly state specific limitations or critiques of current taxonomies but implies that existing approaches may not provide a clear framework for understanding the conceptualization of objects across different fields.
 - The proposed classification in the paper suggests an alternative approach to address these issues, but the abstract does not explicitly discuss limitations or critiques of existing methods.","- ""The classification serves both as a framework for comparison and as a context within which individual concepts can be described.""
  - ""This paper proposes a classification of object-oriented systems based upon the conceptualization underlying an object and how such a conceptualization is described.""
  - ""Four broad families are identified depending on whether systems follows either a class-based model, a frame-based model, a terminological model or an actor-based model.""",,"- The abstract mentions the proposal of a classification system for object-oriented systems but does not provide any details on how this classification was validated.
 - There is no mention of any validation approach, such as mapping to existing languages or empirical testing.
 - The abstract does not specify any criteria used to demonstrate the validity of the classification system.
 - The focus is on the proposal and description of the classification system rather than its validation.","- ""The classification serves both as a framework for comparison and as a context within which individual concepts can be described.""
  - ""This paper proposes a classification of object-oriented systems based upon the conceptualization underlying an object and how such a conceptualization is described.""",,"- The abstract mentions that the paper proposes a classification system for object-oriented systems, which implies a practical application for organizing and understanding these systems.
 - The classification is described as serving ""both as a framework for comparison and as a context within which individual concepts can be described,"" suggesting its use for comparative studies and educational purposes.
 - The abstract does not explicitly mention specific user groups or use cases, but the framework's purpose implies it could be useful for researchers and educators in comparing and teaching about different object-oriented systems.
 - The potential impact on language design is not explicitly mentioned, but the classification could indirectly influence language design by providing a structured framework for understanding object-oriented concepts."
A Formalization of Concepts for Generic Programming,"Jeremiah Willcock, Jaakko Järvi, A. Lumsdaine, D. Musser",-,-,-,17,2004,"Classification framework for conceptual characteristics in generic programming, applicable to several popular languages","Derived from theoretical derivation, focusing on minimal type requirements and algorithmic execution, with a unified framework for concept approximations in existing languages.","- Concepts are not explicitly represented in traditional programming languages.
 - C++ lacks means to express concepts, forcing development outside the language and limiting compiler capabilities.
 - Lack of uniform, language-independent definition of concepts across languages.",Validated through mapping to existing languages; specific languages used in validation not explicitly mentioned; criteria for validity not mentioned.,Framework to help programmers choose appropriate language concepts for problem-solving; Tool for facilitating high-level comparative studies of programming languages; Impact on language design by providing a unified framework for concept representation.,"- ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages, and we present such descriptions for several popular languages used for generic programming.""
  - ""Generic programming is a paradigm for systematic design and classification of software components for optimal reuse.""
  - ""The term concept is used in this context to mean a set of abstractions (such as types) whose membership is determined by a set of requirements.""",,"- The abstract discusses the concept of generic programming, which involves the systematic design and classification of software components. This suggests a focus on classification.
 - The term ""concept"" is defined as a set of abstractions with specific requirements, indicating a formalism related to conceptual characteristics.
 - The paper provides a ""unified framework for realizing concept approximations in existing languages,"" which implies a classification framework that can be applied across multiple languages.
 - The scope of the classification includes ""several popular languages used for generic programming,"" indicating a broad scope but not specifying the exact number of languages or features covered.","- ""Generic programming starts with algorithms, seeking to identify the minimal requirements on types necessary for correct and efficient execution of an algorithm or family of algorithms, leading to generic algorithms that can be applied to arguments of many different types.""
  - ""The term concept is used in this context to mean a set of abstractions (such as types) whose membership is determined by a set of requirements.""
  - ""Generic programming is a paradigm for systematic design and classification of software components for optimal reuse.""
  - ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages, and we present such descriptions for several popular languages used for generic programming.""
  - ""Despite their importance, concepts are not explicitly represented in traditional programming languages.""",,"- The abstract discusses the paradigm of generic programming and its focus on identifying minimal type requirements for algorithms, which suggests a deep conceptual analysis into the nature of algorithms and types.
 - The term ""concept"" is defined as a set of abstractions with specific requirements, indicating a detailed conceptual framework.
 - The abstract mentions that concepts are not explicitly represented in traditional programming languages, which implies that the authors are addressing a gap in current language capabilities.
 - The paper provides a unified framework for concept approximations in existing languages, suggesting a comprehensive approach to conceptual classification.
 - The abstract does not explicitly mention sources such as literature review or empirical analysis, but the focus on providing a unified framework implies a theoretical derivation of concepts.
 - The specific conceptual dimensions or criteria used for classification are not detailed in the abstract, but the focus on minimal type requirements and algorithmic execution suggests a detailed feature-level analysis.","- ""Despite their importance, concepts are not explicitly represented in traditional programming languages.""
  - ""C++, in particular, lacks any means to express concepts, which has forced all concept development to be done outside the language and thus be unavailable to C++ compilers for static checking or optimization.""
  - ""Several other languages do have features than can approximate certain aspects of concepts, but what is missing is a uniform, language-independent definition of concepts.""",,"- The abstract discusses the limitation that traditional programming languages, specifically C++, do not have a means to explicitly represent concepts. This is a conceptual limitation as it forces concept development to occur outside the language.
 - The lack of explicit representation of concepts in C++ means that compilers cannot perform static checking or optimization, which is a methodological limitation.
 - The abstract also mentions that while some languages can approximate certain aspects of concepts, there is no uniform, language-independent definition. This is a limitation in terms of classification and taxonomy, as it implies a lack of consistency across languages.
 - The proposed improvement is the definition of concepts provided in the paper, which aims to offer a unified framework for realizing concept approximations in existing languages.","- ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages, and we present such descriptions for several popular languages used for generic programming.""",,"- The abstract mentions that the paper provides a unified framework for realizing concept approximations in existing languages. This suggests that the validation method involves mapping the proposed formalism to existing languages.
 - The abstract states that descriptions are presented for several popular languages used for generic programming, which implies that these languages are used as examples in the validation process.
 - However, the abstract does not specify the criteria used to demonstrate validity or any empirical testing methods. It only mentions the mapping to existing languages as a form of validation.","- ""The definition of concepts in this paper provides a unified framework for realizing concept approximations in existing languages, and we present such descriptions for several popular languages used for generic programming.""
  - ""C++, in particular, lacks any means to express concepts, which has forced all concept development to be done outside the language and thus be unavailable to C++ compilers for static checking or optimization.""
  - ""The term concept is used in this context to mean a set of abstractions (such as types) whose membership is determined by a set of requirements.""
  - ""Generic programming is a paradigm for systematic design and classification of software components for optimal reuse.""",,"- The abstract discusses the concept of generic programming and its importance in software component design and reuse. This suggests that the intended user groups are likely practitioners and researchers involved in software development and language design.
 - The mention of a ""unified framework for realizing concept approximations in existing languages"" implies a practical application for language designers and developers, as it provides a way to standardize and improve concept representation across different languages.
 - The abstract highlights the lack of explicit concept representation in traditional programming languages, particularly C++. This suggests a potential impact on language design, as the proposed framework could influence future language development to include better concept representation.
 - The presentation of descriptions for several popular languages indicates a potential use case for comparative studies among these languages, facilitating high-level comparisons and potentially aiding in the choice of appropriate language concepts for problem-solving."